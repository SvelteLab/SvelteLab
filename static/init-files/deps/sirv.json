{"directory":{"build.js":{"file":{"contents":"const fs = require('fs');\nconst { join, normalize, resolve } = require('path');\nconst { totalist } = require('totalist/sync');\nconst { parse } = require('@polka/url');\nconst { lookup } = require('mrmime');\n\nconst noop = () => {};\n\nfunction isMatch(uri, arr) {\n\tfor (let i=0; i < arr.length; i++) {\n\t\tif (arr[i].test(uri)) return true;\n\t}\n}\n\nfunction toAssume(uri, extns) {\n\tlet i=0, x, len=uri.length - 1;\n\tif (uri.charCodeAt(len) === 47) {\n\t\turi = uri.substring(0, len);\n\t}\n\n\tlet arr=[], tmp=`${uri}/index`;\n\tfor (; i < extns.length; i++) {\n\t\tx = extns[i] ? `.${extns[i]}` : '';\n\t\tif (uri) arr.push(uri + x);\n\t\tarr.push(tmp + x);\n\t}\n\n\treturn arr;\n}\n\nfunction viaCache(cache, uri, extns) {\n\tlet i=0, data, arr=toAssume(uri, extns);\n\tfor (; i < arr.length; i++) {\n\t\tif (data = cache[arr[i]]) return data;\n\t}\n}\n\nfunction viaLocal(dir, isEtag, uri, extns) {\n\tlet i=0, arr=toAssume(uri, extns);\n\tlet abs, stats, name, headers;\n\tfor (; i < arr.length; i++) {\n\t\tabs = normalize(join(dir, name=arr[i]));\n\t\tif (abs.startsWith(dir) && fs.existsSync(abs)) {\n\t\t\tstats = fs.statSync(abs);\n\t\t\tif (stats.isDirectory()) continue;\n\t\t\theaders = toHeaders(name, stats, isEtag);\n\t\t\theaders['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';\n\t\t\treturn { abs, stats, headers };\n\t\t}\n\t}\n}\n\nfunction is404(req, res) {\n\treturn (res.statusCode=404,res.end());\n}\n\nfunction send(req, res, file, stats, headers) {\n\tlet code=200, tmp, opts={};\n\theaders = { ...headers };\n\n\tfor (let key in headers) {\n\t\ttmp = res.getHeader(key);\n\t\tif (tmp) headers[key] = tmp;\n\t}\n\n\tif (tmp = res.getHeader('content-type')) {\n\t\theaders['Content-Type'] = tmp;\n\t}\n\n\tif (req.headers.range) {\n\t\tcode = 206;\n\t\tlet [x, y] = req.headers.range.replace('bytes=', '').split('-');\n\t\tlet end = opts.end = parseInt(y, 10) || stats.size - 1;\n\t\tlet start = opts.start = parseInt(x, 10) || 0;\n\n\t\tif (start >= stats.size || end >= stats.size) {\n\t\t\tres.setHeader('Content-Range', `bytes */${stats.size}`);\n\t\t\tres.statusCode = 416;\n\t\t\treturn res.end();\n\t\t}\n\n\t\theaders['Content-Range'] = `bytes ${start}-${end}/${stats.size}`;\n\t\theaders['Content-Length'] = (end - start + 1);\n\t\theaders['Accept-Ranges'] = 'bytes';\n\t}\n\n\tres.writeHead(code, headers);\n\tfs.createReadStream(file, opts).pipe(res);\n}\n\nconst ENCODING = {\n\t'.br': 'br',\n\t'.gz': 'gzip',\n};\n\nfunction toHeaders(name, stats, isEtag) {\n\tlet enc = ENCODING[name.slice(-3)];\n\n\tlet ctype = lookup(name.slice(0, enc && -3)) || '';\n\tif (ctype === 'text/html') ctype += ';charset=utf-8';\n\n\tlet headers = {\n\t\t'Content-Length': stats.size,\n\t\t'Content-Type': ctype,\n\t\t'Last-Modified': stats.mtime.toUTCString(),\n\t};\n\n\tif (enc) headers['Content-Encoding'] = enc;\n\tif (isEtag) headers['ETag'] = `W/\"${stats.size}-${stats.mtime.getTime()}\"`;\n\n\treturn headers;\n}\n\nmodule.exports = function (dir, opts={}) {\n\tdir = resolve(dir || '.');\n\n\tlet isNotFound = opts.onNoMatch || is404;\n\tlet setHeaders = opts.setHeaders || noop;\n\n\tlet extensions = opts.extensions || ['html', 'htm'];\n\tlet gzips = opts.gzip && extensions.map(x => `${x}.gz`).concat('gz');\n\tlet brots = opts.brotli && extensions.map(x => `${x}.br`).concat('br');\n\n\tconst FILES = {};\n\n\tlet fallback = '/';\n\tlet isEtag = !!opts.etag;\n\tlet isSPA = !!opts.single;\n\tif (typeof opts.single === 'string') {\n\t\tlet idx = opts.single.lastIndexOf('.');\n\t\tfallback += !!~idx ? opts.single.substring(0, idx) : opts.single;\n\t}\n\n\tlet ignores = [];\n\tif (opts.ignores !== false) {\n\t\tignores.push(/[/]([A-Za-z\\s\\d~$._-]+\\.\\w+){1,}$/); // any extn\n\t\tif (opts.dotfiles) ignores.push(/\\/\\.\\w/);\n\t\telse ignores.push(/\\/\\.well-known/);\n\t\t[].concat(opts.ignores || []).forEach(x => {\n\t\t\tignores.push(new RegExp(x, 'i'));\n\t\t});\n\t}\n\n\tlet cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;\n\tif (cc && opts.immutable) cc += ',immutable';\n\telse if (cc && opts.maxAge === 0) cc += ',must-revalidate';\n\n\tif (!opts.dev) {\n\t\ttotalist(dir, (name, abs, stats) => {\n\t\t\tif (/\\.well-known[\\\\+\\/]/.test(name)) {} // keep\n\t\t\telse if (!opts.dotfiles && /(^\\.|[\\\\+|\\/+]\\.)/.test(name)) return;\n\n\t\t\tlet headers = toHeaders(name, stats, isEtag);\n\t\t\tif (cc) headers['Cache-Control'] = cc;\n\n\t\t\tFILES['/' + name.normalize().replace(/\\\\+/g, '/')] = { abs, stats, headers };\n\t\t});\n\t}\n\n\tlet lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);\n\n\treturn function (req, res, next) {\n\t\tlet extns = [''];\n\t\tlet pathname = parse(req).pathname;\n\t\tlet val = req.headers['accept-encoding'] || '';\n\t\tif (gzips && val.includes('gzip')) extns.unshift(...gzips);\n\t\tif (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);\n\t\textns.push(...extensions); // [...br, ...gz, orig, ...exts]\n\n\t\tif (pathname.indexOf('%') !== -1) {\n\t\t\ttry { pathname = decodeURIComponent(pathname) }\n\t\t\tcatch (err) { /* malform uri */ }\n\t\t}\n\n\t\tlet data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);\n\t\tif (!data) return next ? next() : isNotFound(req, res);\n\n\t\tif (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {\n\t\t\tres.writeHead(304);\n\t\t\treturn res.end();\n\t\t}\n\n\t\tif (gzips || brots) {\n\t\t\tres.setHeader('Vary', 'Accept-Encoding');\n\t\t}\n\n\t\tsetHeaders(res, pathname, data.stats);\n\t\tsend(req, res, data.abs, data.stats, data.headers);\n\t};\n}\n"}},"build.mjs":{"file":{"contents":"import * as fs from 'fs';\nimport { join, normalize, resolve } from 'path';\nimport { totalist } from 'totalist/sync';\nimport { parse } from '@polka/url';\nimport { lookup } from 'mrmime';\n\nconst noop = () => {};\n\nfunction isMatch(uri, arr) {\n\tfor (let i=0; i < arr.length; i++) {\n\t\tif (arr[i].test(uri)) return true;\n\t}\n}\n\nfunction toAssume(uri, extns) {\n\tlet i=0, x, len=uri.length - 1;\n\tif (uri.charCodeAt(len) === 47) {\n\t\turi = uri.substring(0, len);\n\t}\n\n\tlet arr=[], tmp=`${uri}/index`;\n\tfor (; i < extns.length; i++) {\n\t\tx = extns[i] ? `.${extns[i]}` : '';\n\t\tif (uri) arr.push(uri + x);\n\t\tarr.push(tmp + x);\n\t}\n\n\treturn arr;\n}\n\nfunction viaCache(cache, uri, extns) {\n\tlet i=0, data, arr=toAssume(uri, extns);\n\tfor (; i < arr.length; i++) {\n\t\tif (data = cache[arr[i]]) return data;\n\t}\n}\n\nfunction viaLocal(dir, isEtag, uri, extns) {\n\tlet i=0, arr=toAssume(uri, extns);\n\tlet abs, stats, name, headers;\n\tfor (; i < arr.length; i++) {\n\t\tabs = normalize(join(dir, name=arr[i]));\n\t\tif (abs.startsWith(dir) && fs.existsSync(abs)) {\n\t\t\tstats = fs.statSync(abs);\n\t\t\tif (stats.isDirectory()) continue;\n\t\t\theaders = toHeaders(name, stats, isEtag);\n\t\t\theaders['Cache-Control'] = isEtag ? 'no-cache' : 'no-store';\n\t\t\treturn { abs, stats, headers };\n\t\t}\n\t}\n}\n\nfunction is404(req, res) {\n\treturn (res.statusCode=404,res.end());\n}\n\nfunction send(req, res, file, stats, headers) {\n\tlet code=200, tmp, opts={};\n\theaders = { ...headers };\n\n\tfor (let key in headers) {\n\t\ttmp = res.getHeader(key);\n\t\tif (tmp) headers[key] = tmp;\n\t}\n\n\tif (tmp = res.getHeader('content-type')) {\n\t\theaders['Content-Type'] = tmp;\n\t}\n\n\tif (req.headers.range) {\n\t\tcode = 206;\n\t\tlet [x, y] = req.headers.range.replace('bytes=', '').split('-');\n\t\tlet end = opts.end = parseInt(y, 10) || stats.size - 1;\n\t\tlet start = opts.start = parseInt(x, 10) || 0;\n\n\t\tif (start >= stats.size || end >= stats.size) {\n\t\t\tres.setHeader('Content-Range', `bytes */${stats.size}`);\n\t\t\tres.statusCode = 416;\n\t\t\treturn res.end();\n\t\t}\n\n\t\theaders['Content-Range'] = `bytes ${start}-${end}/${stats.size}`;\n\t\theaders['Content-Length'] = (end - start + 1);\n\t\theaders['Accept-Ranges'] = 'bytes';\n\t}\n\n\tres.writeHead(code, headers);\n\tfs.createReadStream(file, opts).pipe(res);\n}\n\nconst ENCODING = {\n\t'.br': 'br',\n\t'.gz': 'gzip',\n};\n\nfunction toHeaders(name, stats, isEtag) {\n\tlet enc = ENCODING[name.slice(-3)];\n\n\tlet ctype = lookup(name.slice(0, enc && -3)) || '';\n\tif (ctype === 'text/html') ctype += ';charset=utf-8';\n\n\tlet headers = {\n\t\t'Content-Length': stats.size,\n\t\t'Content-Type': ctype,\n\t\t'Last-Modified': stats.mtime.toUTCString(),\n\t};\n\n\tif (enc) headers['Content-Encoding'] = enc;\n\tif (isEtag) headers['ETag'] = `W/\"${stats.size}-${stats.mtime.getTime()}\"`;\n\n\treturn headers;\n}\n\nexport default function (dir, opts={}) {\n\tdir = resolve(dir || '.');\n\n\tlet isNotFound = opts.onNoMatch || is404;\n\tlet setHeaders = opts.setHeaders || noop;\n\n\tlet extensions = opts.extensions || ['html', 'htm'];\n\tlet gzips = opts.gzip && extensions.map(x => `${x}.gz`).concat('gz');\n\tlet brots = opts.brotli && extensions.map(x => `${x}.br`).concat('br');\n\n\tconst FILES = {};\n\n\tlet fallback = '/';\n\tlet isEtag = !!opts.etag;\n\tlet isSPA = !!opts.single;\n\tif (typeof opts.single === 'string') {\n\t\tlet idx = opts.single.lastIndexOf('.');\n\t\tfallback += !!~idx ? opts.single.substring(0, idx) : opts.single;\n\t}\n\n\tlet ignores = [];\n\tif (opts.ignores !== false) {\n\t\tignores.push(/[/]([A-Za-z\\s\\d~$._-]+\\.\\w+){1,}$/); // any extn\n\t\tif (opts.dotfiles) ignores.push(/\\/\\.\\w/);\n\t\telse ignores.push(/\\/\\.well-known/);\n\t\t[].concat(opts.ignores || []).forEach(x => {\n\t\t\tignores.push(new RegExp(x, 'i'));\n\t\t});\n\t}\n\n\tlet cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;\n\tif (cc && opts.immutable) cc += ',immutable';\n\telse if (cc && opts.maxAge === 0) cc += ',must-revalidate';\n\n\tif (!opts.dev) {\n\t\ttotalist(dir, (name, abs, stats) => {\n\t\t\tif (/\\.well-known[\\\\+\\/]/.test(name)) {} // keep\n\t\t\telse if (!opts.dotfiles && /(^\\.|[\\\\+|\\/+]\\.)/.test(name)) return;\n\n\t\t\tlet headers = toHeaders(name, stats, isEtag);\n\t\t\tif (cc) headers['Cache-Control'] = cc;\n\n\t\t\tFILES['/' + name.normalize().replace(/\\\\+/g, '/')] = { abs, stats, headers };\n\t\t});\n\t}\n\n\tlet lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);\n\n\treturn function (req, res, next) {\n\t\tlet extns = [''];\n\t\tlet pathname = parse(req).pathname;\n\t\tlet val = req.headers['accept-encoding'] || '';\n\t\tif (gzips && val.includes('gzip')) extns.unshift(...gzips);\n\t\tif (brots && /(br|brotli)/i.test(val)) extns.unshift(...brots);\n\t\textns.push(...extensions); // [...br, ...gz, orig, ...exts]\n\n\t\tif (pathname.indexOf('%') !== -1) {\n\t\t\ttry { pathname = decodeURIComponent(pathname) }\n\t\t\tcatch (err) { /* malform uri */ }\n\t\t}\n\n\t\tlet data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);\n\t\tif (!data) return next ? next() : isNotFound(req, res);\n\n\t\tif (isEtag && req.headers['if-none-match'] === data.headers['ETag']) {\n\t\t\tres.writeHead(304);\n\t\t\treturn res.end();\n\t\t}\n\n\t\tif (gzips || brots) {\n\t\t\tres.setHeader('Vary', 'Accept-Encoding');\n\t\t}\n\n\t\tsetHeaders(res, pathname, data.stats);\n\t\tsend(req, res, data.abs, data.stats, data.headers);\n\t};\n}\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"sirv\",\n  \"version\": \"2.0.2\",\n  \"description\": \"The optimized & lightweight middleware for serving requests to static assets\",\n  \"repository\": \"lukeed/sirv\",\n  \"module\": \"build.mjs\",\n  \"types\": \"sirv.d.ts\",\n  \"main\": \"build.js\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"build.*\",\n    \"sirv.d.ts\"\n  ],\n  \"author\": {\n    \"name\": \"Luke Edwards\",\n    \"email\": \"luke@lukeed.com\",\n    \"url\": \"https://lukeed.com\"\n  },\n  \"engines\": {\n    \"node\": \">= 10\"\n  },\n  \"dependencies\": {\n    \"@polka/url\": \"^1.0.0-next.20\",\n    \"mrmime\": \"^1.0.0\",\n    \"totalist\": \"^3.0.0\"\n  },\n  \"readme\": \"# sirv ![CI](https://github.com/lukeed/sirv/workflows/CI/badge.svg)\\n\\n> The optimized and lightweight middleware for serving requests to static assets\\n\\nYou may use `sirv` as a *very* fast and lightweight alternative to [`serve-static`](https://www.npmjs.com/package/serve-static).\\n\\nThe massive performance advantage over `serve-static` is explained by **not** relying on the file system for existence checks on every request. These are expensive interactions and must be avoided whenever possible! Instead, when not in \\\"dev\\\" mode, `sirv` performs all its file-system operations upfront and then relies on its cache for future operations.\\n\\nThis middleware will work out of the box for [Polka](https://github.com/lukeed/polka), Express, and other Express-like frameworks. It will also work with the native `http`, `https` and `http2` modules. It requires _very_ little effort to modify/wrap it for servers that don't accept the `(req, res, next)` signature.\\n\\n:bulb: For a feature-complete CLI application, check out the sibling [`sirv-cli`](https://github.com/lukeed/sirv/tree/master/packages/sirv-cli) package as an alternative to [`zeit/serve`](https://github.com/zeit/serve)~!\\n\\n## Install\\n\\n```\\n$ npm install --save sirv\\n```\\n\\n\\n## Usage\\n\\n```js\\nconst sirv = require('sirv');\\nconst polka = require('polka');\\nconst compress = require('compression')();\\n\\n// Init `sirv` handler\\nconst assets = sirv('public', {\\n  maxAge: 31536000, // 1Y\\n  immutable: true\\n});\\n\\npolka()\\n  .use(compress, assets)\\n  .use('/api', require('./api'))\\n  .listen(3000, err => {\\n    if (err) throw err;\\n    console.log('> Ready on localhost:3000~!');\\n  });\\n```\\n\\n\\n## API\\n\\n### sirv(dir, opts={})\\n\\nReturns: `Function`\\n\\nThe returned function is a middleware in the standard Express-like signature: `(req, res, next)`, where `req` is the [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage), `res` is the [`http.ServerResponse`](https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_class_http_serverresponse), and `next` (in this case) is the function to call if no file was found for the given path.\\n\\nWhen defined, a `next()` callback is always called _instead of_ the [`opts.onNoMatch`](#optsonnomatch) callback. However, unlike `onNoMatch`, your `next()` is given no arguments.\\n\\n#### dir\\nType: `String`<br>\\nDefault: `.`\\n\\nThe directory from which to read and serve assets. It is resolved to an absolute path &mdash; you must provide an absolute path yourself if `process.cwd()` is not the correct assumption.\\n\\n#### opts.dev\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nEnable \\\"dev\\\" mode, which disables/skips caching. Instead, `sirv` will traverse the file system ***on every request***.\\n\\nAdditionally, `dev` mode will ignore `maxAge` and `immutable` as these options generate a production-oriented `Cache-Control` header value.\\n\\n> **Important:** Do not use `dev` mode in production!\\n\\n#### opts.etag\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nGenerate and attach an `ETag` header to responses.\\n\\n> **Note:** If an incoming request's [`If-None-Match` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) matches the `ETag` value, a `304` response is given.\\n\\n#### opts.dotfiles\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nAllow requests to dotfiles (files or directories beginning with a `.`).\\n\\n> **Note:** Requests to [`/.well-known/*`](https://tools.ietf.org/html/rfc8615) are always allowed.\\n\\n#### opts.extensions\\nType: `Array<String>`<br>\\nDefault: `['html', 'htm']`\\n\\nThe file extension fallbacks to check for if a pathame is not initially found. For example, if a `/login` request cannot find a `login` filename, it will then look for `login.html` and `login.htm` before giving up~!\\n\\n> **Important:** Actually, `sirv` will **also** look for `login/index.html` and `login/index.htm` before giving up.\\n\\n#### opts.gzip\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nDetermine if `sirv` look for **precompiled** `*.gz` files.<br>\\nMust be enabled _and_ the incoming request's [`Accept Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) must include \\\"gzip\\\" in order for `sirv` to search for the gzip'd alternative.\\n\\n> **Note:** The `.gz` assumption also applies to the `opts.extensions` list.\\n\\n```js\\n// NOTE: PSEUDO CODE\\n// Showing lookup logic\\n\\n// Request: [Accept-Encoding: gzip] \\\"/foobar.jpg\\\"\\nlookup([\\n  '/foobar.jpg.gz', '/foobar.jpg',\\n  '/foobar.jpg.html.gz', '/foobar.jpg/index.html.gz',\\n  '/foobar.jpg.htm.gz', '/foobar.jpg/index.htm.gz',\\n  '/foobar.jpg.html', '/foobar.jpg/index.html',\\n  '/foobar.jpg.htm', '/foobar.jpg/index.htm',\\n]);\\n\\n// Request: [Accept-Encoding: gzip] \\\"/\\\"\\nlookup([\\n  '/index.html.gz',\\n  '/index.htm.gz',\\n  '/index.html',\\n  '/index.htm',\\n]);\\n```\\n\\n\\n#### opts.brotli\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nDetermine if `sirv` look for **precompiled** `*.br` files.<br>\\nMust be enabled _and_ the incoming request's [`Accept Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) must include either \\\"br\\\" or \\\"brotli\\\" in order for `sirv` to search for the brotli-compressed alternative.\\n\\n> **Note:** The `.br` assumption also applies to the `opts.extensions` list.\\n\\nWhen both `opts.broli` and `opts.gzip` are enabled &mdash; and all conditions are equal &mdash; then the brotli variant always takes priority.\\n\\n```js\\n// NOTE: PSEUDO CODE\\n// Showing lookup logic\\n\\n// Request: [Accept-Encoding: br] \\\"/foobar.jpg\\\"\\nlookup([\\n  '/foobar.jpg.br', '/foobar.jpg',\\n  '/foobar.jpg.html.br', '/foobar.jpg/index.html.br',\\n  '/foobar.jpg.htm.br', '/foobar.jpg/index.htm.br',\\n  '/foobar.jpg.html', '/foobar.jpg/index.html',\\n  '/foobar.jpg.htm', '/foobar.jpg/index.htm',\\n]);\\n\\n// Request: [Accept-Encoding: br,gz] \\\"/\\\"\\nlookup([\\n  '/index.html.br'\\n  '/index.htm.br'\\n  '/index.html.gz'\\n  '/index.htm.gz'\\n  '/index.html'\\n  '/index.htm'\\n]);\\n```\\n\\n#### opts.maxAge\\nType: `Number`<br>\\nDefault: `undefined`\\n\\nEnables the `Cache-Control` header on responses and sets the `max-age` value (in seconds).<br>\\nFor example, `maxAge: 31536000` is equivalent to one year.\\n\\n#### opts.immutable\\nType: `Boolean`<br>\\nDefault: `false`\\n\\nAppends the [`immutable` directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#Revalidation_and_reloading) on your `Cache-Control` header, used for uniquely-named assets that will not change!\\n\\n> **Important:** Will only work if `opts.maxAge` has a value defined!\\n\\n#### opts.single\\nType: `Boolean` or `String`<br>\\nDefault: `false`\\n\\nTreat the directory as a single-page application.\\n\\nWhen `true`, the directory's index page (default `index.html`) will be sent if the request asset does not exist.<br>\\nYou may pass a `string` value to use a file _instead of_ `index.html` as your fallback.\\n\\nFor example, if \\\"/about\\\" is requested but no variants of that file exist, then the response for \\\"/\\\" is sent instead:\\n\\n```js\\n// Note: This is psuedo code to illustrate what's happening\\n\\n// Request: \\\"/about\\\"\\nlet file = find(['/about', '/about.html', '/about.htm', '/about/index.html', '/about.htm']);\\nif (file) {\\n  send(file);\\n} else if (opts.single === true) {\\n  file = find(['/', '/index.html', '/index.htm']);\\n  send(file);\\n} else if (typeof opts.single === 'string') {\\n  file = find([opts.single]);\\n  send(file);\\n} else {\\n  // next() or 404\\n}\\n```\\n\\n#### opts.ignores\\nType: `false` or `Array<String | RegExp>`\\n\\nSpecify paths/patterns that should ignore the fallback behavior that `opts.single` provides.\\n\\nBy default, any asset-like path (URLs that end with an extension) will be ignored. This means that, for example, if `/foobar.jpg` is not found, a `404` response is sent instead of the `index.html` fallback.\\n\\nAdditionally, any `/.well-known/*` pathname ignores the fallback – as do all other dotfile requests when `opts.dotfiles` is enabled.\\n\\nAny string value(s) will be passed through `new RegExp(value, 'i')` directly.\\n\\nFinally, you may set `ignores: false` to disable ***all*** ignores, including the defaults. Put differently, this will fallback ***all*** unknown pathnames to your `index.html` (or custom `opts.single` value).\\n\\n> **Important:** Only has an effect if `opts.single` is enabled.\\n\\n#### opts.onNoMatch\\nType: `Function`\\n\\nA custom function to run if a file cannot be found for a given request. <br>By default, `sirv` will send a basic `(404) Not found` response.\\n\\nThe function receives the current `req <IncomingMessage>, res <ServerResponse>` pair for as its two arguments.\\n\\n> **Note:** This won't run if a `next` callback has been provided to the middleware; see [`sirv`](#sirvdir-opts) description.\\n\\n#### opts.setHeaders\\nType: `Function`\\n\\nA custom function to append or change any headers on the outgoing response. There is no default.\\n\\nIts signature is `(res, pathname, stats)`, where `res` is the `ServerResponse`, `pathname` is incoming request path (stripped of queries), and `stats` is the file's result from [`fs.statSync`](https://nodejs.org/api/fs.html#fs_fs_statsync_path).\\n\\n\\n## License\\n\\nMIT © [Luke Edwards](https://lukeed.com)\\n\"\n}"}},"readme.md":{"file":{"contents":"# sirv ![CI](https://github.com/lukeed/sirv/workflows/CI/badge.svg)\n\n> The optimized and lightweight middleware for serving requests to static assets\n\nYou may use `sirv` as a *very* fast and lightweight alternative to [`serve-static`](https://www.npmjs.com/package/serve-static).\n\nThe massive performance advantage over `serve-static` is explained by **not** relying on the file system for existence checks on every request. These are expensive interactions and must be avoided whenever possible! Instead, when not in \"dev\" mode, `sirv` performs all its file-system operations upfront and then relies on its cache for future operations.\n\nThis middleware will work out of the box for [Polka](https://github.com/lukeed/polka), Express, and other Express-like frameworks. It will also work with the native `http`, `https` and `http2` modules. It requires _very_ little effort to modify/wrap it for servers that don't accept the `(req, res, next)` signature.\n\n:bulb: For a feature-complete CLI application, check out the sibling [`sirv-cli`](https://github.com/lukeed/sirv/tree/master/packages/sirv-cli) package as an alternative to [`zeit/serve`](https://github.com/zeit/serve)~!\n\n## Install\n\n```\n$ npm install --save sirv\n```\n\n\n## Usage\n\n```js\nconst sirv = require('sirv');\nconst polka = require('polka');\nconst compress = require('compression')();\n\n// Init `sirv` handler\nconst assets = sirv('public', {\n  maxAge: 31536000, // 1Y\n  immutable: true\n});\n\npolka()\n  .use(compress, assets)\n  .use('/api', require('./api'))\n  .listen(3000, err => {\n    if (err) throw err;\n    console.log('> Ready on localhost:3000~!');\n  });\n```\n\n\n## API\n\n### sirv(dir, opts={})\n\nReturns: `Function`\n\nThe returned function is a middleware in the standard Express-like signature: `(req, res, next)`, where `req` is the [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage), `res` is the [`http.ServerResponse`](https://nodejs.org/dist/latest-v9.x/docs/api/http.html#http_class_http_serverresponse), and `next` (in this case) is the function to call if no file was found for the given path.\n\nWhen defined, a `next()` callback is always called _instead of_ the [`opts.onNoMatch`](#optsonnomatch) callback. However, unlike `onNoMatch`, your `next()` is given no arguments.\n\n#### dir\nType: `String`<br>\nDefault: `.`\n\nThe directory from which to read and serve assets. It is resolved to an absolute path &mdash; you must provide an absolute path yourself if `process.cwd()` is not the correct assumption.\n\n#### opts.dev\nType: `Boolean`<br>\nDefault: `false`\n\nEnable \"dev\" mode, which disables/skips caching. Instead, `sirv` will traverse the file system ***on every request***.\n\nAdditionally, `dev` mode will ignore `maxAge` and `immutable` as these options generate a production-oriented `Cache-Control` header value.\n\n> **Important:** Do not use `dev` mode in production!\n\n#### opts.etag\nType: `Boolean`<br>\nDefault: `false`\n\nGenerate and attach an `ETag` header to responses.\n\n> **Note:** If an incoming request's [`If-None-Match` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) matches the `ETag` value, a `304` response is given.\n\n#### opts.dotfiles\nType: `Boolean`<br>\nDefault: `false`\n\nAllow requests to dotfiles (files or directories beginning with a `.`).\n\n> **Note:** Requests to [`/.well-known/*`](https://tools.ietf.org/html/rfc8615) are always allowed.\n\n#### opts.extensions\nType: `Array<String>`<br>\nDefault: `['html', 'htm']`\n\nThe file extension fallbacks to check for if a pathame is not initially found. For example, if a `/login` request cannot find a `login` filename, it will then look for `login.html` and `login.htm` before giving up~!\n\n> **Important:** Actually, `sirv` will **also** look for `login/index.html` and `login/index.htm` before giving up.\n\n#### opts.gzip\nType: `Boolean`<br>\nDefault: `false`\n\nDetermine if `sirv` look for **precompiled** `*.gz` files.<br>\nMust be enabled _and_ the incoming request's [`Accept Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) must include \"gzip\" in order for `sirv` to search for the gzip'd alternative.\n\n> **Note:** The `.gz` assumption also applies to the `opts.extensions` list.\n\n```js\n// NOTE: PSEUDO CODE\n// Showing lookup logic\n\n// Request: [Accept-Encoding: gzip] \"/foobar.jpg\"\nlookup([\n  '/foobar.jpg.gz', '/foobar.jpg',\n  '/foobar.jpg.html.gz', '/foobar.jpg/index.html.gz',\n  '/foobar.jpg.htm.gz', '/foobar.jpg/index.htm.gz',\n  '/foobar.jpg.html', '/foobar.jpg/index.html',\n  '/foobar.jpg.htm', '/foobar.jpg/index.htm',\n]);\n\n// Request: [Accept-Encoding: gzip] \"/\"\nlookup([\n  '/index.html.gz',\n  '/index.htm.gz',\n  '/index.html',\n  '/index.htm',\n]);\n```\n\n\n#### opts.brotli\nType: `Boolean`<br>\nDefault: `false`\n\nDetermine if `sirv` look for **precompiled** `*.br` files.<br>\nMust be enabled _and_ the incoming request's [`Accept Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) must include either \"br\" or \"brotli\" in order for `sirv` to search for the brotli-compressed alternative.\n\n> **Note:** The `.br` assumption also applies to the `opts.extensions` list.\n\nWhen both `opts.broli` and `opts.gzip` are enabled &mdash; and all conditions are equal &mdash; then the brotli variant always takes priority.\n\n```js\n// NOTE: PSEUDO CODE\n// Showing lookup logic\n\n// Request: [Accept-Encoding: br] \"/foobar.jpg\"\nlookup([\n  '/foobar.jpg.br', '/foobar.jpg',\n  '/foobar.jpg.html.br', '/foobar.jpg/index.html.br',\n  '/foobar.jpg.htm.br', '/foobar.jpg/index.htm.br',\n  '/foobar.jpg.html', '/foobar.jpg/index.html',\n  '/foobar.jpg.htm', '/foobar.jpg/index.htm',\n]);\n\n// Request: [Accept-Encoding: br,gz] \"/\"\nlookup([\n  '/index.html.br'\n  '/index.htm.br'\n  '/index.html.gz'\n  '/index.htm.gz'\n  '/index.html'\n  '/index.htm'\n]);\n```\n\n#### opts.maxAge\nType: `Number`<br>\nDefault: `undefined`\n\nEnables the `Cache-Control` header on responses and sets the `max-age` value (in seconds).<br>\nFor example, `maxAge: 31536000` is equivalent to one year.\n\n#### opts.immutable\nType: `Boolean`<br>\nDefault: `false`\n\nAppends the [`immutable` directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#Revalidation_and_reloading) on your `Cache-Control` header, used for uniquely-named assets that will not change!\n\n> **Important:** Will only work if `opts.maxAge` has a value defined!\n\n#### opts.single\nType: `Boolean` or `String`<br>\nDefault: `false`\n\nTreat the directory as a single-page application.\n\nWhen `true`, the directory's index page (default `index.html`) will be sent if the request asset does not exist.<br>\nYou may pass a `string` value to use a file _instead of_ `index.html` as your fallback.\n\nFor example, if \"/about\" is requested but no variants of that file exist, then the response for \"/\" is sent instead:\n\n```js\n// Note: This is psuedo code to illustrate what's happening\n\n// Request: \"/about\"\nlet file = find(['/about', '/about.html', '/about.htm', '/about/index.html', '/about.htm']);\nif (file) {\n  send(file);\n} else if (opts.single === true) {\n  file = find(['/', '/index.html', '/index.htm']);\n  send(file);\n} else if (typeof opts.single === 'string') {\n  file = find([opts.single]);\n  send(file);\n} else {\n  // next() or 404\n}\n```\n\n#### opts.ignores\nType: `false` or `Array<String | RegExp>`\n\nSpecify paths/patterns that should ignore the fallback behavior that `opts.single` provides.\n\nBy default, any asset-like path (URLs that end with an extension) will be ignored. This means that, for example, if `/foobar.jpg` is not found, a `404` response is sent instead of the `index.html` fallback.\n\nAdditionally, any `/.well-known/*` pathname ignores the fallback – as do all other dotfile requests when `opts.dotfiles` is enabled.\n\nAny string value(s) will be passed through `new RegExp(value, 'i')` directly.\n\nFinally, you may set `ignores: false` to disable ***all*** ignores, including the defaults. Put differently, this will fallback ***all*** unknown pathnames to your `index.html` (or custom `opts.single` value).\n\n> **Important:** Only has an effect if `opts.single` is enabled.\n\n#### opts.onNoMatch\nType: `Function`\n\nA custom function to run if a file cannot be found for a given request. <br>By default, `sirv` will send a basic `(404) Not found` response.\n\nThe function receives the current `req <IncomingMessage>, res <ServerResponse>` pair for as its two arguments.\n\n> **Note:** This won't run if a `next` callback has been provided to the middleware; see [`sirv`](#sirvdir-opts) description.\n\n#### opts.setHeaders\nType: `Function`\n\nA custom function to append or change any headers on the outgoing response. There is no default.\n\nIts signature is `(res, pathname, stats)`, where `res` is the `ServerResponse`, `pathname` is incoming request path (stripped of queries), and `stats` is the file's result from [`fs.statSync`](https://nodejs.org/api/fs.html#fs_fs_statsync_path).\n\n\n## License\n\nMIT © [Luke Edwards](https://lukeed.com)\n"}},"sirv.d.ts":{"file":{"contents":"declare module 'sirv' {\n\timport type { Stats } from 'fs';\n\timport type { IncomingMessage, ServerResponse } from 'http';\n\n\ttype Arrayable<T> = T | T[];\n\texport type NextHandler = () => void | Promise<void>;\n\texport type RequestHandler = (req: IncomingMessage, res: ServerResponse, next?: NextHandler) => void;\n\n\texport interface Options {\n\t\tdev?: boolean;\n\t\tetag?: boolean;\n\t\tmaxAge?: number;\n\t\timmutable?: boolean;\n\t\tsingle?: string | boolean;\n\t\tignores?: false | Arrayable<string | RegExp>;\n\t\textensions?: string[];\n\t\tdotfiles?: boolean;\n\t\tbrotli?: boolean;\n\t\tgzip?: boolean;\n\t\tonNoMatch?: (req: IncomingMessage, res: ServerResponse) => void;\n\t\tsetHeaders?: (res: ServerResponse, pathname: string, stats: Stats) => void;\n\t}\n\n\texport default function(dir?: string, opts?: Options): RequestHandler;\n}\n"}}}}