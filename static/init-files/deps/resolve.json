{"directory":{".editorconfig":{"file":{"contents":"root = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nmax_line_length = 200\n\n[*.js]\nblock_comment_start = /*\nblock_comment = *\nblock_comment_end = */\n\n[*.yml]\nindent_size = 1\n\n[package.json]\nindent_style = tab\n\n[lib/core.json]\nindent_style = tab\n\n[CHANGELOG.md]\nindent_style = space\nindent_size = 2\n\n[{*.json,Makefile}]\nmax_line_length = off\n\n[test/{dotdot,resolver,module_dir,multirepo,node_path,pathfilter,precedence}/**/*]\nindent_style = off\nindent_size = off\nmax_line_length = off\ninsert_final_newline = off\n"}},".eslintrc":{"file":{"contents":"{\n    \"root\": true,\n\n    \"extends\": \"@ljharb\",\n\n    \"rules\": {\n        \"indent\": [2, 4],\n        \"strict\": 0,\n        \"complexity\": 0,\n        \"consistent-return\": 0,\n        \"curly\": 0,\n        \"dot-notation\": [2, { \"allowKeywords\": true }],\n        \"func-name-matching\": 0,\n        \"func-style\": 0,\n        \"global-require\": 1,\n        \"id-length\": [2, { \"min\": 1, \"max\": 30 }],\n        \"max-lines\": [2, 350],\n        \"max-lines-per-function\": 0,\n        \"max-nested-callbacks\": 0,\n        \"max-params\": 0,\n        \"max-statements-per-line\": [2, { \"max\": 2 }],\n        \"max-statements\": 0,\n        \"no-magic-numbers\": 0,\n        \"no-shadow\": 0,\n        \"no-use-before-define\": 0,\n        \"sort-keys\": 0,\n    },\n    \"overrides\": [\n        {\n            \"files\": \"bin/**\",\n            \"rules\": {\n                \"no-process-exit\": \"off\",\n            },\n        },\n        {\n            \"files\": \"example/**\",\n            \"rules\": {\n                \"no-console\": 0,\n            },\n        },\n        {\n            \"files\": \"test/resolver/nested_symlinks/mylib/*.js\",\n            \"rules\": {\n                \"no-throw-literal\": 0,\n            },\n        },\n        {\n            \"files\": \"test/**\",\n            \"parserOptions\": {\n                \"ecmaVersion\": 5,\n                \"allowReserved\": false,\n            },\n            \"rules\": {\n                \"dot-notation\": [2, { \"allowPattern\": \"throws\" }],\n                \"max-lines\": 0,\n                \"max-lines-per-function\": 0,\n                \"no-unused-vars\": [2, { \"vars\": \"all\", \"args\": \"none\" }],\n            },\n        },\n    ],\n\n    \"ignorePatterns\": [\n        \"./test/resolver/malformed_package_json/package.json\",\n    ],\n}\n"}},".github":{"directory":{"FUNDING.yml":{"file":{"contents":"# These are supported funding model platforms\n\ngithub: [ljharb]\npatreon: # Replace with a single Patreon username\nopen_collective: # Replace with a single Open Collective username\nko_fi: # Replace with a single Ko-fi username\ntidelift: npm/resolve\ncommunity_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry\nliberapay: # Replace with a single Liberapay username\nissuehunt: # Replace with a single IssueHunt username\notechie: # Replace with a single Otechie username\ncustom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']\n"}}}},"async.js":{"file":{"contents":"'use strict';\n\nmodule.exports = require('./lib/async');\n"}},"bin":{"directory":{"resolve":{"file":{"contents":"#!/usr/bin/env node\n\n'use strict';\n\nvar path = require('path');\nvar fs = require('fs');\n\nif (\n    String(process.env.npm_lifecycle_script).slice(0, 8) !== 'resolve '\n    && (\n        !process.argv\n        || process.argv.length < 2\n        || (process.argv[1] !== __filename && fs.statSync(process.argv[1]).ino !== fs.statSync(__filename).ino)\n        || (process.env._ && path.resolve(process.env._) !== __filename)\n    )\n) {\n    console.error('Error: `resolve` must be run directly as an executable');\n    process.exit(1);\n}\n\nvar supportsPreserveSymlinkFlag = require('supports-preserve-symlinks-flag');\n\nvar preserveSymlinks = false;\nfor (var i = 2; i < process.argv.length; i += 1) {\n    if (process.argv[i].slice(0, 2) === '--') {\n        if (supportsPreserveSymlinkFlag && process.argv[i] === '--preserve-symlinks') {\n            preserveSymlinks = true;\n        } else if (process.argv[i].length > 2) {\n            console.error('Unknown argument ' + process.argv[i].replace(/[=].*$/, ''));\n            process.exit(2);\n        }\n        process.argv.splice(i, 1);\n        i -= 1;\n        if (process.argv[i] === '--') { break; } // eslint-disable-line no-restricted-syntax\n    }\n}\n\nif (process.argv.length < 3) {\n    console.error('Error: `resolve` expects a specifier');\n    process.exit(2);\n}\n\nvar resolve = require('../');\n\nvar result = resolve.sync(process.argv[2], {\n    basedir: process.cwd(),\n    preserveSymlinks: preserveSymlinks\n});\n\nconsole.log(result);\n"}}}},"example":{"directory":{"async.js":{"file":{"contents":"var resolve = require('../');\nresolve('tap', { basedir: __dirname }, function (err, res) {\n    if (err) console.error(err);\n    else console.log(res);\n});\n"}},"sync.js":{"file":{"contents":"var resolve = require('../');\nvar res = resolve.sync('tap', { basedir: __dirname });\nconsole.log(res);\n"}}}},"index.js":{"file":{"contents":"var async = require('./lib/async');\nasync.core = require('./lib/core');\nasync.isCore = require('./lib/is-core');\nasync.sync = require('./lib/sync');\n\nmodule.exports = async;\n"}},"lib":{"directory":{"async.js":{"file":{"contents":"var fs = require('fs');\nvar getHomedir = require('./homedir');\nvar path = require('path');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\nvar isCore = require('is-core-module');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file, cb) {\n    fs.stat(file, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultIsDir = function isDirectory(dir, cb) {\n    fs.stat(dir, function (err, stat) {\n        if (!err) {\n            return cb(null, stat.isDirectory());\n        }\n        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n        return cb(err);\n    });\n};\n\nvar defaultRealpath = function realpath(x, cb) {\n    realpathFS(x, function (realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);\n        else cb(null, realpathErr ? x : realPath);\n    });\n};\n\nvar maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {\n    if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n    } else {\n        cb(null, x);\n    }\n};\n\nvar defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {\n    readFile(pkgfile, function (readFileErr, body) {\n        if (readFileErr) cb(readFileErr);\n        else {\n            try {\n                var pkg = JSON.parse(body);\n                cb(null, pkg);\n            } catch (jsonErr) {\n                cb(null);\n            }\n        }\n    });\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolve(x, options, callback) {\n    var cb = callback;\n    var opts = options;\n    if (typeof options === 'function') {\n        cb = opts;\n        opts = {};\n    }\n    if (typeof x !== 'string') {\n        var err = new TypeError('Path must be a string.');\n        return process.nextTick(function () {\n            cb(err);\n        });\n    }\n\n    opts = normalizeOptions(x, opts);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var readFile = opts.readFile || fs.readFile;\n    var realpath = opts.realpath || defaultRealpath;\n    var readPackage = opts.readPackage || defaultReadPackage;\n    if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');\n        return process.nextTick(function () {\n            cb(conflictErr);\n        });\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = path.resolve(basedir);\n\n    maybeRealpath(\n        realpath,\n        absoluteStart,\n        opts,\n        function (err, realStart) {\n            if (err) cb(err);\n            else init(realStart);\n        }\n    );\n\n    var res;\n    function init(basedir) {\n        if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n            res = path.resolve(basedir, x);\n            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n            if ((/\\/$/).test(x) && res === basedir) {\n                loadAsDirectory(res, opts.package, onfile);\n            } else loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n            return cb(null, x);\n        } else loadNodeModules(x, basedir, function (err, n, pkg) {\n            if (err) cb(err);\n            else if (n) {\n                return maybeRealpath(realpath, n, opts, function (err, realN) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realN, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function onfile(err, m, pkg) {\n        if (err) cb(err);\n        else if (m) cb(null, m, pkg);\n        else loadAsDirectory(res, function (err, d, pkg) {\n            if (err) cb(err);\n            else if (d) {\n                maybeRealpath(realpath, d, opts, function (err, realD) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        cb(null, realD, pkg);\n                    }\n                });\n            } else {\n                var moduleError = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n                moduleError.code = 'MODULE_NOT_FOUND';\n                cb(moduleError);\n            }\n        });\n    }\n\n    function loadAsFile(x, thePackage, callback) {\n        var loadAsFilePackage = thePackage;\n        var cb = callback;\n        if (typeof loadAsFilePackage === 'function') {\n            cb = loadAsFilePackage;\n            loadAsFilePackage = undefined;\n        }\n\n        var exts = [''].concat(extensions);\n        load(exts, x, loadAsFilePackage);\n\n        function load(exts, x, loadPackage) {\n            if (exts.length === 0) return cb(null, undefined, loadPackage);\n            var file = x + exts[0];\n\n            var pkg = loadPackage;\n            if (pkg) onpkg(null, pkg);\n            else loadpkg(path.dirname(file), onpkg);\n\n            function onpkg(err, pkg_, dir) {\n                pkg = pkg_;\n                if (err) return cb(err);\n                if (dir && pkg && opts.pathFilter) {\n                    var rfile = path.relative(dir, file);\n                    var rel = rfile.slice(0, rfile.length - exts[0].length);\n                    var r = opts.pathFilter(pkg, x, rel);\n                    if (r) return load(\n                        [''].concat(extensions.slice()),\n                        path.resolve(dir, r),\n                        pkg\n                    );\n                }\n                isFile(file, onex);\n            }\n            function onex(err, ex) {\n                if (err) return cb(err);\n                if (ex) return cb(null, file, pkg);\n                load(exts.slice(1), x, pkg);\n            }\n        }\n    }\n\n    function loadpkg(dir, cb) {\n        if (dir === '' || dir === '/') return cb(null);\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return cb(null);\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return cb(null);\n\n        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return loadpkg(path.dirname(dir), cb);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                // on err, ex is false\n                if (!ex) return loadpkg(path.dirname(dir), cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n                    cb(null, pkg, dir);\n                });\n            });\n        });\n    }\n\n    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {\n        var cb = callback;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === 'function') {\n            cb = fpkg;\n            fpkg = opts.package;\n        }\n\n        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {\n            if (unwrapErr) return cb(unwrapErr);\n            var pkgfile = path.join(pkgdir, 'package.json');\n            isFile(pkgfile, function (err, ex) {\n                if (err) return cb(err);\n                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);\n\n                readPackage(readFile, pkgfile, function (err, pkgParam) {\n                    if (err) return cb(err);\n\n                    var pkg = pkgParam;\n\n                    if (pkg && opts.packageFilter) {\n                        pkg = opts.packageFilter(pkg, pkgfile);\n                    }\n\n                    if (pkg && pkg.main) {\n                        if (typeof pkg.main !== 'string') {\n                            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');\n                            mainError.code = 'INVALID_PACKAGE_MAIN';\n                            return cb(mainError);\n                        }\n                        if (pkg.main === '.' || pkg.main === './') {\n                            pkg.main = 'index';\n                        }\n                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {\n                            if (err) return cb(err);\n                            if (m) return cb(null, m, pkg);\n                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);\n\n                            var dir = path.resolve(x, pkg.main);\n                            loadAsDirectory(dir, pkg, function (err, n, pkg) {\n                                if (err) return cb(err);\n                                if (n) return cb(null, n, pkg);\n                                loadAsFile(path.join(x, 'index'), pkg, cb);\n                            });\n                        });\n                        return;\n                    }\n\n                    loadAsFile(path.join(x, '/index'), pkg, cb);\n                });\n            });\n        });\n    }\n\n    function processDirs(cb, dirs) {\n        if (dirs.length === 0) return cb(null, undefined);\n        var dir = dirs[0];\n\n        isDirectory(path.dirname(dir), isdir);\n\n        function isdir(err, isdir) {\n            if (err) return cb(err);\n            if (!isdir) return processDirs(cb, dirs.slice(1));\n            loadAsFile(dir, opts.package, onfile);\n        }\n\n        function onfile(err, m, pkg) {\n            if (err) return cb(err);\n            if (m) return cb(null, m, pkg);\n            loadAsDirectory(dir, opts.package, ondir);\n        }\n\n        function ondir(err, n, pkg) {\n            if (err) return cb(err);\n            if (n) return cb(null, n, pkg);\n            processDirs(cb, dirs.slice(1));\n        }\n    }\n    function loadNodeModules(x, start, cb) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        processDirs(\n            cb,\n            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()\n        );\n    }\n};\n"}},"caller.js":{"file":{"contents":"module.exports = function () {\n    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n    var origPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = (new Error()).stack;\n    Error.prepareStackTrace = origPrepareStackTrace;\n    return stack[2].getFileName();\n};\n"}},"core.js":{"file":{"contents":"var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];\n\nfunction specifierIncluded(specifier) {\n    var parts = specifier.split(' ');\n    var op = parts.length > 1 ? parts[0] : '=';\n    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');\n\n    for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(current[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        }\n        if (op === '<') {\n            return cur < ver;\n        } else if (op === '>=') {\n            return cur >= ver;\n        }\n        return false;\n    }\n    return op === '>=';\n}\n\nfunction matchesRange(range) {\n    var specifiers = range.split(/ ?&& ?/);\n    if (specifiers.length === 0) { return false; }\n    for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(specifiers[i])) { return false; }\n    }\n    return true;\n}\n\nfunction versionIncluded(specifierValue) {\n    if (typeof specifierValue === 'boolean') { return specifierValue; }\n    if (specifierValue && typeof specifierValue === 'object') {\n        for (var i = 0; i < specifierValue.length; ++i) {\n            if (matchesRange(specifierValue[i])) { return true; }\n        }\n        return false;\n    }\n    return matchesRange(specifierValue);\n}\n\nvar data = require('./core.json');\n\nvar core = {};\nfor (var mod in data) { // eslint-disable-line no-restricted-syntax\n    if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core[mod] = versionIncluded(data[mod]);\n    }\n}\nmodule.exports = core;\n"}},"core.json":{"file":{"contents":"{\n\t\"assert\": true,\n\t\"node:assert\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"assert/strict\": \">= 15\",\n\t\"node:assert/strict\": \">= 16\",\n\t\"async_hooks\": \">= 8\",\n\t\"node:async_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"buffer_ieee754\": \">= 0.5 && < 0.9.7\",\n\t\"buffer\": true,\n\t\"node:buffer\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"child_process\": true,\n\t\"node:child_process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"cluster\": \">= 0.5\",\n\t\"node:cluster\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"console\": true,\n\t\"node:console\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"constants\": true,\n\t\"node:constants\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"crypto\": true,\n\t\"node:crypto\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_debug_agent\": \">= 1 && < 8\",\n\t\"_debugger\": \"< 8\",\n\t\"dgram\": true,\n\t\"node:dgram\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"diagnostics_channel\": [\">= 14.17 && < 15\", \">= 15.1\"],\n\t\"node:diagnostics_channel\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns\": true,\n\t\"node:dns\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"dns/promises\": \">= 15\",\n\t\"node:dns/promises\": \">= 16\",\n\t\"domain\": \">= 0.7.12\",\n\t\"node:domain\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"events\": true,\n\t\"node:events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"freelist\": \"< 6\",\n\t\"fs\": true,\n\t\"node:fs\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"fs/promises\": [\">= 10 && < 10.1\", \">= 14\"],\n\t\"node:fs/promises\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_agent\": \">= 0.11.1\",\n\t\"node:_http_agent\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_client\": \">= 0.11.1\",\n\t\"node:_http_client\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_common\": \">= 0.11.1\",\n\t\"node:_http_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_incoming\": \">= 0.11.1\",\n\t\"node:_http_incoming\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_outgoing\": \">= 0.11.1\",\n\t\"node:_http_outgoing\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_http_server\": \">= 0.11.1\",\n\t\"node:_http_server\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http\": true,\n\t\"node:http\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"http2\": \">= 8.8\",\n\t\"node:http2\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"https\": true,\n\t\"node:https\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"inspector\": \">= 8\",\n\t\"node:inspector\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_linklist\": \"< 8\",\n\t\"module\": true,\n\t\"node:module\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"net\": true,\n\t\"node:net\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"node-inspect/lib/_inspect\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_client\": \">= 7.6 && < 12\",\n\t\"node-inspect/lib/internal/inspect_repl\": \">= 7.6 && < 12\",\n\t\"os\": true,\n\t\"node:os\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path\": true,\n\t\"node:path\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"path/posix\": \">= 15.3\",\n\t\"node:path/posix\": \">= 16\",\n\t\"path/win32\": \">= 15.3\",\n\t\"node:path/win32\": \">= 16\",\n\t\"perf_hooks\": \">= 8.5\",\n\t\"node:perf_hooks\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"process\": \">= 1\",\n\t\"node:process\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"punycode\": \">= 0.5\",\n\t\"node:punycode\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"querystring\": true,\n\t\"node:querystring\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline\": true,\n\t\"node:readline\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"readline/promises\": \">= 17\",\n\t\"node:readline/promises\": \">= 17\",\n\t\"repl\": true,\n\t\"node:repl\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"smalloc\": \">= 0.11.5 && < 3\",\n\t\"_stream_duplex\": \">= 0.9.4\",\n\t\"node:_stream_duplex\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_transform\": \">= 0.9.4\",\n\t\"node:_stream_transform\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_wrap\": \">= 1.4.1\",\n\t\"node:_stream_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_passthrough\": \">= 0.9.4\",\n\t\"node:_stream_passthrough\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_readable\": \">= 0.9.4\",\n\t\"node:_stream_readable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_stream_writable\": \">= 0.9.4\",\n\t\"node:_stream_writable\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream\": true,\n\t\"node:stream\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"stream/consumers\": \">= 16.7\",\n\t\"node:stream/consumers\": \">= 16.7\",\n\t\"stream/promises\": \">= 15\",\n\t\"node:stream/promises\": \">= 16\",\n\t\"stream/web\": \">= 16.5\",\n\t\"node:stream/web\": \">= 16.5\",\n\t\"string_decoder\": true,\n\t\"node:string_decoder\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"sys\": [\">= 0.4 && < 0.7\", \">= 0.8\"],\n\t\"node:sys\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"node:test\": \">= 18\",\n\t\"timers\": true,\n\t\"node:timers\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"timers/promises\": \">= 15\",\n\t\"node:timers/promises\": \">= 16\",\n\t\"_tls_common\": \">= 0.11.13\",\n\t\"node:_tls_common\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"_tls_legacy\": \">= 0.11.3 && < 10\",\n\t\"_tls_wrap\": \">= 0.11.3\",\n\t\"node:_tls_wrap\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tls\": true,\n\t\"node:tls\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"trace_events\": \">= 10\",\n\t\"node:trace_events\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"tty\": true,\n\t\"node:tty\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"url\": true,\n\t\"node:url\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util\": true,\n\t\"node:util\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"util/types\": \">= 15.3\",\n\t\"node:util/types\": \">= 16\",\n\t\"v8/tools/arguments\": \">= 10 && < 12\",\n\t\"v8/tools/codemap\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/consarray\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/csvparser\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/logreader\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/profile_view\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8/tools/splaytree\": [\">= 4.4 && < 5\", \">= 5.2 && < 12\"],\n\t\"v8\": \">= 1\",\n\t\"node:v8\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"vm\": true,\n\t\"node:vm\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"wasi\": \">= 13.4 && < 13.5\",\n\t\"worker_threads\": \">= 11.7\",\n\t\"node:worker_threads\": [\">= 14.18 && < 15\", \">= 16\"],\n\t\"zlib\": \">= 0.5\",\n\t\"node:zlib\": [\">= 14.18 && < 15\", \">= 16\"]\n}\n"}},"homedir.js":{"file":{"contents":"'use strict';\n\nvar os = require('os');\n\n// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js\n\nmodule.exports = os.homedir || function homedir() {\n    var home = process.env.HOME;\n    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n\n    if (process.platform === 'win32') {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n    }\n\n    if (process.platform === 'darwin') {\n        return home || (user ? '/Users/' + user : null);\n    }\n\n    if (process.platform === 'linux') {\n        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens\n    }\n\n    return home || null;\n};\n"}},"is-core.js":{"file":{"contents":"var isCoreModule = require('is-core-module');\n\nmodule.exports = function isCore(x) {\n    return isCoreModule(x);\n};\n"}},"node-modules-paths.js":{"file":{"contents":"var path = require('path');\nvar parse = path.parse || require('path-parse'); // eslint-disable-line global-require\n\nvar getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {\n    var prefix = '/';\n    if ((/^([A-Za-z]:)/).test(absoluteStart)) {\n        prefix = '';\n    } else if ((/^\\\\\\\\/).test(absoluteStart)) {\n        prefix = '\\\\\\\\';\n    }\n\n    var paths = [absoluteStart];\n    var parsed = parse(absoluteStart);\n    while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n    }\n\n    return paths.reduce(function (dirs, aPath) {\n        return dirs.concat(modules.map(function (moduleDir) {\n            return path.resolve(prefix, aPath, moduleDir);\n        }));\n    }, []);\n};\n\nmodule.exports = function nodeModulesPaths(start, opts, request) {\n    var modules = opts && opts.moduleDirectory\n        ? [].concat(opts.moduleDirectory)\n        : ['node_modules'];\n\n    if (opts && typeof opts.paths === 'function') {\n        return opts.paths(\n            request,\n            start,\n            function () { return getNodeModulesDirs(start, modules); },\n            opts\n        );\n    }\n\n    var dirs = getNodeModulesDirs(start, modules);\n    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n};\n"}},"normalize-options.js":{"file":{"contents":"module.exports = function (x, opts) {\n    /**\n     * This file is purposefully a passthrough. It's expected that third-party\n     * environments will override it at runtime in order to inject special logic\n     * into `resolve` (by manipulating the options). One such example is the PnP\n     * code path in Yarn.\n     */\n\n    return opts || {};\n};\n"}},"sync.js":{"file":{"contents":"var isCore = require('is-core-module');\nvar fs = require('fs');\nvar path = require('path');\nvar getHomedir = require('./homedir');\nvar caller = require('./caller');\nvar nodeModulesPaths = require('./node-modules-paths');\nvar normalizeOptions = require('./normalize-options');\n\nvar realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n\nvar homedir = getHomedir();\nvar defaultPaths = function () {\n    return [\n        path.join(homedir, '.node_modules'),\n        path.join(homedir, '.node_libraries')\n    ];\n};\n\nvar defaultIsFile = function isFile(file) {\n    try {\n        var stat = fs.statSync(file, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && (stat.isFile() || stat.isFIFO());\n};\n\nvar defaultIsDir = function isDirectory(dir) {\n    try {\n        var stat = fs.statSync(dir, { throwIfNoEntry: false });\n    } catch (e) {\n        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n        throw e;\n    }\n    return !!stat && stat.isDirectory();\n};\n\nvar defaultRealpathSync = function realpathSync(x) {\n    try {\n        return realpathFS(x);\n    } catch (realpathErr) {\n        if (realpathErr.code !== 'ENOENT') {\n            throw realpathErr;\n        }\n    }\n    return x;\n};\n\nvar maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {\n    if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n    }\n    return x;\n};\n\nvar defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {\n    var body = readFileSync(pkgfile);\n    try {\n        var pkg = JSON.parse(body);\n        return pkg;\n    } catch (jsonErr) {}\n};\n\nvar getPackageCandidates = function getPackageCandidates(x, start, opts) {\n    var dirs = nodeModulesPaths(start, opts, x);\n    for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n    }\n    return dirs;\n};\n\nmodule.exports = function resolveSync(x, options) {\n    if (typeof x !== 'string') {\n        throw new TypeError('Path must be a string.');\n    }\n    var opts = normalizeOptions(x, options);\n\n    var isFile = opts.isFile || defaultIsFile;\n    var readFileSync = opts.readFileSync || fs.readFileSync;\n    var isDirectory = opts.isDirectory || defaultIsDir;\n    var realpathSync = opts.realpathSync || defaultRealpathSync;\n    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n    if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');\n    }\n    var packageIterator = opts.packageIterator;\n\n    var extensions = opts.extensions || ['.js'];\n    var includeCoreModules = opts.includeCoreModules !== false;\n    var basedir = opts.basedir || path.dirname(caller());\n    var parent = opts.filename || basedir;\n\n    opts.paths = opts.paths || defaultPaths();\n\n    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory\n    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n\n    if ((/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/).test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m) return maybeRealpathSync(realpathSync, m, opts);\n    } else if (includeCoreModules && isCore(x)) {\n        return x;\n    } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n) return maybeRealpathSync(realpathSync, n, opts);\n    }\n\n    var err = new Error(\"Cannot find module '\" + x + \"' from '\" + parent + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n\n    function loadAsFileSync(x) {\n        var pkg = loadpkg(path.dirname(x));\n\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n            var rfile = path.relative(pkg.dir, x);\n            var r = opts.pathFilter(pkg.pkg, x, rfile);\n            if (r) {\n                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign\n            }\n        }\n\n        if (isFile(x)) {\n            return x;\n        }\n\n        for (var i = 0; i < extensions.length; i++) {\n            var file = x + extensions[i];\n            if (isFile(file)) {\n                return file;\n            }\n        }\n    }\n\n    function loadpkg(dir) {\n        if (dir === '' || dir === '/') return;\n        if (process.platform === 'win32' && (/^\\w:[/\\\\]*$/).test(dir)) {\n            return;\n        }\n        if ((/[/\\\\]node_modules[/\\\\]*$/).test(dir)) return;\n\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');\n\n        if (!isFile(pkgfile)) {\n            return loadpkg(path.dirname(dir));\n        }\n\n        var pkg = readPackageSync(readFileSync, pkgfile);\n\n        if (pkg && opts.packageFilter) {\n            // v2 will pass pkgfile\n            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment\n        }\n\n        return { pkg: pkg, dir: dir };\n    }\n\n    function loadAsDirectorySync(x) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');\n        if (isFile(pkgfile)) {\n            try {\n                var pkg = readPackageSync(readFileSync, pkgfile);\n            } catch (e) {}\n\n            if (pkg && opts.packageFilter) {\n                // v2 will pass pkgfile\n                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment\n            }\n\n            if (pkg && pkg.main) {\n                if (typeof pkg.main !== 'string') {\n                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');\n                    mainError.code = 'INVALID_PACKAGE_MAIN';\n                    throw mainError;\n                }\n                if (pkg.main === '.' || pkg.main === './') {\n                    pkg.main = 'index';\n                }\n                try {\n                    var m = loadAsFileSync(path.resolve(x, pkg.main));\n                    if (m) return m;\n                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));\n                    if (n) return n;\n                } catch (e) {}\n            }\n        }\n\n        return loadAsFileSync(path.join(x, '/index'));\n    }\n\n    function loadNodeModulesSync(x, start) {\n        var thunk = function () { return getPackageCandidates(x, start, opts); };\n        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();\n\n        for (var i = 0; i < dirs.length; i++) {\n            var dir = dirs[i];\n            if (isDirectory(path.dirname(dir))) {\n                var m = loadAsFileSync(dir);\n                if (m) return m;\n                var n = loadAsDirectorySync(dir);\n                if (n) return n;\n            }\n        }\n    }\n};\n"}}}},"LICENSE":{"file":{"contents":"MIT License\n\nCopyright (c) 2012 James Halliday\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n\t\"name\": \"resolve\",\n\t\"description\": \"resolve like require.resolve() on behalf of files asynchronously and synchronously\",\n\t\"version\": \"1.22.1\",\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git://github.com/browserify/resolve.git\"\n\t},\n\t\"bin\": {\n\t\t\"resolve\": \"./bin/resolve\"\n\t},\n\t\"main\": \"index.js\",\n\t\"keywords\": [\n\t\t\"resolve\",\n\t\t\"require\",\n\t\t\"node\",\n\t\t\"module\"\n\t],\n\t\"scripts\": {\n\t\t\"prepack\": \"npmignore --auto --commentLines=autogenerated\",\n\t\t\"prepublishOnly\": \"safe-publish-latest && cp node_modules/is-core-module/core.json ./lib/ ||:\",\n\t\t\"prepublish\": \"not-in-publish || npm run prepublishOnly\",\n\t\t\"prelint\": \"eclint check $(git ls-files | xargs find 2> /dev/null | grep -vE 'node_modules|\\\\.git')\",\n\t\t\"lint\": \"eslint --ext=js,mjs --no-eslintrc -c .eslintrc . 'bin/**'\",\n\t\t\"pretests-only\": \"cd ./test/resolver/nested_symlinks && node mylib/sync && node mylib/async\",\n\t\t\"tests-only\": \"tape test/*.js\",\n\t\t\"pretest\": \"npm run lint\",\n\t\t\"test\": \"npm run --silent tests-only\",\n\t\t\"posttest\": \"npm run test:multirepo && aud --production\",\n\t\t\"test:multirepo\": \"cd ./test/resolver/multirepo && npm install && npm test\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@ljharb/eslint-config\": \"^21.0.0\",\n\t\t\"array.prototype.map\": \"^1.0.4\",\n\t\t\"aud\": \"^2.0.0\",\n\t\t\"copy-dir\": \"^1.3.0\",\n\t\t\"eclint\": \"^2.8.1\",\n\t\t\"eslint\": \"=8.8.0\",\n\t\t\"in-publish\": \"^2.0.1\",\n\t\t\"mkdirp\": \"^0.5.5\",\n\t\t\"mv\": \"^2.1.1\",\n\t\t\"npmignore\": \"^0.3.0\",\n\t\t\"object-keys\": \"^1.1.1\",\n\t\t\"rimraf\": \"^2.7.1\",\n\t\t\"safe-publish-latest\": \"^2.0.0\",\n\t\t\"semver\": \"^6.3.0\",\n\t\t\"tap\": \"0.4.13\",\n\t\t\"tape\": \"^5.5.3\",\n\t\t\"tmp\": \"^0.0.31\"\n\t},\n\t\"license\": \"MIT\",\n\t\"author\": {\n\t\t\"name\": \"James Halliday\",\n\t\t\"email\": \"mail@substack.net\",\n\t\t\"url\": \"http://substack.net\"\n\t},\n\t\"funding\": {\n\t\t\"url\": \"https://github.com/sponsors/ljharb\"\n\t},\n\t\"dependencies\": {\n\t\t\"is-core-module\": \"^2.9.0\",\n\t\t\"path-parse\": \"^1.0.7\",\n\t\t\"supports-preserve-symlinks-flag\": \"^1.0.0\"\n\t},\n\t\"publishConfig\": {\n\t\t\"ignore\": [\n\t\t\t\".github/workflows\",\n\t\t\t\"appveyor.yml\"\n\t\t]\n\t}\n}\n"}},"readme.markdown":{"file":{"contents":"# resolve <sup>[![Version Badge][2]][1]</sup>\n\nimplements the [node `require.resolve()` algorithm](https://nodejs.org/api/modules.html#modules_all_together) such that you can `require.resolve()` on behalf of a file asynchronously and synchronously\n\n[![github actions][actions-image]][actions-url]\n[![coverage][codecov-image]][codecov-url]\n[![dependency status][5]][6]\n[![dev dependency status][7]][8]\n[![License][license-image]][license-url]\n[![Downloads][downloads-image]][downloads-url]\n\n[![npm badge][11]][1]\n\n# example\n\nasynchronously resolve:\n\n```js\nvar resolve = require('resolve/async'); // or, require('resolve')\nresolve('tap', { basedir: __dirname }, function (err, res) {\n    if (err) console.error(err);\n    else console.log(res);\n});\n```\n\n```\n$ node example/async.js\n/home/substack/projects/node-resolve/node_modules/tap/lib/main.js\n```\n\nsynchronously resolve:\n\n```js\nvar resolve = require('resolve/sync'); // or, `require('resolve').sync\nvar res = resolve('tap', { basedir: __dirname });\nconsole.log(res);\n```\n\n```\n$ node example/sync.js\n/home/substack/projects/node-resolve/node_modules/tap/lib/main.js\n```\n\n# methods\n\n```js\nvar resolve = require('resolve');\nvar async = require('resolve/async');\nvar sync = require('resolve/sync');\n```\n\nFor both the synchronous and asynchronous methods, errors may have any of the following `err.code` values:\n\n- `MODULE_NOT_FOUND`: the given path string (`id`) could not be resolved to a module\n- `INVALID_BASEDIR`: the specified `opts.basedir` doesn't exist, or is not a directory\n- `INVALID_PACKAGE_MAIN`: a `package.json` was encountered with an invalid `main` property (eg. not a string)\n\n## resolve(id, opts={}, cb)\n\nAsynchronously resolve the module path string `id` into `cb(err, res [, pkg])`, where `pkg` (if defined) is the data from `package.json`.\n\noptions are:\n\n* opts.basedir - directory to begin resolving from\n\n* opts.package - `package.json` data applicable to the module being loaded\n\n* opts.extensions - array of file extensions to search in order\n\n* opts.includeCoreModules - set to `false` to exclude node core modules (e.g. `fs`) from the search\n\n* opts.readFile - how to read files asynchronously\n\n* opts.isFile - function to asynchronously test whether a file exists\n\n* opts.isDirectory - function to asynchronously test whether a file exists and is a directory\n\n* opts.realpath - function to asynchronously resolve a potential symlink to its real path\n\n* `opts.readPackage(readFile, pkgfile, cb)` - function to asynchronously read and parse a package.json file\n  * readFile - the passed `opts.readFile` or `fs.readFile` if not specified\n  * pkgfile - path to package.json\n  * cb - callback\n\n* `opts.packageFilter(pkg, pkgfile, dir)` - transform the parsed package.json contents before looking at the \"main\" field\n  * pkg - package data\n  * pkgfile - path to package.json\n  * dir - directory that contains package.json\n\n* `opts.pathFilter(pkg, path, relativePath)` - transform a path within a package\n  * pkg - package data\n  * path - the path being resolved\n  * relativePath - the path relative from the package.json location\n  * returns - a relative path that will be joined from the package.json location\n\n* opts.paths - require.paths array to use if nothing is found on the normal `node_modules` recursive walk (probably don't use this)\n\n  For advanced users, `paths` can also be a `opts.paths(request, start, opts)` function\n    * request - the import specifier being resolved\n    * start - lookup path\n    * getNodeModulesDirs - a thunk (no-argument function) that returns the paths using standard `node_modules` resolution\n    * opts - the resolution options\n\n* `opts.packageIterator(request, start, opts)` - return the list of candidate paths where the packages sources may be found (probably don't use this)\n    * request - the import specifier being resolved\n    * start - lookup path\n    * getPackageCandidates - a thunk (no-argument function) that returns the paths using standard `node_modules` resolution\n    * opts - the resolution options\n\n* opts.moduleDirectory - directory (or directories) in which to recursively look for modules. default: `\"node_modules\"`\n\n* opts.preserveSymlinks - if true, doesn't resolve `basedir` to real path before resolving.\nThis is the way Node resolves dependencies when executed with the [--preserve-symlinks](https://nodejs.org/api/all.html#cli_preserve_symlinks) flag.\n**Note:** this property is currently `true` by default but it will be changed to\n`false` in the next major version because *Node's resolution algorithm does not preserve symlinks by default*.\n\ndefault `opts` values:\n\n```js\n{\n    paths: [],\n    basedir: __dirname,\n    extensions: ['.js'],\n    includeCoreModules: true,\n    readFile: fs.readFile,\n    isFile: function isFile(file, cb) {\n        fs.stat(file, function (err, stat) {\n            if (!err) {\n                return cb(null, stat.isFile() || stat.isFIFO());\n            }\n            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n            return cb(err);\n        });\n    },\n    isDirectory: function isDirectory(dir, cb) {\n        fs.stat(dir, function (err, stat) {\n            if (!err) {\n                return cb(null, stat.isDirectory());\n            }\n            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n            return cb(err);\n        });\n    },\n    realpath: function realpath(file, cb) {\n        var realpath = typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;\n        realpath(file, function (realPathErr, realPath) {\n            if (realPathErr && realPathErr.code !== 'ENOENT') cb(realPathErr);\n            else cb(null, realPathErr ? file : realPath);\n        });\n    },\n    readPackage: function defaultReadPackage(readFile, pkgfile, cb) {\n        readFile(pkgfile, function (readFileErr, body) {\n            if (readFileErr) cb(readFileErr);\n            else {\n                try {\n                    var pkg = JSON.parse(body);\n                    cb(null, pkg);\n                } catch (jsonErr) {\n                    cb(null);\n                }\n            }\n        });\n    },\n    moduleDirectory: 'node_modules',\n    preserveSymlinks: true\n}\n```\n\n## resolve.sync(id, opts)\n\nSynchronously resolve the module path string `id`, returning the result and\nthrowing an error when `id` can't be resolved.\n\noptions are:\n\n* opts.basedir - directory to begin resolving from\n\n* opts.extensions - array of file extensions to search in order\n\n* opts.includeCoreModules - set to `false` to exclude node core modules (e.g. `fs`) from the search\n\n* opts.readFileSync - how to read files synchronously\n\n* opts.isFile - function to synchronously test whether a file exists\n\n* opts.isDirectory - function to synchronously test whether a file exists and is a directory\n\n* opts.realpathSync - function to synchronously resolve a potential symlink to its real path\n\n* `opts.readPackageSync(readFileSync, pkgfile)` - function to synchronously read and parse a package.json file\n  * readFileSync - the passed `opts.readFileSync` or `fs.readFileSync` if not specified\n  * pkgfile - path to package.json\n\n* `opts.packageFilter(pkg, dir)` - transform the parsed package.json contents before looking at the \"main\" field\n  * pkg - package data\n  * dir - directory that contains package.json (Note: the second argument will change to \"pkgfile\" in v2)\n\n* `opts.pathFilter(pkg, path, relativePath)` - transform a path within a package\n  * pkg - package data\n  * path - the path being resolved\n  * relativePath - the path relative from the package.json location\n  * returns - a relative path that will be joined from the package.json location\n\n* opts.paths - require.paths array to use if nothing is found on the normal `node_modules` recursive walk (probably don't use this)\n\n  For advanced users, `paths` can also be a `opts.paths(request, start, opts)` function\n    * request - the import specifier being resolved\n    * start - lookup path\n    * getNodeModulesDirs - a thunk (no-argument function) that returns the paths using standard `node_modules` resolution\n    * opts - the resolution options\n\n* `opts.packageIterator(request, start, opts)` - return the list of candidate paths where the packages sources may be found (probably don't use this)\n    * request - the import specifier being resolved\n    * start - lookup path\n    * getPackageCandidates - a thunk (no-argument function) that returns the paths using standard `node_modules` resolution\n    * opts - the resolution options\n\n* opts.moduleDirectory - directory (or directories) in which to recursively look for modules. default: `\"node_modules\"`\n\n* opts.preserveSymlinks - if true, doesn't resolve `basedir` to real path before resolving.\nThis is the way Node resolves dependencies when executed with the [--preserve-symlinks](https://nodejs.org/api/all.html#cli_preserve_symlinks) flag.\n**Note:** this property is currently `true` by default but it will be changed to\n`false` in the next major version because *Node's resolution algorithm does not preserve symlinks by default*.\n\ndefault `opts` values:\n\n```js\n{\n    paths: [],\n    basedir: __dirname,\n    extensions: ['.js'],\n    includeCoreModules: true,\n    readFileSync: fs.readFileSync,\n    isFile: function isFile(file) {\n        try {\n            var stat = fs.statSync(file);\n        } catch (e) {\n            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n            throw e;\n        }\n        return stat.isFile() || stat.isFIFO();\n    },\n    isDirectory: function isDirectory(dir) {\n        try {\n            var stat = fs.statSync(dir);\n        } catch (e) {\n            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;\n            throw e;\n        }\n        return stat.isDirectory();\n    },\n    realpathSync: function realpathSync(file) {\n        try {\n            var realpath = typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;\n            return realpath(file);\n        } catch (realPathErr) {\n            if (realPathErr.code !== 'ENOENT') {\n                throw realPathErr;\n            }\n        }\n        return file;\n    },\n    readPackageSync: function defaultReadPackageSync(readFileSync, pkgfile) {\n        var body = readFileSync(pkgfile);\n        try {\n            var pkg = JSON.parse(body);\n            return pkg;\n        } catch (jsonErr) {}\n    },\n    moduleDirectory: 'node_modules',\n    preserveSymlinks: true\n}\n```\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```sh\nnpm install resolve\n```\n\n# license\n\nMIT\n\n[1]: https://npmjs.org/package/resolve\n[2]: https://versionbadg.es/browserify/resolve.svg\n[5]: https://david-dm.org/browserify/resolve.svg\n[6]: https://david-dm.org/browserify/resolve\n[7]: https://david-dm.org/browserify/resolve/dev-status.svg\n[8]: https://david-dm.org/browserify/resolve#info=devDependencies\n[11]: https://nodei.co/npm/resolve.png?downloads=true&stars=true\n[license-image]: https://img.shields.io/npm/l/resolve.svg\n[license-url]: LICENSE\n[downloads-image]: https://img.shields.io/npm/dm/resolve.svg\n[downloads-url]: https://npm-stat.com/charts.html?package=resolve\n[codecov-image]: https://codecov.io/gh/browserify/resolve/branch/main/graphs/badge.svg\n[codecov-url]: https://app.codecov.io/gh/browserify/resolve/\n[actions-image]: https://img.shields.io/endpoint?url=https://github-actions-badge-u3jn4tfpocch.runkit.sh/browserify/resolve\n[actions-url]: https://github.com/browserify/resolve/actions\n"}},"SECURITY.md":{"file":{"contents":"# Security\n\nPlease email [@ljharb](https://github.com/ljharb) or see https://tidelift.com/security if you have a potential security vulnerability to report.\n"}},"sync.js":{"file":{"contents":"'use strict';\n\nmodule.exports = require('./lib/sync');\n"}},"test":{"directory":{"core.js":{"file":{"contents":"var test = require('tape');\nvar keys = require('object-keys');\nvar semver = require('semver');\n\nvar resolve = require('../');\n\nvar brokenNode = semver.satisfies(process.version, '11.11 - 11.13');\n\ntest('core modules', function (t) {\n    t.test('isCore()', function (st) {\n        st.ok(resolve.isCore('fs'));\n        st.ok(resolve.isCore('net'));\n        st.ok(resolve.isCore('http'));\n\n        st.ok(!resolve.isCore('seq'));\n        st.ok(!resolve.isCore('../'));\n\n        st.ok(!resolve.isCore('toString'));\n\n        st.end();\n    });\n\n    t.test('core list', function (st) {\n        var cores = keys(resolve.core);\n        st.plan(cores.length);\n\n        for (var i = 0; i < cores.length; ++i) {\n            var mod = cores[i];\n            // note: this must be require, not require.resolve, due to https://github.com/nodejs/node/issues/43274\n            var requireFunc = function () { require(mod); }; // eslint-disable-line no-loop-func\n            t.comment(mod + ': ' + resolve.core[mod]);\n            if (resolve.core[mod]) {\n                st.doesNotThrow(requireFunc, mod + ' supported; requiring does not throw');\n            } else if (brokenNode) {\n                st.ok(true, 'this version of node is broken: attempting to require things that fail to resolve breaks \"home_paths\" tests');\n            } else {\n                st.throws(requireFunc, mod + ' not supported; requiring throws');\n            }\n        }\n\n        st.end();\n    });\n\n    t.test('core via repl module', { skip: !resolve.core.repl }, function (st) {\n        var libs = require('repl')._builtinLibs; // eslint-disable-line no-underscore-dangle\n        if (!libs) {\n            st.skip('module.builtinModules does not exist');\n            return st.end();\n        }\n        for (var i = 0; i < libs.length; ++i) {\n            var mod = libs[i];\n            st.ok(resolve.core[mod], mod + ' is a core module');\n            st.doesNotThrow(\n                function () { require(mod); }, // eslint-disable-line no-loop-func\n                'requiring ' + mod + ' does not throw'\n            );\n        }\n        st.end();\n    });\n\n    t.test('core via builtinModules list', { skip: !resolve.core.module }, function (st) {\n        var libs = require('module').builtinModules;\n        if (!libs) {\n            st.skip('module.builtinModules does not exist');\n            return st.end();\n        }\n        var blacklist = [\n            '_debug_agent',\n            'v8/tools/tickprocessor-driver',\n            'v8/tools/SourceMap',\n            'v8/tools/tickprocessor',\n            'v8/tools/profile'\n        ];\n        for (var i = 0; i < libs.length; ++i) {\n            var mod = libs[i];\n            if (blacklist.indexOf(mod) === -1) {\n                st.ok(resolve.core[mod], mod + ' is a core module');\n                st.doesNotThrow(\n                    function () { require(mod); }, // eslint-disable-line no-loop-func\n                    'requiring ' + mod + ' does not throw'\n                );\n            }\n        }\n        st.end();\n    });\n\n    t.end();\n});\n"}},"dotdot":{"directory":{"abc":{"directory":{"index.js":{"file":{"contents":"var x = require('..');\nconsole.log(x);\n"}}}},"index.js":{"file":{"contents":"module.exports = 'whatever';\n"}}}},"dotdot.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('dotdot', function (t) {\n    t.plan(4);\n    var dir = path.join(__dirname, '/dotdot/abc');\n\n    resolve('..', { basedir: dir }, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(__dirname, 'dotdot/index.js'));\n    });\n\n    resolve('.', { basedir: dir }, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('dotdot sync', function (t) {\n    t.plan(2);\n    var dir = path.join(__dirname, '/dotdot/abc');\n\n    var a = resolve.sync('..', { basedir: dir });\n    t.equal(a, path.join(__dirname, 'dotdot/index.js'));\n\n    var b = resolve.sync('.', { basedir: dir });\n    t.equal(b, path.join(dir, 'index.js'));\n});\n"}},"faulty_basedir.js":{"file":{"contents":"var test = require('tape');\nvar path = require('path');\nvar resolve = require('../');\n\ntest('faulty basedir must produce error in windows', { skip: process.platform !== 'win32' }, function (t) {\n    t.plan(1);\n\n    var resolverDir = 'C:\\\\a\\\\b\\\\c\\\\d';\n\n    resolve('tape/lib/test.js', { basedir: resolverDir }, function (err, res, pkg) {\n        t.equal(!!err, true);\n    });\n});\n\ntest('non-existent basedir should not throw when preserveSymlinks is false', function (t) {\n    t.plan(2);\n\n    var opts = {\n        basedir: path.join(path.sep, 'unreal', 'path', 'that', 'does', 'not', 'exist'),\n        preserveSymlinks: false\n    };\n\n    var module = './dotdot/abc';\n\n    resolve(module, opts, function (err, res) {\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n        t.equal(res, undefined);\n    });\n});\n"}},"filter.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('filter', function (t) {\n    t.plan(4);\n    var dir = path.join(__dirname, 'resolver');\n    var packageFilterArgs;\n    resolve('./baz', {\n        basedir: dir,\n        packageFilter: function (pkg, pkgfile) {\n            pkg.main = 'doom'; // eslint-disable-line no-param-reassign\n            packageFilterArgs = [pkg, pkgfile];\n            return pkg;\n        }\n    }, function (err, res, pkg) {\n        if (err) t.fail(err);\n\n        t.equal(res, path.join(dir, 'baz/doom.js'), 'changing the package \"main\" works');\n\n        var packageData = packageFilterArgs[0];\n        t.equal(pkg, packageData, 'first packageFilter argument is \"pkg\"');\n        t.equal(packageData.main, 'doom', 'package \"main\" was altered');\n\n        var packageFile = packageFilterArgs[1];\n        t.equal(\n            packageFile,\n            path.join(dir, 'baz/package.json'),\n            'second packageFilter argument is \"pkgfile\"'\n        );\n\n        t.end();\n    });\n});\n"}},"filter_sync.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('filter', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var packageFilterArgs;\n    var res = resolve.sync('./baz', {\n        basedir: dir,\n        // NOTE: in v2.x, this will be `pkg, pkgfile, dir`, but must remain \"broken\" here in v1.x for compatibility\n        packageFilter: function (pkg, /*pkgfile,*/ dir) { // eslint-disable-line spaced-comment\n            pkg.main = 'doom'; // eslint-disable-line no-param-reassign\n            packageFilterArgs = 'is 1.x' ? [pkg, dir] : [pkg, pkgfile, dir]; // eslint-disable-line no-constant-condition, no-undef\n            return pkg;\n        }\n    });\n\n    t.equal(res, path.join(dir, 'baz/doom.js'), 'changing the package \"main\" works');\n\n    var packageData = packageFilterArgs[0];\n    t.equal(packageData.main, 'doom', 'package \"main\" was altered');\n\n    if (!'is 1.x') { // eslint-disable-line no-constant-condition\n        var packageFile = packageFilterArgs[1];\n        t.equal(packageFile, path.join(dir, 'baz', 'package.json'), 'package.json path is correct');\n    }\n\n    var packageDir = packageFilterArgs['is 1.x' ? 1 : 2]; // eslint-disable-line no-constant-condition\n    // eslint-disable-next-line no-constant-condition\n    t.equal(packageDir, path.join(dir, 'baz'), ('is 1.x' ? 'second' : 'third') + ' packageFilter argument is \"dir\"');\n\n    t.end();\n});\n"}},"home_paths.js":{"file":{"contents":"'use strict';\n\nvar fs = require('fs');\nvar homedir = require('../lib/homedir');\nvar path = require('path');\n\nvar test = require('tape');\nvar mkdirp = require('mkdirp');\nvar rimraf = require('rimraf');\nvar mv = require('mv');\nvar copyDir = require('copy-dir');\nvar tmp = require('tmp');\n\nvar HOME = homedir();\n\nvar hnm = path.join(HOME, '.node_modules');\nvar hnl = path.join(HOME, '.node_libraries');\n\nvar resolve = require('../async');\n\nfunction makeDir(t, dir, cb) {\n    mkdirp(dir, function (err) {\n        if (err) {\n            cb(err);\n        } else {\n            t.teardown(function cleanup() {\n                rimraf.sync(dir);\n            });\n            cb();\n        }\n    });\n}\n\nfunction makeTempDir(t, dir, cb) {\n    if (fs.existsSync(dir)) {\n        var tmpResult = tmp.dirSync();\n        t.teardown(tmpResult.removeCallback);\n        var backup = path.join(tmpResult.name, path.basename(dir));\n        mv(dir, backup, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                t.teardown(function () {\n                    mv(backup, dir, cb);\n                });\n                makeDir(t, dir, cb);\n            }\n        });\n    } else {\n        makeDir(t, dir, cb);\n    }\n}\n\ntest('homedir module paths', function (t) {\n    t.plan(7);\n\n    makeTempDir(t, hnm, function (err) {\n        t.error(err, 'no error with HNM temp dir');\n        if (err) {\n            return t.end();\n        }\n\n        var bazHNMDir = path.join(hnm, 'baz');\n        var dotMainDir = path.join(hnm, 'dot_main');\n        copyDir.sync(path.join(__dirname, 'resolver/baz'), bazHNMDir);\n        copyDir.sync(path.join(__dirname, 'resolver/dot_main'), dotMainDir);\n\n        var bazPkg = { name: 'baz', main: 'quux.js' };\n        var dotMainPkg = { main: 'index' };\n\n        var bazHNMmain = path.join(bazHNMDir, 'quux.js');\n        t.equal(require.resolve('baz'), bazHNMmain, 'sanity check: require.resolve finds HNM `baz`');\n        var dotMainMain = path.join(dotMainDir, 'index.js');\n        t.equal(require.resolve('dot_main'), dotMainMain, 'sanity check: require.resolve finds `dot_main`');\n\n        makeTempDir(t, hnl, function (err) {\n            t.error(err, 'no error with HNL temp dir');\n            if (err) {\n                return t.end();\n            }\n            var bazHNLDir = path.join(hnl, 'baz');\n            copyDir.sync(path.join(__dirname, 'resolver/baz'), bazHNLDir);\n\n            var dotSlashMainDir = path.join(hnl, 'dot_slash_main');\n            var dotSlashMainMain = path.join(dotSlashMainDir, 'index.js');\n            var dotSlashMainPkg = { main: 'index' };\n            copyDir.sync(path.join(__dirname, 'resolver/dot_slash_main'), dotSlashMainDir);\n\n            t.equal(require.resolve('baz'), bazHNMmain, 'sanity check: require.resolve finds HNM `baz`');\n            t.equal(require.resolve('dot_slash_main'), dotSlashMainMain, 'sanity check: require.resolve finds HNL `dot_slash_main`');\n\n            t.test('with temp dirs', function (st) {\n                st.plan(3);\n\n                st.test('just in `$HOME/.node_modules`', function (s2t) {\n                    s2t.plan(3);\n\n                    resolve('dot_main', function (err, res, pkg) {\n                        s2t.error(err, 'no error resolving `dot_main`');\n                        s2t.equal(res, dotMainMain, '`dot_main` resolves in `$HOME/.node_modules`');\n                        s2t.deepEqual(pkg, dotMainPkg);\n                    });\n                });\n\n                st.test('just in `$HOME/.node_libraries`', function (s2t) {\n                    s2t.plan(3);\n\n                    resolve('dot_slash_main', function (err, res, pkg) {\n                        s2t.error(err, 'no error resolving `dot_slash_main`');\n                        s2t.equal(res, dotSlashMainMain, '`dot_slash_main` resolves in `$HOME/.node_libraries`');\n                        s2t.deepEqual(pkg, dotSlashMainPkg);\n                    });\n                });\n\n                st.test('in `$HOME/.node_libraries` and `$HOME/.node_modules`', function (s2t) {\n                    s2t.plan(3);\n\n                    resolve('baz', function (err, res, pkg) {\n                        s2t.error(err, 'no error resolving `baz`');\n                        s2t.equal(res, bazHNMmain, '`baz` resolves in `$HOME/.node_modules` when in both');\n                        s2t.deepEqual(pkg, bazPkg);\n                    });\n                });\n            });\n        });\n    });\n});\n"}},"home_paths_sync.js":{"file":{"contents":"'use strict';\n\nvar fs = require('fs');\nvar homedir = require('../lib/homedir');\nvar path = require('path');\n\nvar test = require('tape');\nvar mkdirp = require('mkdirp');\nvar rimraf = require('rimraf');\nvar mv = require('mv');\nvar copyDir = require('copy-dir');\nvar tmp = require('tmp');\n\nvar HOME = homedir();\n\nvar hnm = path.join(HOME, '.node_modules');\nvar hnl = path.join(HOME, '.node_libraries');\n\nvar resolve = require('../sync');\n\nfunction makeDir(t, dir, cb) {\n    mkdirp(dir, function (err) {\n        if (err) {\n            cb(err);\n        } else {\n            t.teardown(function cleanup() {\n                rimraf.sync(dir);\n            });\n            cb();\n        }\n    });\n}\n\nfunction makeTempDir(t, dir, cb) {\n    if (fs.existsSync(dir)) {\n        var tmpResult = tmp.dirSync();\n        t.teardown(tmpResult.removeCallback);\n        var backup = path.join(tmpResult.name, path.basename(dir));\n        mv(dir, backup, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                t.teardown(function () {\n                    mv(backup, dir, cb);\n                });\n                makeDir(t, dir, cb);\n            }\n        });\n    } else {\n        makeDir(t, dir, cb);\n    }\n}\n\ntest('homedir module paths', function (t) {\n    t.plan(7);\n\n    makeTempDir(t, hnm, function (err) {\n        t.error(err, 'no error with HNM temp dir');\n        if (err) {\n            return t.end();\n        }\n\n        var bazHNMDir = path.join(hnm, 'baz');\n        var dotMainDir = path.join(hnm, 'dot_main');\n        copyDir.sync(path.join(__dirname, 'resolver/baz'), bazHNMDir);\n        copyDir.sync(path.join(__dirname, 'resolver/dot_main'), dotMainDir);\n\n        var bazHNMmain = path.join(bazHNMDir, 'quux.js');\n        t.equal(require.resolve('baz'), bazHNMmain, 'sanity check: require.resolve finds HNM `baz`');\n        var dotMainMain = path.join(dotMainDir, 'index.js');\n        t.equal(require.resolve('dot_main'), dotMainMain, 'sanity check: require.resolve finds `dot_main`');\n\n        makeTempDir(t, hnl, function (err) {\n            t.error(err, 'no error with HNL temp dir');\n            if (err) {\n                return t.end();\n            }\n            var bazHNLDir = path.join(hnl, 'baz');\n            copyDir.sync(path.join(__dirname, 'resolver/baz'), bazHNLDir);\n\n            var dotSlashMainDir = path.join(hnl, 'dot_slash_main');\n            var dotSlashMainMain = path.join(dotSlashMainDir, 'index.js');\n            copyDir.sync(path.join(__dirname, 'resolver/dot_slash_main'), dotSlashMainDir);\n\n            t.equal(require.resolve('baz'), bazHNMmain, 'sanity check: require.resolve finds HNM `baz`');\n            t.equal(require.resolve('dot_slash_main'), dotSlashMainMain, 'sanity check: require.resolve finds HNL `dot_slash_main`');\n\n            t.test('with temp dirs', function (st) {\n                st.plan(3);\n\n                st.test('just in `$HOME/.node_modules`', function (s2t) {\n                    s2t.plan(1);\n\n                    var res = resolve('dot_main');\n                    s2t.equal(res, dotMainMain, '`dot_main` resolves in `$HOME/.node_modules`');\n                });\n\n                st.test('just in `$HOME/.node_libraries`', function (s2t) {\n                    s2t.plan(1);\n\n                    var res = resolve('dot_slash_main');\n                    s2t.equal(res, dotSlashMainMain, '`dot_slash_main` resolves in `$HOME/.node_libraries`');\n                });\n\n                st.test('in `$HOME/.node_libraries` and `$HOME/.node_modules`', function (s2t) {\n                    s2t.plan(1);\n\n                    var res = resolve('baz');\n                    s2t.equal(res, bazHNMmain, '`baz` resolves in `$HOME/.node_modules` when in both');\n                });\n            });\n        });\n    });\n});\n"}},"mock.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('mock', function (t) {\n    t.plan(8);\n\n    var files = {};\n    files[path.resolve('/foo/bar/baz.js')] = 'beep';\n\n    var dirs = {};\n    dirs[path.resolve('/foo/bar')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, path.resolve(file)));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            readFile: function (file, cb) {\n                cb(null, files[path.resolve(file)]);\n            },\n            realpath: function (file, cb) {\n                cb(null, file);\n            }\n        };\n    }\n\n    resolve('./baz', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/baz.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('./baz.js', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/baz.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('baz', opts('/foo/bar'), function (err, res) {\n        t.equal(err.message, \"Cannot find module 'baz' from '\" + path.resolve('/foo/bar') + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    resolve('../baz', opts('/foo/bar'), function (err, res) {\n        t.equal(err.message, \"Cannot find module '../baz' from '\" + path.resolve('/foo/bar') + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n});\n\ntest('mock from package', function (t) {\n    t.plan(8);\n\n    var files = {};\n    files[path.resolve('/foo/bar/baz.js')] = 'beep';\n\n    var dirs = {};\n    dirs[path.resolve('/foo/bar')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, file));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            'package': { main: 'bar' },\n            readFile: function (file, cb) {\n                cb(null, files[file]);\n            },\n            realpath: function (file, cb) {\n                cb(null, file);\n            }\n        };\n    }\n\n    resolve('./baz', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/baz.js'));\n        t.equal(pkg && pkg.main, 'bar');\n    });\n\n    resolve('./baz.js', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/baz.js'));\n        t.equal(pkg && pkg.main, 'bar');\n    });\n\n    resolve('baz', opts('/foo/bar'), function (err, res) {\n        t.equal(err.message, \"Cannot find module 'baz' from '\" + path.resolve('/foo/bar') + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    resolve('../baz', opts('/foo/bar'), function (err, res) {\n        t.equal(err.message, \"Cannot find module '../baz' from '\" + path.resolve('/foo/bar') + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n});\n\ntest('mock package', function (t) {\n    t.plan(2);\n\n    var files = {};\n    files[path.resolve('/foo/node_modules/bar/baz.js')] = 'beep';\n    files[path.resolve('/foo/node_modules/bar/package.json')] = JSON.stringify({\n        main: './baz.js'\n    });\n\n    var dirs = {};\n    dirs[path.resolve('/foo')] = true;\n    dirs[path.resolve('/foo/node_modules')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, path.resolve(file)));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            readFile: function (file, cb) {\n                cb(null, files[path.resolve(file)]);\n            },\n            realpath: function (file, cb) {\n                cb(null, file);\n            }\n        };\n    }\n\n    resolve('bar', opts('/foo'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/node_modules/bar/baz.js'));\n        t.equal(pkg && pkg.main, './baz.js');\n    });\n});\n\ntest('mock package from package', function (t) {\n    t.plan(2);\n\n    var files = {};\n    files[path.resolve('/foo/node_modules/bar/baz.js')] = 'beep';\n    files[path.resolve('/foo/node_modules/bar/package.json')] = JSON.stringify({\n        main: './baz.js'\n    });\n\n    var dirs = {};\n    dirs[path.resolve('/foo')] = true;\n    dirs[path.resolve('/foo/node_modules')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, path.resolve(file)));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            'package': { main: 'bar' },\n            readFile: function (file, cb) {\n                cb(null, files[path.resolve(file)]);\n            },\n            realpath: function (file, cb) {\n                cb(null, file);\n            }\n        };\n    }\n\n    resolve('bar', opts('/foo'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/node_modules/bar/baz.js'));\n        t.equal(pkg && pkg.main, './baz.js');\n    });\n});\n\ntest('symlinked', function (t) {\n    t.plan(4);\n\n    var files = {};\n    files[path.resolve('/foo/bar/baz.js')] = 'beep';\n    files[path.resolve('/foo/bar/symlinked/baz.js')] = 'beep';\n\n    var dirs = {};\n    dirs[path.resolve('/foo/bar')] = true;\n    dirs[path.resolve('/foo/bar/symlinked')] = true;\n\n    function opts(basedir) {\n        return {\n            preserveSymlinks: false,\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, path.resolve(file)));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            readFile: function (file, cb) {\n                cb(null, files[path.resolve(file)]);\n            },\n            realpath: function (file, cb) {\n                var resolved = path.resolve(file);\n\n                if (resolved.indexOf('symlinked') >= 0) {\n                    cb(null, resolved);\n                    return;\n                }\n\n                var ext = path.extname(resolved);\n\n                if (ext) {\n                    var dir = path.dirname(resolved);\n                    var base = path.basename(resolved);\n                    cb(null, path.join(dir, 'symlinked', base));\n                } else {\n                    cb(null, path.join(resolved, 'symlinked'));\n                }\n            }\n        };\n    }\n\n    resolve('./baz', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/symlinked/baz.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('./baz.js', opts('/foo/bar'), function (err, res, pkg) {\n        if (err) return t.fail(err);\n        t.equal(res, path.resolve('/foo/bar/symlinked/baz.js'));\n        t.equal(pkg, undefined);\n    });\n});\n\ntest('readPackage', function (t) {\n    t.plan(3);\n\n    var files = {};\n    files[path.resolve('/foo/node_modules/bar/something-else.js')] = 'beep';\n    files[path.resolve('/foo/node_modules/bar/package.json')] = JSON.stringify({\n        main: './baz.js'\n    });\n    files[path.resolve('/foo/node_modules/bar/baz.js')] = 'boop';\n\n    var dirs = {};\n    dirs[path.resolve('/foo')] = true;\n    dirs[path.resolve('/foo/node_modules')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file, cb) {\n                cb(null, Object.prototype.hasOwnProperty.call(files, path.resolve(file)));\n            },\n            isDirectory: function (dir, cb) {\n                cb(null, !!dirs[path.resolve(dir)]);\n            },\n            'package': { main: 'bar' },\n            readFile: function (file, cb) {\n                cb(null, files[path.resolve(file)]);\n            },\n            realpath: function (file, cb) {\n                cb(null, file);\n            }\n        };\n    }\n\n    t.test('with readFile', function (st) {\n        st.plan(3);\n\n        resolve('bar', opts('/foo'), function (err, res, pkg) {\n            st.error(err);\n            st.equal(res, path.resolve('/foo/node_modules/bar/baz.js'));\n            st.equal(pkg && pkg.main, './baz.js');\n        });\n    });\n\n    var readPackage = function (readFile, file, cb) {\n        var barPackage = path.join('bar', 'package.json');\n        if (file.slice(-barPackage.length) === barPackage) {\n            cb(null, { main: './something-else.js' });\n        } else {\n            cb(null, JSON.parse(files[path.resolve(file)]));\n        }\n    };\n\n    t.test('with readPackage', function (st) {\n        st.plan(3);\n\n        var options = opts('/foo');\n        delete options.readFile;\n        options.readPackage = readPackage;\n        resolve('bar', options, function (err, res, pkg) {\n            st.error(err);\n            st.equal(res, path.resolve('/foo/node_modules/bar/something-else.js'));\n            st.equal(pkg && pkg.main, './something-else.js');\n        });\n    });\n\n    t.test('with readFile and readPackage', function (st) {\n        st.plan(1);\n\n        var options = opts('/foo');\n        options.readPackage = readPackage;\n        resolve('bar', options, function (err) {\n            st.throws(function () { throw err; }, TypeError, 'errors when both readFile and readPackage are provided');\n        });\n    });\n});\n"}},"mock_sync.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('mock', function (t) {\n    t.plan(4);\n\n    var files = {};\n    files[path.resolve('/foo/bar/baz.js')] = 'beep';\n\n    var dirs = {};\n    dirs[path.resolve('/foo/bar')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file) {\n                return Object.prototype.hasOwnProperty.call(files, path.resolve(file));\n            },\n            isDirectory: function (dir) {\n                return !!dirs[path.resolve(dir)];\n            },\n            readFileSync: function (file) {\n                return files[path.resolve(file)];\n            },\n            realpathSync: function (file) {\n                return file;\n            }\n        };\n    }\n\n    t.equal(\n        resolve.sync('./baz', opts('/foo/bar')),\n        path.resolve('/foo/bar/baz.js')\n    );\n\n    t.equal(\n        resolve.sync('./baz.js', opts('/foo/bar')),\n        path.resolve('/foo/bar/baz.js')\n    );\n\n    t.throws(function () {\n        resolve.sync('baz', opts('/foo/bar'));\n    });\n\n    t.throws(function () {\n        resolve.sync('../baz', opts('/foo/bar'));\n    });\n});\n\ntest('mock package', function (t) {\n    t.plan(1);\n\n    var files = {};\n    files[path.resolve('/foo/node_modules/bar/baz.js')] = 'beep';\n    files[path.resolve('/foo/node_modules/bar/package.json')] = JSON.stringify({\n        main: './baz.js'\n    });\n\n    var dirs = {};\n    dirs[path.resolve('/foo')] = true;\n    dirs[path.resolve('/foo/node_modules')] = true;\n\n    function opts(basedir) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file) {\n                return Object.prototype.hasOwnProperty.call(files, path.resolve(file));\n            },\n            isDirectory: function (dir) {\n                return !!dirs[path.resolve(dir)];\n            },\n            readFileSync: function (file) {\n                return files[path.resolve(file)];\n            },\n            realpathSync: function (file) {\n                return file;\n            }\n        };\n    }\n\n    t.equal(\n        resolve.sync('bar', opts('/foo')),\n        path.resolve('/foo/node_modules/bar/baz.js')\n    );\n});\n\ntest('symlinked', function (t) {\n    t.plan(2);\n\n    var files = {};\n    files[path.resolve('/foo/bar/baz.js')] = 'beep';\n    files[path.resolve('/foo/bar/symlinked/baz.js')] = 'beep';\n\n    var dirs = {};\n    dirs[path.resolve('/foo/bar')] = true;\n    dirs[path.resolve('/foo/bar/symlinked')] = true;\n\n    function opts(basedir) {\n        return {\n            preserveSymlinks: false,\n            basedir: path.resolve(basedir),\n            isFile: function (file) {\n                return Object.prototype.hasOwnProperty.call(files, path.resolve(file));\n            },\n            isDirectory: function (dir) {\n                return !!dirs[path.resolve(dir)];\n            },\n            readFileSync: function (file) {\n                return files[path.resolve(file)];\n            },\n            realpathSync: function (file) {\n                var resolved = path.resolve(file);\n\n                if (resolved.indexOf('symlinked') >= 0) {\n                    return resolved;\n                }\n\n                var ext = path.extname(resolved);\n\n                if (ext) {\n                    var dir = path.dirname(resolved);\n                    var base = path.basename(resolved);\n                    return path.join(dir, 'symlinked', base);\n                }\n                return path.join(resolved, 'symlinked');\n            }\n        };\n    }\n\n    t.equal(\n        resolve.sync('./baz', opts('/foo/bar')),\n        path.resolve('/foo/bar/symlinked/baz.js')\n    );\n\n    t.equal(\n        resolve.sync('./baz.js', opts('/foo/bar')),\n        path.resolve('/foo/bar/symlinked/baz.js')\n    );\n});\n\ntest('readPackageSync', function (t) {\n    t.plan(3);\n\n    var files = {};\n    files[path.resolve('/foo/node_modules/bar/something-else.js')] = 'beep';\n    files[path.resolve('/foo/node_modules/bar/package.json')] = JSON.stringify({\n        main: './baz.js'\n    });\n    files[path.resolve('/foo/node_modules/bar/baz.js')] = 'boop';\n\n    var dirs = {};\n    dirs[path.resolve('/foo')] = true;\n    dirs[path.resolve('/foo/node_modules')] = true;\n\n    function opts(basedir, useReadPackage) {\n        return {\n            basedir: path.resolve(basedir),\n            isFile: function (file) {\n                return Object.prototype.hasOwnProperty.call(files, path.resolve(file));\n            },\n            isDirectory: function (dir) {\n                return !!dirs[path.resolve(dir)];\n            },\n            readFileSync: useReadPackage ? null : function (file) {\n                return files[path.resolve(file)];\n            },\n            realpathSync: function (file) {\n                return file;\n            }\n        };\n    }\n    t.test('with readFile', function (st) {\n        st.plan(1);\n\n        st.equal(\n            resolve.sync('bar', opts('/foo')),\n            path.resolve('/foo/node_modules/bar/baz.js')\n        );\n    });\n\n    var readPackageSync = function (readFileSync, file) {\n        if (file.indexOf(path.join('bar', 'package.json')) >= 0) {\n            return { main: './something-else.js' };\n        }\n        return JSON.parse(files[path.resolve(file)]);\n    };\n\n    t.test('with readPackage', function (st) {\n        st.plan(1);\n\n        var options = opts('/foo');\n        delete options.readFileSync;\n        options.readPackageSync = readPackageSync;\n\n        st.equal(\n            resolve.sync('bar', options),\n            path.resolve('/foo/node_modules/bar/something-else.js')\n        );\n    });\n\n    t.test('with readFile and readPackage', function (st) {\n        st.plan(1);\n\n        var options = opts('/foo');\n        options.readPackageSync = readPackageSync;\n        st.throws(\n            function () { resolve.sync('bar', options); },\n            TypeError,\n            'errors when both readFile and readPackage are provided'\n        );\n    });\n});\n\n"}},"module_dir":{"directory":{"xmodules":{"directory":{"aaa":{"directory":{"index.js":{"file":{"contents":"module.exports = function (x) { return x * 100; };\n"}}}}}},"ymodules":{"directory":{"aaa":{"directory":{"index.js":{"file":{"contents":"module.exports = function (x) { return x + 100; };\n"}}}}}},"zmodules":{"directory":{"bbb":{"directory":{"main.js":{"file":{"contents":"module.exports = function (n) { return n * 111; };\n"}},"package.json":{"file":{"contents":"{\n  \"main\": \"main.js\"\n}\n"}}}}}}}},"module_dir.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('moduleDirectory strings', function (t) {\n    t.plan(4);\n    var dir = path.join(__dirname, 'module_dir');\n    var xopts = {\n        basedir: dir,\n        moduleDirectory: 'xmodules'\n    };\n    resolve('aaa', xopts, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, '/xmodules/aaa/index.js'));\n    });\n\n    var yopts = {\n        basedir: dir,\n        moduleDirectory: 'ymodules'\n    };\n    resolve('aaa', yopts, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, '/ymodules/aaa/index.js'));\n    });\n});\n\ntest('moduleDirectory array', function (t) {\n    t.plan(6);\n    var dir = path.join(__dirname, 'module_dir');\n    var aopts = {\n        basedir: dir,\n        moduleDirectory: ['xmodules', 'ymodules', 'zmodules']\n    };\n    resolve('aaa', aopts, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, '/xmodules/aaa/index.js'));\n    });\n\n    var bopts = {\n        basedir: dir,\n        moduleDirectory: ['zmodules', 'ymodules', 'xmodules']\n    };\n    resolve('aaa', bopts, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, '/ymodules/aaa/index.js'));\n    });\n\n    var copts = {\n        basedir: dir,\n        moduleDirectory: ['xmodules', 'ymodules', 'zmodules']\n    };\n    resolve('bbb', copts, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, '/zmodules/bbb/main.js'));\n    });\n});\n"}},"node-modules-paths.js":{"file":{"contents":"var test = require('tape');\nvar path = require('path');\nvar parse = path.parse || require('path-parse');\nvar keys = require('object-keys');\n\nvar nodeModulesPaths = require('../lib/node-modules-paths');\n\nvar verifyDirs = function verifyDirs(t, start, dirs, moduleDirectories, paths) {\n    var moduleDirs = [].concat(moduleDirectories || 'node_modules');\n    if (paths) {\n        for (var k = 0; k < paths.length; ++k) {\n            moduleDirs.push(path.basename(paths[k]));\n        }\n    }\n\n    var foundModuleDirs = {};\n    var uniqueDirs = {};\n    var parsedDirs = {};\n    for (var i = 0; i < dirs.length; ++i) {\n        var parsed = parse(dirs[i]);\n        if (!foundModuleDirs[parsed.base]) { foundModuleDirs[parsed.base] = 0; }\n        foundModuleDirs[parsed.base] += 1;\n        parsedDirs[parsed.dir] = true;\n        uniqueDirs[dirs[i]] = true;\n    }\n    t.equal(keys(parsedDirs).length >= start.split(path.sep).length, true, 'there are >= dirs than \"start\" has');\n    var foundModuleDirNames = keys(foundModuleDirs);\n    t.deepEqual(foundModuleDirNames, moduleDirs, 'all desired module dirs were found');\n    t.equal(keys(uniqueDirs).length, dirs.length, 'all dirs provided were unique');\n\n    var counts = {};\n    for (var j = 0; j < foundModuleDirNames.length; ++j) {\n        counts[foundModuleDirs[j]] = true;\n    }\n    t.equal(keys(counts).length, 1, 'all found module directories had the same count');\n};\n\ntest('node-modules-paths', function (t) {\n    t.test('no options', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var dirs = nodeModulesPaths(start);\n\n        verifyDirs(t, start, dirs);\n\n        t.end();\n    });\n\n    t.test('empty options', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var dirs = nodeModulesPaths(start, {});\n\n        verifyDirs(t, start, dirs);\n\n        t.end();\n    });\n\n    t.test('with paths=array option', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var paths = ['a', 'b'];\n        var dirs = nodeModulesPaths(start, { paths: paths });\n\n        verifyDirs(t, start, dirs, null, paths);\n\n        t.end();\n    });\n\n    t.test('with paths=function option', function (t) {\n        var paths = function paths(request, absoluteStart, getNodeModulesDirs, opts) {\n            return getNodeModulesDirs().concat(path.join(absoluteStart, 'not node modules', request));\n        };\n\n        var start = path.join(__dirname, 'resolver');\n        var dirs = nodeModulesPaths(start, { paths: paths }, 'pkg');\n\n        verifyDirs(t, start, dirs, null, [path.join(start, 'not node modules', 'pkg')]);\n\n        t.end();\n    });\n\n    t.test('with paths=function skipping node modules resolution', function (t) {\n        var paths = function paths(request, absoluteStart, getNodeModulesDirs, opts) {\n            return [];\n        };\n        var start = path.join(__dirname, 'resolver');\n        var dirs = nodeModulesPaths(start, { paths: paths });\n        t.deepEqual(dirs, [], 'no node_modules was computed');\n        t.end();\n    });\n\n    t.test('with moduleDirectory option', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var moduleDirectory = 'not node modules';\n        var dirs = nodeModulesPaths(start, { moduleDirectory: moduleDirectory });\n\n        verifyDirs(t, start, dirs, moduleDirectory);\n\n        t.end();\n    });\n\n    t.test('with 1 moduleDirectory and paths options', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var paths = ['a', 'b'];\n        var moduleDirectory = 'not node modules';\n        var dirs = nodeModulesPaths(start, { paths: paths, moduleDirectory: moduleDirectory });\n\n        verifyDirs(t, start, dirs, moduleDirectory, paths);\n\n        t.end();\n    });\n\n    t.test('with 1+ moduleDirectory and paths options', function (t) {\n        var start = path.join(__dirname, 'resolver');\n        var paths = ['a', 'b'];\n        var moduleDirectories = ['not node modules', 'other modules'];\n        var dirs = nodeModulesPaths(start, { paths: paths, moduleDirectory: moduleDirectories });\n\n        verifyDirs(t, start, dirs, moduleDirectories, paths);\n\n        t.end();\n    });\n\n    t.test('combine paths correctly on Windows', function (t) {\n        var start = 'C:\\\\Users\\\\username\\\\myProject\\\\src';\n        var paths = [];\n        var moduleDirectories = ['node_modules', start];\n        var dirs = nodeModulesPaths(start, { paths: paths, moduleDirectory: moduleDirectories });\n\n        t.equal(dirs.indexOf(path.resolve(start)) > -1, true, 'should contain start dir');\n\n        t.end();\n    });\n\n    t.test('combine paths correctly on non-Windows', { skip: process.platform === 'win32' }, function (t) {\n        var start = '/Users/username/git/myProject/src';\n        var paths = [];\n        var moduleDirectories = ['node_modules', '/Users/username/git/myProject/src'];\n        var dirs = nodeModulesPaths(start, { paths: paths, moduleDirectory: moduleDirectories });\n\n        t.equal(dirs.indexOf(path.resolve(start)) > -1, true, 'should contain start dir');\n\n        t.end();\n    });\n});\n"}},"node_path":{"directory":{"x":{"directory":{"aaa":{"directory":{"index.js":{"file":{"contents":"module.exports = 'A';\n"}}}},"ccc":{"directory":{"index.js":{"file":{"contents":"module.exports = 'C';\n"}}}}}},"y":{"directory":{"bbb":{"directory":{"index.js":{"file":{"contents":"module.exports = 'B';\n"}}}},"ccc":{"directory":{"index.js":{"file":{"contents":"module.exports = 'CY';\n"}}}}}}}},"node_path.js":{"file":{"contents":"var fs = require('fs');\nvar path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('$NODE_PATH', function (t) {\n    t.plan(8);\n\n    var isDir = function (dir, cb) {\n        if (dir === '/node_path' || dir === 'node_path/x') {\n            return cb(null, true);\n        }\n        fs.stat(dir, function (err, stat) {\n            if (!err) {\n                return cb(null, stat.isDirectory());\n            }\n            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);\n            return cb(err);\n        });\n    };\n\n    resolve('aaa', {\n        paths: [\n            path.join(__dirname, '/node_path/x'),\n            path.join(__dirname, '/node_path/y')\n        ],\n        basedir: __dirname,\n        isDirectory: isDir\n    }, function (err, res) {\n        t.error(err);\n        t.equal(res, path.join(__dirname, '/node_path/x/aaa/index.js'), 'aaa resolves');\n    });\n\n    resolve('bbb', {\n        paths: [\n            path.join(__dirname, '/node_path/x'),\n            path.join(__dirname, '/node_path/y')\n        ],\n        basedir: __dirname,\n        isDirectory: isDir\n    }, function (err, res) {\n        t.error(err);\n        t.equal(res, path.join(__dirname, '/node_path/y/bbb/index.js'), 'bbb resolves');\n    });\n\n    resolve('ccc', {\n        paths: [\n            path.join(__dirname, '/node_path/x'),\n            path.join(__dirname, '/node_path/y')\n        ],\n        basedir: __dirname,\n        isDirectory: isDir\n    }, function (err, res) {\n        t.error(err);\n        t.equal(res, path.join(__dirname, '/node_path/x/ccc/index.js'), 'ccc resolves');\n    });\n\n    // ensure that relative paths still resolve against the regular `node_modules` correctly\n    resolve('tap', {\n        paths: [\n            'node_path'\n        ],\n        basedir: path.join(__dirname, 'node_path/x'),\n        isDirectory: isDir\n    }, function (err, res) {\n        var root = require('tap/package.json').main; // eslint-disable-line global-require\n        t.error(err);\n        t.equal(res, path.resolve(__dirname, '..', 'node_modules/tap', root), 'tap resolves');\n    });\n});\n"}},"nonstring.js":{"file":{"contents":"var test = require('tape');\nvar resolve = require('../');\n\ntest('nonstring', function (t) {\n    t.plan(1);\n    resolve(555, function (err, res, pkg) {\n        t.ok(err);\n    });\n});\n"}},"pathfilter":{"directory":{"deep_ref":{"directory":{"main.js":{"file":{"contents":""}}}}}},"pathfilter.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\nvar resolverDir = path.join(__dirname, '/pathfilter/deep_ref');\n\nvar pathFilterFactory = function (t) {\n    return function (pkg, x, remainder) {\n        t.equal(pkg.version, '1.2.3');\n        t.equal(x, path.join(resolverDir, 'node_modules/deep/ref'));\n        t.equal(remainder, 'ref');\n        return 'alt';\n    };\n};\n\ntest('#62: deep module references and the pathFilter', function (t) {\n    t.test('deep/ref.js', function (st) {\n        st.plan(3);\n\n        resolve('deep/ref', { basedir: resolverDir }, function (err, res, pkg) {\n            if (err) st.fail(err);\n\n            st.equal(pkg.version, '1.2.3');\n            st.equal(res, path.join(resolverDir, 'node_modules/deep/ref.js'));\n        });\n\n        var res = resolve.sync('deep/ref', { basedir: resolverDir });\n        st.equal(res, path.join(resolverDir, 'node_modules/deep/ref.js'));\n    });\n\n    t.test('deep/deeper/ref', function (st) {\n        st.plan(4);\n\n        resolve(\n            'deep/deeper/ref',\n            { basedir: resolverDir },\n            function (err, res, pkg) {\n                if (err) t.fail(err);\n                st.notEqual(pkg, undefined);\n                st.equal(pkg.version, '1.2.3');\n                st.equal(res, path.join(resolverDir, 'node_modules/deep/deeper/ref.js'));\n            }\n        );\n\n        var res = resolve.sync(\n            'deep/deeper/ref',\n            { basedir: resolverDir }\n        );\n        st.equal(res, path.join(resolverDir, 'node_modules/deep/deeper/ref.js'));\n    });\n\n    t.test('deep/ref alt', function (st) {\n        st.plan(8);\n\n        var pathFilter = pathFilterFactory(st);\n\n        var res = resolve.sync(\n            'deep/ref',\n            { basedir: resolverDir, pathFilter: pathFilter }\n        );\n        st.equal(res, path.join(resolverDir, 'node_modules/deep/alt.js'));\n\n        resolve(\n            'deep/ref',\n            { basedir: resolverDir, pathFilter: pathFilter },\n            function (err, res, pkg) {\n                if (err) st.fail(err);\n                st.equal(res, path.join(resolverDir, 'node_modules/deep/alt.js'));\n                st.end();\n            }\n        );\n    });\n\n    t.end();\n});\n"}},"precedence":{"directory":{"aaa":{"directory":{"index.js":{"file":{"contents":"module.exports = 'okok';\n"}},"main.js":{"file":{"contents":"console.log(require('./'));\n"}}}},"aaa.js":{"file":{"contents":"module.exports = 'wtf';\n"}},"bbb":{"directory":{"main.js":{"file":{"contents":"console.log(require('./')); // should throw\n"}}}},"bbb.js":{"file":{"contents":"module.exports = '>_<';\n"}}}},"precedence.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\n\ntest('precedence', function (t) {\n    t.plan(3);\n    var dir = path.join(__dirname, 'precedence/aaa');\n\n    resolve('./', { basedir: dir }, function (err, res, pkg) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, 'index.js'));\n        t.equal(pkg.name, 'resolve');\n    });\n});\n\ntest('./ should not load ${dir}.js', function (t) { // eslint-disable-line no-template-curly-in-string\n    t.plan(1);\n    var dir = path.join(__dirname, 'precedence/bbb');\n\n    resolve('./', { basedir: dir }, function (err, res, pkg) {\n        t.ok(err);\n    });\n});\n"}},"resolver":{"directory":{"baz":{"directory":{"doom.js":{"file":{"contents":""}},"package.json":{"file":{"contents":"{\n    \"name\": \"baz\",\n    \"main\": \"quux.js\"\n}\n"}},"quux.js":{"file":{"contents":"module.exports = 1;\n"}}}},"browser_field":{"directory":{"a.js":{"file":{"contents":""}},"b.js":{"file":{"contents":""}},"package.json":{"file":{"contents":"{\n  \"name\": \"browser_field\",\n  \"main\": \"a\",\n  \"browser\": \"b\"\n}\n"}}}},"cup.coffee":{"file":{"contents":"\n"}},"dot_main":{"directory":{"index.js":{"file":{"contents":"module.exports = 1;\n"}},"package.json":{"file":{"contents":"{\n    \"main\": \".\"\n}\n"}}}},"dot_slash_main":{"directory":{"index.js":{"file":{"contents":"module.exports = 1;\n"}},"package.json":{"file":{"contents":"{\n    \"main\": \"./\"\n}\n"}}}},"false_main":{"directory":{"index.js":{"file":{"contents":""}},"package.json":{"file":{"contents":"{\n\t\"name\": \"false_main\",\n\t\"main\": false\n}\n"}}}},"foo.js":{"file":{"contents":"module.exports = 1;\n"}},"incorrect_main":{"directory":{"index.js":{"file":{"contents":"// this is the actual main file 'index.js', not 'wrong.js' like the package.json would indicate\nmodule.exports = 1;\n"}},"package.json":{"file":{"contents":"{\n    \"main\": \"wrong.js\"\n}\n"}}}},"invalid_main":{"directory":{"package.json":{"file":{"contents":"{\n  \"name\": \"invalid_main\",\n  \"main\": [\n    \"why is this a thing\",\n    \"srsly omg wtf\"\n  ]\n}\n"}}}},"malformed_package_json":{"directory":{"index.js":{"file":{"contents":""}},"package.json":{"file":{"contents":"{\n"}}}},"mug.coffee":{"file":{"contents":""}},"mug.js":{"file":{"contents":""}},"multirepo":{"directory":{"lerna.json":{"file":{"contents":"{\n  \"packages\": [\n    \"packages/*\"\n  ],\n  \"version\": \"0.0.0\"\n}\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"monorepo-symlink-test\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"postinstall\": \"lerna bootstrap\",\n    \"test\": \"node packages/package-a\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"jquery\": \"^3.3.1\",\n    \"resolve\": \"../../../\"\n  },\n  \"devDependencies\": {\n    \"lerna\": \"^3.4.3\"\n  }\n}\n"}},"packages":{"directory":{"package-a":{"directory":{"index.js":{"file":{"contents":"'use strict';\n\nvar assert = require('assert');\nvar path = require('path');\nvar resolve = require('resolve');\n\nvar basedir = __dirname + '/node_modules/@my-scope/package-b';\n\nvar expected = path.join(__dirname, '../../node_modules/jquery/dist/jquery.js');\n\n/*\n * preserveSymlinks === false\n * will search NPM package from\n * - packages/package-b/node_modules\n * - packages/node_modules\n * - node_modules\n */\nassert.equal(resolve.sync('jquery', { basedir: basedir, preserveSymlinks: false }), expected);\nassert.equal(resolve.sync('../../node_modules/jquery', { basedir: basedir, preserveSymlinks: false }), expected);\n\n/*\n * preserveSymlinks === true\n * will search NPM package from\n * - packages/package-a/node_modules/@my-scope/packages/package-b/node_modules\n * - packages/package-a/node_modules/@my-scope/packages/node_modules\n * - packages/package-a/node_modules/@my-scope/node_modules\n * - packages/package-a/node_modules/node_modules\n * - packages/package-a/node_modules\n * - packages/node_modules\n * - node_modules\n */\nassert.equal(resolve.sync('jquery', { basedir: basedir, preserveSymlinks: true }), expected);\nassert.equal(resolve.sync('../../../../../node_modules/jquery', { basedir: basedir, preserveSymlinks: true }), expected);\n\nconsole.log(' * all monorepo paths successfully resolved through symlinks');\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"@my-scope/package-a\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"description\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\"\n  },\n  \"dependencies\": {\n    \"@my-scope/package-b\": \"^0.0.0\"\n  }\n}\n"}}}},"package-b":{"directory":{"index.js":{"file":{"contents":""}},"package.json":{"file":{"contents":"{\n  \"name\": \"@my-scope/package-b\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"description\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\"\n  },\n  \"dependencies\": {\n    \"@my-scope/package-a\": \"^0.0.0\"\n  }\n}\n"}}}}}}}},"nested_symlinks":{"directory":{"mylib":{"directory":{"async.js":{"file":{"contents":"var a = require.resolve('buffer/').replace(process.cwd(), '$CWD');\nvar b;\nvar c;\n\nvar test = function test() {\n    console.log(a, ': require.resolve, preserveSymlinks ' + (process.execArgv.indexOf('preserve-symlinks') > -1 ? 'true' : 'false'));\n    console.log(b, ': preserveSymlinks true');\n    console.log(c, ': preserveSymlinks false');\n\n    if (a !== b && a !== c) {\n        throw 'async: no match';\n    }\n    console.log('async: success! a matched either b or c\\n');\n};\n\nrequire('resolve')('buffer/', { preserveSymlinks: true }, function (err, result) {\n    if (err) { throw err; }\n    b = result.replace(process.cwd(), '$CWD');\n    if (b && c) { test(); }\n});\nrequire('resolve')('buffer/', { preserveSymlinks: false }, function (err, result) {\n    if (err) { throw err; }\n    c = result.replace(process.cwd(), '$CWD');\n    if (b && c) { test(); }\n});\n\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"mylib\",\n  \"version\": \"0.0.0\",\n  \"description\": \"\",\n  \"private\": true,\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"buffer\": \"*\"\n  }\n}\n"}},"sync.js":{"file":{"contents":"var a = require.resolve('buffer/').replace(process.cwd(), '$CWD');\nvar b = require('resolve').sync('buffer/', { preserveSymlinks: true }).replace(process.cwd(), '$CWD');\nvar c = require('resolve').sync('buffer/', { preserveSymlinks: false }).replace(process.cwd(), '$CWD');\n\nconsole.log(a, ': require.resolve, preserveSymlinks ' + (process.execArgv.indexOf('preserve-symlinks') > -1 ? 'true' : 'false'));\nconsole.log(b, ': preserveSymlinks true');\nconsole.log(c, ': preserveSymlinks false');\n\nif (a !== b && a !== c) {\n    throw 'sync: no match';\n}\nconsole.log('sync: success! a matched either b or c\\n');\n"}}}}}},"other_path":{"directory":{"lib":{"directory":{"other-lib.js":{"file":{"contents":""}}}},"root.js":{"file":{"contents":""}}}},"quux":{"directory":{"foo":{"directory":{"index.js":{"file":{"contents":"module.exports = 1;\n"}}}}}},"same_names":{"directory":{"foo":{"directory":{"index.js":{"file":{"contents":"module.exports = 1;\n"}}}},"foo.js":{"file":{"contents":"module.exports = 42;\n"}}}},"symlinked":{"directory":{"package":{"directory":{"bar.js":{"file":{"contents":"module.exports = 'bar';\n"}},"package.json":{"file":{"contents":"{\n    \"main\": \"bar.js\"\n}"}}}},"_":{"directory":{"node_modules":{"directory":{"foo.js":{"file":{"contents":""}}}},"symlink_target":{"directory":{".gitkeep":{"file":{"contents":""}}}}}}}},"without_basedir":{"directory":{"main.js":{"file":{"contents":"var resolve = require('../../../');\n\nmodule.exports = function (t, cb) {\n    resolve('mymodule', null, cb);\n};\n"}}}}}},"resolver.js":{"file":{"contents":"var path = require('path');\nvar test = require('tape');\nvar resolve = require('../');\nvar async = require('../async');\n\ntest('`./async` entry point', function (t) {\n    t.equal(resolve, async, '`./async` entry point is the same as `main`');\n    t.end();\n});\n\ntest('async foo', function (t) {\n    t.plan(12);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./foo', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.name, 'resolve');\n    });\n\n    resolve('./foo.js', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.name, 'resolve');\n    });\n\n    resolve('./foo', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.main, 'resolver');\n    });\n\n    resolve('./foo.js', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg.main, 'resolver');\n    });\n\n    resolve('./foo', { basedir: dir, filename: path.join(dir, 'baz.js') }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n    });\n\n    resolve('foo', { basedir: dir }, function (err) {\n        t.equal(err.message, \"Cannot find module 'foo' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    resolve('foo', { basedir: dir, filename: path.join(dir, 'baz.js') }, function (err) {\n        t.equal(err.message, \"Cannot find module 'foo' from '\" + path.join(dir, 'baz.js') + \"'\");\n    });\n});\n\ntest('bar', function (t) {\n    t.plan(6);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('foo', { basedir: dir + '/bar' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('foo', { basedir: dir + '/bar' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('foo', { basedir: dir + '/bar', 'package': { main: 'bar' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg.main, 'bar');\n    });\n});\n\ntest('baz', function (t) {\n    t.plan(4);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./baz', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'baz/quux.js'));\n        t.equal(pkg.main, 'quux.js');\n    });\n\n    resolve('./baz', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'baz/quux.js'));\n        t.equal(pkg.main, 'quux.js');\n    });\n});\n\ntest('biz', function (t) {\n    t.plan(24);\n    var dir = path.join(__dirname, 'resolver/biz/node_modules');\n\n    resolve('./grux', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('./grux', { basedir: dir, 'package': { main: 'biz' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg.main, 'biz');\n    });\n\n    resolve('./garply', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('./garply', { basedir: dir, 'package': { main: 'biz' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('tiv', { basedir: dir + '/grux' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('tiv', { basedir: dir + '/grux', 'package': { main: 'grux' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg.main, 'grux');\n    });\n\n    resolve('tiv', { basedir: dir + '/garply' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('tiv', { basedir: dir + '/garply', 'package': { main: './lib' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('grux', { basedir: dir + '/tiv' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('grux', { basedir: dir + '/tiv', 'package': { main: 'tiv' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg.main, 'tiv');\n    });\n\n    resolve('garply', { basedir: dir + '/tiv' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('garply', { basedir: dir + '/tiv', 'package': { main: 'tiv' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n});\n\ntest('quux', function (t) {\n    t.plan(2);\n    var dir = path.join(__dirname, 'resolver/quux');\n\n    resolve('./foo', { basedir: dir, 'package': { main: 'quux' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo/index.js'));\n        t.equal(pkg.main, 'quux');\n    });\n});\n\ntest('normalize', function (t) {\n    t.plan(2);\n    var dir = path.join(__dirname, 'resolver/biz/node_modules/grux');\n\n    resolve('../grux', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n        t.equal(pkg, undefined);\n    });\n});\n\ntest('cup', function (t) {\n    t.plan(5);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./cup', { basedir: dir, extensions: ['.js', '.coffee'] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'cup.coffee'));\n    });\n\n    resolve('./cup.coffee', { basedir: dir }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'cup.coffee'));\n    });\n\n    resolve('./cup', { basedir: dir, extensions: ['.js'] }, function (err, res) {\n        t.equal(err.message, \"Cannot find module './cup' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    resolve('./cup', { basedir: dir, extensions: ['.js'], filename: path.join(dir, 'cupboard.js') }, function (err, res) {\n        t.equal(err.message, \"Cannot find module './cup' from '\" + path.join(dir, 'cupboard.js') + \"'\");\n    });\n});\n\ntest('mug', function (t) {\n    t.plan(3);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./mug', { basedir: dir }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'mug.js'));\n    });\n\n    resolve('./mug', { basedir: dir, extensions: ['.coffee', '.js'] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, '/mug.coffee'));\n    });\n\n    resolve('./mug', { basedir: dir, extensions: ['.js', '.coffee'] }, function (err, res) {\n        t.equal(res, path.join(dir, '/mug.js'));\n    });\n});\n\ntest('other path', function (t) {\n    t.plan(6);\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'bar');\n    var otherDir = path.join(resolverDir, 'other_path');\n\n    resolve('root', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'other_path/root.js'));\n    });\n\n    resolve('lib/other-lib', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'other_path/lib/other-lib.js'));\n    });\n\n    resolve('root', { basedir: dir }, function (err, res) {\n        t.equal(err.message, \"Cannot find module 'root' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    resolve('zzz', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        t.equal(err.message, \"Cannot find module 'zzz' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n});\n\ntest('path iterator', function (t) {\n    t.plan(2);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    var exactIterator = function (x, start, getPackageCandidates, opts) {\n        return [path.join(resolverDir, x)];\n    };\n\n    resolve('baz', { packageIterator: exactIterator }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'baz/quux.js'));\n        t.equal(pkg && pkg.name, 'baz');\n    });\n});\n\ntest('incorrect main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'incorrect_main');\n\n    resolve('./incorrect_main', { basedir: resolverDir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('missing index', function (t) {\n    t.plan(2);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    resolve('./missing_index', { basedir: resolverDir }, function (err, res, pkg) {\n        t.ok(err instanceof Error);\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    });\n});\n\ntest('missing main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    resolve('./missing_main', { basedir: resolverDir }, function (err, res, pkg) {\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    });\n});\n\ntest('null main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    resolve('./null_main', { basedir: resolverDir }, function (err, res, pkg) {\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    });\n});\n\ntest('main: false', function (t) {\n    t.plan(2);\n\n    var basedir = path.join(__dirname, 'resolver');\n    var dir = path.join(basedir, 'false_main');\n    resolve('./false_main', { basedir: basedir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(\n            res,\n            path.join(dir, 'index.js'),\n            '`\"main\": false`: resolves to `index.js`'\n        );\n        t.deepEqual(pkg, {\n            name: 'false_main',\n            main: false\n        });\n    });\n});\n\ntest('without basedir', function (t) {\n    t.plan(1);\n\n    var dir = path.join(__dirname, 'resolver/without_basedir');\n    var tester = require(path.join(dir, 'main.js')); // eslint-disable-line global-require\n\n    tester(t, function (err, res, pkg) {\n        if (err) {\n            t.fail(err);\n        } else {\n            t.equal(res, path.join(dir, 'node_modules/mymodule.js'));\n        }\n    });\n});\n\ntest('#52 - incorrectly resolves module-paths like \"./someFolder/\" when there is a file of the same name', function (t) {\n    t.plan(2);\n\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./foo', { basedir: path.join(dir, 'same_names') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo.js'));\n    });\n\n    resolve('./foo/', { basedir: path.join(dir, 'same_names') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n});\n\ntest('#211 - incorrectly resolves module-paths like \".\" when from inside a folder with a sibling file of the same name', function (t) {\n    t.plan(2);\n\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./', { basedir: path.join(dir, 'same_names/foo') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n\n    resolve('.', { basedir: path.join(dir, 'same_names/foo') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n});\n\ntest('async: #121 - treating an existing file as a dir when no basedir', function (t) {\n    var testFile = path.basename(__filename);\n\n    t.test('sanity check', function (st) {\n        st.plan(1);\n        resolve('./' + testFile, function (err, res, pkg) {\n            if (err) t.fail(err);\n            st.equal(res, __filename, 'sanity check');\n        });\n    });\n\n    t.test('with a fake directory', function (st) {\n        st.plan(4);\n\n        resolve('./' + testFile + '/blah', function (err, res, pkg) {\n            st.ok(err, 'there is an error');\n            st.notOk(res, 'no result');\n\n            st.equal(err && err.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');\n            st.equal(\n                err && err.message,\n                'Cannot find module \\'./' + testFile + '/blah\\' from \\'' + __dirname + '\\'',\n                'can not find nonexistent module'\n            );\n            st.end();\n        });\n    });\n\n    t.end();\n});\n\ntest('async dot main', function (t) {\n    var start = new Date();\n    t.plan(3);\n    resolve('./resolver/dot_main', function (err, ret) {\n        t.notOk(err);\n        t.equal(ret, path.join(__dirname, 'resolver/dot_main/index.js'));\n        t.ok(new Date() - start < 50, 'resolve.sync timedout');\n        t.end();\n    });\n});\n\ntest('async dot slash main', function (t) {\n    var start = new Date();\n    t.plan(3);\n    resolve('./resolver/dot_slash_main', function (err, ret) {\n        t.notOk(err);\n        t.equal(ret, path.join(__dirname, 'resolver/dot_slash_main/index.js'));\n        t.ok(new Date() - start < 50, 'resolve.sync timedout');\n        t.end();\n    });\n});\n\ntest('not a directory', function (t) {\n    t.plan(6);\n    var path = './foo';\n    resolve(path, { basedir: __filename }, function (err, res, pkg) {\n        t.ok(err, 'a non-directory errors');\n        t.equal(arguments.length, 1);\n        t.equal(res, undefined);\n        t.equal(pkg, undefined);\n\n        t.equal(err && err.message, 'Cannot find module \\'' + path + '\\' from \\'' + __filename + '\\'');\n        t.equal(err && err.code, 'MODULE_NOT_FOUND');\n    });\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    t.plan(5);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve('./invalid_main', { basedir: dir }, function (err, res, pkg) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n        t.equal(res, undefined, 'res is undefined');\n        t.equal(pkg, undefined, 'pkg is undefined');\n    });\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    t.plan(5);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve('./invalid_main', { basedir: dir }, function (err, res, pkg) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n        t.equal(res, undefined, 'res is undefined');\n        t.equal(pkg, undefined, 'pkg is undefined');\n    });\n});\n\ntest('browser field in package.json', function (t) {\n    t.plan(3);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve(\n        './browser_field',\n        {\n            basedir: dir,\n            packageFilter: function packageFilter(pkg) {\n                if (pkg.browser) {\n                    pkg.main = pkg.browser; // eslint-disable-line no-param-reassign\n                    delete pkg.browser; // eslint-disable-line no-param-reassign\n                }\n                return pkg;\n            }\n        },\n        function (err, res, pkg) {\n            if (err) t.fail(err);\n            t.equal(res, path.join(dir, 'browser_field', 'b.js'));\n            t.equal(pkg && pkg.main, 'b');\n            t.equal(pkg && pkg.browser, undefined);\n        }\n    );\n});\n\ntest('absolute paths', function (t) {\n    t.plan(4);\n\n    var extensionless = __filename.slice(0, -path.extname(__filename).length);\n\n    resolve(__filename, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'absolute path to this file resolves'\n        );\n    });\n    resolve(extensionless, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'extensionless absolute path to this file resolves'\n        );\n    });\n    resolve(__filename, { basedir: process.cwd() }, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'absolute path to this file with a basedir resolves'\n        );\n    });\n    resolve(extensionless, { basedir: process.cwd() }, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'extensionless absolute path to this file with a basedir resolves'\n        );\n    });\n});\n\ntest('malformed package.json', function (t) {\n    /* eslint operator-linebreak: [\"error\", \"before\"], function-paren-newline: \"off\" */\n    t.plan(\n        (3 * 3) // 3 sets of 3 assertions in the final callback\n        + 2 // 1 readPackage call with malformed package.json\n    );\n\n    var basedir = path.join(__dirname, 'resolver/malformed_package_json');\n    var expected = path.join(basedir, 'index.js');\n\n    resolve('./index.js', { basedir: basedir }, function (err, res, pkg) {\n        t.error(err, 'no error');\n        t.equal(res, expected, 'malformed package.json is silently ignored');\n        t.equal(pkg, undefined, 'malformed package.json gives an undefined `pkg` argument');\n    });\n\n    resolve(\n        './index.js',\n        {\n            basedir: basedir,\n            packageFilter: function (pkg, pkgfile, dir) {\n                t.fail('should not reach here');\n            }\n        },\n        function (err, res, pkg) {\n            t.error(err, 'with packageFilter: no error');\n            t.equal(res, expected, 'with packageFilter: malformed package.json is silently ignored');\n            t.equal(pkg, undefined, 'with packageFilter: malformed package.json gives an undefined `pkg` argument');\n        }\n    );\n\n    resolve(\n        './index.js',\n        {\n            basedir: basedir,\n            readPackage: function (readFile, pkgfile, cb) {\n                t.equal(pkgfile, path.join(basedir, 'package.json'), 'readPackageSync: `pkgfile` is package.json path');\n                readFile(pkgfile, function (err, result) {\n                    try {\n                        cb(null, JSON.parse(result));\n                    } catch (e) {\n                        t.ok(e instanceof SyntaxError, 'readPackage: malformed package.json parses as a syntax error');\n                        cb(null);\n                    }\n                });\n            }\n        },\n        function (err, res, pkg) {\n            t.error(err, 'with readPackage: no error');\n            t.equal(res, expected, 'with readPackage: malformed package.json is silently ignored');\n            t.equal(pkg, undefined, 'with readPackage: malformed package.json gives an undefined `pkg` argument');\n        }\n    );\n});\n"}},"resolver_sync.js":{"file":{"contents":"var path = require('path');\nvar fs = require('fs');\nvar test = require('tape');\n\nvar resolve = require('../');\nvar sync = require('../sync');\n\nvar requireResolveSupportsPaths = require.resolve.length > 1\n    && !(/^v12\\.[012]\\./).test(process.version); // broken in v12.0-12.2, see https://github.com/nodejs/node/issues/27794\n\ntest('`./sync` entry point', function (t) {\n    t.equal(resolve.sync, sync, '`./sync` entry point is the same as `.sync` on `main`');\n    t.end();\n});\n\ntest('foo', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./foo', { basedir: dir }),\n        path.join(dir, 'foo.js'),\n        './foo'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo', { basedir: dir }),\n            require.resolve('./foo', { paths: [dir] }),\n            './foo: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo.js', { basedir: dir }),\n        path.join(dir, 'foo.js'),\n        './foo.js'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo.js', { basedir: dir }),\n            require.resolve('./foo.js', { paths: [dir] }),\n            './foo.js: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo.js', { basedir: dir, filename: path.join(dir, 'bar.js') }),\n        path.join(dir, 'foo.js')\n    );\n\n    t.throws(function () {\n        resolve.sync('foo', { basedir: dir });\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    t.throws(\n        function () {\n            resolve.sync('foo', { basedir: dir, filename: path.join(dir, 'bar.js') });\n        },\n        {\n            name: 'Error',\n            message: \"Cannot find module 'foo' from '\" + path.join(dir, 'bar.js') + \"'\"\n        }\n    );\n\n    t.end();\n});\n\ntest('bar', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    var basedir = path.join(dir, 'bar');\n\n    t.equal(\n        resolve.sync('foo', { basedir: basedir }),\n        path.join(dir, 'bar/node_modules/foo/index.js'),\n        'foo in bar'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('foo', { basedir: basedir }),\n            require.resolve('foo', { paths: [basedir] }),\n            'foo in bar: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('baz', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./baz', { basedir: dir }),\n        path.join(dir, 'baz/quux.js'),\n        './baz'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./baz', { basedir: dir }),\n            require.resolve('./baz', { paths: [dir] }),\n            './baz: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('biz', function (t) {\n    var dir = path.join(__dirname, 'resolver/biz/node_modules');\n\n    t.equal(\n        resolve.sync('./grux', { basedir: dir }),\n        path.join(dir, 'grux/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./grux', { basedir: dir }),\n            require.resolve('./grux', { paths: [dir] }),\n            './grux: resolve.sync === require.resolve'\n        );\n    }\n\n    var tivDir = path.join(dir, 'grux');\n    t.equal(\n        resolve.sync('tiv', { basedir: tivDir }),\n        path.join(dir, 'tiv/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('tiv', { basedir: tivDir }),\n            require.resolve('tiv', { paths: [tivDir] }),\n            'tiv: resolve.sync === require.resolve'\n        );\n    }\n\n    var gruxDir = path.join(dir, 'tiv');\n    t.equal(\n        resolve.sync('grux', { basedir: gruxDir }),\n        path.join(dir, 'grux/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('grux', { basedir: gruxDir }),\n            require.resolve('grux', { paths: [gruxDir] }),\n            'grux: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('normalize', function (t) {\n    var dir = path.join(__dirname, 'resolver/biz/node_modules/grux');\n\n    t.equal(\n        resolve.sync('../grux', { basedir: dir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('../grux', { basedir: dir }),\n            require.resolve('../grux', { paths: [dir] }),\n            '../grux: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('cup', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./cup', {\n            basedir: dir,\n            extensions: ['.js', '.coffee']\n        }),\n        path.join(dir, 'cup.coffee'),\n        './cup -> ./cup.coffee'\n    );\n\n    t.equal(\n        resolve.sync('./cup.coffee', { basedir: dir }),\n        path.join(dir, 'cup.coffee'),\n        './cup.coffee'\n    );\n\n    t.throws(function () {\n        resolve.sync('./cup', {\n            basedir: dir,\n            extensions: ['.js']\n        });\n    });\n\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./cup.coffee', { basedir: dir, extensions: ['.js', '.coffee'] }),\n            require.resolve('./cup.coffee', { paths: [dir] }),\n            './cup.coffee: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('mug', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    t.equal(\n        resolve.sync('./mug', { basedir: dir }),\n        path.join(dir, 'mug.js'),\n        './mug -> ./mug.js'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./mug', { basedir: dir }),\n            require.resolve('./mug', { paths: [dir] }),\n            './mug: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./mug', {\n            basedir: dir,\n            extensions: ['.coffee', '.js']\n        }),\n        path.join(dir, 'mug.coffee'),\n        './mug -> ./mug.coffee'\n    );\n\n    t.equal(\n        resolve.sync('./mug', {\n            basedir: dir,\n            extensions: ['.js', '.coffee']\n        }),\n        path.join(dir, 'mug.js'),\n        './mug -> ./mug.js'\n    );\n\n    t.end();\n});\n\ntest('other path', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'bar');\n    var otherDir = path.join(resolverDir, 'other_path');\n\n    t.equal(\n        resolve.sync('root', {\n            basedir: dir,\n            paths: [otherDir]\n        }),\n        path.join(resolverDir, 'other_path/root.js')\n    );\n\n    t.equal(\n        resolve.sync('lib/other-lib', {\n            basedir: dir,\n            paths: [otherDir]\n        }),\n        path.join(resolverDir, 'other_path/lib/other-lib.js')\n    );\n\n    t.throws(function () {\n        resolve.sync('root', { basedir: dir });\n    });\n\n    t.throws(function () {\n        resolve.sync('zzz', {\n            basedir: dir,\n            paths: [otherDir]\n        });\n    });\n\n    t.end();\n});\n\ntest('path iterator', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    var exactIterator = function (x, start, getPackageCandidates, opts) {\n        return [path.join(resolverDir, x)];\n    };\n\n    t.equal(\n        resolve.sync('baz', { packageIterator: exactIterator }),\n        path.join(resolverDir, 'baz/quux.js')\n    );\n\n    t.end();\n});\n\ntest('incorrect main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'incorrect_main');\n\n    t.equal(\n        resolve.sync('./incorrect_main', { basedir: resolverDir }),\n        path.join(dir, 'index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./incorrect_main', { basedir: resolverDir }),\n            require.resolve('./incorrect_main', { paths: [resolverDir] }),\n            './incorrect_main: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('missing index', function (t) {\n    t.plan(requireResolveSupportsPaths ? 2 : 1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    try {\n        resolve.sync('./missing_index', { basedir: resolverDir });\n        t.fail('did not fail');\n    } catch (err) {\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    }\n    if (requireResolveSupportsPaths) {\n        try {\n            require.resolve('./missing_index', { basedir: resolverDir });\n            t.fail('require.resolve did not fail');\n        } catch (err) {\n            t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n        }\n    }\n});\n\ntest('missing main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    try {\n        resolve.sync('./missing_main', { basedir: resolverDir });\n        t.fail('require.resolve did not fail');\n    } catch (err) {\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    }\n    if (requireResolveSupportsPaths) {\n        try {\n            resolve.sync('./missing_main', { basedir: resolverDir });\n            t.fail('require.resolve did not fail');\n        } catch (err) {\n            t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n        }\n    }\n\n    t.end();\n});\n\ntest('null main', function (t) {\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    try {\n        resolve.sync('./null_main', { basedir: resolverDir });\n        t.fail('require.resolve did not fail');\n    } catch (err) {\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n    }\n    if (requireResolveSupportsPaths) {\n        try {\n            resolve.sync('./null_main', { basedir: resolverDir });\n            t.fail('require.resolve did not fail');\n        } catch (err) {\n            t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error has correct error code');\n        }\n    }\n\n    t.end();\n});\n\ntest('main: false', function (t) {\n    var basedir = path.join(__dirname, 'resolver');\n    var dir = path.join(basedir, 'false_main');\n    t.equal(\n        resolve.sync('./false_main', { basedir: basedir }),\n        path.join(dir, 'index.js'),\n        '`\"main\": false`: resolves to `index.js`'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./false_main', { basedir: basedir }),\n            require.resolve('./false_main', { paths: [basedir] }),\n            '`\"main\": false`: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\nvar stubStatSync = function stubStatSync(fn) {\n    var statSync = fs.statSync;\n    try {\n        fs.statSync = function () {\n            throw new EvalError('Unknown Error');\n        };\n        return fn();\n    } finally {\n        fs.statSync = statSync;\n    }\n};\n\ntest('#79 - re-throw non ENOENT errors from stat', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n\n    stubStatSync(function () {\n        t.throws(function () {\n            resolve.sync('foo', { basedir: dir });\n        }, /Unknown Error/);\n    });\n\n    t.end();\n});\n\ntest('#52 - incorrectly resolves module-paths like \"./someFolder/\" when there is a file of the same name', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var basedir = path.join(dir, 'same_names');\n\n    t.equal(\n        resolve.sync('./foo', { basedir: basedir }),\n        path.join(dir, 'same_names/foo.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo', { basedir: basedir }),\n            require.resolve('./foo', { paths: [basedir] }),\n            './foo: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('./foo/', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js')\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./foo/', { basedir: basedir }),\n            require.resolve('./foo/', { paths: [basedir] }),\n            './foo/: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('#211 - incorrectly resolves module-paths like \".\" when from inside a folder with a sibling file of the same name', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var basedir = path.join(dir, 'same_names/foo');\n\n    t.equal(\n        resolve.sync('./', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js'),\n        './'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./', { basedir: basedir }),\n            require.resolve('./', { paths: [basedir] }),\n            './: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync('.', { basedir: basedir }),\n        path.join(dir, 'same_names/foo/index.js'),\n        '.'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('.', { basedir: basedir }),\n            require.resolve('.', { paths: [basedir] }),\n            '.: resolve.sync === require.resolve',\n            { todo: true }\n        );\n    }\n\n    t.end();\n});\n\ntest('sync: #121 - treating an existing file as a dir when no basedir', function (t) {\n    var testFile = path.basename(__filename);\n\n    t.test('sanity check', function (st) {\n        st.equal(\n            resolve.sync('./' + testFile),\n            __filename,\n            'sanity check'\n        );\n        st.equal(\n            resolve.sync('./' + testFile),\n            require.resolve('./' + testFile),\n            'sanity check: resolve.sync === require.resolve'\n        );\n\n        st.end();\n    });\n\n    t.test('with a fake directory', function (st) {\n        function run() { return resolve.sync('./' + testFile + '/blah'); }\n\n        st.throws(run, 'throws an error');\n\n        try {\n            run();\n        } catch (e) {\n            st.equal(e.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');\n            st.equal(\n                e.message,\n                'Cannot find module \\'./' + testFile + '/blah\\' from \\'' + __dirname + '\\'',\n                'can not find nonexistent module'\n            );\n        }\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('sync dot main', function (t) {\n    var start = new Date();\n\n    t.equal(\n        resolve.sync('./resolver/dot_main'),\n        path.join(__dirname, 'resolver/dot_main/index.js'),\n        './resolver/dot_main'\n    );\n    t.equal(\n        resolve.sync('./resolver/dot_main'),\n        require.resolve('./resolver/dot_main'),\n        './resolver/dot_main: resolve.sync === require.resolve'\n    );\n\n    t.ok(new Date() - start < 50, 'resolve.sync timedout');\n\n    t.end();\n});\n\ntest('sync dot slash main', function (t) {\n    var start = new Date();\n\n    t.equal(\n        resolve.sync('./resolver/dot_slash_main'),\n        path.join(__dirname, 'resolver/dot_slash_main/index.js')\n    );\n    t.equal(\n        resolve.sync('./resolver/dot_slash_main'),\n        require.resolve('./resolver/dot_slash_main'),\n        './resolver/dot_slash_main: resolve.sync === require.resolve'\n    );\n\n    t.ok(new Date() - start < 50, 'resolve.sync timedout');\n\n    t.end();\n});\n\ntest('not a directory', function (t) {\n    var path = './foo';\n    try {\n        resolve.sync(path, { basedir: __filename });\n        t.fail();\n    } catch (err) {\n        t.ok(err, 'a non-directory errors');\n        t.equal(err && err.message, 'Cannot find module \\'' + path + \"' from '\" + __filename + \"'\");\n        t.equal(err && err.code, 'MODULE_NOT_FOUND');\n    }\n    t.end();\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    try {\n        var result = resolve.sync('./invalid_main', { basedir: dir });\n        t.equal(result, undefined, 'result should not exist');\n        t.fail('should not get here');\n    } catch (err) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n    }\n    t.end();\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    try {\n        var result = resolve.sync('./invalid_main', { basedir: dir });\n        t.equal(result, undefined, 'result should not exist');\n        t.fail('should not get here');\n    } catch (err) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n    }\n    t.end();\n});\n\ntest('browser field in package.json', function (t) {\n    var dir = path.join(__dirname, 'resolver');\n    var res = resolve.sync('./browser_field', {\n        basedir: dir,\n        packageFilter: function packageFilter(pkg) {\n            if (pkg.browser) {\n                pkg.main = pkg.browser; // eslint-disable-line no-param-reassign\n                delete pkg.browser; // eslint-disable-line no-param-reassign\n            }\n            return pkg;\n        }\n    });\n    t.equal(res, path.join(dir, 'browser_field', 'b.js'));\n    t.end();\n});\n\ntest('absolute paths', function (t) {\n    var extensionless = __filename.slice(0, -path.extname(__filename).length);\n\n    t.equal(\n        resolve.sync(__filename),\n        __filename,\n        'absolute path to this file resolves'\n    );\n    t.equal(\n        resolve.sync(__filename),\n        require.resolve(__filename),\n        'absolute path to this file: resolve.sync === require.resolve'\n    );\n\n    t.equal(\n        resolve.sync(extensionless),\n        __filename,\n        'extensionless absolute path to this file resolves'\n    );\n    t.equal(\n        resolve.sync(__filename),\n        require.resolve(__filename),\n        'absolute path to this file: resolve.sync === require.resolve'\n    );\n\n    t.equal(\n        resolve.sync(__filename, { basedir: process.cwd() }),\n        __filename,\n        'absolute path to this file with a basedir resolves'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync(__filename, { basedir: process.cwd() }),\n            require.resolve(__filename, { paths: [process.cwd()] }),\n            'absolute path to this file + basedir: resolve.sync === require.resolve'\n        );\n    }\n\n    t.equal(\n        resolve.sync(extensionless, { basedir: process.cwd() }),\n        __filename,\n        'extensionless absolute path to this file with a basedir resolves'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync(extensionless, { basedir: process.cwd() }),\n            require.resolve(extensionless, { paths: [process.cwd()] }),\n            'extensionless absolute path to this file + basedir: resolve.sync === require.resolve'\n        );\n    }\n\n    t.end();\n});\n\ntest('malformed package.json', function (t) {\n    t.plan(5 + (requireResolveSupportsPaths ? 1 : 0));\n\n    var basedir = path.join(__dirname, 'resolver/malformed_package_json');\n    var expected = path.join(basedir, 'index.js');\n\n    t.equal(\n        resolve.sync('./index.js', { basedir: basedir }),\n        expected,\n        'malformed package.json is silently ignored'\n    );\n    if (requireResolveSupportsPaths) {\n        t.equal(\n            resolve.sync('./index.js', { basedir: basedir }),\n            require.resolve('./index.js', { paths: [basedir] }),\n            'malformed package.json: resolve.sync === require.resolve'\n        );\n    }\n\n    var res1 = resolve.sync(\n        './index.js',\n        {\n            basedir: basedir,\n            packageFilter: function (pkg, pkgfile, dir) {\n                t.fail('should not reach here');\n            }\n        }\n    );\n\n    t.equal(\n        res1,\n        expected,\n        'with packageFilter: malformed package.json is silently ignored'\n    );\n\n    var res2 = resolve.sync(\n        './index.js',\n        {\n            basedir: basedir,\n            readPackageSync: function (readFileSync, pkgfile) {\n                t.equal(pkgfile, path.join(basedir, 'package.json'), 'readPackageSync: `pkgfile` is package.json path');\n                var result = String(readFileSync(pkgfile));\n                try {\n                    return JSON.parse(result);\n                } catch (e) {\n                    t.ok(e instanceof SyntaxError, 'readPackageSync: malformed package.json parses as a syntax error');\n                }\n            }\n        }\n    );\n\n    t.equal(\n        res2,\n        expected,\n        'with readPackageSync: malformed package.json is silently ignored'\n    );\n});\n"}},"shadowed_core":{"directory":{"node_modules":{"directory":{"util":{"directory":{"index.js":{"file":{"contents":""}}}}}}}},"shadowed_core.js":{"file":{"contents":"var test = require('tape');\nvar resolve = require('../');\nvar path = require('path');\n\ntest('shadowed core modules still return core module', function (t) {\n    t.plan(2);\n\n    resolve('util', { basedir: path.join(__dirname, 'shadowed_core') }, function (err, res) {\n        t.ifError(err);\n        t.equal(res, 'util');\n    });\n});\n\ntest('shadowed core modules still return core module [sync]', function (t) {\n    t.plan(1);\n\n    var res = resolve.sync('util', { basedir: path.join(__dirname, 'shadowed_core') });\n\n    t.equal(res, 'util');\n});\n\ntest('shadowed core modules return shadow when appending `/`', function (t) {\n    t.plan(2);\n\n    resolve('util/', { basedir: path.join(__dirname, 'shadowed_core') }, function (err, res) {\n        t.ifError(err);\n        t.equal(res, path.join(__dirname, 'shadowed_core/node_modules/util/index.js'));\n    });\n});\n\ntest('shadowed core modules return shadow when appending `/` [sync]', function (t) {\n    t.plan(1);\n\n    var res = resolve.sync('util/', { basedir: path.join(__dirname, 'shadowed_core') });\n\n    t.equal(res, path.join(__dirname, 'shadowed_core/node_modules/util/index.js'));\n});\n\ntest('shadowed core modules return shadow with `includeCoreModules: false`', function (t) {\n    t.plan(2);\n\n    resolve('util', { basedir: path.join(__dirname, 'shadowed_core'), includeCoreModules: false }, function (err, res) {\n        t.ifError(err);\n        t.equal(res, path.join(__dirname, 'shadowed_core/node_modules/util/index.js'));\n    });\n});\n\ntest('shadowed core modules return shadow with `includeCoreModules: false` [sync]', function (t) {\n    t.plan(1);\n\n    var res = resolve.sync('util', { basedir: path.join(__dirname, 'shadowed_core'), includeCoreModules: false });\n\n    t.equal(res, path.join(__dirname, 'shadowed_core/node_modules/util/index.js'));\n});\n"}},"subdirs.js":{"file":{"contents":"var test = require('tape');\nvar resolve = require('../');\nvar path = require('path');\n\ntest('subdirs', function (t) {\n    t.plan(2);\n\n    var dir = path.join(__dirname, '/subdirs');\n    resolve('a/b/c/x.json', { basedir: dir }, function (err, res) {\n        t.ifError(err);\n        t.equal(res, path.join(dir, 'node_modules/a/b/c/x.json'));\n    });\n});\n"}},"symlinks.js":{"file":{"contents":"var path = require('path');\nvar fs = require('fs');\nvar test = require('tape');\nvar map = require('array.prototype.map');\nvar resolve = require('../');\n\nvar symlinkDir = path.join(__dirname, 'resolver', 'symlinked', 'symlink');\nvar packageDir = path.join(__dirname, 'resolver', 'symlinked', '_', 'node_modules', 'package');\nvar modADir = path.join(__dirname, 'symlinks', 'source', 'node_modules', 'mod-a');\nvar symlinkModADir = path.join(__dirname, 'symlinks', 'dest', 'node_modules', 'mod-a');\ntry {\n    fs.unlinkSync(symlinkDir);\n} catch (err) {}\ntry {\n    fs.unlinkSync(packageDir);\n} catch (err) {}\ntry {\n    fs.unlinkSync(modADir);\n} catch (err) {}\ntry {\n    fs.unlinkSync(symlinkModADir);\n} catch (err) {}\n\ntry {\n    fs.symlinkSync('./_/symlink_target', symlinkDir, 'dir');\n} catch (err) {\n    // if fails then it is probably on Windows and lets try to create a junction\n    fs.symlinkSync(path.join(__dirname, 'resolver', 'symlinked', '_', 'symlink_target') + '\\\\', symlinkDir, 'junction');\n}\ntry {\n    fs.symlinkSync('../../package', packageDir, 'dir');\n} catch (err) {\n    // if fails then it is probably on Windows and lets try to create a junction\n    fs.symlinkSync(path.join(__dirname, '..', '..', 'package') + '\\\\', packageDir, 'junction');\n}\ntry {\n    fs.symlinkSync('../../source/node_modules/mod-a', symlinkModADir, 'dir');\n} catch (err) {\n    // if fails then it is probably on Windows and lets try to create a junction\n    fs.symlinkSync(path.join(__dirname, '..', '..', 'source', 'node_modules', 'mod-a') + '\\\\', symlinkModADir, 'junction');\n}\n\ntest('symlink', function (t) {\n    t.plan(2);\n\n    resolve('foo', { basedir: symlinkDir, preserveSymlinks: false }, function (err, res, pkg) {\n        t.error(err);\n        t.equal(res, path.join(__dirname, 'resolver', 'symlinked', '_', 'node_modules', 'foo.js'));\n    });\n});\n\ntest('sync symlink when preserveSymlinks = true', function (t) {\n    t.plan(4);\n\n    resolve('foo', { basedir: symlinkDir }, function (err, res, pkg) {\n        t.ok(err, 'there is an error');\n        t.notOk(res, 'no result');\n\n        t.equal(err && err.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');\n        t.equal(\n            err && err.message,\n            'Cannot find module \\'foo\\' from \\'' + symlinkDir + '\\'',\n            'can not find nonexistent module'\n        );\n    });\n});\n\ntest('sync symlink', function (t) {\n    var start = new Date();\n    t.doesNotThrow(function () {\n        t.equal(\n            resolve.sync('foo', { basedir: symlinkDir, preserveSymlinks: false }),\n            path.join(__dirname, 'resolver', 'symlinked', '_', 'node_modules', 'foo.js')\n        );\n    });\n    t.ok(new Date() - start < 50, 'resolve.sync timedout');\n    t.end();\n});\n\ntest('sync symlink when preserveSymlinks = true', function (t) {\n    t.throws(function () {\n        resolve.sync('foo', { basedir: symlinkDir });\n    }, /Cannot find module 'foo'/);\n    t.end();\n});\n\ntest('sync symlink from node_modules to other dir when preserveSymlinks = false', function (t) {\n    var basedir = path.join(__dirname, 'resolver', 'symlinked', '_');\n    var fn = resolve.sync('package', { basedir: basedir, preserveSymlinks: false });\n\n    t.equal(fn, path.resolve(__dirname, 'resolver/symlinked/package/bar.js'));\n    t.end();\n});\n\ntest('async symlink from node_modules to other dir when preserveSymlinks = false', function (t) {\n    t.plan(2);\n    var basedir = path.join(__dirname, 'resolver', 'symlinked', '_');\n    resolve('package', { basedir: basedir, preserveSymlinks: false }, function (err, result) {\n        t.notOk(err, 'no error');\n        t.equal(result, path.resolve(__dirname, 'resolver/symlinked/package/bar.js'));\n    });\n});\n\ntest('packageFilter', function (t) {\n    function relative(x) {\n        return path.relative(__dirname, x);\n    }\n\n    function testPackageFilter(preserveSymlinks) {\n        return function (st) {\n            st.plan('is 1.x' ? 3 : 5); // eslint-disable-line no-constant-condition\n\n            var destMain = 'symlinks/dest/node_modules/mod-a/index.js';\n            var destPkg = 'symlinks/dest/node_modules/mod-a/package.json';\n            var sourceMain = 'symlinks/source/node_modules/mod-a/index.js';\n            var sourcePkg = 'symlinks/source/node_modules/mod-a/package.json';\n            var destDir = path.join(__dirname, 'symlinks', 'dest');\n\n            /* eslint multiline-comment-style: 0 */\n            /* v2.x will restore these tests\n            var packageFilterPath = [];\n            var actualPath = resolve.sync('mod-a', {\n                basedir: destDir,\n                preserveSymlinks: preserveSymlinks,\n                packageFilter: function (pkg, pkgfile, dir) {\n                    packageFilterPath.push(pkgfile);\n                }\n            });\n            st.equal(\n                relative(actualPath),\n                path.normalize(preserveSymlinks ? destMain : sourceMain),\n                'sync: actual path is correct'\n            );\n            st.deepEqual(\n                map(packageFilterPath, relative),\n                map(preserveSymlinks ? [destPkg, destPkg] : [sourcePkg, sourcePkg], path.normalize),\n                'sync: packageFilter pkgfile arg is correct'\n            );\n            */\n\n            var asyncPackageFilterPath = [];\n            resolve(\n                'mod-a',\n                {\n                    basedir: destDir,\n                    preserveSymlinks: preserveSymlinks,\n                    packageFilter: function (pkg, pkgfile) {\n                        asyncPackageFilterPath.push(pkgfile);\n                    }\n                },\n                function (err, actualPath) {\n                    st.error(err, 'no error');\n                    st.equal(\n                        relative(actualPath),\n                        path.normalize(preserveSymlinks ? destMain : sourceMain),\n                        'async: actual path is correct'\n                    );\n                    st.deepEqual(\n                        map(asyncPackageFilterPath, relative),\n                        map(\n                            preserveSymlinks ? [destPkg, destPkg, destPkg] : [sourcePkg, sourcePkg, sourcePkg],\n                            path.normalize\n                        ),\n                        'async: packageFilter pkgfile arg is correct'\n                    );\n                }\n            );\n        };\n    }\n\n    t.test('preserveSymlinks: false', testPackageFilter(false));\n\n    t.test('preserveSymlinks: true', testPackageFilter(true));\n\n    t.end();\n});\n"}}}}}}