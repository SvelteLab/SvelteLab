{"directory":{"bin":{"directory":{"help.md":{"file":{"contents":"  Sorcery version <%= version %>\n  =====================================\n\n  Usage:\n    sorcery [options]\n\n  Options:\n    -h, --help                  Show help message\n    -v, --version               Show version\n    -i, --input <file|folder>   Input file\n    -o, --output <file|folder>  Output file (if absent, will overwrite input)\n    -d, --datauri               Append map as a data URI, rather than separate file\n    -x, --excludeContent        Don't populate the sourcesContent array\n\n\n  Example:\n\n    sorcery --input some/generated/code.min.js\n    sorcery --input tmp --output dist\n\n\n  For more information visit https://github.com/Rich-Harris/sorcery\n"}},"showHelp.js":{"file":{"contents":"var fs = require( 'fs' ),\n\tpath = require( 'path' );\n\nmodule.exports = function ( stream ) {\n\tfs.readFile( path.join( __dirname, 'help.md' ), function ( err, result ) {\n\t\tvar help;\n\n\t\tif ( err ) throw err;\n\n\t\thelp = result.toString().replace( '<%= version %>', require( '../package.json' ).version );\n\t\t( stream || process.stderr ).write( '\\n' + help + '\\n' );\n\t});\n};"}},"sorcery":{"file":{"contents":"#!/usr/bin/env node\n\nvar path = require( 'path' );\nvar minimist = require( 'minimist' );\nvar sander = require( 'sander' );\nvar showHelp = require( './showHelp' );\nvar command;\nvar sorcery = require( '../' );\n\nvar validExtensions = { js: true };\n\ncommand = minimist( process.argv.slice( 2 ), {\n\talias: {\n\t\ti: 'input',\n\t\to: 'output',\n\t\tv: 'version',\n\t\th: 'help',\n\t\td: 'datauri',\n\t\tx: 'excludeContent'\n\t}\n});\n\nif ( command.help ) {\n\tshowHelp( process.stdout );\n}\n\nelse if ( process.argv.length <= 2 && process.stdin.isTTY ) {\n\tshowHelp( process.stderr );\n}\n\nelse if ( command.version ) {\n\tconsole.log( 'Sorcery version ' + require( '../package.json' ).version );\n}\n\nelse if ( !command.input ) {\n\tconsole.error( 'Error: You must supply an --input (-i) argument. Type sorcery --help for more info' );\n}\n\nelse {\n\tsander.stat( command.input ).then( function ( stats ) {\n\t\tif ( stats.isDirectory() ) {\n\t\t\treturn sander.lsr( command.input ).then( function ( files ) {\n\t\t\t\tfiles = files.filter( function ( file ) {\n\t\t\t\t\treturn validExtensions[ path.extname( file ).slice( 1 ) ];\n\t\t\t\t});\n\n\t\t\t\treturn files.reduce( function ( promise, file ) {\n\t\t\t\t\treturn promise.then( function () {\n\t\t\t\t\t\tvar input = path.join( command.input, file );\n\t\t\t\t\t\tvar output = path.join( command.output || command.input, file );\n\n\t\t\t\t\t\treturn sorcery.load( input ).then( function ( chain ) {\n\t\t\t\t\t\t\treturn chain.write( output, {\n\t\t\t\t\t\t\t\tinline: command.datauri,\n\t\t\t\t\t\t\t\tincludeContent: !command.excludeContent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}, Promise.resolve() );\n\t\t\t});\n\t\t}\n\n\t\treturn sorcery.load( command.input ).then( function ( chain ) {\n\t\t\treturn chain.write( command.output || command.input, {\n\t\t\t\tinline: command.datauri,\n\t\t\t\tincludeContent: !command.excludeContent\n\t\t\t});\n\t\t});\n\t}).catch( function ( err ) {\n\t\tsetTimeout( function () {\n\t\t\tthrow err;\n\t\t});\n\t});\n}\n"}}}},"dist":{"directory":{"sorcery.cjs.js":{"file":{"contents":"'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar path = require('path');\nvar sander = require('sander');\n\nvar __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;\nfunction __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }\n\nvar sourcemapCodec_umd = __commonjs(function (module, exports, global) {\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(__commonjs_global, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n});\n\nvar codec = (sourcemapCodec_umd && typeof sourcemapCodec_umd === 'object' && 'default' in sourcemapCodec_umd ? sourcemapCodec_umd['default'] : sourcemapCodec_umd);\n\n/**\n * Decodes a base64 string\n * @param {string} base64 - the string to decode\n * @returns {string}\n */\nfunction atob ( base64 ) {\n\treturn new Buffer( base64, 'base64' ).toString( 'utf8' );\n}\n\n// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;\n\nfunction parseJSON ( json, url ) {\n\ttry {\n\t\treturn JSON.parse( json );\n\t} catch ( err ) {\n\t\tthrow new Error( (\"Could not parse sourcemap (\" + url + \"): \" + (err.message)) );\n\t}\n}\n\n/**\n * Turns a sourceMappingURL into a sourcemap\n * @param {string} url - the sourceMappingURL. Can be a\n   base64-encoded data URI\n * @param {string} base - the URL against which relative URLS\n   should be resolved\n * @param {boolean} sync - if `true`, return a promise, otherwise\n   return the sourcemap\n * @returns {object} - a version 3 sourcemap\n */\nfunction getMapFromUrl ( url, base, sync ) {\n\tif ( /^data:/.test( url ) ) { // TODO beef this up\n\t\tvar match = /base64,(.+)$/.exec( url );\n\n\t\tif ( !match ) {\n\t\t\tthrow new Error( (SOURCEMAPPING_URL$1 + \" is not base64-encoded\") );\n\t\t}\n\n\t\tvar json = atob( match[1] );\n\t\tvar map = parseJSON( json, (\"data URI in \" + base) );\n\t\treturn sync ? map : sander.Promise.resolve( map );\n\t}\n\n\turl = path.resolve( path.dirname( base ), decodeURI( url ) );\n\n\tif ( sync ) {\n\t\treturn parseJSON( sander.readFileSync( url, { encoding: 'utf-8' }), url );\n\t} else {\n\t\treturn sander.readFile( url, { encoding: 'utf-8' }).then( function (json) { return parseJSON( json, url ); } );\n\t}\n}\n\nfunction getSourceMappingUrl ( str ) {\n\tvar index, substring, url, match;\n\n\t// assume we want the last occurence\n\tindex = str.lastIndexOf( (SOURCEMAPPING_URL$1 + \"=\") );\n\n\tif ( index === -1 ) {\n\t\treturn null;\n\t}\n\n\tsubstring = str.substring( index + 17 );\n\tmatch = /^[^\\r\\n]+/.exec( substring );\n\n\turl = match ? match[0] : null;\n\n\t// possibly a better way to do this, but we don't want to exclude whitespace\n\t// from the sourceMappingURL because it might not have been correctly encoded\n\tif ( url && url.slice( -2 ) === '*/' ) {\n\t\turl = url.slice( 0, -2 ).trim();\n\t}\n\n\treturn url;\n}\n\nfunction getMap ( node, sourceMapByPath, sync ) {\n\tif ( node.file in sourceMapByPath ) {\n\t\tvar map = sourceMapByPath[ node.file ];\n\t\treturn sync ? map : sander.Promise.resolve( map );\n\t}\n\n\telse {\n\t\tvar url = getSourceMappingUrl( node.content );\n\n\t\tif ( !url ) {\n\t\t\tnode.isOriginalSource = true;\n\t\t\treturn sync ? null : sander.Promise.resolve( null );\n\t\t}\n\n\t\treturn getMapFromUrl( url, node.file, sync );\n\t}\n}\n\nfunction Node (ref) {\n\tvar file = ref.file;\n\tvar content = ref.content;\n\n\tthis.file = file ? path.resolve( file ) : null;\n\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\tif ( !this.file && this.content === null ) {\n\t\tthrow new Error( 'A source must specify either file or content' );\n\t}\n\n\t// these get filled in later\n\tthis.map = null;\n\tthis.mappings = null;\n\tthis.sources = null;\n\tthis.isOriginalSource = null;\n\n\tthis._stats = {\n\t\tdecodingTime: 0,\n\t\tencodingTime: 0,\n\t\ttracingTime: 0,\n\n\t\tuntraceable: 0\n\t};\n}\n\nNode.prototype = {\n\tload: function load ( sourcesContentByPath, sourceMapByPath ) {\n\t\tvar this$1 = this;\n\n\t\treturn getContent( this, sourcesContentByPath ).then( function (content) {\n\t\t\tthis$1.content = sourcesContentByPath[ this$1.file ] = content;\n\n\t\t\treturn getMap( this$1, sourceMapByPath ).then( function (map) {\n\t\t\t\tif ( !map ) return null;\n\n\t\t\t\tthis$1.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\tthis$1.mappings = codec.decode( map.mappings );\n\t\t\t\tvar decodingTime = process.hrtime( decodingStart );\n\t\t\t\tthis$1._stats.decodingTime = 1e9 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\tvar sourceRoot = path.resolve( path.dirname( this$1.file ), map.sourceRoot || '' );\n\n\t\t\t\tthis$1.sources = map.sources.map( function ( source, i ) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? path.resolve( sourceRoot, source ) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = this$1.sources.map( function (node) { return node.load( sourcesContentByPath, sourceMapByPath ); } );\n\t\t\t\treturn sander.Promise.all( promises );\n\t\t\t});\n\t\t});\n\t},\n\n\tloadSync: function loadSync ( sourcesContentByPath, sourceMapByPath ) {\n\t\tif ( !this.content ) {\n\t\t\tif ( !sourcesContentByPath[ this.file ] ) {\n\t\t\t\tsourcesContentByPath[ this.file ] = sander.readFileSync( this.file, { encoding: 'utf-8' });\n\t\t\t}\n\n\t\t\tthis.content = sourcesContentByPath[ this.file ];\n\t\t}\n\n\t\tvar map = getMap( this, sourceMapByPath, true );\n\t\tvar sourcesContent;\n\n\t\tif ( !map ) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = codec.decode( map.mappings );\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tvar sourceRoot = path.resolve( path.dirname( this.file ), map.sourceRoot || '' );\n\n\t\t\tthis.sources = map.sources.map( function ( source, i ) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: path.resolve( sourceRoot, source ),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Traces a segment back to its origin\n\t * @param {number} lineIndex - the zero-based line index of the\n\t   segment as found in `this`\n\t * @param {number} columnIndex - the zero-based column index of the\n\t   segment as found in `this`\n\t * @param {string || null} - if specified, the name that should be\n\t   (eventually) returned, as it is closest to the generated code\n\t * @returns {object}\n\t     @property {string} source - the filepath of the source\n\t     @property {number} line - the one-based line index\n\t     @property {number} column - the zero-based column index\n\t     @property {string || null} name - the name corresponding\n\t     to the segment being traced\n\t */\n\ttrace: function trace ( lineIndex, columnIndex, name ) {\n\t\tvar this$1 = this;\n\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif ( this.isOriginalSource ) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[ lineIndex ];\n\n\t\tif ( !segments || segments.length === 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( columnIndex != null ) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif ( generatedCodeColumn > columnIndex ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( generatedCodeColumn === columnIndex ) {\n\t\t\t\t\tif ( segments[i].length < 4 ) return null;\n\n\t\t\t\t\tvar sourceFileIndex$1 = segments[i][1];\n\t\t\t\t\tvar sourceCodeLine$1 = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar nameIndex$1 = segments[i][4];\n\n\t\t\t\t\tvar parent$1 = this$1.sources[ sourceFileIndex$1 ];\n\t\t\t\t\treturn parent$1.trace( sourceCodeLine$1, sourceCodeColumn, this$1.map.names[ nameIndex$1 ] || name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[ sourceFileIndex ];\n\t\treturn parent.trace( sourceCodeLine, null, this.map.names[ nameIndex ] || name );\n\t}\n};\n\nfunction getContent ( node, sourcesContentByPath ) {\n\tif ( node.file in sourcesContentByPath ) {\n\t\tnode.content = sourcesContentByPath[ node.file ];\n\t}\n\n\tif ( !node.content ) {\n\t\treturn sander.readFile( node.file, { encoding: 'utf-8' });\n\t}\n\n\treturn sander.Promise.resolve( node.content );\n}\n\n/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nfunction btoa ( str ) {\n\treturn new Buffer( str ).toString( 'base64' );\n}\n\nfunction SourceMap ( properties ) {\n\tthis.version = 3;\n\n\tthis.file           = properties.file;\n\tthis.sources        = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names          = properties.names;\n\tthis.mappings       = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString: function toString () {\n\t\treturn JSON.stringify( this );\n\t},\n\n\ttoUrl: function toUrl () {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\n\t}\n};\n\nfunction slash ( path ) {\n\treturn typeof path === 'string' ?\n\t\tpath.replace( /\\\\/g, '/' ) :\n\t\tpath;\n}\n\nvar SOURCEMAP_COMMENT = new RegExp( \"\\n*(?:\" +\n\t\"\\\\/\\\\/[@#]\\\\s*\" + SOURCEMAPPING_URL$1 + \"=([^'\\\"]+)|\" +      // js\n\t\"\\\\/\\\\*#?\\\\s*\" + SOURCEMAPPING_URL$1 + \"=([^'\\\"]+)\\\\s\\\\*\\\\/)\" + // css\n'\\\\s*$', 'g' );\n\nfunction Chain ( node, sourcesContentByPath ) {\n\tthis.node = node;\n\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\tthis._stats = {};\n}\n\nChain.prototype = {\n\tstat: function stat () {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1e6,\n\t\t\ttotalDecodingTime: ( this._stats.decodingTime + tally( this.node.sources, 'decodingTime' ) ) / 1e6,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1e6,\n\t\t\ttracingTime: this._stats.tracingTime / 1e6,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t},\n\n\tapply: function apply ( options ) {\n\t\tvar this$1 = this;\n\t\tif ( options === void 0 ) options = {};\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function ( segment, result ) {\n\t\t\tif ( segment.length < 4 ) return;\n\n\t\t\tvar traced = this$1.node.sources[ segment[1] ].trace( // source\n\t\t\t\tsegment[2], // source code line\n\t\t\t\tsegment[3], // source code column\n\t\t\t\tthis$1.node.map.names[ segment[4] ]\n\t\t\t);\n\n\t\t\tif ( !traced ) {\n\t\t\t\tthis$1._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf( traced.source );\n\t\t\tif ( !~sourceIndex ) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push( traced.source );\n\t\t\t}\n\n\t\t\tvar newSegment = [\n\t\t\t\tsegment[0], // generated code column\n\t\t\t\tsourceIndex,\n\t\t\t\ttraced.line - 1,\n\t\t\t\ttraced.column\n\t\t\t];\n\n\t\t\tif ( traced.name ) {\n\t\t\t\tvar nameIndex = allNames.indexOf( traced.name );\n\t\t\t\tif ( !~nameIndex ) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push( traced.name );\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[ result.length ] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array( i );\n\n\t\tvar j, line, result;\n\n\t\twhile ( i-- ) {\n\t\t\tline = this$1.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor ( j = 0; j < line.length; j += 1 ) {\n\t\t\t\tapplySegment( line[j], result );\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime( tracingStart );\n\t\tthis._stats.tracingTime = 1e9 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = codec.encode( resolved );\n\t\tvar encodingTime = process.hrtime( encodingStart );\n\t\tthis._stats.encodingTime = 1e9 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: path.basename( this.node.file ),\n\t\t\tsources: allSources.map( function (source) { return slash( path.relative( options.base || path.dirname( this$1.node.file ), source ) ); } ),\n\t\t\tsourcesContent: allSources.map( function (source) { return includeContent ? this$1.sourcesContentByPath[ source ] : null; } ),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t},\n\n\ttrace: function trace ( oneBasedLineIndex, zeroBasedColumnIndex ) {\n\t\treturn this.node.trace( oneBasedLineIndex - 1, zeroBasedColumnIndex, null );\n\t},\n\n\twrite: function write ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tvar ref = processWriteOptions( dest, this, options );\n\t\tvar resolved = ref.resolved;\n\t\tvar content = ref.content;\n\t\tvar map = ref.map;\n\n\t\tvar promises = [ sander.writeFile( resolved, content ) ];\n\n\t\tif ( !options.inline ) {\n\t\t\tpromises.push( sander.writeFile( resolved + '.map', map.toString() ) );\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t},\n\n\twriteSync: function writeSync ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tvar ref = processWriteOptions( dest, this, options );\n\t\tvar resolved = ref.resolved;\n\t\tvar content = ref.content;\n\t\tvar map = ref.map;\n\n\t\tsander.writeFileSync( resolved, content );\n\n\t\tif ( !options.inline ) {\n\t\t\tsander.writeFileSync( resolved + '.map', map.toString() );\n\t\t}\n\t}\n};\n\nfunction processWriteOptions ( dest, chain, options ) {\n\tvar resolved = path.resolve( dest );\n\n\tvar map = chain.apply({\n\t\tincludeContent: options.includeContent,\n\t\tbase: options.base ? path.resolve( options.base ) : path.dirname( resolved )\n\t});\n\n\tvar url = options.inline ? map.toUrl() : ( options.absolutePath ? resolved : path.basename( resolved ) ) + '.map';\n\n\t// TODO shouldn't url be relative?\n\tvar content = chain.node.content.replace( SOURCEMAP_COMMENT, '' ) + sourcemapComment( url, resolved );\n\n\treturn { resolved: resolved, content: content, map: map };\n}\n\nfunction tally ( nodes, stat ) {\n\treturn nodes.reduce( function ( total, node ) {\n\t\treturn total + node._stats[ stat ];\n\t}, 0 );\n}\n\nfunction sourcemapComment ( url, dest ) {\n\tvar ext = path.extname( dest );\n\turl = encodeURI( url );\n\n\tif ( ext === '.css' ) {\n\t\treturn (\"\\n/*# \" + SOURCEMAPPING_URL$1 + \"=\" + url + \" */\\n\");\n\t}\n\n\treturn (\"\\n//# \" + SOURCEMAPPING_URL$1 + \"=\" + url + \"\\n\");\n}\n\nfunction load ( file, options ) {\n\tvar ref = init( file, options );\n\tvar node = ref.node;\n\tvar sourcesContentByPath = ref.sourcesContentByPath;\n\tvar sourceMapByPath = ref.sourceMapByPath;\n\n\treturn node.load( sourcesContentByPath, sourceMapByPath )\n\t\t.then( function () { return node.isOriginalSource ? null : new Chain( node, sourcesContentByPath ); } );\n}\n\nfunction loadSync ( file, options ) {\n\tif ( options === void 0 ) options = {};\n\n\tvar ref = init( file, options );\n\tvar node = ref.node;\n\tvar sourcesContentByPath = ref.sourcesContentByPath;\n\tvar sourceMapByPath = ref.sourceMapByPath;\n\n\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\treturn node.isOriginalSource ? null : new Chain( node, sourcesContentByPath );\n}\n\nfunction init ( file, options ) {\n\tif ( options === void 0 ) options = {};\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif ( options.content ) {\n\t\tObject.keys( options.content ).forEach( function (key) {\n\t\t\tsourcesContentByPath[ path.resolve( key ) ] = options.content[ key ];\n\t\t});\n\t}\n\n\tif ( options.sourcemaps ) {\n\t\tObject.keys( options.sourcemaps ).forEach( function (key) {\n\t\t\tsourceMapByPath[ path.resolve( key ) ] = options.sourcemaps[ key ];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n\nexports.load = load;\nexports.loadSync = loadSync;\n//# sourceMappingURL=sorcery.cjs.js.map"}},"sorcery.cjs.js.map":{"file":{"contents":"{\"version\":3,\"file\":null,\"sources\":[\"../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\",\"../src/utils/atob.js\",\"../src/utils/sourceMappingURL.js\",\"../src/utils/getMapFromUrl.js\",\"../src/utils/getSourceMappingUrl.js\",\"../src/utils/getMap.js\",\"../src/Node.js\",\"../src/utils/btoa.js\",\"../src/SourceMap.js\",\"../src/utils/slash.js\",\"../src/Chain.js\",\"../src/index.js\"],\"sourcesContent\":[\"(function (global, factory) {\\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\\n})(this, (function (exports) { 'use strict';\\n\\n    const comma = ','.charCodeAt(0);\\n    const semicolon = ';'.charCodeAt(0);\\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    const intToChar = new Uint8Array(64); // 64 possible chars.\\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\\n    for (let i = 0; i < chars.length; i++) {\\n        const c = chars.charCodeAt(i);\\n        intToChar[i] = c;\\n        charToInt[c] = i;\\n    }\\n    // Provide a fallback for older environments.\\n    const td = typeof TextDecoder !== 'undefined'\\n        ? /* #__PURE__ */ new TextDecoder()\\n        : typeof Buffer !== 'undefined'\\n            ? {\\n                decode(buf) {\\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\\n                    return out.toString();\\n                },\\n            }\\n            : {\\n                decode(buf) {\\n                    let out = '';\\n                    for (let i = 0; i < buf.length; i++) {\\n                        out += String.fromCharCode(buf[i]);\\n                    }\\n                    return out;\\n                },\\n            };\\n    function decode(mappings) {\\n        const state = new Int32Array(5);\\n        const decoded = [];\\n        let index = 0;\\n        do {\\n            const semi = indexOf(mappings, index);\\n            const line = [];\\n            let sorted = true;\\n            let lastCol = 0;\\n            state[0] = 0;\\n            for (let i = index; i < semi; i++) {\\n                let seg;\\n                i = decodeInteger(mappings, i, state, 0); // genColumn\\n                const col = state[0];\\n                if (col < lastCol)\\n                    sorted = false;\\n                lastCol = col;\\n                if (hasMoreVlq(mappings, i, semi)) {\\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\\n                    if (hasMoreVlq(mappings, i, semi)) {\\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\\n                        seg = [col, state[1], state[2], state[3], state[4]];\\n                    }\\n                    else {\\n                        seg = [col, state[1], state[2], state[3]];\\n                    }\\n                }\\n                else {\\n                    seg = [col];\\n                }\\n                line.push(seg);\\n            }\\n            if (!sorted)\\n                sort(line);\\n            decoded.push(line);\\n            index = semi + 1;\\n        } while (index <= mappings.length);\\n        return decoded;\\n    }\\n    function indexOf(mappings, index) {\\n        const idx = mappings.indexOf(';', index);\\n        return idx === -1 ? mappings.length : idx;\\n    }\\n    function decodeInteger(mappings, pos, state, j) {\\n        let value = 0;\\n        let shift = 0;\\n        let integer = 0;\\n        do {\\n            const c = mappings.charCodeAt(pos++);\\n            integer = charToInt[c];\\n            value |= (integer & 31) << shift;\\n            shift += 5;\\n        } while (integer & 32);\\n        const shouldNegate = value & 1;\\n        value >>>= 1;\\n        if (shouldNegate) {\\n            value = -0x80000000 | -value;\\n        }\\n        state[j] += value;\\n        return pos;\\n    }\\n    function hasMoreVlq(mappings, i, length) {\\n        if (i >= length)\\n            return false;\\n        return mappings.charCodeAt(i) !== comma;\\n    }\\n    function sort(line) {\\n        line.sort(sortComparator);\\n    }\\n    function sortComparator(a, b) {\\n        return a[0] - b[0];\\n    }\\n    function encode(decoded) {\\n        const state = new Int32Array(5);\\n        const bufLength = 1024 * 16;\\n        const subLength = bufLength - 36;\\n        const buf = new Uint8Array(bufLength);\\n        const sub = buf.subarray(0, subLength);\\n        let pos = 0;\\n        let out = '';\\n        for (let i = 0; i < decoded.length; i++) {\\n            const line = decoded[i];\\n            if (i > 0) {\\n                if (pos === bufLength) {\\n                    out += td.decode(buf);\\n                    pos = 0;\\n                }\\n                buf[pos++] = semicolon;\\n            }\\n            if (line.length === 0)\\n                continue;\\n            state[0] = 0;\\n            for (let j = 0; j < line.length; j++) {\\n                const segment = line[j];\\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\\n                // may push a comma.\\n                if (pos > subLength) {\\n                    out += td.decode(sub);\\n                    buf.copyWithin(0, subLength, pos);\\n                    pos -= subLength;\\n                }\\n                if (j > 0)\\n                    buf[pos++] = comma;\\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\\n                if (segment.length === 1)\\n                    continue;\\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\\n                if (segment.length === 4)\\n                    continue;\\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\\n            }\\n        }\\n        return out + td.decode(buf.subarray(0, pos));\\n    }\\n    function encodeInteger(buf, pos, state, segment, j) {\\n        const next = segment[j];\\n        let num = next - state[j];\\n        state[j] = next;\\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\\n        do {\\n            let clamped = num & 0b011111;\\n            num >>>= 5;\\n            if (num > 0)\\n                clamped |= 0b100000;\\n            buf[pos++] = intToChar[clamped];\\n        } while (num > 0);\\n        return pos;\\n    }\\n\\n    exports.decode = decode;\\n    exports.encode = encode;\\n\\n    Object.defineProperty(exports, '__esModule', { value: true });\\n\\n}));\\n//# sourceMappingURL=sourcemap-codec.umd.js.map\\n\",\"/**\\n * Decodes a base64 string\\n * @param {string} base64 - the string to decode\\n * @returns {string}\\n */\\nexport default function atob ( base64 ) {\\n\\treturn new Buffer( base64, 'base64' ).toString( 'utf8' );\\n}\",\"// this looks ridiculous, but it prevents sourcemap tooling from mistaking\\n// this for an actual sourceMappingURL\\nlet SOURCEMAPPING_URL = 'sourceMa';\\nSOURCEMAPPING_URL += 'ppingURL';\\n\\nexport default SOURCEMAPPING_URL;\\n\",\"import { dirname, resolve } from 'path';\\nimport { readFile, readFileSync, Promise } from 'sander';\\nimport atob from './atob.js';\\nimport SOURCEMAPPING_URL from './sourceMappingURL.js';\\n\\nfunction parseJSON ( json, url ) {\\n\\ttry {\\n\\t\\treturn JSON.parse( json );\\n\\t} catch ( err ) {\\n\\t\\tthrow new Error( `Could not parse sourcemap (${url}): ${err.message}` );\\n\\t}\\n}\\n\\n/**\\n * Turns a sourceMappingURL into a sourcemap\\n * @param {string} url - the sourceMappingURL. Can be a\\n   base64-encoded data URI\\n * @param {string} base - the URL against which relative URLS\\n   should be resolved\\n * @param {boolean} sync - if `true`, return a promise, otherwise\\n   return the sourcemap\\n * @returns {object} - a version 3 sourcemap\\n */\\nexport default function getMapFromUrl ( url, base, sync ) {\\n\\tif ( /^data:/.test( url ) ) { // TODO beef this up\\n\\t\\tconst match = /base64,(.+)$/.exec( url );\\n\\n\\t\\tif ( !match ) {\\n\\t\\t\\tthrow new Error( `${SOURCEMAPPING_URL} is not base64-encoded` );\\n\\t\\t}\\n\\n\\t\\tconst json = atob( match[1] );\\n\\t\\tconst map = parseJSON( json, `data URI in ${base}` );\\n\\t\\treturn sync ? map : Promise.resolve( map );\\n\\t}\\n\\n\\turl = resolve( dirname( base ), decodeURI( url ) );\\n\\n\\tif ( sync ) {\\n\\t\\treturn parseJSON( readFileSync( url, { encoding: 'utf-8' }), url );\\n\\t} else {\\n\\t\\treturn readFile( url, { encoding: 'utf-8' }).then( json => parseJSON( json, url ) );\\n\\t}\\n}\\n\",\"import SOURCEMAPPING_URL from './sourceMappingURL.js';\\n\\nexport default function getSourceMappingUrl ( str ) {\\n\\tvar index, substring, url, match;\\n\\n\\t// assume we want the last occurence\\n\\tindex = str.lastIndexOf( `${SOURCEMAPPING_URL}=` );\\n\\n\\tif ( index === -1 ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tsubstring = str.substring( index + 17 );\\n\\tmatch = /^[^\\\\r\\\\n]+/.exec( substring );\\n\\n\\turl = match ? match[0] : null;\\n\\n\\t// possibly a better way to do this, but we don't want to exclude whitespace\\n\\t// from the sourceMappingURL because it might not have been correctly encoded\\n\\tif ( url && url.slice( -2 ) === '*/' ) {\\n\\t\\turl = url.slice( 0, -2 ).trim();\\n\\t}\\n\\n\\treturn url;\\n}\\n\",\"import { Promise } from 'sander';\\nimport getMapFromUrl from './getMapFromUrl.js';\\nimport getSourceMappingUrl from './getSourceMappingUrl.js';\\n\\nexport default function getMap ( node, sourceMapByPath, sync ) {\\n\\tif ( node.file in sourceMapByPath ) {\\n\\t\\tconst map = sourceMapByPath[ node.file ];\\n\\t\\treturn sync ? map : Promise.resolve( map );\\n\\t}\\n\\n\\telse {\\n\\t\\tconst url = getSourceMappingUrl( node.content );\\n\\n\\t\\tif ( !url ) {\\n\\t\\t\\tnode.isOriginalSource = true;\\n\\t\\t\\treturn sync ? null : Promise.resolve( null );\\n\\t\\t}\\n\\n\\t\\treturn getMapFromUrl( url, node.file, sync );\\n\\t}\\n}\\n\",\"import { dirname, resolve } from 'path';\\nimport { readFile, readFileSync, Promise } from 'sander';\\nimport codec from '@jridgewell/sourcemap-codec';\\nimport getMap from './utils/getMap.js';\\n\\nexport default function Node ({ file, content }) {\\n\\tthis.file = file ? resolve( file ) : null;\\n\\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\\n\\n\\tif ( !this.file && this.content === null ) {\\n\\t\\tthrow new Error( 'A source must specify either file or content' );\\n\\t}\\n\\n\\t// these get filled in later\\n\\tthis.map = null;\\n\\tthis.mappings = null;\\n\\tthis.sources = null;\\n\\tthis.isOriginalSource = null;\\n\\n\\tthis._stats = {\\n\\t\\tdecodingTime: 0,\\n\\t\\tencodingTime: 0,\\n\\t\\ttracingTime: 0,\\n\\n\\t\\tuntraceable: 0\\n\\t};\\n}\\n\\nNode.prototype = {\\n\\tload ( sourcesContentByPath, sourceMapByPath ) {\\n\\t\\treturn getContent( this, sourcesContentByPath ).then( content => {\\n\\t\\t\\tthis.content = sourcesContentByPath[ this.file ] = content;\\n\\n\\t\\t\\treturn getMap( this, sourceMapByPath ).then( map => {\\n\\t\\t\\t\\tif ( !map ) return null;\\n\\n\\t\\t\\t\\tthis.map = map;\\n\\n\\t\\t\\t\\tlet decodingStart = process.hrtime();\\n\\t\\t\\t\\tthis.mappings = codec.decode( map.mappings );\\n\\t\\t\\t\\tlet decodingTime = process.hrtime( decodingStart );\\n\\t\\t\\t\\tthis._stats.decodingTime = 1e9 * decodingTime[0] + decodingTime[1];\\n\\n\\t\\t\\t\\tconst sourcesContent = map.sourcesContent || [];\\n\\n\\t\\t\\t\\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\\n\\n\\t\\t\\t\\tthis.sources = map.sources.map( ( source, i ) => {\\n\\t\\t\\t\\t\\treturn new Node({\\n\\t\\t\\t\\t\\t\\tfile: source ? resolve( sourceRoot, source ) : null,\\n\\t\\t\\t\\t\\t\\tcontent: sourcesContent[i]\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tconst promises = this.sources.map( node => node.load( sourcesContentByPath, sourceMapByPath ) );\\n\\t\\t\\t\\treturn Promise.all( promises );\\n\\t\\t\\t});\\n\\t\\t});\\n\\t},\\n\\n\\tloadSync ( sourcesContentByPath, sourceMapByPath ) {\\n\\t\\tif ( !this.content ) {\\n\\t\\t\\tif ( !sourcesContentByPath[ this.file ] ) {\\n\\t\\t\\t\\tsourcesContentByPath[ this.file ] = readFileSync( this.file, { encoding: 'utf-8' });\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.content = sourcesContentByPath[ this.file ];\\n\\t\\t}\\n\\n\\t\\tconst map = getMap( this, sourceMapByPath, true );\\n\\t\\tlet sourcesContent;\\n\\n\\t\\tif ( !map ) {\\n\\t\\t\\tthis.isOriginalSource = true;\\n\\t\\t} else {\\n\\t\\t\\tthis.map = map;\\n\\t\\t\\tthis.mappings = codec.decode( map.mappings );\\n\\n\\t\\t\\tsourcesContent = map.sourcesContent || [];\\n\\n\\t\\t\\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\\n\\n\\t\\t\\tthis.sources = map.sources.map( ( source, i ) => {\\n\\t\\t\\t\\tconst node = new Node({\\n\\t\\t\\t\\t\\tfile: resolve( sourceRoot, source ),\\n\\t\\t\\t\\t\\tcontent: sourcesContent[i]\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t/**\\n\\t * Traces a segment back to its origin\\n\\t * @param {number} lineIndex - the zero-based line index of the\\n\\t   segment as found in `this`\\n\\t * @param {number} columnIndex - the zero-based column index of the\\n\\t   segment as found in `this`\\n\\t * @param {string || null} - if specified, the name that should be\\n\\t   (eventually) returned, as it is closest to the generated code\\n\\t * @returns {object}\\n\\t     @property {string} source - the filepath of the source\\n\\t     @property {number} line - the one-based line index\\n\\t     @property {number} column - the zero-based column index\\n\\t     @property {string || null} name - the name corresponding\\n\\t     to the segment being traced\\n\\t */\\n\\ttrace ( lineIndex, columnIndex, name ) {\\n\\t\\t// If this node doesn't have a source map, we have\\n\\t\\t// to assume it is the original source\\n\\t\\tif ( this.isOriginalSource ) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tsource: this.file,\\n\\t\\t\\t\\tline: lineIndex + 1,\\n\\t\\t\\t\\tcolumn: columnIndex || 0,\\n\\t\\t\\t\\tname: name\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to figure out what this position in\\n\\t\\t// the intermediate file corresponds to in *its* source\\n\\t\\tconst segments = this.mappings[ lineIndex ];\\n\\n\\t\\tif ( !segments || segments.length === 0 ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ( columnIndex != null ) {\\n\\t\\t\\tlet len = segments.length;\\n\\t\\t\\tlet i;\\n\\n\\t\\t\\tfor ( i = 0; i < len; i += 1 ) {\\n\\t\\t\\t\\tlet generatedCodeColumn = segments[i][0];\\n\\n\\t\\t\\t\\tif ( generatedCodeColumn > columnIndex ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( generatedCodeColumn === columnIndex ) {\\n\\t\\t\\t\\t\\tif ( segments[i].length < 4 ) return null;\\n\\n\\t\\t\\t\\t\\tlet sourceFileIndex = segments[i][1];\\n\\t\\t\\t\\t\\tlet sourceCodeLine = segments[i][2];\\n\\t\\t\\t\\t\\tlet sourceCodeColumn = segments[i][3];\\n\\t\\t\\t\\t\\tlet nameIndex = segments[i][4];\\n\\n\\t\\t\\t\\t\\tlet parent = this.sources[ sourceFileIndex ];\\n\\t\\t\\t\\t\\treturn parent.trace( sourceCodeLine, sourceCodeColumn, this.map.names[ nameIndex ] || name );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// fall back to a line mapping\\n\\t\\tlet sourceFileIndex = segments[0][1];\\n\\t\\tlet sourceCodeLine = segments[0][2];\\n\\t\\tlet nameIndex = segments[0][4];\\n\\n\\t\\tlet parent = this.sources[ sourceFileIndex ];\\n\\t\\treturn parent.trace( sourceCodeLine, null, this.map.names[ nameIndex ] || name );\\n\\t}\\n};\\n\\nfunction getContent ( node, sourcesContentByPath ) {\\n\\tif ( node.file in sourcesContentByPath ) {\\n\\t\\tnode.content = sourcesContentByPath[ node.file ];\\n\\t}\\n\\n\\tif ( !node.content ) {\\n\\t\\treturn readFile( node.file, { encoding: 'utf-8' });\\n\\t}\\n\\n\\treturn Promise.resolve( node.content );\\n}\\n\",\"/**\\n * Encodes a string as base64\\n * @param {string} str - the string to encode\\n * @returns {string}\\n */\\nexport default function btoa ( str ) {\\n\\treturn new Buffer( str ).toString( 'base64' );\\n}\",\"import btoa from './utils/btoa.js';\\n\\nexport default function SourceMap ( properties ) {\\n\\tthis.version = 3;\\n\\n\\tthis.file           = properties.file;\\n\\tthis.sources        = properties.sources;\\n\\tthis.sourcesContent = properties.sourcesContent;\\n\\tthis.names          = properties.names;\\n\\tthis.mappings       = properties.mappings;\\n}\\n\\nSourceMap.prototype = {\\n\\ttoString () {\\n\\t\\treturn JSON.stringify( this );\\n\\t},\\n\\n\\ttoUrl () {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\\n\\t}\\n};\\n\",\"export default function slash ( path ) {\\n\\treturn typeof path === 'string' ?\\n\\t\\tpath.replace( /\\\\\\\\/g, '/' ) :\\n\\t\\tpath;\\n}\\n\",\"import { basename, dirname, extname, relative, resolve } from 'path';\\nimport { writeFile, writeFileSync } from 'sander';\\nimport codec from '@jridgewell/sourcemap-codec';\\nimport SourceMap from './SourceMap.js';\\nimport slash from './utils/slash.js';\\nimport SOURCEMAPPING_URL from './utils/sourceMappingURL.js';\\n\\nconst SOURCEMAP_COMMENT = new RegExp( `\\\\n*(?:` +\\n\\t`\\\\\\\\/\\\\\\\\/[@#]\\\\\\\\s*${SOURCEMAPPING_URL}=([^'\\\"]+)|` +      // js\\n\\t`\\\\\\\\/\\\\\\\\*#?\\\\\\\\s*${SOURCEMAPPING_URL}=([^'\\\"]+)\\\\\\\\s\\\\\\\\*\\\\\\\\/)` + // css\\n'\\\\\\\\s*$', 'g' );\\n\\nexport default function Chain ( node, sourcesContentByPath ) {\\n\\tthis.node = node;\\n\\tthis.sourcesContentByPath = sourcesContentByPath;\\n\\n\\tthis._stats = {};\\n}\\n\\nChain.prototype = {\\n\\tstat () {\\n\\t\\treturn {\\n\\t\\t\\tselfDecodingTime: this._stats.decodingTime / 1e6,\\n\\t\\t\\ttotalDecodingTime: ( this._stats.decodingTime + tally( this.node.sources, 'decodingTime' ) ) / 1e6,\\n\\n\\t\\t\\tencodingTime: this._stats.encodingTime / 1e6,\\n\\t\\t\\ttracingTime: this._stats.tracingTime / 1e6,\\n\\n\\t\\t\\tuntraceable: this._stats.untraceable\\n\\t\\t};\\n\\t},\\n\\n\\tapply ( options = {} ) {\\n\\t\\tlet allNames = [];\\n\\t\\tlet allSources = [];\\n\\n\\t\\tconst applySegment = ( segment, result ) => {\\n\\t\\t\\tif ( segment.length < 4 ) return;\\n\\n\\t\\t\\tconst traced = this.node.sources[ segment[1] ].trace( // source\\n\\t\\t\\t\\tsegment[2], // source code line\\n\\t\\t\\t\\tsegment[3], // source code column\\n\\t\\t\\t\\tthis.node.map.names[ segment[4] ]\\n\\t\\t\\t);\\n\\n\\t\\t\\tif ( !traced ) {\\n\\t\\t\\t\\tthis._stats.untraceable += 1;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet sourceIndex = allSources.indexOf( traced.source );\\n\\t\\t\\tif ( !~sourceIndex ) {\\n\\t\\t\\t\\tsourceIndex = allSources.length;\\n\\t\\t\\t\\tallSources.push( traced.source );\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet newSegment = [\\n\\t\\t\\t\\tsegment[0], // generated code column\\n\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\ttraced.line - 1,\\n\\t\\t\\t\\ttraced.column\\n\\t\\t\\t];\\n\\n\\t\\t\\tif ( traced.name ) {\\n\\t\\t\\t\\tlet nameIndex = allNames.indexOf( traced.name );\\n\\t\\t\\t\\tif ( !~nameIndex ) {\\n\\t\\t\\t\\t\\tnameIndex = allNames.length;\\n\\t\\t\\t\\t\\tallNames.push( traced.name );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnewSegment[4] = nameIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult[ result.length ] = newSegment;\\n\\t\\t};\\n\\n\\t\\t// Trace mappings\\n\\t\\tlet tracingStart = process.hrtime();\\n\\n\\t\\tlet i = this.node.mappings.length;\\n\\t\\tlet resolved = new Array( i );\\n\\n\\t\\tlet j, line, result;\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tline = this.node.mappings[i];\\n\\t\\t\\tresolved[i] = result = [];\\n\\n\\t\\t\\tfor ( j = 0; j < line.length; j += 1 ) {\\n\\t\\t\\t\\tapplySegment( line[j], result );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet tracingTime = process.hrtime( tracingStart );\\n\\t\\tthis._stats.tracingTime = 1e9 * tracingTime[0] + tracingTime[1];\\n\\n\\t\\t// Encode mappings\\n\\t\\tlet encodingStart = process.hrtime();\\n\\t\\tlet mappings = codec.encode( resolved );\\n\\t\\tlet encodingTime = process.hrtime( encodingStart );\\n\\t\\tthis._stats.encodingTime = 1e9 * encodingTime[0] + encodingTime[1];\\n\\n\\t\\tlet includeContent = options.includeContent !== false;\\n\\n\\t\\treturn new SourceMap({\\n\\t\\t\\tfile: basename( this.node.file ),\\n\\t\\t\\tsources: allSources.map( source => slash( relative( options.base || dirname( this.node.file ), source ) ) ),\\n\\t\\t\\tsourcesContent: allSources.map( source => includeContent ? this.sourcesContentByPath[ source ] : null ),\\n\\t\\t\\tnames: allNames,\\n\\t\\t\\tmappings\\n\\t\\t});\\n\\t},\\n\\n\\ttrace ( oneBasedLineIndex, zeroBasedColumnIndex ) {\\n\\t\\treturn this.node.trace( oneBasedLineIndex - 1, zeroBasedColumnIndex, null );\\n\\t},\\n\\n\\twrite ( dest, options ) {\\n\\t\\tif ( typeof dest !== 'string' ) {\\n\\t\\t\\toptions = dest;\\n\\t\\t\\tdest = this.node.file;\\n\\t\\t}\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\\n\\n\\t\\tlet promises = [ writeFile( resolved, content ) ];\\n\\n\\t\\tif ( !options.inline ) {\\n\\t\\t\\tpromises.push( writeFile( resolved + '.map', map.toString() ) );\\n\\t\\t}\\n\\n\\t\\treturn Promise.all( promises );\\n\\t},\\n\\n\\twriteSync ( dest, options ) {\\n\\t\\tif ( typeof dest !== 'string' ) {\\n\\t\\t\\toptions = dest;\\n\\t\\t\\tdest = this.node.file;\\n\\t\\t}\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\\n\\n\\t\\twriteFileSync( resolved, content );\\n\\n\\t\\tif ( !options.inline ) {\\n\\t\\t\\twriteFileSync( resolved + '.map', map.toString() );\\n\\t\\t}\\n\\t}\\n};\\n\\nfunction processWriteOptions ( dest, chain, options ) {\\n\\tconst resolved = resolve( dest );\\n\\n\\tconst map = chain.apply({\\n\\t\\tincludeContent: options.includeContent,\\n\\t\\tbase: options.base ? resolve( options.base ) : dirname( resolved )\\n\\t});\\n\\n\\tconst url = options.inline ? map.toUrl() : ( options.absolutePath ? resolved : basename( resolved ) ) + '.map';\\n\\n\\t// TODO shouldn't url be relative?\\n\\tconst content = chain.node.content.replace( SOURCEMAP_COMMENT, '' ) + sourcemapComment( url, resolved );\\n\\n\\treturn { resolved, content, map };\\n}\\n\\nfunction tally ( nodes, stat ) {\\n\\treturn nodes.reduce( ( total, node ) => {\\n\\t\\treturn total + node._stats[ stat ];\\n\\t}, 0 );\\n}\\n\\nfunction sourcemapComment ( url, dest ) {\\n\\tconst ext = extname( dest );\\n\\turl = encodeURI( url );\\n\\n\\tif ( ext === '.css' ) {\\n\\t\\treturn `\\\\n/*# ${SOURCEMAPPING_URL}=${url} */\\\\n`;\\n\\t}\\n\\n\\treturn `\\\\n//# ${SOURCEMAPPING_URL}=${url}\\\\n`;\\n}\\n\",\"import { resolve } from 'path';\\nimport Node from './Node.js';\\nimport Chain from './Chain.js';\\n\\nexport function load ( file, options ) {\\n\\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\\n\\n\\treturn node.load( sourcesContentByPath, sourceMapByPath )\\n\\t\\t.then( () => node.isOriginalSource ? null : new Chain( node, sourcesContentByPath ) );\\n}\\n\\nexport function loadSync ( file, options = {} ) {\\n\\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\\n\\n\\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\\n\\treturn node.isOriginalSource ? null : new Chain( node, sourcesContentByPath );\\n}\\n\\nfunction init ( file, options = {} ) {\\n\\tconst node = new Node({ file });\\n\\n\\tlet sourcesContentByPath = {};\\n\\tlet sourceMapByPath = {};\\n\\n\\tif ( options.content ) {\\n\\t\\tObject.keys( options.content ).forEach( key => {\\n\\t\\t\\tsourcesContentByPath[ resolve( key ) ] = options.content[ key ];\\n\\t\\t});\\n\\t}\\n\\n\\tif ( options.sourcemaps ) {\\n\\t\\tObject.keys( options.sourcemaps ).forEach( key => {\\n\\t\\t\\tsourceMapByPath[ resolve( key ) ] = options.sourcemaps[ key ];\\n\\t\\t});\\n\\t}\\n\\n\\treturn { node, sourcesContentByPath, sourceMapByPath };\\n}\\n\"],\"names\":[\"this\",\"let\",\"const\",\"SOURCEMAPPING_URL\",\"Promise\",\"resolve\",\"dirname\",\"readFileSync\",\"readFile\",\"sourceFileIndex\",\"sourceCodeLine\",\"nameIndex\",\"parent\",\"basename\",\"relative\",\"writeFile\",\"writeFileSync\",\"extname\"],\"mappings\":\"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\"}"}},"sorcery.es6.js":{"file":{"contents":"import { resolve, dirname, relative, basename, extname } from 'path';\nimport { readFileSync, Promise as Promise$1, readFile, writeFileSync, writeFile } from 'sander';\n\nvar __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;\nfunction __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }\n\nvar sourcemapCodec_umd = __commonjs(function (module, exports, global) {\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(__commonjs_global, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n});\n\nvar codec = (sourcemapCodec_umd && typeof sourcemapCodec_umd === 'object' && 'default' in sourcemapCodec_umd ? sourcemapCodec_umd['default'] : sourcemapCodec_umd);\n\n/**\n * Decodes a base64 string\n * @param {string} base64 - the string to decode\n * @returns {string}\n */\nfunction atob ( base64 ) {\n\treturn new Buffer( base64, 'base64' ).toString( 'utf8' );\n}\n\n// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nvar SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nvar SOURCEMAPPING_URL$1 = SOURCEMAPPING_URL;\n\nfunction parseJSON ( json, url ) {\n\ttry {\n\t\treturn JSON.parse( json );\n\t} catch ( err ) {\n\t\tthrow new Error( (\"Could not parse sourcemap (\" + url + \"): \" + (err.message)) );\n\t}\n}\n\n/**\n * Turns a sourceMappingURL into a sourcemap\n * @param {string} url - the sourceMappingURL. Can be a\n   base64-encoded data URI\n * @param {string} base - the URL against which relative URLS\n   should be resolved\n * @param {boolean} sync - if `true`, return a promise, otherwise\n   return the sourcemap\n * @returns {object} - a version 3 sourcemap\n */\nfunction getMapFromUrl ( url, base, sync ) {\n\tif ( /^data:/.test( url ) ) { // TODO beef this up\n\t\tvar match = /base64,(.+)$/.exec( url );\n\n\t\tif ( !match ) {\n\t\t\tthrow new Error( (SOURCEMAPPING_URL$1 + \" is not base64-encoded\") );\n\t\t}\n\n\t\tvar json = atob( match[1] );\n\t\tvar map = parseJSON( json, (\"data URI in \" + base) );\n\t\treturn sync ? map : Promise$1.resolve( map );\n\t}\n\n\turl = resolve( dirname( base ), decodeURI( url ) );\n\n\tif ( sync ) {\n\t\treturn parseJSON( readFileSync( url, { encoding: 'utf-8' }), url );\n\t} else {\n\t\treturn readFile( url, { encoding: 'utf-8' }).then( function (json) { return parseJSON( json, url ); } );\n\t}\n}\n\nfunction getSourceMappingUrl ( str ) {\n\tvar index, substring, url, match;\n\n\t// assume we want the last occurence\n\tindex = str.lastIndexOf( (SOURCEMAPPING_URL$1 + \"=\") );\n\n\tif ( index === -1 ) {\n\t\treturn null;\n\t}\n\n\tsubstring = str.substring( index + 17 );\n\tmatch = /^[^\\r\\n]+/.exec( substring );\n\n\turl = match ? match[0] : null;\n\n\t// possibly a better way to do this, but we don't want to exclude whitespace\n\t// from the sourceMappingURL because it might not have been correctly encoded\n\tif ( url && url.slice( -2 ) === '*/' ) {\n\t\turl = url.slice( 0, -2 ).trim();\n\t}\n\n\treturn url;\n}\n\nfunction getMap ( node, sourceMapByPath, sync ) {\n\tif ( node.file in sourceMapByPath ) {\n\t\tvar map = sourceMapByPath[ node.file ];\n\t\treturn sync ? map : Promise$1.resolve( map );\n\t}\n\n\telse {\n\t\tvar url = getSourceMappingUrl( node.content );\n\n\t\tif ( !url ) {\n\t\t\tnode.isOriginalSource = true;\n\t\t\treturn sync ? null : Promise$1.resolve( null );\n\t\t}\n\n\t\treturn getMapFromUrl( url, node.file, sync );\n\t}\n}\n\nfunction Node (ref) {\n\tvar file = ref.file;\n\tvar content = ref.content;\n\n\tthis.file = file ? resolve( file ) : null;\n\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\tif ( !this.file && this.content === null ) {\n\t\tthrow new Error( 'A source must specify either file or content' );\n\t}\n\n\t// these get filled in later\n\tthis.map = null;\n\tthis.mappings = null;\n\tthis.sources = null;\n\tthis.isOriginalSource = null;\n\n\tthis._stats = {\n\t\tdecodingTime: 0,\n\t\tencodingTime: 0,\n\t\ttracingTime: 0,\n\n\t\tuntraceable: 0\n\t};\n}\n\nNode.prototype = {\n\tload: function load ( sourcesContentByPath, sourceMapByPath ) {\n\t\tvar this$1 = this;\n\n\t\treturn getContent( this, sourcesContentByPath ).then( function (content) {\n\t\t\tthis$1.content = sourcesContentByPath[ this$1.file ] = content;\n\n\t\t\treturn getMap( this$1, sourceMapByPath ).then( function (map) {\n\t\t\t\tif ( !map ) return null;\n\n\t\t\t\tthis$1.map = map;\n\n\t\t\t\tvar decodingStart = process.hrtime();\n\t\t\t\tthis$1.mappings = codec.decode( map.mappings );\n\t\t\t\tvar decodingTime = process.hrtime( decodingStart );\n\t\t\t\tthis$1._stats.decodingTime = 1e9 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tvar sourcesContent = map.sourcesContent || [];\n\n\t\t\t\tvar sourceRoot = resolve( dirname( this$1.file ), map.sourceRoot || '' );\n\n\t\t\t\tthis$1.sources = map.sources.map( function ( source, i ) {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolve( sourceRoot, source ) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tvar promises = this$1.sources.map( function (node) { return node.load( sourcesContentByPath, sourceMapByPath ); } );\n\t\t\t\treturn Promise$1.all( promises );\n\t\t\t});\n\t\t});\n\t},\n\n\tloadSync: function loadSync ( sourcesContentByPath, sourceMapByPath ) {\n\t\tif ( !this.content ) {\n\t\t\tif ( !sourcesContentByPath[ this.file ] ) {\n\t\t\t\tsourcesContentByPath[ this.file ] = readFileSync( this.file, { encoding: 'utf-8' });\n\t\t\t}\n\n\t\t\tthis.content = sourcesContentByPath[ this.file ];\n\t\t}\n\n\t\tvar map = getMap( this, sourceMapByPath, true );\n\t\tvar sourcesContent;\n\n\t\tif ( !map ) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = codec.decode( map.mappings );\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tvar sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\n\n\t\t\tthis.sources = map.sources.map( function ( source, i ) {\n\t\t\t\tvar node = new Node({\n\t\t\t\t\tfile: resolve( sourceRoot, source ),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Traces a segment back to its origin\n\t * @param {number} lineIndex - the zero-based line index of the\n\t   segment as found in `this`\n\t * @param {number} columnIndex - the zero-based column index of the\n\t   segment as found in `this`\n\t * @param {string || null} - if specified, the name that should be\n\t   (eventually) returned, as it is closest to the generated code\n\t * @returns {object}\n\t     @property {string} source - the filepath of the source\n\t     @property {number} line - the one-based line index\n\t     @property {number} column - the zero-based column index\n\t     @property {string || null} name - the name corresponding\n\t     to the segment being traced\n\t */\n\ttrace: function trace ( lineIndex, columnIndex, name ) {\n\t\tvar this$1 = this;\n\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif ( this.isOriginalSource ) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tvar segments = this.mappings[ lineIndex ];\n\n\t\tif ( !segments || segments.length === 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( columnIndex != null ) {\n\t\t\tvar len = segments.length;\n\t\t\tvar i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tvar generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif ( generatedCodeColumn > columnIndex ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( generatedCodeColumn === columnIndex ) {\n\t\t\t\t\tif ( segments[i].length < 4 ) return null;\n\n\t\t\t\t\tvar sourceFileIndex$1 = segments[i][1];\n\t\t\t\t\tvar sourceCodeLine$1 = segments[i][2];\n\t\t\t\t\tvar sourceCodeColumn = segments[i][3];\n\t\t\t\t\tvar nameIndex$1 = segments[i][4];\n\n\t\t\t\t\tvar parent$1 = this$1.sources[ sourceFileIndex$1 ];\n\t\t\t\t\treturn parent$1.trace( sourceCodeLine$1, sourceCodeColumn, this$1.map.names[ nameIndex$1 ] || name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tvar sourceFileIndex = segments[0][1];\n\t\tvar sourceCodeLine = segments[0][2];\n\t\tvar nameIndex = segments[0][4];\n\n\t\tvar parent = this.sources[ sourceFileIndex ];\n\t\treturn parent.trace( sourceCodeLine, null, this.map.names[ nameIndex ] || name );\n\t}\n};\n\nfunction getContent ( node, sourcesContentByPath ) {\n\tif ( node.file in sourcesContentByPath ) {\n\t\tnode.content = sourcesContentByPath[ node.file ];\n\t}\n\n\tif ( !node.content ) {\n\t\treturn readFile( node.file, { encoding: 'utf-8' });\n\t}\n\n\treturn Promise$1.resolve( node.content );\n}\n\n/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nfunction btoa ( str ) {\n\treturn new Buffer( str ).toString( 'base64' );\n}\n\nfunction SourceMap ( properties ) {\n\tthis.version = 3;\n\n\tthis.file           = properties.file;\n\tthis.sources        = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names          = properties.names;\n\tthis.mappings       = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString: function toString () {\n\t\treturn JSON.stringify( this );\n\t},\n\n\ttoUrl: function toUrl () {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\n\t}\n};\n\nfunction slash ( path ) {\n\treturn typeof path === 'string' ?\n\t\tpath.replace( /\\\\/g, '/' ) :\n\t\tpath;\n}\n\nvar SOURCEMAP_COMMENT = new RegExp( \"\\n*(?:\" +\n\t\"\\\\/\\\\/[@#]\\\\s*\" + SOURCEMAPPING_URL$1 + \"=([^'\\\"]+)|\" +      // js\n\t\"\\\\/\\\\*#?\\\\s*\" + SOURCEMAPPING_URL$1 + \"=([^'\\\"]+)\\\\s\\\\*\\\\/)\" + // css\n'\\\\s*$', 'g' );\n\nfunction Chain ( node, sourcesContentByPath ) {\n\tthis.node = node;\n\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\tthis._stats = {};\n}\n\nChain.prototype = {\n\tstat: function stat () {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1e6,\n\t\t\ttotalDecodingTime: ( this._stats.decodingTime + tally( this.node.sources, 'decodingTime' ) ) / 1e6,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1e6,\n\t\t\ttracingTime: this._stats.tracingTime / 1e6,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t},\n\n\tapply: function apply ( options ) {\n\t\tvar this$1 = this;\n\t\tif ( options === void 0 ) options = {};\n\n\t\tvar allNames = [];\n\t\tvar allSources = [];\n\n\t\tvar applySegment = function ( segment, result ) {\n\t\t\tif ( segment.length < 4 ) return;\n\n\t\t\tvar traced = this$1.node.sources[ segment[1] ].trace( // source\n\t\t\t\tsegment[2], // source code line\n\t\t\t\tsegment[3], // source code column\n\t\t\t\tthis$1.node.map.names[ segment[4] ]\n\t\t\t);\n\n\t\t\tif ( !traced ) {\n\t\t\t\tthis$1._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar sourceIndex = allSources.indexOf( traced.source );\n\t\t\tif ( !~sourceIndex ) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push( traced.source );\n\t\t\t}\n\n\t\t\tvar newSegment = [\n\t\t\t\tsegment[0], // generated code column\n\t\t\t\tsourceIndex,\n\t\t\t\ttraced.line - 1,\n\t\t\t\ttraced.column\n\t\t\t];\n\n\t\t\tif ( traced.name ) {\n\t\t\t\tvar nameIndex = allNames.indexOf( traced.name );\n\t\t\t\tif ( !~nameIndex ) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push( traced.name );\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[ result.length ] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tvar tracingStart = process.hrtime();\n\n\t\tvar i = this.node.mappings.length;\n\t\tvar resolved = new Array( i );\n\n\t\tvar j, line, result;\n\n\t\twhile ( i-- ) {\n\t\t\tline = this$1.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor ( j = 0; j < line.length; j += 1 ) {\n\t\t\t\tapplySegment( line[j], result );\n\t\t\t}\n\t\t}\n\n\t\tvar tracingTime = process.hrtime( tracingStart );\n\t\tthis._stats.tracingTime = 1e9 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tvar encodingStart = process.hrtime();\n\t\tvar mappings = codec.encode( resolved );\n\t\tvar encodingTime = process.hrtime( encodingStart );\n\t\tthis._stats.encodingTime = 1e9 * encodingTime[0] + encodingTime[1];\n\n\t\tvar includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename( this.node.file ),\n\t\t\tsources: allSources.map( function (source) { return slash( relative( options.base || dirname( this$1.node.file ), source ) ); } ),\n\t\t\tsourcesContent: allSources.map( function (source) { return includeContent ? this$1.sourcesContentByPath[ source ] : null; } ),\n\t\t\tnames: allNames,\n\t\t\tmappings: mappings\n\t\t});\n\t},\n\n\ttrace: function trace ( oneBasedLineIndex, zeroBasedColumnIndex ) {\n\t\treturn this.node.trace( oneBasedLineIndex - 1, zeroBasedColumnIndex, null );\n\t},\n\n\twrite: function write ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tvar ref = processWriteOptions( dest, this, options );\n\t\tvar resolved = ref.resolved;\n\t\tvar content = ref.content;\n\t\tvar map = ref.map;\n\n\t\tvar promises = [ writeFile( resolved, content ) ];\n\n\t\tif ( !options.inline ) {\n\t\t\tpromises.push( writeFile( resolved + '.map', map.toString() ) );\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t},\n\n\twriteSync: function writeSync ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tvar ref = processWriteOptions( dest, this, options );\n\t\tvar resolved = ref.resolved;\n\t\tvar content = ref.content;\n\t\tvar map = ref.map;\n\n\t\twriteFileSync( resolved, content );\n\n\t\tif ( !options.inline ) {\n\t\t\twriteFileSync( resolved + '.map', map.toString() );\n\t\t}\n\t}\n};\n\nfunction processWriteOptions ( dest, chain, options ) {\n\tvar resolved = resolve( dest );\n\n\tvar map = chain.apply({\n\t\tincludeContent: options.includeContent,\n\t\tbase: options.base ? resolve( options.base ) : dirname( resolved )\n\t});\n\n\tvar url = options.inline ? map.toUrl() : ( options.absolutePath ? resolved : basename( resolved ) ) + '.map';\n\n\t// TODO shouldn't url be relative?\n\tvar content = chain.node.content.replace( SOURCEMAP_COMMENT, '' ) + sourcemapComment( url, resolved );\n\n\treturn { resolved: resolved, content: content, map: map };\n}\n\nfunction tally ( nodes, stat ) {\n\treturn nodes.reduce( function ( total, node ) {\n\t\treturn total + node._stats[ stat ];\n\t}, 0 );\n}\n\nfunction sourcemapComment ( url, dest ) {\n\tvar ext = extname( dest );\n\turl = encodeURI( url );\n\n\tif ( ext === '.css' ) {\n\t\treturn (\"\\n/*# \" + SOURCEMAPPING_URL$1 + \"=\" + url + \" */\\n\");\n\t}\n\n\treturn (\"\\n//# \" + SOURCEMAPPING_URL$1 + \"=\" + url + \"\\n\");\n}\n\nfunction load ( file, options ) {\n\tvar ref = init( file, options );\n\tvar node = ref.node;\n\tvar sourcesContentByPath = ref.sourcesContentByPath;\n\tvar sourceMapByPath = ref.sourceMapByPath;\n\n\treturn node.load( sourcesContentByPath, sourceMapByPath )\n\t\t.then( function () { return node.isOriginalSource ? null : new Chain( node, sourcesContentByPath ); } );\n}\n\nfunction loadSync ( file, options ) {\n\tif ( options === void 0 ) options = {};\n\n\tvar ref = init( file, options );\n\tvar node = ref.node;\n\tvar sourcesContentByPath = ref.sourcesContentByPath;\n\tvar sourceMapByPath = ref.sourceMapByPath;\n\n\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\treturn node.isOriginalSource ? null : new Chain( node, sourcesContentByPath );\n}\n\nfunction init ( file, options ) {\n\tif ( options === void 0 ) options = {};\n\n\tvar node = new Node({ file: file });\n\n\tvar sourcesContentByPath = {};\n\tvar sourceMapByPath = {};\n\n\tif ( options.content ) {\n\t\tObject.keys( options.content ).forEach( function (key) {\n\t\t\tsourcesContentByPath[ resolve( key ) ] = options.content[ key ];\n\t\t});\n\t}\n\n\tif ( options.sourcemaps ) {\n\t\tObject.keys( options.sourcemaps ).forEach( function (key) {\n\t\t\tsourceMapByPath[ resolve( key ) ] = options.sourcemaps[ key ];\n\t\t});\n\t}\n\n\treturn { node: node, sourcesContentByPath: sourcesContentByPath, sourceMapByPath: sourceMapByPath };\n}\n\nexport { load, loadSync };\n//# sourceMappingURL=sorcery.es6.js.map"}},"sorcery.es6.js.map":{"file":{"contents":"{\"version\":3,\"file\":null,\"sources\":[\"../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js\",\"../src/utils/atob.js\",\"../src/utils/sourceMappingURL.js\",\"../src/utils/getMapFromUrl.js\",\"../src/utils/getSourceMappingUrl.js\",\"../src/utils/getMap.js\",\"../src/Node.js\",\"../src/utils/btoa.js\",\"../src/SourceMap.js\",\"../src/utils/slash.js\",\"../src/Chain.js\",\"../src/index.js\"],\"sourcesContent\":[\"(function (global, factory) {\\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\\n})(this, (function (exports) { 'use strict';\\n\\n    const comma = ','.charCodeAt(0);\\n    const semicolon = ';'.charCodeAt(0);\\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    const intToChar = new Uint8Array(64); // 64 possible chars.\\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\\n    for (let i = 0; i < chars.length; i++) {\\n        const c = chars.charCodeAt(i);\\n        intToChar[i] = c;\\n        charToInt[c] = i;\\n    }\\n    // Provide a fallback for older environments.\\n    const td = typeof TextDecoder !== 'undefined'\\n        ? /* #__PURE__ */ new TextDecoder()\\n        : typeof Buffer !== 'undefined'\\n            ? {\\n                decode(buf) {\\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\\n                    return out.toString();\\n                },\\n            }\\n            : {\\n                decode(buf) {\\n                    let out = '';\\n                    for (let i = 0; i < buf.length; i++) {\\n                        out += String.fromCharCode(buf[i]);\\n                    }\\n                    return out;\\n                },\\n            };\\n    function decode(mappings) {\\n        const state = new Int32Array(5);\\n        const decoded = [];\\n        let index = 0;\\n        do {\\n            const semi = indexOf(mappings, index);\\n            const line = [];\\n            let sorted = true;\\n            let lastCol = 0;\\n            state[0] = 0;\\n            for (let i = index; i < semi; i++) {\\n                let seg;\\n                i = decodeInteger(mappings, i, state, 0); // genColumn\\n                const col = state[0];\\n                if (col < lastCol)\\n                    sorted = false;\\n                lastCol = col;\\n                if (hasMoreVlq(mappings, i, semi)) {\\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\\n                    if (hasMoreVlq(mappings, i, semi)) {\\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\\n                        seg = [col, state[1], state[2], state[3], state[4]];\\n                    }\\n                    else {\\n                        seg = [col, state[1], state[2], state[3]];\\n                    }\\n                }\\n                else {\\n                    seg = [col];\\n                }\\n                line.push(seg);\\n            }\\n            if (!sorted)\\n                sort(line);\\n            decoded.push(line);\\n            index = semi + 1;\\n        } while (index <= mappings.length);\\n        return decoded;\\n    }\\n    function indexOf(mappings, index) {\\n        const idx = mappings.indexOf(';', index);\\n        return idx === -1 ? mappings.length : idx;\\n    }\\n    function decodeInteger(mappings, pos, state, j) {\\n        let value = 0;\\n        let shift = 0;\\n        let integer = 0;\\n        do {\\n            const c = mappings.charCodeAt(pos++);\\n            integer = charToInt[c];\\n            value |= (integer & 31) << shift;\\n            shift += 5;\\n        } while (integer & 32);\\n        const shouldNegate = value & 1;\\n        value >>>= 1;\\n        if (shouldNegate) {\\n            value = -0x80000000 | -value;\\n        }\\n        state[j] += value;\\n        return pos;\\n    }\\n    function hasMoreVlq(mappings, i, length) {\\n        if (i >= length)\\n            return false;\\n        return mappings.charCodeAt(i) !== comma;\\n    }\\n    function sort(line) {\\n        line.sort(sortComparator);\\n    }\\n    function sortComparator(a, b) {\\n        return a[0] - b[0];\\n    }\\n    function encode(decoded) {\\n        const state = new Int32Array(5);\\n        const bufLength = 1024 * 16;\\n        const subLength = bufLength - 36;\\n        const buf = new Uint8Array(bufLength);\\n        const sub = buf.subarray(0, subLength);\\n        let pos = 0;\\n        let out = '';\\n        for (let i = 0; i < decoded.length; i++) {\\n            const line = decoded[i];\\n            if (i > 0) {\\n                if (pos === bufLength) {\\n                    out += td.decode(buf);\\n                    pos = 0;\\n                }\\n                buf[pos++] = semicolon;\\n            }\\n            if (line.length === 0)\\n                continue;\\n            state[0] = 0;\\n            for (let j = 0; j < line.length; j++) {\\n                const segment = line[j];\\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\\n                // may push a comma.\\n                if (pos > subLength) {\\n                    out += td.decode(sub);\\n                    buf.copyWithin(0, subLength, pos);\\n                    pos -= subLength;\\n                }\\n                if (j > 0)\\n                    buf[pos++] = comma;\\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\\n                if (segment.length === 1)\\n                    continue;\\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\\n                if (segment.length === 4)\\n                    continue;\\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\\n            }\\n        }\\n        return out + td.decode(buf.subarray(0, pos));\\n    }\\n    function encodeInteger(buf, pos, state, segment, j) {\\n        const next = segment[j];\\n        let num = next - state[j];\\n        state[j] = next;\\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\\n        do {\\n            let clamped = num & 0b011111;\\n            num >>>= 5;\\n            if (num > 0)\\n                clamped |= 0b100000;\\n            buf[pos++] = intToChar[clamped];\\n        } while (num > 0);\\n        return pos;\\n    }\\n\\n    exports.decode = decode;\\n    exports.encode = encode;\\n\\n    Object.defineProperty(exports, '__esModule', { value: true });\\n\\n}));\\n//# sourceMappingURL=sourcemap-codec.umd.js.map\\n\",\"/**\\n * Decodes a base64 string\\n * @param {string} base64 - the string to decode\\n * @returns {string}\\n */\\nexport default function atob ( base64 ) {\\n\\treturn new Buffer( base64, 'base64' ).toString( 'utf8' );\\n}\",\"// this looks ridiculous, but it prevents sourcemap tooling from mistaking\\n// this for an actual sourceMappingURL\\nlet SOURCEMAPPING_URL = 'sourceMa';\\nSOURCEMAPPING_URL += 'ppingURL';\\n\\nexport default SOURCEMAPPING_URL;\\n\",\"import { dirname, resolve } from 'path';\\nimport { readFile, readFileSync, Promise } from 'sander';\\nimport atob from './atob.js';\\nimport SOURCEMAPPING_URL from './sourceMappingURL.js';\\n\\nfunction parseJSON ( json, url ) {\\n\\ttry {\\n\\t\\treturn JSON.parse( json );\\n\\t} catch ( err ) {\\n\\t\\tthrow new Error( `Could not parse sourcemap (${url}): ${err.message}` );\\n\\t}\\n}\\n\\n/**\\n * Turns a sourceMappingURL into a sourcemap\\n * @param {string} url - the sourceMappingURL. Can be a\\n   base64-encoded data URI\\n * @param {string} base - the URL against which relative URLS\\n   should be resolved\\n * @param {boolean} sync - if `true`, return a promise, otherwise\\n   return the sourcemap\\n * @returns {object} - a version 3 sourcemap\\n */\\nexport default function getMapFromUrl ( url, base, sync ) {\\n\\tif ( /^data:/.test( url ) ) { // TODO beef this up\\n\\t\\tconst match = /base64,(.+)$/.exec( url );\\n\\n\\t\\tif ( !match ) {\\n\\t\\t\\tthrow new Error( `${SOURCEMAPPING_URL} is not base64-encoded` );\\n\\t\\t}\\n\\n\\t\\tconst json = atob( match[1] );\\n\\t\\tconst map = parseJSON( json, `data URI in ${base}` );\\n\\t\\treturn sync ? map : Promise.resolve( map );\\n\\t}\\n\\n\\turl = resolve( dirname( base ), decodeURI( url ) );\\n\\n\\tif ( sync ) {\\n\\t\\treturn parseJSON( readFileSync( url, { encoding: 'utf-8' }), url );\\n\\t} else {\\n\\t\\treturn readFile( url, { encoding: 'utf-8' }).then( json => parseJSON( json, url ) );\\n\\t}\\n}\\n\",\"import SOURCEMAPPING_URL from './sourceMappingURL.js';\\n\\nexport default function getSourceMappingUrl ( str ) {\\n\\tvar index, substring, url, match;\\n\\n\\t// assume we want the last occurence\\n\\tindex = str.lastIndexOf( `${SOURCEMAPPING_URL}=` );\\n\\n\\tif ( index === -1 ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tsubstring = str.substring( index + 17 );\\n\\tmatch = /^[^\\\\r\\\\n]+/.exec( substring );\\n\\n\\turl = match ? match[0] : null;\\n\\n\\t// possibly a better way to do this, but we don't want to exclude whitespace\\n\\t// from the sourceMappingURL because it might not have been correctly encoded\\n\\tif ( url && url.slice( -2 ) === '*/' ) {\\n\\t\\turl = url.slice( 0, -2 ).trim();\\n\\t}\\n\\n\\treturn url;\\n}\\n\",\"import { Promise } from 'sander';\\nimport getMapFromUrl from './getMapFromUrl.js';\\nimport getSourceMappingUrl from './getSourceMappingUrl.js';\\n\\nexport default function getMap ( node, sourceMapByPath, sync ) {\\n\\tif ( node.file in sourceMapByPath ) {\\n\\t\\tconst map = sourceMapByPath[ node.file ];\\n\\t\\treturn sync ? map : Promise.resolve( map );\\n\\t}\\n\\n\\telse {\\n\\t\\tconst url = getSourceMappingUrl( node.content );\\n\\n\\t\\tif ( !url ) {\\n\\t\\t\\tnode.isOriginalSource = true;\\n\\t\\t\\treturn sync ? null : Promise.resolve( null );\\n\\t\\t}\\n\\n\\t\\treturn getMapFromUrl( url, node.file, sync );\\n\\t}\\n}\\n\",\"import { dirname, resolve } from 'path';\\nimport { readFile, readFileSync, Promise } from 'sander';\\nimport codec from '@jridgewell/sourcemap-codec';\\nimport getMap from './utils/getMap.js';\\n\\nexport default function Node ({ file, content }) {\\n\\tthis.file = file ? resolve( file ) : null;\\n\\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\\n\\n\\tif ( !this.file && this.content === null ) {\\n\\t\\tthrow new Error( 'A source must specify either file or content' );\\n\\t}\\n\\n\\t// these get filled in later\\n\\tthis.map = null;\\n\\tthis.mappings = null;\\n\\tthis.sources = null;\\n\\tthis.isOriginalSource = null;\\n\\n\\tthis._stats = {\\n\\t\\tdecodingTime: 0,\\n\\t\\tencodingTime: 0,\\n\\t\\ttracingTime: 0,\\n\\n\\t\\tuntraceable: 0\\n\\t};\\n}\\n\\nNode.prototype = {\\n\\tload ( sourcesContentByPath, sourceMapByPath ) {\\n\\t\\treturn getContent( this, sourcesContentByPath ).then( content => {\\n\\t\\t\\tthis.content = sourcesContentByPath[ this.file ] = content;\\n\\n\\t\\t\\treturn getMap( this, sourceMapByPath ).then( map => {\\n\\t\\t\\t\\tif ( !map ) return null;\\n\\n\\t\\t\\t\\tthis.map = map;\\n\\n\\t\\t\\t\\tlet decodingStart = process.hrtime();\\n\\t\\t\\t\\tthis.mappings = codec.decode( map.mappings );\\n\\t\\t\\t\\tlet decodingTime = process.hrtime( decodingStart );\\n\\t\\t\\t\\tthis._stats.decodingTime = 1e9 * decodingTime[0] + decodingTime[1];\\n\\n\\t\\t\\t\\tconst sourcesContent = map.sourcesContent || [];\\n\\n\\t\\t\\t\\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\\n\\n\\t\\t\\t\\tthis.sources = map.sources.map( ( source, i ) => {\\n\\t\\t\\t\\t\\treturn new Node({\\n\\t\\t\\t\\t\\t\\tfile: source ? resolve( sourceRoot, source ) : null,\\n\\t\\t\\t\\t\\t\\tcontent: sourcesContent[i]\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tconst promises = this.sources.map( node => node.load( sourcesContentByPath, sourceMapByPath ) );\\n\\t\\t\\t\\treturn Promise.all( promises );\\n\\t\\t\\t});\\n\\t\\t});\\n\\t},\\n\\n\\tloadSync ( sourcesContentByPath, sourceMapByPath ) {\\n\\t\\tif ( !this.content ) {\\n\\t\\t\\tif ( !sourcesContentByPath[ this.file ] ) {\\n\\t\\t\\t\\tsourcesContentByPath[ this.file ] = readFileSync( this.file, { encoding: 'utf-8' });\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.content = sourcesContentByPath[ this.file ];\\n\\t\\t}\\n\\n\\t\\tconst map = getMap( this, sourceMapByPath, true );\\n\\t\\tlet sourcesContent;\\n\\n\\t\\tif ( !map ) {\\n\\t\\t\\tthis.isOriginalSource = true;\\n\\t\\t} else {\\n\\t\\t\\tthis.map = map;\\n\\t\\t\\tthis.mappings = codec.decode( map.mappings );\\n\\n\\t\\t\\tsourcesContent = map.sourcesContent || [];\\n\\n\\t\\t\\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\\n\\n\\t\\t\\tthis.sources = map.sources.map( ( source, i ) => {\\n\\t\\t\\t\\tconst node = new Node({\\n\\t\\t\\t\\t\\tfile: resolve( sourceRoot, source ),\\n\\t\\t\\t\\t\\tcontent: sourcesContent[i]\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\\n\\t\\t\\t\\treturn node;\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t/**\\n\\t * Traces a segment back to its origin\\n\\t * @param {number} lineIndex - the zero-based line index of the\\n\\t   segment as found in `this`\\n\\t * @param {number} columnIndex - the zero-based column index of the\\n\\t   segment as found in `this`\\n\\t * @param {string || null} - if specified, the name that should be\\n\\t   (eventually) returned, as it is closest to the generated code\\n\\t * @returns {object}\\n\\t     @property {string} source - the filepath of the source\\n\\t     @property {number} line - the one-based line index\\n\\t     @property {number} column - the zero-based column index\\n\\t     @property {string || null} name - the name corresponding\\n\\t     to the segment being traced\\n\\t */\\n\\ttrace ( lineIndex, columnIndex, name ) {\\n\\t\\t// If this node doesn't have a source map, we have\\n\\t\\t// to assume it is the original source\\n\\t\\tif ( this.isOriginalSource ) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tsource: this.file,\\n\\t\\t\\t\\tline: lineIndex + 1,\\n\\t\\t\\t\\tcolumn: columnIndex || 0,\\n\\t\\t\\t\\tname: name\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to figure out what this position in\\n\\t\\t// the intermediate file corresponds to in *its* source\\n\\t\\tconst segments = this.mappings[ lineIndex ];\\n\\n\\t\\tif ( !segments || segments.length === 0 ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tif ( columnIndex != null ) {\\n\\t\\t\\tlet len = segments.length;\\n\\t\\t\\tlet i;\\n\\n\\t\\t\\tfor ( i = 0; i < len; i += 1 ) {\\n\\t\\t\\t\\tlet generatedCodeColumn = segments[i][0];\\n\\n\\t\\t\\t\\tif ( generatedCodeColumn > columnIndex ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( generatedCodeColumn === columnIndex ) {\\n\\t\\t\\t\\t\\tif ( segments[i].length < 4 ) return null;\\n\\n\\t\\t\\t\\t\\tlet sourceFileIndex = segments[i][1];\\n\\t\\t\\t\\t\\tlet sourceCodeLine = segments[i][2];\\n\\t\\t\\t\\t\\tlet sourceCodeColumn = segments[i][3];\\n\\t\\t\\t\\t\\tlet nameIndex = segments[i][4];\\n\\n\\t\\t\\t\\t\\tlet parent = this.sources[ sourceFileIndex ];\\n\\t\\t\\t\\t\\treturn parent.trace( sourceCodeLine, sourceCodeColumn, this.map.names[ nameIndex ] || name );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// fall back to a line mapping\\n\\t\\tlet sourceFileIndex = segments[0][1];\\n\\t\\tlet sourceCodeLine = segments[0][2];\\n\\t\\tlet nameIndex = segments[0][4];\\n\\n\\t\\tlet parent = this.sources[ sourceFileIndex ];\\n\\t\\treturn parent.trace( sourceCodeLine, null, this.map.names[ nameIndex ] || name );\\n\\t}\\n};\\n\\nfunction getContent ( node, sourcesContentByPath ) {\\n\\tif ( node.file in sourcesContentByPath ) {\\n\\t\\tnode.content = sourcesContentByPath[ node.file ];\\n\\t}\\n\\n\\tif ( !node.content ) {\\n\\t\\treturn readFile( node.file, { encoding: 'utf-8' });\\n\\t}\\n\\n\\treturn Promise.resolve( node.content );\\n}\\n\",\"/**\\n * Encodes a string as base64\\n * @param {string} str - the string to encode\\n * @returns {string}\\n */\\nexport default function btoa ( str ) {\\n\\treturn new Buffer( str ).toString( 'base64' );\\n}\",\"import btoa from './utils/btoa.js';\\n\\nexport default function SourceMap ( properties ) {\\n\\tthis.version = 3;\\n\\n\\tthis.file           = properties.file;\\n\\tthis.sources        = properties.sources;\\n\\tthis.sourcesContent = properties.sourcesContent;\\n\\tthis.names          = properties.names;\\n\\tthis.mappings       = properties.mappings;\\n}\\n\\nSourceMap.prototype = {\\n\\ttoString () {\\n\\t\\treturn JSON.stringify( this );\\n\\t},\\n\\n\\ttoUrl () {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\\n\\t}\\n};\\n\",\"export default function slash ( path ) {\\n\\treturn typeof path === 'string' ?\\n\\t\\tpath.replace( /\\\\\\\\/g, '/' ) :\\n\\t\\tpath;\\n}\\n\",\"import { basename, dirname, extname, relative, resolve } from 'path';\\nimport { writeFile, writeFileSync } from 'sander';\\nimport codec from '@jridgewell/sourcemap-codec';\\nimport SourceMap from './SourceMap.js';\\nimport slash from './utils/slash.js';\\nimport SOURCEMAPPING_URL from './utils/sourceMappingURL.js';\\n\\nconst SOURCEMAP_COMMENT = new RegExp( `\\\\n*(?:` +\\n\\t`\\\\\\\\/\\\\\\\\/[@#]\\\\\\\\s*${SOURCEMAPPING_URL}=([^'\\\"]+)|` +      // js\\n\\t`\\\\\\\\/\\\\\\\\*#?\\\\\\\\s*${SOURCEMAPPING_URL}=([^'\\\"]+)\\\\\\\\s\\\\\\\\*\\\\\\\\/)` + // css\\n'\\\\\\\\s*$', 'g' );\\n\\nexport default function Chain ( node, sourcesContentByPath ) {\\n\\tthis.node = node;\\n\\tthis.sourcesContentByPath = sourcesContentByPath;\\n\\n\\tthis._stats = {};\\n}\\n\\nChain.prototype = {\\n\\tstat () {\\n\\t\\treturn {\\n\\t\\t\\tselfDecodingTime: this._stats.decodingTime / 1e6,\\n\\t\\t\\ttotalDecodingTime: ( this._stats.decodingTime + tally( this.node.sources, 'decodingTime' ) ) / 1e6,\\n\\n\\t\\t\\tencodingTime: this._stats.encodingTime / 1e6,\\n\\t\\t\\ttracingTime: this._stats.tracingTime / 1e6,\\n\\n\\t\\t\\tuntraceable: this._stats.untraceable\\n\\t\\t};\\n\\t},\\n\\n\\tapply ( options = {} ) {\\n\\t\\tlet allNames = [];\\n\\t\\tlet allSources = [];\\n\\n\\t\\tconst applySegment = ( segment, result ) => {\\n\\t\\t\\tif ( segment.length < 4 ) return;\\n\\n\\t\\t\\tconst traced = this.node.sources[ segment[1] ].trace( // source\\n\\t\\t\\t\\tsegment[2], // source code line\\n\\t\\t\\t\\tsegment[3], // source code column\\n\\t\\t\\t\\tthis.node.map.names[ segment[4] ]\\n\\t\\t\\t);\\n\\n\\t\\t\\tif ( !traced ) {\\n\\t\\t\\t\\tthis._stats.untraceable += 1;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet sourceIndex = allSources.indexOf( traced.source );\\n\\t\\t\\tif ( !~sourceIndex ) {\\n\\t\\t\\t\\tsourceIndex = allSources.length;\\n\\t\\t\\t\\tallSources.push( traced.source );\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet newSegment = [\\n\\t\\t\\t\\tsegment[0], // generated code column\\n\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\ttraced.line - 1,\\n\\t\\t\\t\\ttraced.column\\n\\t\\t\\t];\\n\\n\\t\\t\\tif ( traced.name ) {\\n\\t\\t\\t\\tlet nameIndex = allNames.indexOf( traced.name );\\n\\t\\t\\t\\tif ( !~nameIndex ) {\\n\\t\\t\\t\\t\\tnameIndex = allNames.length;\\n\\t\\t\\t\\t\\tallNames.push( traced.name );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnewSegment[4] = nameIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult[ result.length ] = newSegment;\\n\\t\\t};\\n\\n\\t\\t// Trace mappings\\n\\t\\tlet tracingStart = process.hrtime();\\n\\n\\t\\tlet i = this.node.mappings.length;\\n\\t\\tlet resolved = new Array( i );\\n\\n\\t\\tlet j, line, result;\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tline = this.node.mappings[i];\\n\\t\\t\\tresolved[i] = result = [];\\n\\n\\t\\t\\tfor ( j = 0; j < line.length; j += 1 ) {\\n\\t\\t\\t\\tapplySegment( line[j], result );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet tracingTime = process.hrtime( tracingStart );\\n\\t\\tthis._stats.tracingTime = 1e9 * tracingTime[0] + tracingTime[1];\\n\\n\\t\\t// Encode mappings\\n\\t\\tlet encodingStart = process.hrtime();\\n\\t\\tlet mappings = codec.encode( resolved );\\n\\t\\tlet encodingTime = process.hrtime( encodingStart );\\n\\t\\tthis._stats.encodingTime = 1e9 * encodingTime[0] + encodingTime[1];\\n\\n\\t\\tlet includeContent = options.includeContent !== false;\\n\\n\\t\\treturn new SourceMap({\\n\\t\\t\\tfile: basename( this.node.file ),\\n\\t\\t\\tsources: allSources.map( source => slash( relative( options.base || dirname( this.node.file ), source ) ) ),\\n\\t\\t\\tsourcesContent: allSources.map( source => includeContent ? this.sourcesContentByPath[ source ] : null ),\\n\\t\\t\\tnames: allNames,\\n\\t\\t\\tmappings\\n\\t\\t});\\n\\t},\\n\\n\\ttrace ( oneBasedLineIndex, zeroBasedColumnIndex ) {\\n\\t\\treturn this.node.trace( oneBasedLineIndex - 1, zeroBasedColumnIndex, null );\\n\\t},\\n\\n\\twrite ( dest, options ) {\\n\\t\\tif ( typeof dest !== 'string' ) {\\n\\t\\t\\toptions = dest;\\n\\t\\t\\tdest = this.node.file;\\n\\t\\t}\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\\n\\n\\t\\tlet promises = [ writeFile( resolved, content ) ];\\n\\n\\t\\tif ( !options.inline ) {\\n\\t\\t\\tpromises.push( writeFile( resolved + '.map', map.toString() ) );\\n\\t\\t}\\n\\n\\t\\treturn Promise.all( promises );\\n\\t},\\n\\n\\twriteSync ( dest, options ) {\\n\\t\\tif ( typeof dest !== 'string' ) {\\n\\t\\t\\toptions = dest;\\n\\t\\t\\tdest = this.node.file;\\n\\t\\t}\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\\n\\n\\t\\twriteFileSync( resolved, content );\\n\\n\\t\\tif ( !options.inline ) {\\n\\t\\t\\twriteFileSync( resolved + '.map', map.toString() );\\n\\t\\t}\\n\\t}\\n};\\n\\nfunction processWriteOptions ( dest, chain, options ) {\\n\\tconst resolved = resolve( dest );\\n\\n\\tconst map = chain.apply({\\n\\t\\tincludeContent: options.includeContent,\\n\\t\\tbase: options.base ? resolve( options.base ) : dirname( resolved )\\n\\t});\\n\\n\\tconst url = options.inline ? map.toUrl() : ( options.absolutePath ? resolved : basename( resolved ) ) + '.map';\\n\\n\\t// TODO shouldn't url be relative?\\n\\tconst content = chain.node.content.replace( SOURCEMAP_COMMENT, '' ) + sourcemapComment( url, resolved );\\n\\n\\treturn { resolved, content, map };\\n}\\n\\nfunction tally ( nodes, stat ) {\\n\\treturn nodes.reduce( ( total, node ) => {\\n\\t\\treturn total + node._stats[ stat ];\\n\\t}, 0 );\\n}\\n\\nfunction sourcemapComment ( url, dest ) {\\n\\tconst ext = extname( dest );\\n\\turl = encodeURI( url );\\n\\n\\tif ( ext === '.css' ) {\\n\\t\\treturn `\\\\n/*# ${SOURCEMAPPING_URL}=${url} */\\\\n`;\\n\\t}\\n\\n\\treturn `\\\\n//# ${SOURCEMAPPING_URL}=${url}\\\\n`;\\n}\\n\",\"import { resolve } from 'path';\\nimport Node from './Node.js';\\nimport Chain from './Chain.js';\\n\\nexport function load ( file, options ) {\\n\\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\\n\\n\\treturn node.load( sourcesContentByPath, sourceMapByPath )\\n\\t\\t.then( () => node.isOriginalSource ? null : new Chain( node, sourcesContentByPath ) );\\n}\\n\\nexport function loadSync ( file, options = {} ) {\\n\\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\\n\\n\\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\\n\\treturn node.isOriginalSource ? null : new Chain( node, sourcesContentByPath );\\n}\\n\\nfunction init ( file, options = {} ) {\\n\\tconst node = new Node({ file });\\n\\n\\tlet sourcesContentByPath = {};\\n\\tlet sourceMapByPath = {};\\n\\n\\tif ( options.content ) {\\n\\t\\tObject.keys( options.content ).forEach( key => {\\n\\t\\t\\tsourcesContentByPath[ resolve( key ) ] = options.content[ key ];\\n\\t\\t});\\n\\t}\\n\\n\\tif ( options.sourcemaps ) {\\n\\t\\tObject.keys( options.sourcemaps ).forEach( key => {\\n\\t\\t\\tsourceMapByPath[ resolve( key ) ] = options.sourcemaps[ key ];\\n\\t\\t});\\n\\t}\\n\\n\\treturn { node, sourcesContentByPath, sourceMapByPath };\\n}\\n\"],\"names\":[\"this\",\"let\",\"const\",\"SOURCEMAPPING_URL\",\"Promise\",\"sourceFileIndex\",\"sourceCodeLine\",\"nameIndex\",\"parent\"],\"mappings\":\";;;;;;;AAAA,CAAC,UAAU,MAAM,EAAE,OAAO,EAAE;IACxB,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC;IAC/E,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,SAAS,CAAC,EAAE,OAAO,CAAC;KACxE,MAAM,GAAG,OAAO,UAAU,KAAK,WAAW,GAAG,UAAU,GAAG,MAAM,IAAI,IAAI,EAAE,OAAO,CAAC,MAAM,CAAC,cAAc,GAAG,EAAE,CAAC,CAAC,CAAC;CACnH,EAAEA,iBAAI,GAAG,UAAU,OAAO,EAAE,EAAE,YAAY,CAAC;;IAExC,MAAM,KAAK,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IAChC,MAAM,SAAS,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACpC,MAAM,KAAK,GAAG,kEAAkE,CAAC;IACjF,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;IACrC,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;IACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,MAAM,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAC9B,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QACjB,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KACpB;;IAED,MAAM,EAAE,GAAG,OAAO,WAAW,KAAK,WAAW;0BACvB,IAAI,WAAW,EAAE;UACjC,OAAO,MAAM,KAAK,WAAW;cACzB;gBACE,MAAM,CAAC,GAAG,EAAE;oBACR,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;oBACpE,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;iBACzB;aACJ;cACC;gBACE,MAAM,CAAC,GAAG,EAAE;oBACR,IAAI,GAAG,GAAG,EAAE,CAAC;oBACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBACjC,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;qBACtC;oBACD,OAAO,GAAG,CAAC;iBACd;aACJ,CAAC;IACV,SAAS,MAAM,CAAC,QAAQ,EAAE;QACtB,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,OAAO,GAAG,EAAE,CAAC;QACnB,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,GAAG;YACC,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YACtC,MAAM,IAAI,GAAG,EAAE,CAAC;YAChB,IAAI,MAAM,GAAG,IAAI,CAAC;YAClB,IAAI,OAAO,GAAG,CAAC,CAAC;YAChB,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACb,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;gBAC/B,IAAI,GAAG,CAAC;gBACR,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;gBACzC,MAAM,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,GAAG,GAAG,OAAO;oBACb,MAAM,GAAG,KAAK,CAAC;gBACnB,OAAO,GAAG,GAAG,CAAC;gBACd,IAAI,UAAU,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;oBAC/B,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;oBACzC,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;oBACzC,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;oBACzC,IAAI,UAAU,CAAC,QAAQ,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;wBAC/B,CAAC,GAAG,aAAa,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;wBACzC,GAAG,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;qBACvD;yBACI;wBACD,GAAG,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC7C;iBACJ;qBACI;oBACD,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;iBACf;gBACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aAClB;YACD,IAAI,CAAC,MAAM;gBACP,IAAI,CAAC,IAAI,CAAC,CAAC;YACf,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACnB,KAAK,GAAG,IAAI,GAAG,CAAC,CAAC;SACpB,QAAQ,KAAK,IAAI,QAAQ,CAAC,MAAM,EAAE;QACnC,OAAO,OAAO,CAAC;KAClB;IACD,SAAS,OAAO,CAAC,QAAQ,EAAE,KAAK,EAAE;QAC9B,MAAM,GAAG,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACzC,OAAO,GAAG,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,GAAG,CAAC;KAC7C;IACD,SAAS,aAAa,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE;QAC5C,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,GAAG;YACC,MAAM,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC;YACrC,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACvB,KAAK,IAAI,CAAC,OAAO,GAAG,EAAE,KAAK,KAAK,CAAC;YACjC,KAAK,IAAI,CAAC,CAAC;SACd,QAAQ,OAAO,GAAG,EAAE,EAAE;QACvB,MAAM,YAAY,GAAG,KAAK,GAAG,CAAC,CAAC;QAC/B,KAAK,MAAM,CAAC,CAAC;QACb,IAAI,YAAY,EAAE;YACd,KAAK,GAAG,CAAC,UAAU,GAAG,CAAC,KAAK,CAAC;SAChC;QACD,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;QAClB,OAAO,GAAG,CAAC;KACd;IACD,SAAS,UAAU,CAAC,QAAQ,EAAE,CAAC,EAAE,MAAM,EAAE;QACrC,IAAI,CAAC,IAAI,MAAM;YACX,OAAO,KAAK,CAAC;QACjB,OAAO,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC;KAC3C;IACD,SAAS,IAAI,CAAC,IAAI,EAAE;QAChB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;KAC7B;IACD,SAAS,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE;QAC1B,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;KACtB;IACD,SAAS,MAAM,CAAC,OAAO,EAAE;QACrB,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;QAC5B,MAAM,SAAS,GAAG,SAAS,GAAG,EAAE,CAAC;QACjC,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;QACtC,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QACvC,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,IAAI,GAAG,GAAG,EAAE,CAAC;QACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,GAAG,CAAC,EAAE;gBACP,IAAI,GAAG,KAAK,SAAS,EAAE;oBACnB,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;oBACtB,GAAG,GAAG,CAAC,CAAC;iBACX;gBACD,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC;aAC1B;YACD,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;gBACjB,SAAS;YACb,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAClC,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;;;gBAGxB,IAAI,GAAG,GAAG,SAAS,EAAE;oBACjB,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;oBACtB,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;oBAClC,GAAG,IAAI,SAAS,CAAC;iBACpB;gBACD,IAAI,CAAC,GAAG,CAAC;oBACL,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK,CAAC;gBACvB,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;gBACjD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;oBACpB,SAAS;gBACb,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;gBACjD,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;gBACjD,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;gBACjD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;oBACpB,SAAS;gBACb,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;aACpD;SACJ;QACD,OAAO,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;KAChD;IACD,SAAS,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,EAAE;QAChD,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QACxB,IAAI,GAAG,GAAG,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAC1B,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAChB,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;QAC3C,GAAG;YACC,IAAI,OAAO,GAAG,GAAG,GAAG,QAAQ,CAAC;YAC7B,GAAG,MAAM,CAAC,CAAC;YACX,IAAI,GAAG,GAAG,CAAC;gBACP,OAAO,IAAI,QAAQ,CAAC;YACxB,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;SACnC,QAAQ,GAAG,GAAG,CAAC,EAAE;QAClB,OAAO,GAAG,CAAC;KACd;;IAED,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;IACxB,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;;IAExB,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;;CAEjE,EAAE,CAAC;;;;;AC7KJ;;;;;AAKA,AAAe,SAAS,IAAI,GAAG,MAAM,GAAG;CACvC,OAAO,IAAI,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,CAAC;;;ACN1D;;AAEAC,IAAI,iBAAiB,GAAG,UAAU,CAAC;AACnC,iBAAiB,IAAI,UAAU,CAAC;;AAEhC,0BAAe,iBAAiB,CAAC;;ACAjC,SAAS,SAAS,GAAG,IAAI,EAAE,GAAG,GAAG;CAChC,IAAI;EACH,OAAO,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC;EAC1B,CAAC,QAAQ,GAAG,GAAG;EACf,MAAM,IAAI,KAAK,EAAE,CAAA,6BAA4B,GAAE,GAAG,QAAI,IAAE,GAAG,CAAC,OAAO,CAAA,CAAE,EAAE,CAAC;EACxE;CACD;;;;;;;;;;;;AAYD,AAAe,SAAS,aAAa,GAAG,GAAG,EAAE,IAAI,EAAE,IAAI,GAAG;CACzD,KAAK,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG;EAC3BC,IAAM,KAAK,GAAG,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC;;EAEzC,KAAK,CAAC,KAAK,GAAG;GACb,MAAM,IAAI,KAAK,EAAE,CAAAC,mBAAoB,2BAAuB,CAAC,EAAE,CAAC;GAChE;;EAEDD,IAAM,IAAI,GAAG,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;EAC9BA,IAAM,GAAG,GAAG,SAAS,EAAE,IAAI,EAAE,CAAA,cAAa,GAAE,IAAI,CAAE,EAAE,CAAC;EACrD,OAAO,IAAI,GAAG,GAAG,GAAGE,SAAO,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC;EAC3C;;CAED,GAAG,GAAG,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;;CAEnD,KAAK,IAAI,GAAG;EACX,OAAO,SAAS,EAAE,YAAY,EAAE,GAAG,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC;EACnE,MAAM;EACN,OAAO,QAAQ,EAAE,GAAG,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,IAAI,EAAE,UAAA,IAAI,EAAC,SAAG,SAAS,EAAE,IAAI,EAAE,GAAG,EAAE,GAAA,EAAE,CAAC;EACpF;CACD;;ACzCc,SAAS,mBAAmB,GAAG,GAAG,GAAG;CACnD,IAAI,KAAK,EAAE,SAAS,EAAE,GAAG,EAAE,KAAK,CAAC;;;CAGjC,KAAK,GAAG,GAAG,CAAC,WAAW,EAAE,CAAAD,mBAAoB,MAAE,CAAC,EAAE,CAAC;;CAEnD,KAAK,KAAK,KAAK,CAAC,CAAC,GAAG;EACnB,OAAO,IAAI,CAAC;EACZ;;CAED,SAAS,GAAG,GAAG,CAAC,SAAS,EAAE,KAAK,GAAG,EAAE,EAAE,CAAC;CACxC,KAAK,GAAG,WAAW,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC;;CAEtC,GAAG,GAAG,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;;;;CAI9B,KAAK,GAAG,IAAI,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,KAAK,IAAI,GAAG;EACtC,GAAG,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;EAChC;;CAED,OAAO,GAAG,CAAC;CACX;;ACpBc,SAAS,MAAM,GAAG,IAAI,EAAE,eAAe,EAAE,IAAI,GAAG;CAC9D,KAAK,IAAI,CAAC,IAAI,IAAI,eAAe,GAAG;EACnCD,IAAM,GAAG,GAAG,eAAe,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;EACzC,OAAO,IAAI,GAAG,GAAG,GAAGE,SAAO,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC;EAC3C;;MAEI;EACJF,IAAM,GAAG,GAAG,mBAAmB,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;;EAEhD,KAAK,CAAC,GAAG,GAAG;GACX,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;GAC7B,OAAO,IAAI,GAAG,IAAI,GAAGE,SAAO,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC;GAC7C;;EAED,OAAO,aAAa,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC;EAC7C;CACD;;ACfc,SAAS,IAAI,EAAE,GAAA,EAAmB;KAAjB,IAAI,YAAE;KAAA,OAAO;;CAC5C,IAAI,CAAC,IAAI,GAAG,IAAI,GAAG,OAAO,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;CAC1C,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,IAAI,CAAC;;CAE/B,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,GAAG;EAC1C,MAAM,IAAI,KAAK,EAAE,8CAA8C,EAAE,CAAC;EAClE;;;CAGD,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC;CAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;CACrB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;CACpB,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;;CAE7B,IAAI,CAAC,MAAM,GAAG;EACb,YAAY,EAAE,CAAC;EACf,YAAY,EAAE,CAAC;EACf,WAAW,EAAE,CAAC;;EAEd,WAAW,EAAE,CAAC;EACd,CAAC;CACF;;AAED,IAAI,CAAC,SAAS,GAAG;CAChB,IAAI,eAAA,GAAG,oBAAoB,EAAE,eAAe,GAAG;;;EAC9C,OAAO,UAAU,EAAE,IAAI,EAAE,oBAAoB,EAAE,CAAC,IAAI,EAAE,UAAA,OAAO,EAAC;GAC7DJ,MAAI,CAAC,OAAO,GAAG,oBAAoB,EAAEA,MAAI,CAAC,IAAI,EAAE,GAAG,OAAO,CAAC;;GAE3D,OAAO,MAAM,EAAEA,MAAI,EAAE,eAAe,EAAE,CAAC,IAAI,EAAE,UAAA,GAAG,EAAC;IAChD,KAAK,CAAC,GAAG,GAAG,OAAO,IAAI,CAAC;;IAExBA,MAAI,CAAC,GAAG,GAAG,GAAG,CAAC;;IAEfC,IAAI,aAAa,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;IACrCD,MAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC;IAC7CC,IAAI,YAAY,GAAG,OAAO,CAAC,MAAM,EAAE,aAAa,EAAE,CAAC;IACnDD,MAAI,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG,GAAG,YAAY,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;;IAEnEE,IAAM,cAAc,GAAG,GAAG,CAAC,cAAc,IAAI,EAAE,CAAC;;IAEhDA,IAAM,UAAU,GAAG,OAAO,EAAE,OAAO,EAAEF,MAAI,CAAC,IAAI,EAAE,EAAE,GAAG,CAAC,UAAU,IAAI,EAAE,EAAE,CAAC;;IAEzEA,MAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,EAAE,WAAE,MAAM,EAAE,CAAC,GAAG;KAC7C,OAAO,IAAI,IAAI,CAAC;MACf,IAAI,EAAE,MAAM,GAAG,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,IAAI;MACnD,OAAO,EAAE,cAAc,CAAC,CAAC,CAAC;MAC1B,CAAC,CAAC;KACH,CAAC,CAAC;;IAEHE,IAAM,QAAQ,GAAGF,MAAI,CAAC,OAAO,CAAC,GAAG,EAAE,UAAA,IAAI,EAAC,SAAG,IAAI,CAAC,IAAI,EAAE,oBAAoB,EAAE,eAAe,EAAE,GAAA,EAAE,CAAC;IAChG,OAAOI,SAAO,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC;IAC/B,CAAC,CAAC;GACH,CAAC,CAAC;EACH;;CAED,QAAQ,mBAAA,GAAG,oBAAoB,EAAE,eAAe,GAAG;EAClD,KAAK,CAAC,IAAI,CAAC,OAAO,GAAG;GACpB,KAAK,CAAC,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG;IACzC,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,YAAY,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC;IACpF;;GAED,IAAI,CAAC,OAAO,GAAG,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;GACjD;;EAEDF,IAAM,GAAG,GAAG,MAAM,EAAE,IAAI,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC;EAClDD,IAAI,cAAc,CAAC;;EAEnB,KAAK,CAAC,GAAG,GAAG;GACX,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;GAC7B,MAAM;GACN,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;GACf,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC;;GAE7C,cAAc,GAAG,GAAG,CAAC,cAAc,IAAI,EAAE,CAAC;;GAE1CC,IAAM,UAAU,GAAG,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,GAAG,CAAC,UAAU,IAAI,EAAE,EAAE,CAAC;;GAEzE,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,EAAE,WAAE,MAAM,EAAE,CAAC,GAAG;IAC7CA,IAAM,IAAI,GAAG,IAAI,IAAI,CAAC;KACrB,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE;KACnC,OAAO,EAAE,cAAc,CAAC,CAAC,CAAC;KAC1B,CAAC,CAAC;;IAEH,IAAI,CAAC,QAAQ,EAAE,oBAAoB,EAAE,eAAe,EAAE,CAAC;IACvD,OAAO,IAAI,CAAC;IACZ,CAAC,CAAC;GACH;EACD;;;;;;;;;;;;;;;;;CAiBD,KAAK,gBAAA,GAAG,SAAS,EAAE,WAAW,EAAE,IAAI,GAAG;;;;;EAGtC,KAAK,IAAI,CAAC,gBAAgB,GAAG;GAC5B,OAAO;IACN,MAAM,EAAE,IAAI,CAAC,IAAI;IACjB,IAAI,EAAE,SAAS,GAAG,CAAC;IACnB,MAAM,EAAE,WAAW,IAAI,CAAC;IACxB,IAAI,EAAE,IAAI;IACV,CAAC;GACF;;;;EAIDA,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE,SAAS,EAAE,CAAC;;EAE5C,KAAK,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,GAAG;GACzC,OAAO,IAAI,CAAC;GACZ;;EAED,KAAK,WAAW,IAAI,IAAI,GAAG;GAC1BD,IAAI,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;GAC1BA,IAAI,CAAC,CAAC;;GAEN,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG;IAC9BA,IAAI,mBAAmB,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;IAEzC,KAAK,mBAAmB,GAAG,WAAW,GAAG;KACxC,MAAM;KACN;;IAED,KAAK,mBAAmB,KAAK,WAAW,GAAG;KAC1C,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,OAAO,IAAI,CAAC;;KAE1CA,IAAII,iBAAe,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACrCJ,IAAIK,gBAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACpCL,IAAI,gBAAgB,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACtCA,IAAIM,WAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;KAE/BN,IAAIO,QAAM,GAAGR,MAAI,CAAC,OAAO,EAAEK,iBAAe,EAAE,CAAC;KAC7C,OAAOG,QAAM,CAAC,KAAK,EAAEF,gBAAc,EAAE,gBAAgB,EAAEN,MAAI,CAAC,GAAG,CAAC,KAAK,EAAEO,WAAS,EAAE,IAAI,IAAI,EAAE,CAAC;KAC7F;IACD;GACD;;;EAGDN,IAAI,eAAe,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACrCA,IAAI,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACpCA,IAAI,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;EAE/BA,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,eAAe,EAAE,CAAC;EAC7C,OAAO,MAAM,CAAC,KAAK,EAAE,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC;EACjF;CACD,CAAC;;AAEF,SAAS,UAAU,GAAG,IAAI,EAAE,oBAAoB,GAAG;CAClD,KAAK,IAAI,CAAC,IAAI,IAAI,oBAAoB,GAAG;EACxC,IAAI,CAAC,OAAO,GAAG,oBAAoB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;EACjD;;CAED,KAAK,CAAC,IAAI,CAAC,OAAO,GAAG;EACpB,OAAO,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC;EACnD;;CAED,OAAOG,SAAO,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC;CACvC;;AC9KD;;;;;AAKA,AAAe,SAAS,IAAI,GAAG,GAAG,GAAG;CACpC,OAAO,IAAI,MAAM,EAAE,GAAG,EAAE,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC;;;ACJhC,SAAS,SAAS,GAAG,UAAU,GAAG;CAChD,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;;CAEjB,IAAI,CAAC,IAAI,aAAa,UAAU,CAAC,IAAI,CAAC;CACtC,IAAI,CAAC,OAAO,UAAU,UAAU,CAAC,OAAO,CAAC;CACzC,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,cAAc,CAAC;CAChD,IAAI,CAAC,KAAK,YAAY,UAAU,CAAC,KAAK,CAAC;CACvC,IAAI,CAAC,QAAQ,SAAS,UAAU,CAAC,QAAQ,CAAC;CAC1C;;AAED,SAAS,CAAC,SAAS,GAAG;CACrB,QAAQ,mBAAA,IAAI;EACX,OAAO,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC;EAC9B;;CAED,KAAK,gBAAA,IAAI;EACR,OAAO,6CAA6C,GAAG,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC;EAC/E;CACD,CAAC;;ACpBa,SAAS,KAAK,GAAG,IAAI,GAAG;CACtC,OAAO,OAAO,IAAI,KAAK,QAAQ;EAC9B,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE;EAC1B,IAAI,CAAC;CACN;;ACGDF,IAAM,iBAAiB,GAAG,IAAI,MAAM,EAAE,QAAO;CAC5C,gBAAe,GAAEC,mBAAiB,gBAAW;CAC7C,cAAa,GAAEA,mBAAiB,yBAAoB;AACrD,OAAO,EAAE,GAAG,EAAE,CAAC;;AAEf,AAAe,SAAS,KAAK,GAAG,IAAI,EAAE,oBAAoB,GAAG;CAC5D,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;CACjB,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;;CAEjD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;CACjB;;AAED,KAAK,CAAC,SAAS,GAAG;CACjB,IAAI,eAAA,IAAI;EACP,OAAO;GACN,gBAAgB,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG;GAChD,iBAAiB,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,GAAG,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,GAAG,GAAG;;GAElG,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG;GAC5C,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,GAAG,GAAG;;GAE1C,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW;GACpC,CAAC;EACF;;CAED,KAAK,gBAAA,GAAG,OAAY,GAAG;oBAAR;mCAAA,GAAG,EAAE;;EACnBF,IAAI,QAAQ,GAAG,EAAE,CAAC;EAClBA,IAAI,UAAU,GAAG,EAAE,CAAC;;EAEpBC,IAAM,YAAY,GAAG,WAAE,OAAO,EAAE,MAAM,GAAG;GACxC,KAAK,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,OAAO;;GAEjCA,IAAM,MAAM,GAAGF,MAAI,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK;IACnD,OAAO,CAAC,CAAC,CAAC;IACV,OAAO,CAAC,CAAC,CAAC;IACVA,MAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE;IACjC,CAAC;;GAEF,KAAK,CAAC,MAAM,GAAG;IACdA,MAAI,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,CAAC;IAC7B,OAAO;IACP;;GAEDC,IAAI,WAAW,GAAG,UAAU,CAAC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;GACtD,KAAK,CAAC,CAAC,WAAW,GAAG;IACpB,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC;IAChC,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;IACjC;;GAEDA,IAAI,UAAU,GAAG;IAChB,OAAO,CAAC,CAAC,CAAC;IACV,WAAW;IACX,MAAM,CAAC,IAAI,GAAG,CAAC;IACf,MAAM,CAAC,MAAM;IACb,CAAC;;GAEF,KAAK,MAAM,CAAC,IAAI,GAAG;IAClBA,IAAI,SAAS,GAAG,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;IAChD,KAAK,CAAC,CAAC,SAAS,GAAG;KAClB,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC;KAC5B,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;KAC7B;;IAED,UAAU,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;IAC1B;;GAED,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC;GACrC,CAAC;;;EAGFA,IAAI,YAAY,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;;EAEpCA,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;EAClCA,IAAI,QAAQ,GAAG,IAAI,KAAK,EAAE,CAAC,EAAE,CAAC;;EAE9BA,IAAI,CAAC,EAAE,IAAI,EAAE,MAAM,CAAC;;EAEpB,QAAQ,CAAC,EAAE,GAAG;GACb,IAAI,GAAGD,MAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;GAC7B,QAAQ,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,EAAE,CAAC;;GAE1B,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,GAAG;IACtC,YAAY,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC;IAChC;GACD;;EAEDC,IAAI,WAAW,GAAG,OAAO,CAAC,MAAM,EAAE,YAAY,EAAE,CAAC;EACjD,IAAI,CAAC,MAAM,CAAC,WAAW,GAAG,GAAG,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;;;EAGhEA,IAAI,aAAa,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;EACrCA,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC;EACxCA,IAAI,YAAY,GAAG,OAAO,CAAC,MAAM,EAAE,aAAa,EAAE,CAAC;EACnD,IAAI,CAAC,MAAM,CAAC,YAAY,GAAG,GAAG,GAAG,YAAY,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;;EAEnEA,IAAI,cAAc,GAAG,OAAO,CAAC,cAAc,KAAK,KAAK,CAAC;;EAEtD,OAAO,IAAI,SAAS,CAAC;GACpB,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;GAChC,OAAO,EAAE,UAAU,CAAC,GAAG,EAAE,UAAA,MAAM,EAAC,SAAG,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,EAAED,MAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,EAAE,GAAA,EAAE;GAC3G,cAAc,EAAE,UAAU,CAAC,GAAG,EAAE,UAAA,MAAM,EAAC,SAAG,cAAc,GAAGA,MAAI,CAAC,oBAAoB,EAAE,MAAM,EAAE,GAAG,IAAI,GAAA,EAAE;GACvG,KAAK,EAAE,QAAQ;GACf,UAAA,QAAQ;GACR,CAAC,CAAC;EACH;;CAED,KAAK,gBAAA,GAAG,iBAAiB,EAAE,oBAAoB,GAAG;EACjD,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,iBAAiB,GAAG,CAAC,EAAE,oBAAoB,EAAE,IAAI,EAAE,CAAC;EAC5E;;CAED,KAAK,gBAAA,GAAG,IAAI,EAAE,OAAO,GAAG;EACvB,KAAK,OAAO,IAAI,KAAK,QAAQ,GAAG;GAC/B,OAAO,GAAG,IAAI,CAAC;GACf,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;GACtB;;EAED,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;;EAExB,OAAgC,GAAG,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;EAArE,IAAA,QAAQ;EAAE,IAAA,OAAO;EAAE,IAAA,GAAG,WAAxB;;EAENC,IAAI,QAAQ,GAAG,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC;;EAElD,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG;GACtB,QAAQ,CAAC,IAAI,EAAE,SAAS,EAAE,QAAQ,GAAG,MAAM,EAAE,GAAG,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC;GAChE;;EAED,OAAO,OAAO,CAAC,GAAG,EAAE,QAAQ,EAAE,CAAC;EAC/B;;CAED,SAAS,oBAAA,GAAG,IAAI,EAAE,OAAO,GAAG;EAC3B,KAAK,OAAO,IAAI,KAAK,QAAQ,GAAG;GAC/B,OAAO,GAAG,IAAI,CAAC;GACf,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;GACtB;;EAED,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;;EAExB,OAAgC,GAAG,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;EAArE,IAAA,QAAQ;EAAE,IAAA,OAAO;EAAE,IAAA,GAAG,WAAxB;;EAEN,aAAa,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;;EAEnC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG;GACtB,aAAa,EAAE,QAAQ,GAAG,MAAM,EAAE,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC;GACnD;EACD;CACD,CAAC;;AAEF,SAAS,mBAAmB,GAAG,IAAI,EAAE,KAAK,EAAE,OAAO,GAAG;CACrDC,IAAM,QAAQ,GAAG,OAAO,EAAE,IAAI,EAAE,CAAC;;CAEjCA,IAAM,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC;EACvB,cAAc,EAAE,OAAO,CAAC,cAAc;EACtC,IAAI,EAAE,OAAO,CAAC,IAAI,GAAG,OAAO,EAAE,OAAO,CAAC,IAAI,EAAE,GAAG,OAAO,EAAE,QAAQ,EAAE;EAClE,CAAC,CAAC;;CAEHA,IAAM,GAAG,GAAG,OAAO,CAAC,MAAM,GAAG,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,CAAC,YAAY,GAAG,QAAQ,GAAG,QAAQ,EAAE,QAAQ,EAAE,EAAE,GAAG,MAAM,CAAC;;;CAG/GA,IAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,iBAAiB,EAAE,EAAE,EAAE,GAAG,gBAAgB,EAAE,GAAG,EAAE,QAAQ,EAAE,CAAC;;CAExG,OAAO,EAAE,UAAA,QAAQ,EAAE,SAAA,OAAO,EAAE,KAAA,GAAG,EAAE,CAAC;CAClC;;AAED,SAAS,KAAK,GAAG,KAAK,EAAE,IAAI,GAAG;CAC9B,OAAO,KAAK,CAAC,MAAM,EAAE,WAAE,KAAK,EAAE,IAAI,GAAG;EACpC,OAAO,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC;EACnC,EAAE,CAAC,EAAE,CAAC;CACP;;AAED,SAAS,gBAAgB,GAAG,GAAG,EAAE,IAAI,GAAG;CACvCA,IAAM,GAAG,GAAG,OAAO,EAAE,IAAI,EAAE,CAAC;CAC5B,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,CAAC;;CAEvB,KAAK,GAAG,KAAK,MAAM,GAAG;EACrB,OAAO,CAAA,QAAO,GAAEC,mBAAiB,MAAE,GAAE,GAAG,UAAM,CAAC,CAAC;EAChD;;CAED,OAAO,CAAA,QAAO,GAAEA,mBAAiB,MAAE,GAAE,GAAG,OAAG,CAAC,CAAC;CAC7C;;ACrLM,SAAS,IAAI,GAAG,IAAI,EAAE,OAAO,GAAG;CACtC,OAAqD,GAAG,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;CAArE,IAAA,IAAI;CAAE,IAAA,oBAAoB;CAAE,IAAA,eAAe,uBAA7C;;CAEN,OAAO,IAAI,CAAC,IAAI,EAAE,oBAAoB,EAAE,eAAe,EAAE;GACvD,IAAI,EAAE,YAAG,SAAG,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,IAAI,KAAK,EAAE,IAAI,EAAE,oBAAoB,EAAE,GAAA,EAAE,CAAC;CACvF;;AAED,AAAO,SAAS,QAAQ,GAAG,IAAI,EAAE,OAAY,GAAG;kCAAR,GAAG,EAAE;;CAC5C,OAAqD,GAAG,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;CAArE,IAAA,IAAI;CAAE,IAAA,oBAAoB;CAAE,IAAA,eAAe,uBAA7C;;CAEN,IAAI,CAAC,QAAQ,EAAE,oBAAoB,EAAE,eAAe,EAAE,CAAC;CACvD,OAAO,IAAI,CAAC,gBAAgB,GAAG,IAAI,GAAG,IAAI,KAAK,EAAE,IAAI,EAAE,oBAAoB,EAAE,CAAC;CAC9E;;AAED,SAAS,IAAI,GAAG,IAAI,EAAE,OAAY,GAAG;kCAAR,GAAG,EAAE;;CACjCD,IAAM,IAAI,GAAG,IAAI,IAAI,CAAC,EAAE,MAAA,IAAI,EAAE,CAAC,CAAC;;CAEhCD,IAAI,oBAAoB,GAAG,EAAE,CAAC;CAC9BA,IAAI,eAAe,GAAG,EAAE,CAAC;;CAEzB,KAAK,OAAO,CAAC,OAAO,GAAG;EACtB,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,OAAO,EAAE,UAAA,GAAG,EAAC;GAC3C,oBAAoB,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE,GAAG,OAAO,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC;GAChE,CAAC,CAAC;EACH;;CAED,KAAK,OAAO,CAAC,UAAU,GAAG;EACzB,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,UAAU,EAAE,CAAC,OAAO,EAAE,UAAA,GAAG,EAAC;GAC9C,eAAe,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE,GAAG,OAAO,CAAC,UAAU,EAAE,GAAG,EAAE,CAAC;GAC9D,CAAC,CAAC;EACH;;CAED,OAAO,EAAE,MAAA,IAAI,EAAE,sBAAA,oBAAoB,EAAE,iBAAA,eAAe,EAAE,CAAC;CACvD;;\"}"}}}},"package.json":{"file":{"contents":"{\n\t\"name\": \"sorcery\",\n\t\"description\": \"Resolve a chain of sourcemaps back to the original source\",\n\t\"version\": \"0.11.0\",\n\t\"author\": \"Rich Harris\",\n\t\"repository\": \"https://github.com/Rich-Harris/sorcery\",\n\t\"main\": \"dist/sorcery.cjs.js\",\n\t\"jsnext:main\": \"dist/sorcery.es6.js\",\n\t\"license\": \"MIT\",\n\t\"dependencies\": {\n\t\t\"buffer-crc32\": \"^0.2.5\",\n\t\t\"minimist\": \"^1.2.0\",\n\t\t\"sander\": \"^0.5.0\",\n\t\t\"@jridgewell/sourcemap-codec\": \"^1.4.14\"\n\t},\n\t\"devDependencies\": {\n\t\t\"buble\": \"^0.10.4\",\n\t\t\"codecov.io\": \"^0.1.6\",\n\t\t\"coffee-script\": \"^1.10.0\",\n\t\t\"eslint\": \"^2.8.0\",\n\t\t\"glob\": \"^7.0.3\",\n\t\t\"istanbul\": \"^0.4.3\",\n\t\t\"less\": \"^2.6.1\",\n\t\t\"mocha\": \"^2.4.5\",\n\t\t\"promise-map-series\": \"^0.2.2\",\n\t\t\"remap-istanbul\": \"^0.6.3\",\n\t\t\"rollup\": \"^0.31.0\",\n\t\t\"rollup-plugin-buble\": \"^0.10.0\",\n\t\t\"rollup-plugin-commonjs\": \"^2.2.1\",\n\t\t\"rollup-plugin-npm\": \"^1.4.0\",\n\t\t\"source-map\": \"^0.5.3\",\n\t\t\"source-map-support\": \"^0.4.0\",\n\t\t\"uglify-js\": \"^2.6.2\"\n\t},\n\t\"bin\": {\n\t\t\"sorcery\": \"bin/sorcery\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"rm -rf dist && rollup -c -f cjs -o dist/sorcery.cjs.js && rollup -c -f es6 -o dist/sorcery.es6.js\",\n\t\t\"pretest\": \"npm run build\",\n\t\t\"prepare-tests\": \"node test/samples/prepare-tests.js\",\n\t\t\"test\": \"mocha --compilers js:buble/register\",\n\t\t\"prepublish\": \"npm test\",\n\t\t\"lint\": \"eslint src\",\n\t\t\"pretest-coverage\": \"npm run build\",\n\t\t\"test-coverage\": \"rm -rf coverage/* && istanbul cover --report json node_modules/.bin/_mocha -- -u exports -R spec test/test.js\",\n\t\t\"posttest-coverage\": \"remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped.json -b dist && remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped.lcov -t lcovonly -b dist && remap-istanbul -i coverage/coverage-final.json -o coverage/coverage-remapped -t html -b dist\",\n\t\t\"ci\": \"npm run test-coverage && codecov < coverage/coverage-remapped.lcov\"\n\t},\n\t\"files\": [\n\t\t\"src/\",\n\t\t\"dist/\",\n\t\t\"bin/\",\n\t\t\"README.md\"\n\t]\n}\n"}},"README.md":{"file":{"contents":"# sorcery.js\n\nSourcemaps are great - if you have a JavaScript file, and you minify it, your minifier can generate a map that lets you debug as though you were looking at the original uncompressed code.\n\nBut if you have more than one transformation - say you want to transpile your JavaScript, concatenate several files into one, and minify the result - it gets a little trickier. Each intermediate step needs to be able to both *ingest* a sourcemap and *generate* one, all the time pointing back to the original source.\n\nMost compilers don't do that. ([UglifyJS](https://github.com/mishoo/UglifyJS2) is an honourable exception.) So when you fire up devtools, instead of looking at the original source you find yourself looking at the final intermediate step in the chain of transformations.\n\n**Sorcery aims to fix that.** Given an file at the end of a transformation chain (e.g., your minified JavaScript), it will follow the entire chain back to the original source, and generate a new sourcemap that describes the whole process. How? Magic.\n\nThis is a work-in-progress - suitable for playing around with, but don't rely on it to debug air traffic control software or medical equipment. Other than that, it can't do much harm.\n\n\n## Usage\n\n### As a node module\n\nInstall sorcery locally:\n\n```bash\nnpm install sorcery\n```\n\n```js\nvar sorcery = require( 'sorcery' );\n\nsorcery.load( 'some/generated/code.min.js' ).then( function ( chain ) {\n  // generate a flattened sourcemap\n  var map = chain.apply(); // { version: 3, file: 'code.min.js', ... }\n\n  // get a JSON representation of the sourcemap\n  map.toString(); // '{\"version\":3,\"file\":\"code.min.js\",...}'\n\n  // get a data URI representation\n  map.toUrl(); // 'data:application/json;charset=utf-8;base64,eyJ2ZXJ...'\n\n  // write to a new file - this will create `output.js` and\n  // `output.js.map`, and will preserve relative paths. It\n  // returns a Promise\n  chain.write( 'output.js' );\n\n  // write to a new file but use an absolute path for the\n  // sourceMappingURL\n  chain.write( 'output.js', { absolutePath: true });\n\n  // write to a new file, but append the flattened sourcemap as a data URI\n  chain.write( 'output.js', { inline: true });\n\n  // overwrite the existing file\n  chain.write();\n  chain.write({ inline: true });\n\n  // find the origin of line x, column y. Returns an object with\n  // `source`, `line`, `column` and (if applicable) `name` properties.\n  // Note - for consistency with other tools, line numbers are always\n  // one-based, column numbers are always zero-based. It's daft, I know.\n  var loc = chain.trace( x, y );\n});\n\n// You can also use sorcery synchronously:\nvar chain = sorcery.loadSync( 'some/generated/code.min.js' );\nvar map = chain.apply();\nvar loc = chain.trace( x, y );\nchain.writeSync();\n```\n\n#### Advanced options\n\nYou can pass an optional second argument to `sorcery.load()` and `sorcery.loadSync()`, with zero or more of the following properties:\n\n* `content` - a map of `filename: contents` pairs. `filename` will be resolved against the current working directory if needs be\n* `sourcemaps` - a map of `filename: sourcemap` pairs, where `filename` is the name of the file the sourcemap is related to. This will override any `sourceMappingURL` comments in the file itself.\n\nFor example:\n\n```js\nsorcery.load( 'some/generated/code.min.js', {\n  content: {\n    'some/minified/code.min.js': '...',\n    'some/transpiled/code.js': '...',\n    'some/original/code.js': '...'\n  },\n  sourcemaps: {\n    'some/minified/code.min.js': {...},\n    'some/transpiled/code.js': {...}\n  }\n}).then( chain => {\n  /* ... */\n});\n```\n\nAny files not found will be read from the filesystem as normal.\n\n### On the command line\n\nFirst, install sorcery globally:\n\n```bash\nnpm install -g sorcery\n```\n\n```\nUsage:\n  sorcery [options]\n\nOptions:\n  -h, --help               Show help message\n  -v, --version            Show version\n  -i, --input <file>       Input file\n  -o, --output <file>      Output file (if absent, will overwrite input)\n  -d, --datauri            Append map as a data URI, rather than separate file\n  -x, --excludeContent     Don't populate the sourcesContent array\n```\n\nExamples:\n\n```bash\n# overwrite sourcemap in place (will write map to\n# some/generated/code.min.js.map, and update\n# sourceMappingURL comment if necessary\nsorcery -i some/generated/code.min.js\n\n# append flattened sourcemap as an inline data URI\n# (will delete existing .map file, if applicable)\nsorcery -d -i some/generated/code.min.js\n\n# write to a new file (will create newfile.js and\n# newfile.js.map)\nsorcery -i some/generated/code.min.js -o newfile.js\n```\n\n\n## License\n\nMIT\n"}},"src":{"directory":{"Chain.js":{"file":{"contents":"import { basename, dirname, extname, relative, resolve } from 'path';\nimport { writeFile, writeFileSync } from 'sander';\nimport codec from '@jridgewell/sourcemap-codec';\nimport SourceMap from './SourceMap.js';\nimport slash from './utils/slash.js';\nimport SOURCEMAPPING_URL from './utils/sourceMappingURL.js';\n\nconst SOURCEMAP_COMMENT = new RegExp( `\\n*(?:` +\n\t`\\\\/\\\\/[@#]\\\\s*${SOURCEMAPPING_URL}=([^'\"]+)|` +      // js\n\t`\\\\/\\\\*#?\\\\s*${SOURCEMAPPING_URL}=([^'\"]+)\\\\s\\\\*\\\\/)` + // css\n'\\\\s*$', 'g' );\n\nexport default function Chain ( node, sourcesContentByPath ) {\n\tthis.node = node;\n\tthis.sourcesContentByPath = sourcesContentByPath;\n\n\tthis._stats = {};\n}\n\nChain.prototype = {\n\tstat () {\n\t\treturn {\n\t\t\tselfDecodingTime: this._stats.decodingTime / 1e6,\n\t\t\ttotalDecodingTime: ( this._stats.decodingTime + tally( this.node.sources, 'decodingTime' ) ) / 1e6,\n\n\t\t\tencodingTime: this._stats.encodingTime / 1e6,\n\t\t\ttracingTime: this._stats.tracingTime / 1e6,\n\n\t\t\tuntraceable: this._stats.untraceable\n\t\t};\n\t},\n\n\tapply ( options = {} ) {\n\t\tlet allNames = [];\n\t\tlet allSources = [];\n\n\t\tconst applySegment = ( segment, result ) => {\n\t\t\tif ( segment.length < 4 ) return;\n\n\t\t\tconst traced = this.node.sources[ segment[1] ].trace( // source\n\t\t\t\tsegment[2], // source code line\n\t\t\t\tsegment[3], // source code column\n\t\t\t\tthis.node.map.names[ segment[4] ]\n\t\t\t);\n\n\t\t\tif ( !traced ) {\n\t\t\t\tthis._stats.untraceable += 1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet sourceIndex = allSources.indexOf( traced.source );\n\t\t\tif ( !~sourceIndex ) {\n\t\t\t\tsourceIndex = allSources.length;\n\t\t\t\tallSources.push( traced.source );\n\t\t\t}\n\n\t\t\tlet newSegment = [\n\t\t\t\tsegment[0], // generated code column\n\t\t\t\tsourceIndex,\n\t\t\t\ttraced.line - 1,\n\t\t\t\ttraced.column\n\t\t\t];\n\n\t\t\tif ( traced.name ) {\n\t\t\t\tlet nameIndex = allNames.indexOf( traced.name );\n\t\t\t\tif ( !~nameIndex ) {\n\t\t\t\t\tnameIndex = allNames.length;\n\t\t\t\t\tallNames.push( traced.name );\n\t\t\t\t}\n\n\t\t\t\tnewSegment[4] = nameIndex;\n\t\t\t}\n\n\t\t\tresult[ result.length ] = newSegment;\n\t\t};\n\n\t\t// Trace mappings\n\t\tlet tracingStart = process.hrtime();\n\n\t\tlet i = this.node.mappings.length;\n\t\tlet resolved = new Array( i );\n\n\t\tlet j, line, result;\n\n\t\twhile ( i-- ) {\n\t\t\tline = this.node.mappings[i];\n\t\t\tresolved[i] = result = [];\n\n\t\t\tfor ( j = 0; j < line.length; j += 1 ) {\n\t\t\t\tapplySegment( line[j], result );\n\t\t\t}\n\t\t}\n\n\t\tlet tracingTime = process.hrtime( tracingStart );\n\t\tthis._stats.tracingTime = 1e9 * tracingTime[0] + tracingTime[1];\n\n\t\t// Encode mappings\n\t\tlet encodingStart = process.hrtime();\n\t\tlet mappings = codec.encode( resolved );\n\t\tlet encodingTime = process.hrtime( encodingStart );\n\t\tthis._stats.encodingTime = 1e9 * encodingTime[0] + encodingTime[1];\n\n\t\tlet includeContent = options.includeContent !== false;\n\n\t\treturn new SourceMap({\n\t\t\tfile: basename( this.node.file ),\n\t\t\tsources: allSources.map( source => slash( relative( options.base || dirname( this.node.file ), source ) ) ),\n\t\t\tsourcesContent: allSources.map( source => includeContent ? this.sourcesContentByPath[ source ] : null ),\n\t\t\tnames: allNames,\n\t\t\tmappings\n\t\t});\n\t},\n\n\ttrace ( oneBasedLineIndex, zeroBasedColumnIndex ) {\n\t\treturn this.node.trace( oneBasedLineIndex - 1, zeroBasedColumnIndex, null );\n\t},\n\n\twrite ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\n\n\t\tlet promises = [ writeFile( resolved, content ) ];\n\n\t\tif ( !options.inline ) {\n\t\t\tpromises.push( writeFile( resolved + '.map', map.toString() ) );\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t},\n\n\twriteSync ( dest, options ) {\n\t\tif ( typeof dest !== 'string' ) {\n\t\t\toptions = dest;\n\t\t\tdest = this.node.file;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tconst { resolved, content, map } = processWriteOptions( dest, this, options );\n\n\t\twriteFileSync( resolved, content );\n\n\t\tif ( !options.inline ) {\n\t\t\twriteFileSync( resolved + '.map', map.toString() );\n\t\t}\n\t}\n};\n\nfunction processWriteOptions ( dest, chain, options ) {\n\tconst resolved = resolve( dest );\n\n\tconst map = chain.apply({\n\t\tincludeContent: options.includeContent,\n\t\tbase: options.base ? resolve( options.base ) : dirname( resolved )\n\t});\n\n\tconst url = options.inline ? map.toUrl() : ( options.absolutePath ? resolved : basename( resolved ) ) + '.map';\n\n\t// TODO shouldn't url be relative?\n\tconst content = chain.node.content.replace( SOURCEMAP_COMMENT, '' ) + sourcemapComment( url, resolved );\n\n\treturn { resolved, content, map };\n}\n\nfunction tally ( nodes, stat ) {\n\treturn nodes.reduce( ( total, node ) => {\n\t\treturn total + node._stats[ stat ];\n\t}, 0 );\n}\n\nfunction sourcemapComment ( url, dest ) {\n\tconst ext = extname( dest );\n\turl = encodeURI( url );\n\n\tif ( ext === '.css' ) {\n\t\treturn `\\n/*# ${SOURCEMAPPING_URL}=${url} */\\n`;\n\t}\n\n\treturn `\\n//# ${SOURCEMAPPING_URL}=${url}\\n`;\n}\n"}},"index.js":{"file":{"contents":"import { resolve } from 'path';\nimport Node from './Node.js';\nimport Chain from './Chain.js';\n\nexport function load ( file, options ) {\n\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\n\n\treturn node.load( sourcesContentByPath, sourceMapByPath )\n\t\t.then( () => node.isOriginalSource ? null : new Chain( node, sourcesContentByPath ) );\n}\n\nexport function loadSync ( file, options = {} ) {\n\tconst { node, sourcesContentByPath, sourceMapByPath } = init( file, options );\n\n\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\treturn node.isOriginalSource ? null : new Chain( node, sourcesContentByPath );\n}\n\nfunction init ( file, options = {} ) {\n\tconst node = new Node({ file });\n\n\tlet sourcesContentByPath = {};\n\tlet sourceMapByPath = {};\n\n\tif ( options.content ) {\n\t\tObject.keys( options.content ).forEach( key => {\n\t\t\tsourcesContentByPath[ resolve( key ) ] = options.content[ key ];\n\t\t});\n\t}\n\n\tif ( options.sourcemaps ) {\n\t\tObject.keys( options.sourcemaps ).forEach( key => {\n\t\t\tsourceMapByPath[ resolve( key ) ] = options.sourcemaps[ key ];\n\t\t});\n\t}\n\n\treturn { node, sourcesContentByPath, sourceMapByPath };\n}\n"}},"Node.js":{"file":{"contents":"import { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport codec from '@jridgewell/sourcemap-codec';\nimport getMap from './utils/getMap.js';\n\nexport default function Node ({ file, content }) {\n\tthis.file = file ? resolve( file ) : null;\n\tthis.content = content || null; // sometimes exists in sourcesContent, sometimes doesn't\n\n\tif ( !this.file && this.content === null ) {\n\t\tthrow new Error( 'A source must specify either file or content' );\n\t}\n\n\t// these get filled in later\n\tthis.map = null;\n\tthis.mappings = null;\n\tthis.sources = null;\n\tthis.isOriginalSource = null;\n\n\tthis._stats = {\n\t\tdecodingTime: 0,\n\t\tencodingTime: 0,\n\t\ttracingTime: 0,\n\n\t\tuntraceable: 0\n\t};\n}\n\nNode.prototype = {\n\tload ( sourcesContentByPath, sourceMapByPath ) {\n\t\treturn getContent( this, sourcesContentByPath ).then( content => {\n\t\t\tthis.content = sourcesContentByPath[ this.file ] = content;\n\n\t\t\treturn getMap( this, sourceMapByPath ).then( map => {\n\t\t\t\tif ( !map ) return null;\n\n\t\t\t\tthis.map = map;\n\n\t\t\t\tlet decodingStart = process.hrtime();\n\t\t\t\tthis.mappings = codec.decode( map.mappings );\n\t\t\t\tlet decodingTime = process.hrtime( decodingStart );\n\t\t\t\tthis._stats.decodingTime = 1e9 * decodingTime[0] + decodingTime[1];\n\n\t\t\t\tconst sourcesContent = map.sourcesContent || [];\n\n\t\t\t\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\n\n\t\t\t\tthis.sources = map.sources.map( ( source, i ) => {\n\t\t\t\t\treturn new Node({\n\t\t\t\t\t\tfile: source ? resolve( sourceRoot, source ) : null,\n\t\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tconst promises = this.sources.map( node => node.load( sourcesContentByPath, sourceMapByPath ) );\n\t\t\t\treturn Promise.all( promises );\n\t\t\t});\n\t\t});\n\t},\n\n\tloadSync ( sourcesContentByPath, sourceMapByPath ) {\n\t\tif ( !this.content ) {\n\t\t\tif ( !sourcesContentByPath[ this.file ] ) {\n\t\t\t\tsourcesContentByPath[ this.file ] = readFileSync( this.file, { encoding: 'utf-8' });\n\t\t\t}\n\n\t\t\tthis.content = sourcesContentByPath[ this.file ];\n\t\t}\n\n\t\tconst map = getMap( this, sourceMapByPath, true );\n\t\tlet sourcesContent;\n\n\t\tif ( !map ) {\n\t\t\tthis.isOriginalSource = true;\n\t\t} else {\n\t\t\tthis.map = map;\n\t\t\tthis.mappings = codec.decode( map.mappings );\n\n\t\t\tsourcesContent = map.sourcesContent || [];\n\n\t\t\tconst sourceRoot = resolve( dirname( this.file ), map.sourceRoot || '' );\n\n\t\t\tthis.sources = map.sources.map( ( source, i ) => {\n\t\t\t\tconst node = new Node({\n\t\t\t\t\tfile: resolve( sourceRoot, source ),\n\t\t\t\t\tcontent: sourcesContent[i]\n\t\t\t\t});\n\n\t\t\t\tnode.loadSync( sourcesContentByPath, sourceMapByPath );\n\t\t\t\treturn node;\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * Traces a segment back to its origin\n\t * @param {number} lineIndex - the zero-based line index of the\n\t   segment as found in `this`\n\t * @param {number} columnIndex - the zero-based column index of the\n\t   segment as found in `this`\n\t * @param {string || null} - if specified, the name that should be\n\t   (eventually) returned, as it is closest to the generated code\n\t * @returns {object}\n\t     @property {string} source - the filepath of the source\n\t     @property {number} line - the one-based line index\n\t     @property {number} column - the zero-based column index\n\t     @property {string || null} name - the name corresponding\n\t     to the segment being traced\n\t */\n\ttrace ( lineIndex, columnIndex, name ) {\n\t\t// If this node doesn't have a source map, we have\n\t\t// to assume it is the original source\n\t\tif ( this.isOriginalSource ) {\n\t\t\treturn {\n\t\t\t\tsource: this.file,\n\t\t\t\tline: lineIndex + 1,\n\t\t\t\tcolumn: columnIndex || 0,\n\t\t\t\tname: name\n\t\t\t};\n\t\t}\n\n\t\t// Otherwise, we need to figure out what this position in\n\t\t// the intermediate file corresponds to in *its* source\n\t\tconst segments = this.mappings[ lineIndex ];\n\n\t\tif ( !segments || segments.length === 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( columnIndex != null ) {\n\t\t\tlet len = segments.length;\n\t\t\tlet i;\n\n\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\tlet generatedCodeColumn = segments[i][0];\n\n\t\t\t\tif ( generatedCodeColumn > columnIndex ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( generatedCodeColumn === columnIndex ) {\n\t\t\t\t\tif ( segments[i].length < 4 ) return null;\n\n\t\t\t\t\tlet sourceFileIndex = segments[i][1];\n\t\t\t\t\tlet sourceCodeLine = segments[i][2];\n\t\t\t\t\tlet sourceCodeColumn = segments[i][3];\n\t\t\t\t\tlet nameIndex = segments[i][4];\n\n\t\t\t\t\tlet parent = this.sources[ sourceFileIndex ];\n\t\t\t\t\treturn parent.trace( sourceCodeLine, sourceCodeColumn, this.map.names[ nameIndex ] || name );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// fall back to a line mapping\n\t\tlet sourceFileIndex = segments[0][1];\n\t\tlet sourceCodeLine = segments[0][2];\n\t\tlet nameIndex = segments[0][4];\n\n\t\tlet parent = this.sources[ sourceFileIndex ];\n\t\treturn parent.trace( sourceCodeLine, null, this.map.names[ nameIndex ] || name );\n\t}\n};\n\nfunction getContent ( node, sourcesContentByPath ) {\n\tif ( node.file in sourcesContentByPath ) {\n\t\tnode.content = sourcesContentByPath[ node.file ];\n\t}\n\n\tif ( !node.content ) {\n\t\treturn readFile( node.file, { encoding: 'utf-8' });\n\t}\n\n\treturn Promise.resolve( node.content );\n}\n"}},"SourceMap.js":{"file":{"contents":"import btoa from './utils/btoa.js';\n\nexport default function SourceMap ( properties ) {\n\tthis.version = 3;\n\n\tthis.file           = properties.file;\n\tthis.sources        = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names          = properties.names;\n\tthis.mappings       = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString () {\n\t\treturn JSON.stringify( this );\n\t},\n\n\ttoUrl () {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );\n\t}\n};\n"}},"utils":{"directory":{"atob.js":{"file":{"contents":"/**\n * Decodes a base64 string\n * @param {string} base64 - the string to decode\n * @returns {string}\n */\nexport default function atob ( base64 ) {\n\treturn new Buffer( base64, 'base64' ).toString( 'utf8' );\n}"}},"btoa.js":{"file":{"contents":"/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nexport default function btoa ( str ) {\n\treturn new Buffer( str ).toString( 'base64' );\n}"}},"getMap.js":{"file":{"contents":"import { Promise } from 'sander';\nimport getMapFromUrl from './getMapFromUrl.js';\nimport getSourceMappingUrl from './getSourceMappingUrl.js';\n\nexport default function getMap ( node, sourceMapByPath, sync ) {\n\tif ( node.file in sourceMapByPath ) {\n\t\tconst map = sourceMapByPath[ node.file ];\n\t\treturn sync ? map : Promise.resolve( map );\n\t}\n\n\telse {\n\t\tconst url = getSourceMappingUrl( node.content );\n\n\t\tif ( !url ) {\n\t\t\tnode.isOriginalSource = true;\n\t\t\treturn sync ? null : Promise.resolve( null );\n\t\t}\n\n\t\treturn getMapFromUrl( url, node.file, sync );\n\t}\n}\n"}},"getMapFromUrl.js":{"file":{"contents":"import { dirname, resolve } from 'path';\nimport { readFile, readFileSync, Promise } from 'sander';\nimport atob from './atob.js';\nimport SOURCEMAPPING_URL from './sourceMappingURL.js';\n\nfunction parseJSON ( json, url ) {\n\ttry {\n\t\treturn JSON.parse( json );\n\t} catch ( err ) {\n\t\tthrow new Error( `Could not parse sourcemap (${url}): ${err.message}` );\n\t}\n}\n\n/**\n * Turns a sourceMappingURL into a sourcemap\n * @param {string} url - the sourceMappingURL. Can be a\n   base64-encoded data URI\n * @param {string} base - the URL against which relative URLS\n   should be resolved\n * @param {boolean} sync - if `true`, return a promise, otherwise\n   return the sourcemap\n * @returns {object} - a version 3 sourcemap\n */\nexport default function getMapFromUrl ( url, base, sync ) {\n\tif ( /^data:/.test( url ) ) { // TODO beef this up\n\t\tconst match = /base64,(.+)$/.exec( url );\n\n\t\tif ( !match ) {\n\t\t\tthrow new Error( `${SOURCEMAPPING_URL} is not base64-encoded` );\n\t\t}\n\n\t\tconst json = atob( match[1] );\n\t\tconst map = parseJSON( json, `data URI in ${base}` );\n\t\treturn sync ? map : Promise.resolve( map );\n\t}\n\n\turl = resolve( dirname( base ), decodeURI( url ) );\n\n\tif ( sync ) {\n\t\treturn parseJSON( readFileSync( url, { encoding: 'utf-8' }), url );\n\t} else {\n\t\treturn readFile( url, { encoding: 'utf-8' }).then( json => parseJSON( json, url ) );\n\t}\n}\n"}},"getSourceMappingUrl.js":{"file":{"contents":"import SOURCEMAPPING_URL from './sourceMappingURL.js';\n\nexport default function getSourceMappingUrl ( str ) {\n\tvar index, substring, url, match;\n\n\t// assume we want the last occurence\n\tindex = str.lastIndexOf( `${SOURCEMAPPING_URL}=` );\n\n\tif ( index === -1 ) {\n\t\treturn null;\n\t}\n\n\tsubstring = str.substring( index + 17 );\n\tmatch = /^[^\\r\\n]+/.exec( substring );\n\n\turl = match ? match[0] : null;\n\n\t// possibly a better way to do this, but we don't want to exclude whitespace\n\t// from the sourceMappingURL because it might not have been correctly encoded\n\tif ( url && url.slice( -2 ) === '*/' ) {\n\t\turl = url.slice( 0, -2 ).trim();\n\t}\n\n\treturn url;\n}\n"}},"slash.js":{"file":{"contents":"export default function slash ( path ) {\n\treturn typeof path === 'string' ?\n\t\tpath.replace( /\\\\/g, '/' ) :\n\t\tpath;\n}\n"}},"sourceMappingURL.js":{"file":{"contents":"// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nexport default SOURCEMAPPING_URL;\n"}}}}}}}}