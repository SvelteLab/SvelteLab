{"directory":{"async":{"directory":{"index.browser.cjs":{"file":{"contents":"let random = async bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return async (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = crypto.getRandomValues(new Uint8Array(step))\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet nanoid = async (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet, random }\n"}},"index.browser.js":{"file":{"contents":"let random = async bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return async (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = crypto.getRandomValues(new Uint8Array(step))\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet nanoid = async (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\nexport { nanoid, customAlphabet, random }\n"}},"index.cjs":{"file":{"contents":"let crypto = require('crypto')\nlet { urlAlphabet } = require('../url-alphabet/index.cjs')\nlet random = bytes =>\n  new Promise((resolve, reject) => {\n    crypto.randomFill(Buffer.allocUnsafe(bytes), (err, buf) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(buf)\n      }\n    })\n  })\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  let tick = (id, size = defaultSize) =>\n    random(step).then(bytes => {\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n      return tick(id, size)\n    })\n  return size => tick('', size)\n}\nlet nanoid = (size = 21) =>\n  random(size).then(bytes => {\n    let id = ''\n    while (size--) {\n      id += urlAlphabet[bytes[size] & 63]\n    }\n    return id\n  })\nmodule.exports = { nanoid, customAlphabet, random }\n"}},"index.d.ts":{"file":{"contents":"/**\n * Generate secure URL-friendly unique ID. The non-blocking version.\n *\n * By default, the ID will have 21 symbols to have a collision probability\n * similar to UUID v4.\n *\n * ```js\n * import { nanoid } from 'nanoid/async'\n * nanoid().then(id => {\n *   model.id = id\n * })\n * ```\n *\n * @param size Size of the ID. The default size is 21.\n * @returns A promise with a random string.\n */\nexport function nanoid(size?: number): Promise<string>\n\n/**\n * A low-level function.\n * Generate secure unique ID with custom alphabet. The non-blocking version.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param alphabet Alphabet used to generate the ID.\n * @param defaultSize Size of the ID. The default size is 21.\n * @returns A function that returns a promise with a random string.\n *\n * ```js\n * import { customAlphabet } from 'nanoid/async'\n * const nanoid = customAlphabet('0123456789абвгдеё', 5)\n * nanoid().then(id => {\n *   model.id = id //=> \"8ё56а\"\n * })\n * ```\n */\nexport function customAlphabet(\n  alphabet: string,\n  defaultSize?: number\n): (size?: number) => Promise<string>\n\n/**\n * Generate an array of random bytes collected from hardware noise.\n *\n * ```js\n * import { random } from 'nanoid/async'\n * random(5).then(bytes => {\n *   bytes //=> [10, 67, 212, 67, 89]\n * })\n * ```\n *\n * @param bytes Size of the array.\n * @returns A promise with a random bytes array.\n */\nexport function random(bytes: number): Promise<Uint8Array>\n"}},"index.js":{"file":{"contents":"import crypto from 'crypto'\nimport { urlAlphabet } from '../url-alphabet/index.js'\nlet random = bytes =>\n  new Promise((resolve, reject) => {\n    crypto.randomFill(Buffer.allocUnsafe(bytes), (err, buf) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(buf)\n      }\n    })\n  })\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  let tick = (id, size = defaultSize) =>\n    random(step).then(bytes => {\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n      return tick(id, size)\n    })\n  return size => tick('', size)\n}\nlet nanoid = (size = 21) =>\n  random(size).then(bytes => {\n    let id = ''\n    while (size--) {\n      id += urlAlphabet[bytes[size] & 63]\n    }\n    return id\n  })\nexport { nanoid, customAlphabet, random }\n"}},"index.native.js":{"file":{"contents":"import { getRandomBytesAsync } from 'expo-random'\nimport { urlAlphabet } from '../url-alphabet/index.js'\nlet random = getRandomBytesAsync\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  let tick = (id, size = defaultSize) =>\n    random(step).then(bytes => {\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n      return tick(id, size)\n    })\n  return size => tick('', size)\n}\nlet nanoid = (size = 21) =>\n  random(size).then(bytes => {\n    let id = ''\n    while (size--) {\n      id += urlAlphabet[bytes[size] & 63]\n    }\n    return id\n  })\nexport { nanoid, customAlphabet, random }\n"}},"package.json":{"file":{"contents":"{\n  \"type\": \"module\",\n  \"main\": \"index.cjs\",\n  \"module\": \"index.js\",\n  \"react-native\": {\n    \"./index.js\": \"./index.native.js\"\n  },\n  \"browser\": {\n    \"./index.js\": \"./index.browser.js\",\n    \"./index.cjs\": \"./index.browser.cjs\"\n  }\n}"}}}},"bin":{"directory":{"nanoid.cjs":{"file":{"contents":"#!/usr/bin/env node\n\nlet { nanoid, customAlphabet } = require('..')\n\nfunction print(msg) {\n  process.stdout.write(msg + '\\n')\n}\n\nfunction error(msg) {\n  process.stderr.write(msg + '\\n')\n  process.exit(1)\n}\n\nif (process.argv.includes('--help') || process.argv.includes('-h')) {\n  print(`\n  Usage\n    $ nanoid [options]\n\n  Options\n    -s, --size       Generated ID size\n    -a, --alphabet   Alphabet to use\n    -h, --help       Show this help\n\n  Examples\n    $ nanoid --s 15\n    S9sBF77U6sDB8Yg\n\n    $ nanoid --size 10 --alphabet abc\n    bcabababca`)\n  process.exit()\n}\n\nlet alphabet, size\nfor (let i = 2; i < process.argv.length; i++) {\n  let arg = process.argv[i]\n  if (arg === '--size' || arg === '-s') {\n    size = Number(process.argv[i + 1])\n    i += 1\n    if (Number.isNaN(size) || size <= 0) {\n      error('Size must be positive integer')\n    }\n  } else if (arg === '--alphabet' || arg === '-a') {\n    alphabet = process.argv[i + 1]\n    i += 1\n  } else {\n    error('Unknown argument ' + arg)\n  }\n}\n\nif (alphabet) {\n  let customNanoid = customAlphabet(alphabet, size)\n  print(customNanoid())\n} else {\n  print(nanoid(size))\n}\n"}}}},"index.browser.cjs":{"file":{"contents":"let { urlAlphabet } = require('./url-alphabet/index.cjs')\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n"}},"index.browser.js":{"file":{"contents":"import { urlAlphabet } from './url-alphabet/index.js'\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n"}},"index.cjs":{"file":{"contents":"let crypto = require('crypto')\nlet { urlAlphabet } = require('./url-alphabet/index.cjs')\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n"}},"index.d.ts":{"file":{"contents":"/**\n * Generate secure URL-friendly unique ID.\n *\n * By default, the ID will have 21 symbols to have a collision probability\n * similar to UUID v4.\n *\n * ```js\n * import { nanoid } from 'nanoid'\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n * ```\n *\n * @param size Size of the ID. The default size is 21.\n * @returns A random string.\n */\nexport function nanoid(size?: number): string\n\n/**\n * Generate secure unique ID with custom alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * @param alphabet Alphabet used to generate the ID.\n * @param defaultSize Size of the ID. The default size is 21.\n * @returns A random string generator.\n *\n * ```js\n * const { customAlphabet } = require('nanoid')\n * const nanoid = customAlphabet('0123456789абвгдеё', 5)\n * nanoid() //=> \"8ё56а\"\n * ```\n */\nexport function customAlphabet(\n  alphabet: string,\n  defaultSize?: number\n): (size?: number) => string\n\n/**\n * Generate unique ID with custom random generator and alphabet.\n *\n * Alphabet must contain 256 symbols or less. Otherwise, the generator\n * will not be secure.\n *\n * ```js\n * import { customRandom } from 'nanoid/format'\n *\n * const nanoid = customRandom('abcdef', 5, size => {\n *   const random = []\n *   for (let i = 0; i < size; i++) {\n *     random.push(randomByte())\n *   }\n *   return random\n * })\n *\n * nanoid() //=> \"fbaef\"\n * ```\n *\n * @param alphabet Alphabet used to generate a random string.\n * @param size Size of the random string.\n * @param random A random bytes generator.\n * @returns A random string generator.\n */\nexport function customRandom(\n  alphabet: string,\n  size: number,\n  random: (bytes: number) => Uint8Array\n): () => string\n\n/**\n * URL safe symbols.\n *\n * ```js\n * import { urlAlphabet } from 'nanoid'\n * const nanoid = customAlphabet(urlAlphabet, 10)\n * nanoid() //=> \"Uakgb_J5m9\"\n * ```\n */\nexport const urlAlphabet: string\n\n/**\n * Generate an array of random bytes collected from hardware noise.\n *\n * ```js\n * import { customRandom, random } from 'nanoid'\n * const nanoid = customRandom(\"abcdef\", 5, random)\n * ```\n *\n * @param bytes Size of the array.\n * @returns An array of random bytes.\n */\nexport function random(bytes: number): Uint8Array\n"}},"index.js":{"file":{"contents":"import crypto from 'crypto'\nimport { urlAlphabet } from './url-alphabet/index.js'\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n"}},"LICENSE":{"file":{"contents":"The MIT License (MIT)\n\nCopyright 2017 Andrey Sitnik <andrey@sitnik.ru>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"}},"nanoid.js":{"file":{"contents":"export let nanoid=(t=21)=>crypto.getRandomValues(new Uint8Array(t)).reduce(((t,e)=>t+=(e&=63)<36?e.toString(36):e<62?(e-26).toString(36).toUpperCase():e<63?\"_\":\"-\"),\"\");"}},"non-secure":{"directory":{"index.cjs":{"file":{"contents":"let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet }\n"}},"index.d.ts":{"file":{"contents":"/**\n * Generate URL-friendly unique ID. This method uses the non-secure\n * predictable random generator with bigger collision probability.\n *\n * ```js\n * import { nanoid } from 'nanoid/non-secure'\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n * ```\n *\n * @param size Size of the ID. The default size is 21.\n * @returns A random string.\n */\nexport function nanoid(size?: number): string\n\n/**\n * Generate a unique ID based on a custom alphabet.\n * This method uses the non-secure predictable random generator\n * with bigger collision probability.\n *\n * @param alphabet Alphabet used to generate the ID.\n * @param defaultSize Size of the ID. The default size is 21.\n * @returns A random string generator.\n *\n * ```js\n * import { customAlphabet } from 'nanoid/non-secure'\n * const nanoid = customAlphabet('0123456789абвгдеё', 5)\n * model.id = //=> \"8ё56а\"\n * ```\n */\nexport function customAlphabet(\n  alphabet: string,\n  defaultSize?: number\n): (size?: number) => string\n"}},"index.js":{"file":{"contents":"let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n"}},"package.json":{"file":{"contents":"{\n  \"type\": \"module\",\n  \"main\": \"index.cjs\",\n  \"module\": \"index.js\",\n  \"react-native\": \"index.js\"\n}"}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"nanoid\",\n  \"version\": \"3.3.4\",\n  \"description\": \"A tiny (116 bytes), secure URL-friendly unique string ID generator\",\n  \"keywords\": [\n    \"uuid\",\n    \"random\",\n    \"id\",\n    \"url\"\n  ],\n  \"engines\": {\n    \"node\": \"^10 || ^12 || ^13.7 || ^14 || >=15.0.1\"\n  },\n  \"author\": \"Andrey Sitnik <andrey@sitnik.ru>\",\n  \"license\": \"MIT\",\n  \"repository\": \"ai/nanoid\",\n  \"browser\": {\n    \"./index.js\": \"./index.browser.js\",\n    \"./async/index.js\": \"./async/index.browser.js\",\n    \"./async/index.cjs\": \"./async/index.browser.cjs\",\n    \"./index.cjs\": \"./index.browser.cjs\"\n  },\n  \"react-native\": \"index.js\",\n  \"bin\": \"./bin/nanoid.cjs\",\n  \"sideEffects\": false,\n  \"types\": \"./index.d.ts\",\n  \"type\": \"module\",\n  \"main\": \"index.cjs\",\n  \"module\": \"index.js\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"browser\": \"./index.browser.js\",\n      \"require\": \"./index.cjs\",\n      \"import\": \"./index.js\",\n      \"default\": \"./index.js\"\n    },\n    \"./index.d.ts\": \"./index.d.ts\",\n    \"./package.json\": \"./package.json\",\n    \"./async/package.json\": \"./async/package.json\",\n    \"./async\": {\n      \"browser\": \"./async/index.browser.js\",\n      \"require\": \"./async/index.cjs\",\n      \"import\": \"./async/index.js\",\n      \"default\": \"./async/index.js\"\n    },\n    \"./non-secure/package.json\": \"./non-secure/package.json\",\n    \"./non-secure\": {\n      \"require\": \"./non-secure/index.cjs\",\n      \"import\": \"./non-secure/index.js\",\n      \"default\": \"./non-secure/index.js\"\n    },\n    \"./url-alphabet/package.json\": \"./url-alphabet/package.json\",\n    \"./url-alphabet\": {\n      \"require\": \"./url-alphabet/index.cjs\",\n      \"import\": \"./url-alphabet/index.js\",\n      \"default\": \"./url-alphabet/index.js\"\n    }\n  }\n}"}},"README.md":{"file":{"contents":"# Nano ID\n\n<img src=\"https://ai.github.io/nanoid/logo.svg\" align=\"right\"\n     alt=\"Nano ID logo by Anton Lovchikov\" width=\"180\" height=\"94\">\n\n**English** | [Русский](./README.ru.md) | [简体中文](./README.zh-CN.md) | [Bahasa Indonesia](./README.id-ID.md)\n\nA tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n\n> “An amazing level of senseless perfectionism,\n> which is simply impossible not to respect.”\n\n* **Small.** 130 bytes (minified and gzipped). No dependencies.\n  [Size Limit] controls the size.\n* **Fast.** It is 2 times faster than UUID.\n* **Safe.** It uses hardware random generator. Can be used in clusters.\n* **Short IDs.** It uses a larger alphabet than UUID (`A-Za-z0-9_-`).\n  So ID size was reduced from 36 to 21 symbols.\n* **Portable.** Nano ID was ported\n  to [20 programming languages](#other-programming-languages).\n\n```js\nimport { nanoid } from 'nanoid'\nmodel.id = nanoid() //=> \"V1StGXR8_Z5jdHi6B-myT\"\n```\n\nSupports modern browsers, IE [with Babel], Node.js and React Native.\n\n[online tool]: https://gitpod.io/#https://github.com/ai/nanoid/\n[with Babel]:  https://developer.epages.com/blog/coding/how-to-transpile-node-modules-with-babel-and-webpack-in-a-monorepo/\n[Size Limit]:  https://github.com/ai/size-limit\n\n<a href=\"https://evilmartians.com/?utm_source=nanoid\">\n  <img src=\"https://evilmartians.com/badges/sponsored-by-evil-martians.svg\"\n       alt=\"Sponsored by Evil Martians\" width=\"236\" height=\"54\">\n</a>\n\n## Docs\nRead **[full docs](https://github.com/ai/nanoid#readme)** on GitHub.\n"}},"url-alphabet":{"directory":{"index.cjs":{"file":{"contents":"let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nmodule.exports = { urlAlphabet }\n"}},"index.js":{"file":{"contents":"let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport { urlAlphabet }\n"}},"package.json":{"file":{"contents":"{\n  \"type\": \"module\",\n  \"main\": \"index.cjs\",\n  \"module\": \"index.js\",\n  \"react-native\": \"index.js\"\n}"}}}}}}