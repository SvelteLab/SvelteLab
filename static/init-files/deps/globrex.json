{"directory":{"index.js":{"file":{"contents":"const isWin = process.platform === 'win32';\nconst SEP = isWin ? `\\\\\\\\+` : `\\\\/`;\nconst SEP_ESC = isWin ? `\\\\\\\\` : `/`;\nconst GLOBSTAR = `((?:[^/]*(?:/|$))*)`;\nconst WILDCARD = `([^/]*)`;\nconst GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}]*(?:${SEP_ESC}|$))*)`;\nconst WILDCARD_SEGMENT = `([^${SEP_ESC}]*)`;\n\n/**\n * Convert any glob pattern to a JavaScript Regexp object\n * @param {String} glob Glob pattern to convert\n * @param {Object} opts Configuration object\n * @param {Boolean} [opts.extended=false] Support advanced ext globbing\n * @param {Boolean} [opts.globstar=false] Support globstar\n * @param {Boolean} [opts.strict=true] be laissez faire about mutiple slashes\n * @param {Boolean} [opts.filepath=''] Parse as filepath for extra path related features\n * @param {String} [opts.flags=''] RegExp globs\n * @returns {Object} converted object with string, segments and RegExp object\n */\nfunction globrex(glob, {extended = false, globstar = false, strict = false, filepath = false, flags = ''} = {}) {\n    let regex = '';\n    let segment = '';\n    let path = { regex: '', segments: [] };\n\n    // If we are doing extended matching, this boolean is true when we are inside\n    // a group (eg {*.html,*.js}), and false otherwise.\n    let inGroup = false;\n    let inRange = false;\n\n    // extglob stack. Keep track of scope\n    const ext = [];\n\n    // Helper function to build string and segments\n    function add(str, {split, last, only}={}) {\n        if (only !== 'path') regex += str;\n        if (filepath && only !== 'regex') {\n            path.regex += (str === '\\\\/' ? SEP : str);\n            if (split) {\n                if (last) segment += str;\n                if (segment !== '') {\n                    if (!flags.includes('g')) segment = `^${segment}$`; // change it 'includes'\n                    path.segments.push(new RegExp(segment, flags));\n                }\n                segment = '';\n            } else {\n                segment += str;\n            }\n        }\n    }\n\n    let c, n;\n    for (let i = 0; i < glob.length; i++) {\n        c = glob[i];\n        n = glob[i + 1];\n\n        if (['\\\\', '$', '^', '.', '='].includes(c)) {\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '/') {\n            add(`\\\\${c}`, {split: true});\n            if (n === '/' && !strict) regex += '?';\n            continue;\n        }\n\n        if (c === '(') {\n            if (ext.length) {\n                add(c);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === ')') {\n            if (ext.length) {\n                add(c);\n                let type = ext.pop();\n                if (type === '@') {\n                    add('{1}');\n                } else if (type === '!') {\n                    add('([^\\/]*)');\n                } else {\n                    add(type);\n                }\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n        \n        if (c === '|') {\n            if (ext.length) {\n                add(c);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '+') {\n            if (n === '(' && extended) {\n                ext.push(c);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '@' && extended) {\n            if (n === '(') {\n                ext.push(c);\n                continue;\n            }\n        }\n\n        if (c === '!') {\n            if (extended) {\n                if (inRange) {\n                    add('^');\n                    continue\n                }\n                if (n === '(') {\n                    ext.push(c);\n                    add('(?!');\n                    i++;\n                    continue;\n                }\n                add(`\\\\${c}`);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '?') {\n            if (extended) {\n                if (n === '(') {\n                    ext.push(c);\n                } else {\n                    add('.');\n                }\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '[') {\n            if (inRange && n === ':') {\n                i++; // skip [\n                let value = '';\n                while(glob[++i] !== ':') value += glob[i];\n                if (value === 'alnum') add('(\\\\w|\\\\d)');\n                else if (value === 'space') add('\\\\s');\n                else if (value === 'digit') add('\\\\d');\n                i++; // skip last ]\n                continue;\n            }\n            if (extended) {\n                inRange = true;\n                add(c);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === ']') {\n            if (extended) {\n                inRange = false;\n                add(c);\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '{') {\n            if (extended) {\n                inGroup = true;\n                add('(');\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '}') {\n            if (extended) {\n                inGroup = false;\n                add(')');\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === ',') {\n            if (inGroup) {\n                add('|');\n                continue;\n            }\n            add(`\\\\${c}`);\n            continue;\n        }\n\n        if (c === '*') {\n            if (n === '(' && extended) {\n                ext.push(c);\n                continue;\n            }\n            // Move over all consecutive \"*\"'s.\n            // Also store the previous and next characters\n            let prevChar = glob[i - 1];\n            let starCount = 1;\n            while (glob[i + 1] === '*') {\n                starCount++;\n                i++;\n            }\n            let nextChar = glob[i + 1];\n            if (!globstar) {\n                // globstar is disabled, so treat any number of \"*\" as one\n                add('.*');\n            } else {\n                // globstar is enabled, so determine if this is a globstar segment\n                let isGlobstar =\n                    starCount > 1 && // multiple \"*\"'s\n                    (prevChar === '/' || prevChar === undefined) && // from the start of the segment\n                    (nextChar === '/' || nextChar === undefined); // to the end of the segment\n                if (isGlobstar) {\n                    // it's a globstar, so match zero or more path segments\n                    add(GLOBSTAR, {only:'regex'});\n                    add(GLOBSTAR_SEGMENT, {only:'path', last:true, split:true});\n                    i++; // move over the \"/\"\n                } else {\n                    // it's not a globstar, so only match one path segment\n                    add(WILDCARD, {only:'regex'});\n                    add(WILDCARD_SEGMENT, {only:'path'});\n                }\n            }\n            continue;\n        }\n\n        add(c);\n    }\n\n\n    // When regexp 'g' flag is specified don't\n    // constrain the regular expression with ^ & $\n    if (!flags.includes('g')) {\n        regex = `^${regex}$`;\n        segment = `^${segment}$`;\n        if (filepath) path.regex = `^${path.regex}$`;\n    }\n\n    const result = {regex: new RegExp(regex, flags)};\n\n    // Push the last segment\n    if (filepath) {\n        path.segments.push(new RegExp(segment, flags));\n        path.regex = new RegExp(path.regex, flags);\n        path.globstar = new RegExp(!flags.includes('g') ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags);\n        result.path = path;\n    }\n\n    return result;\n}\n\nmodule.exports = globrex;\n"}},"license":{"file":{"contents":"MIT License\n\nCopyright (c) 2018 Terkel Gjervig Nielsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"globrex\",\n  \"version\": \"0.1.2\",\n  \"description\": \"Glob to regular expression with support for extended globs\",\n  \"main\": \"index.js\",\n  \"author\": \"Terkel Gjervig\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/terkelg/globrex\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"keywords\": [\n    \"glob\",\n    \"regex\",\n    \"regexp\",\n    \"parser\",\n    \"glob2regx\",\n    \"compiler\"\n  ],\n  \"scripts\": {\n    \"test\": \"tape test/*.js | tap-spec\"\n  },\n  \"devDependencies\": {\n    \"tap-spec\": \"^4.1.1\",\n    \"tape\": \"^4.8.0\"\n  }\n}\n"}},"readme.md":{"file":{"contents":"<div align=\"center\">\n  <img src=\"https://github.com/terkelg/globrex/raw/master/globrex.png\" alt=\"globrex\" width=\"500\" />\n</div>\n\n<h1 align=\"center\">globrex</h1>\n\n<div align=\"center\">\n  <a href=\"https://npmjs.org/package/globrex\">\n    <img src=\"https://img.shields.io/npm/v/globrex.svg\" alt=\"version\" />\n  </a>\n  <a href=\"https://travis-ci.org/terkelg/globrex\">\n    <img src=\"https://img.shields.io/travis/terkelg/globrex.svg\" alt=\"travis\" />\n  </a>\n  <a href=\"https://ci.appveyor.com/project/terkelg/globrex\">\n    <img src=\"https://ci.appveyor.com/api/projects/status/ecbnb3whibj5iqcj?svg=true\" alt=\"appveyor\" />\n  </a>\n  <a href=\"https://npmjs.org/package/globrex\">\n    <img src=\"https://img.shields.io/npm/dm/globrex.svg\" alt=\"downloads\" />\n  </a>\n</div>\n\n<div align=\"center\">Simple but powerful glob to regular expression compiler.</div>\n\n<br />\n\n\n## Install\n\n```\nnpm install globrex --save\n```\n\n\n## Core Features\n\n- 💪 **extended globbing:** transform advance `ExtGlob` features\n- 📦 **simple**: no dependencies\n- 🛣️ **paths**: split paths into multiple `RegExp` segments\n\n\n## Usage\n\n```js\nconst globrex = require('globrex');\n\nconst result = globrex('p*uck')\n// => { regex: /^p.*uck$/, string: '^p.*uck$', segments: [ /^p.*uck$/ ] }\n\nresult.regex.test('pluck'); // true\n```\n\n\n## API\n\n### globrex(glob, options)\n\nType: `function`<br>\nReturns: `Object`\n\nTransform globs intp regular expressions.\nReturns object with the following properties:\n\n\n#### regex\n\nType: `RegExp`\n\nJavaScript `RegExp` instance.\n\n> **Note**: Read more about how to use [RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) on MDN.\n\n\n#### path\n\nThis property only exists if the option `filepath` is true.\n\n> **Note:** `filepath` is `false` by default\n\n#### path.segments\n\nType: `Array`\n\nArray of `RegExp` instances seperated by `/`. \nThis can be usable when working with file paths or urls. \n\nExample array could be:\n```js\n[ /^foo$/, /^bar$/, /^([^\\/]*)$/, '^baz\\\\.(md|js|txt)$' ]\n```\n\n\n#### path.regex\n\nType: `RegExp`\n\nJavaScript `RegExp` instance build for testign against paths.\nThe regex have different path seperators depending on host OS.\n\n\n### glob\n\nType: `String`\n\nGlob string to transform.\n\n\n### options.extended\n\nType: `Boolean`<br>\nDefault: `false`\n\nEnable all advanced features from `extglob`.\n\nMatching so called \"extended\" globs pattern like single character matching, matching ranges of characters, group matching, etc.\n\n> **Note**: Interprets `[a-d]` as `[abcd]`. To match a literal `-`, include it as first or last character.\n\n\n### options.globstar\n\nType: `Boolean`<br>\nDefault: `false`\n\nWhen globstar is `false` globs like `'/foo/*'` are transformed to the following\n`'^\\/foo\\/.*$'` which will match any string beginning with `'/foo/'`.\n\nWhen the globstar option is `true`, the same `'/foo/*'` glob is transformed to\n`'^\\/foo\\/[^/]*$'` which will match any string beginning with `'/foo/'` that **does not have** a `'/'` to the right of it. `'/foo/*'` will match: `'/foo/bar'`, `'/foo/bar.txt'` but not `'/foo/bar/baz'` or `'/foo/bar/baz.txt'`.\n\n> **Note**: When globstar is `true`, `'/foo/**'` is equivelant to `'/foo/*'` when globstar is `false`.\n\n\n### options.strict\n\nType: `Boolean`<br>\nDefault: `false`\n\nBe forgiving about mutiple slashes, like `///` and make everything after the first `/` optional. This is how bash glob works.\n\n\n### options.flags\n\nType: `String`<br>\nDefault: `''`\n\nRegExp flags (e.g. `'i'` ) to pass to the RegExp constructor.\n\n\n### options.filepath\n\nType: `Boolean`<br>\nDefault: `false`\n\nParse input strings as it was a file path for special path related features. This feature only makes sense if the input is a POSIX path like `/foo/bar/hello.js` or URLs.\n\nWhen `true` the returned object will have an additional `path` object.\n\n- `segment`: Array containing a `RegExp` object for each path segment.\n- `regex`: OS specific file path `RegExp`. Path seperator used is based on the operating system.\n- `globstar`: Regex string used to test for globstars.\n\n> **Note: Please only use forward-slashes in file path glob expressions**\n> Though windows uses either `/` or `\\` as its path separator, only `/`\n> characters are used by this glob implementation.  You must use\n> forward-slashes **only** in glob expressions. Back-slashes will always\n> be interpreted as escape characters, not path separators.\n\n\n## References\n\nLearn more about advanced globbing here\n- [mywiki.wooledge.org/glob](http://mywiki.wooledge.org/glob)\n- [linuxjournal](http://www.linuxjournal.com/content/bash-extended-globbing)\n\n\n## License\n\nMIT © [Terkel Gjervig](https://terkel.com)\n"}}}}