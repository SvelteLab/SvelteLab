{"directory":{".eslintrc.js":{"file":{"contents":"'use strict';\n\nmodule.exports = {\n  extends: '@mscdex/eslint-config',\n};\n"}},".github":{"directory":{"workflows":{"directory":{"ci.yml":{"file":{"contents":"name: CI\n\non:\n  pull_request:\n  push:\n    branches: [ master ]\n\njobs:\n  tests-linux:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        node-version: [10.x, 12.x, 14.x, 16.x]\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n      - name: Install module\n        run: npm install\n      - name: Run tests\n        run: npm test\n"}},"lint.yml":{"file":{"contents":"name: lint\n\non:\n  pull_request:\n  push:\n    branches: [ master ]\n\nenv:\n  NODE_VERSION: 16.x\n\njobs:\n  lint-js:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ env.NODE_VERSION }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n      - name: Install ESLint + ESLint configs/plugins\n        run: npm install --only=dev\n      - name: Lint files\n        run: npm run lint\n"}}}}}},"lib":{"directory":{"sbmh.js":{"file":{"contents":"'use strict';\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nfunction memcmp(buf1, pos1, buf2, pos2, num) {\n  for (let i = 0; i < num; ++i) {\n    if (buf1[pos1 + i] !== buf2[pos2 + i])\n      return false;\n  }\n  return true;\n}\n\nclass SBMH {\n  constructor(needle, cb) {\n    if (typeof cb !== 'function')\n      throw new Error('Missing match callback');\n\n    if (typeof needle === 'string')\n      needle = Buffer.from(needle);\n    else if (!Buffer.isBuffer(needle))\n      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);\n\n    const needleLen = needle.length;\n\n    this.maxMatches = Infinity;\n    this.matches = 0;\n\n    this._cb = cb;\n    this._lookbehindSize = 0;\n    this._needle = needle;\n    this._bufPos = 0;\n\n    this._lookbehind = Buffer.allocUnsafe(needleLen);\n\n    // Initialize occurrence table.\n    this._occ = [\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen, needleLen, needleLen,\n      needleLen, needleLen, needleLen, needleLen\n    ];\n\n    // Populate occurrence table with analysis of the needle, ignoring the last\n    // letter.\n    if (needleLen > 1) {\n      for (let i = 0; i < needleLen - 1; ++i)\n        this._occ[needle[i]] = needleLen - 1 - i;\n    }\n  }\n\n  reset() {\n    this.matches = 0;\n    this._lookbehindSize = 0;\n    this._bufPos = 0;\n  }\n\n  push(chunk, pos) {\n    let result;\n    if (!Buffer.isBuffer(chunk))\n      chunk = Buffer.from(chunk, 'latin1');\n    const chunkLen = chunk.length;\n    this._bufPos = pos || 0;\n    while (result !== chunkLen && this.matches < this.maxMatches)\n      result = feed(this, chunk);\n    return result;\n  }\n\n  destroy() {\n    const lbSize = this._lookbehindSize;\n    if (lbSize)\n      this._cb(false, this._lookbehind, 0, lbSize, false);\n    this.reset();\n  }\n}\n\nfunction feed(self, data) {\n  const len = data.length;\n  const needle = self._needle;\n  const needleLen = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehindSize - 2]\n  let pos = -self._lookbehindSize;\n  const lastNeedleCharPos = needleLen - 1;\n  const lastNeedleChar = needle[lastNeedleCharPos];\n  const end = len - needleLen;\n  const occ = self._occ;\n  const lookbehind = self._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= end) {\n      const nextPos = pos + lastNeedleCharPos;\n      const ch = (nextPos < 0\n                  ? lookbehind[self._lookbehindSize + nextPos]\n                  : data[nextPos]);\n\n      if (ch === lastNeedleChar\n          && matchNeedle(self, data, pos, lastNeedleCharPos)) {\n        self._lookbehindSize = 0;\n        ++self.matches;\n        if (pos > -self._lookbehindSize)\n          self._cb(true, lookbehind, 0, self._lookbehindSize + pos, false);\n        else\n          self._cb(true, undefined, 0, 0, true);\n\n        return (self._bufPos = pos + needleLen);\n      }\n\n      pos += occ[ch];\n    }\n\n    // No match.\n\n    // There's too few data for Boyer-Moore-Horspool to run,\n    // so let's use a different algorithm to skip as much as\n    // we can.\n    // Forward pos until\n    //   the trailing part of lookbehind + data\n    //   looks like the beginning of the needle\n    // or until\n    //   pos == 0\n    while (pos < 0 && !matchNeedle(self, data, pos, len - pos))\n      ++pos;\n\n    if (pos < 0) {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      const bytesToCutOff = self._lookbehindSize + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        self._cb(false, lookbehind, 0, bytesToCutOff, false);\n      }\n\n      self._lookbehindSize -= bytesToCutOff;\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, self._lookbehindSize);\n      lookbehind.set(data, self._lookbehindSize);\n      self._lookbehindSize += len;\n\n      self._bufPos = len;\n      return len;\n    }\n\n    // Discard lookbehind buffer.\n    self._cb(false, lookbehind, 0, self._lookbehindSize, false);\n    self._lookbehindSize = 0;\n  }\n\n  pos += self._bufPos;\n\n  const firstNeedleChar = needle[0];\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= end) {\n    const ch = data[pos + lastNeedleCharPos];\n\n    if (ch === lastNeedleChar\n        && data[pos] === firstNeedleChar\n        && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {\n      ++self.matches;\n      if (pos > 0)\n        self._cb(true, data, self._bufPos, pos, true);\n      else\n        self._cb(true, undefined, 0, 0, true);\n\n      return (self._bufPos = pos + needleLen);\n    }\n\n    pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  while (pos < len) {\n    if (data[pos] !== firstNeedleChar\n        || !memcmp(data, pos, needle, 0, len - pos)) {\n      ++pos;\n      continue;\n    }\n    data.copy(lookbehind, 0, pos, len);\n    self._lookbehindSize = len - pos;\n    break;\n  }\n\n  // Everything until `pos` is guaranteed not to contain needle data.\n  if (pos > 0)\n    self._cb(false, data, self._bufPos, pos < len ? pos : len, true);\n\n  self._bufPos = len;\n  return len;\n}\n\nfunction matchNeedle(self, data, pos, len) {\n  const lb = self._lookbehind;\n  const lbSize = self._lookbehindSize;\n  const needle = self._needle;\n\n  for (let i = 0; i < len; ++i, ++pos) {\n    const ch = (pos < 0 ? lb[lbSize + pos] : data[pos]);\n    if (ch !== needle[i])\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n"}}}},"LICENSE":{"file":{"contents":"Copyright Brian White. All rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including without limitation the\r\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\nsell copies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\nIN THE SOFTWARE."}},"package.json":{"file":{"contents":"{\n  \"name\": \"streamsearch\",\n  \"version\": \"1.1.0\",\n  \"author\": \"Brian White <mscdex@mscdex.net>\",\n  \"description\": \"Streaming Boyer-Moore-Horspool searching for node.js\",\n  \"main\": \"./lib/sbmh.js\",\n  \"engines\": {\n    \"node\": \">=10.0.0\"\n  },\n  \"devDependencies\": {\n    \"@mscdex/eslint-config\": \"^1.1.0\",\n    \"eslint\": \"^7.32.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node test/test.js\",\n    \"lint\": \"eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js lib test\",\n    \"lint:fix\": \"npm run lint -- --fix\"\n  },\n  \"keywords\": [\n    \"stream\",\n    \"horspool\",\n    \"boyer-moore-horspool\",\n    \"boyer-moore\",\n    \"search\"\n  ],\n  \"licenses\": [{\n    \"type\": \"MIT\",\n    \"url\": \"http://github.com/mscdex/streamsearch/raw/master/LICENSE\"\n  }],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"http://github.com/mscdex/streamsearch.git\"\n  }\n}\n"}},"README.md":{"file":{"contents":"Description\n===========\n\nstreamsearch is a module for [node.js](http://nodejs.org/) that allows searching a stream using the Boyer-Moore-Horspool algorithm.\n\nThis module is based heavily on the Streaming Boyer-Moore-Horspool C++ implementation by Hongli Lai [here](https://github.com/FooBarWidget/boyer-moore-horspool).\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v10.0.0 or newer\n\n\nInstallation\n============\n\n    npm install streamsearch\n\nExample\n=======\n\n```js\n  const { inspect } = require('util');\n\n  const StreamSearch = require('streamsearch');\n\n  const needle = Buffer.from('\\r\\n');\n  const ss = new StreamSearch(needle, (isMatch, data, start, end) => {\n    if (data)\n      console.log('data: ' + inspect(data.toString('latin1', start, end)));\n    if (isMatch)\n      console.log('match!');\n  });\n\n  const chunks = [\n    'foo',\n    ' bar',\n    '\\r',\n    '\\n',\n    'baz, hello\\r',\n    '\\n world.',\n    '\\r\\n Node.JS rules!!\\r\\n\\r\\n',\n  ];\n  for (const chunk of chunks)\n    ss.push(Buffer.from(chunk));\n\n  // output:\n  //\n  // data: 'foo'\n  // data: ' bar'\n  // match!\n  // data: 'baz, hello'\n  // match!\n  // data: ' world.'\n  // match!\n  // data: ' Node.JS rules!!'\n  // match!\n  // data: ''\n  // match!\n```\n\n\nAPI\n===\n\nProperties\n----------\n\n* **maxMatches** - < _integer_ > - The maximum number of matches. Defaults to `Infinity`.\n\n* **matches** - < _integer_ > - The current match count.\n\n\nFunctions\n---------\n\n* **(constructor)**(< _mixed_ >needle, < _function_ >callback) - Creates and returns a new instance for searching for a _Buffer_ or _string_ `needle`. `callback` is called any time there is non-matching data and/or there is a needle match. `callback` will be called with the following arguments:\n\n  1. `isMatch` - _boolean_ - Indicates whether a match has been found\n\n  2. `data` - _mixed_ - If set, this contains data that did not match the needle.\n\n  3. `start` - _integer_ - The index in `data` where the non-matching data begins (inclusive).\n\n  4. `end` - _integer_ - The index in `data` where the non-matching data ends (exclusive).\n\n  5. `isSafeData` - _boolean_ - Indicates if it is safe to store a reference to `data` (e.g. as-is or via `data.slice()`) or not, as in some cases `data` may point to a Buffer whose contents change over time.\n\n* **destroy**() - _(void)_ - Emits any last remaining unmatched data that may still be buffered and then resets internal state.\n\n* **push**(< _Buffer_ >chunk) - _integer_ - Processes `chunk`, searching for a match. The return value is the last processed index in `chunk` + 1.\n\n* **reset**() - _(void)_ - Resets internal state. Useful for when you wish to start searching a new/different stream for example.\n\n"}},"test":{"directory":{"test.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\n\nconst StreamSearch = require('../lib/sbmh.js');\n\n[\n  {\n    needle: '\\r\\n',\n    chunks: [\n      'foo',\n      ' bar',\n      '\\r',\n      '\\n',\n      'baz, hello\\r',\n      '\\n world.',\n      '\\r\\n Node.JS rules!!\\r\\n\\r\\n',\n    ],\n    expect: [\n      [false, 'foo'],\n      [false, ' bar'],\n      [ true, null],\n      [false, 'baz, hello'],\n      [ true, null],\n      [false, ' world.'],\n      [ true, null],\n      [ true, ' Node.JS rules!!'],\n      [ true, ''],\n    ],\n  },\n  {\n    needle: '---foobarbaz',\n    chunks: [\n      '---foobarbaz',\n      'asdf',\n      '\\r\\n',\n      '---foobarba',\n      '---foobar',\n      'ba',\n      '\\r\\n---foobarbaz--\\r\\n',\n    ],\n    expect: [\n      [ true, null],\n      [false, 'asdf'],\n      [false, '\\r\\n'],\n      [false, '---foobarba'],\n      [false, '---foobarba'],\n      [ true, '\\r\\n'],\n      [false, '--\\r\\n'],\n    ],\n  },\n].forEach((test, i) => {\n  console.log(`Running test #${i + 1}`);\n  const { needle, chunks, expect } = test;\n\n  const results = [];\n  const ss = new StreamSearch(Buffer.from(needle),\n                              (isMatch, data, start, end) => {\n    if (data)\n      data = data.toString('latin1', start, end);\n    else\n      data = null;\n    results.push([isMatch, data]);\n  });\n\n  for (const chunk of chunks)\n    ss.push(Buffer.from(chunk));\n\n  assert.deepStrictEqual(results, expect);\n});\n"}}}}}}