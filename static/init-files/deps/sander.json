{"directory":{"CHANGELOG.md":{"file":{"contents":"# changelog\n\n## 0.5.1\n\n* Update dependencies\n\n## 0.5.0\n\n* Update dependencies\n* Simplify build process\n\n## 0.4.0\n\n* Add ES6 build\n\n## 0.3.8\n\n* `sander.writeFile` and `sander.appendFile` return promises that resolve with the data written or appended\n\n## 0.3.7\n\n* Previous version introduced a bug that affected older versions of Node.js – now fixed\n\n## 0.3.6\n\n* In Node.js 4, buffers are created in JavaScript – replace `!== '[object Buffer]'` check with `=== '[object Object]'`\n\n## 0.3.5\n\n* `sander.writeFile` and `sander.appendFile`, and their sync equivalents, can take a final `options` argument specifying e.g. encoding ([#6](https://github.com/Rich-Harris/sander/pull/6))\n\n## 0.3.4\n\n* Fix `symlinkOrCopy` on Windows ([#4](https://github.com/Rich-Harris/sander/pull/4)) - thanks [@clintwood](https://github.com/clintwood)\n\n## 0.3.3\n\n* Reinstate graceful-fs to avoid EMFILE errors\n\n## 0.3.2\n\n* Create intermediate directories when symlinking\n\n## 0.3.1\n\n* Include dist files in npm package. (Whoops!)\n\n## 0.3.0\n\n* Rewrote as ES6 modules\n* Added `symlinkOrCopy` and `symlinkOrCopySync` methods, inspired by [symlink-or-copy](https://github.com/broccolijs/node-symlink-or-copy)\n\n## 0.2.4\n\n* Add `appendFile` and `appendFileSync` methods ([#2](https://github.com/Rich-Harris/sander/issues/2))\n\n## 0.2.2-0.2.3\n\n* Appeasing the npm gods\n\n## 0.2.1\n\n* `sander.copydir()` no longer fails with empty directories\n\n## 0.2.0\n\n* Now using [graceful-fs](https://github.com/isaacs/node-graceful-fs), to prevent EMFILE errors from ruining your day\n* Intermediate directories are created by `sander.link()`, `sander.rename()` and their synchronous equivalents\n"}},"dist":{"directory":{"sander.cjs.js":{"file":{"contents":"'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar fs = require('graceful-fs');\nvar es6Promise = require('es6-promise');\nvar path = require('path');\nvar mkdirp = _interopDefault(require('mkdirp'));\nvar fs$1 = require('fs');\nvar _rimraf = _interopDefault(require('rimraf'));\n\nfunction resolvePath ( args ) {\n\treturn path.resolve.apply( null, args );\n}\n\nfunction normaliseArguments ( args ) {\n\tvar len = args.length;\n\n\tvar buildingPath = true;\n\tvar pathargs = [];\n\tvar normalised = [ null ]; // null is a placeholder for the resolved path\n\tvar i;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( buildingPath && typeof args[i] === 'string' ) {\n\t\t\tpathargs[i] = args[i];\n\t\t} else {\n\t\t\tbuildingPath = false;\n\t\t\tnormalised.push( args[i] );\n\t\t}\n\t}\n\n\tnormalised[0] = resolvePath( pathargs );\n\n\treturn normalised;\n}\n\nfunction asyncMethod ( methodName ) {\n\treturn function () {\n\t\tvar args = normaliseArguments( arguments );\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\targs.push( function ( err, result ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}\n\nfunction syncMethod ( methodName ) {\n\treturn function () {\n\t\tvar args = normaliseArguments( arguments );\n\t\treturn fs[ methodName ].apply( fs, args );\n\t};\n}\n\nfunction asyncFileDescriptorMethod ( methodName ) {\n\treturn function () {\n\t\tvar arguments$1 = arguments;\n\n\t\tvar args = [];\n\t\tvar i = arguments.length;\n\n\t\twhile ( i-- ) {\n\t\t\targs[i] = arguments$1[i];\n\t\t}\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\targs.push( function ( err, result ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}\n\nfunction resolvePathAndOptions ( args ) {\n\tvar options;\n\tvar pathargs;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\n\t\tvar i = args.length - 1;\n\t\tpathargs = new Array( i );\n\n\t\twhile ( i-- ) {\n\t\t\tpathargs[i] = args[i];\n\t\t}\n\t} else {\n\t\toptions = {};\n\t\tpathargs = args;\n\t}\n\n\tvar resolvedPath = path.resolve.apply( null, pathargs );\n\n\treturn { options: options, resolvedPath: resolvedPath };\n}\n\nfunction createReadStream$1 () {\n\tvar ref = resolvePathAndOptions( arguments ), resolvedPath = ref.resolvedPath, options = ref.options;\n\treturn fs.createReadStream( resolvedPath, options );\n}\n\nfunction createWriteStream$1 () {\n\tvar ref = resolvePathAndOptions( arguments ), resolvedPath = ref.resolvedPath, options = ref.options;\n\n\tmkdirp.sync( path.dirname( resolvedPath ) );\n\treturn fs.createWriteStream( resolvedPath, options );\n}\n\nfunction exists () {\n\tvar target = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil ) {\n\t\tfs.exists( target, function ( exists ) { return fulfil( exists ); } );\n\t});\n}\n\nfunction existsSync () {\n\treturn fs.existsSync( resolvePath( arguments ) );\n}\n\nvar rename = asyncMethod$1( 'rename' );\nvar link = asyncMethod$1( 'link' );\n\nvar renameSync = syncMethod$1( 'renameSync' );\nvar linkSync = syncMethod$1( 'linkSync' );\n\nfunction asyncMethod$1 ( methodName ) {\n\treturn function () {\n\t\tvar src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar dest = resolvePath( arguments );\n\n\t\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\t\tmkdirp( path.dirname( dest ), function ( err ) {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs[ methodName ]( src, dest, function ( err ) {\n\t\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction syncMethod$1 ( methodName ) {\n\treturn function () {\n\t\tvar src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar dest = resolvePath( arguments );\n\n\t\t\t\tmkdirp.sync( path.dirname( dest ) );\n\t\t\t\treturn fs[ methodName ]( src, dest );\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction mkdir () {\n\tvar dir = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\tmkdirp( dir, function ( err ) {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction mkdirSync () {\n\tvar dir = resolvePath( arguments );\n\tmkdirp.sync( dir );\n}\n\nfunction normaliseArguments$1 ( args ) {\n\tvar options;\n\tvar flags;\n\tvar i;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\t\tflags = args[ args.length - 2 ];\n\t\ti = args.length - 2;\n\t} else {\n\t\toptions = {};\n\t\tflags = args[ args.length - 1 ];\n\t\ti = args.length - 1;\n\t}\n\n\tvar pathargs = new Array( i );\n\twhile ( i-- ) {\n\t\tpathargs[i] = args[i];\n\t}\n\n\tvar resolvedPath = resolvePath( pathargs );\n\n\treturn { resolvedPath: resolvedPath, options: options, flags: flags };\n}\n\nfunction bailIfExists ( src, flags, mode ) {\n\tvar alreadyExists;\n\n\ttry {\n\t\tfs.statSync( src );\n\t\talreadyExists = true;\n\t} catch ( err ) {\n\t\tif ( err.code !== 'ENOENT' ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif ( alreadyExists ) {\n\t\t// attempt the operation = that way, we get the intended error message\n\t\t// TODO can't we just do this in the first place?\n\t\tfs.openSync( src, flags, mode );\n\t}\n}\n\nfunction open () {\n\tvar ref = normaliseArguments$1( arguments ), src = ref.resolvedPath, options = ref.options, flags = ref.flags;\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\tfunction open () {\n\t\t\tfs.open( src, flags, options.mode, function ( err, fd ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( fd );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// create dirs if necessary\n\t\tif ( /^[wa]/.test( flags ) ) {\n\t\t\tmkdirp( path.dirname( src ), function ( err ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\topen();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\topen();\n\t\t}\n\t});\n}\n\n\nfunction openSync () {\n\tvar ref = normaliseArguments$1( arguments ), src = ref.resolvedPath, options = ref.options, flags = ref.flags;\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\t// create dirs if necessary\n\tif ( /^[wa]/.test( flags ) ) {\n\t\tmkdirp.sync( path.dirname( src ) );\n\t}\n\n\treturn fs.openSync( src, flags, options.mode );\n}\n\nfunction symlink () {\n\tvar src = resolvePath( arguments );\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), options = ref.options, dest = ref.resolvedPath;\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tmkdirp( path.dirname( dest ), function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.symlink( src, dest, options.type, function ( err ) {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction symlinkSync () {\n\tvar src = resolvePath( arguments );\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), options = ref.options, dest = ref.resolvedPath;\n\t\t\tmkdirp.sync( path.dirname( dest ) );\n\t\t\treturn fs.symlinkSync( src, dest, options.type );\n\t\t}\n\t};\n}\n\nvar writeFile = asyncMethod$2( 'writeFile' );\nvar appendFile = asyncMethod$2( 'appendFile' );\n\nvar writeFileSync = syncMethod$2( 'writeFileSync' );\nvar appendFileSync = syncMethod$2( 'appendFileSync' );\n\nfunction normaliseArguments$2 ( args ) {\n\targs = Array.prototype.slice.call( args, 0 );\n\tvar opts = {};\n\n\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\n\t\topts = args.pop();\n\t}\n\n\treturn { opts: opts, data: args.pop(), dest: resolvePath( args ) };\n}\n\nfunction asyncMethod$2 ( methodName ) {\n\treturn function () {\n\t\tvar ref = normaliseArguments$2( arguments ), dest = ref.dest, data = ref.data, opts = ref.opts;\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\tmkdirp( path.dirname( dest ), function ( err ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfs[ methodName ]( dest, data, opts, function ( err ) {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfulfil( data );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction syncMethod$2 ( methodName ) {\n\treturn function () {\n\t\tvar ref = normaliseArguments$2( arguments ), dest = ref.dest, data = ref.data;\n\n\t\tmkdirp.sync( path.dirname( dest ) );\n\t\treturn fs[ methodName ]( dest, data );\n\t};\n}\n\nfunction copydir () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tfunction copydir ( src, dest, cb ) {\n\t\t\t\tmkdirp( dest, function ( err ) {\n\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\tfs.readdir( src, function ( err, files ) {\n\t\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\t\tvar remaining = files.length;\n\n\t\t\t\t\t\tif ( !remaining ) return cb();\n\n\t\t\t\t\t\tfunction check ( err ) {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treturn cb( err );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( !--remaining ) {\n\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfiles.forEach( function ( filename ) {\n\t\t\t\t\t\t\tvar srcpath = src + path.sep + filename;\n\t\t\t\t\t\t\tvar destpath = dest + path.sep + filename;\n\n\t\t\t\t\t\t\tfs.stat( srcpath, function ( err, stats ) {\n\t\t\t\t\t\t\t\tvar readStream, writeStream;\n\n\t\t\t\t\t\t\t\tif ( stats.isDirectory() ) {\n\t\t\t\t\t\t\t\t\treturn copydir( srcpath, destpath, check );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treadStream = fs.createReadStream( srcpath, readOptions );\n\t\t\t\t\t\t\t\twriteStream = fs.createWriteStream( destpath, writeOptions );\n\n\t\t\t\t\t\t\t\treadStream.on( 'error', cb );\n\t\t\t\t\t\t\t\twriteStream.on( 'error', cb );\n\n\t\t\t\t\t\t\t\twriteStream.on( 'close', check );\n\n\t\t\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tcopydir( src, dest, function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfulfil();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copydirSync () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tfunction copydir ( src, dest ) {\n\t\t\t\tmkdirp.sync( dest );\n\n\t\t\t\tfs.readdirSync( src ).forEach( function ( filename ) {\n\t\t\t\t\tvar srcpath = src + path.sep + filename;\n\t\t\t\t\tvar destpath = dest + path.sep + filename;\n\n\t\t\t\t\tif ( fs.statSync( srcpath ).isDirectory() ) {\n\t\t\t\t\t\treturn copydir( srcpath, destpath );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = fs.readFileSync( srcpath, readOptions );\n\t\t\t\t\tfs.writeFileSync( destpath, data, writeOptions );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcopydir( src, dest );\n\t\t}\n\t};\n}\n\nfunction copyFile () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tmkdirp( path.dirname( dest ), function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar readStream = fs.createReadStream( src, readOptions );\n\t\t\t\t\t\tvar writeStream = fs.createWriteStream( dest, writeOptions );\n\n\t\t\t\t\t\treadStream.on( 'error', reject );\n\t\t\t\t\t\twriteStream.on( 'error', reject );\n\n\t\t\t\t\t\twriteStream.on( 'close', fulfil );\n\n\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copyFileSync () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tvar data = fs.readFileSync( src, readOptions );\n\n\t\t\tmkdirp.sync( path.dirname( dest ) );\n\t\t\tfs.writeFileSync( dest, data, writeOptions );\n\t\t}\n\t};\n}\n\nfunction walk ( dir, callback ) {\n\tvar results = [];\n\n\tfs$1.readdir( dir, function ( err, files ) {\n\t\tif ( err ) return callback( err );\n\n\t\tvar pending = files.length;\n\t\tif ( !pending ) return callback( null, results );\n\n\t\tfiles.forEach( function ( file ) {\n\t\t\tfile = path.resolve( dir, file );\n\n\t\t\tfs$1.stat( file, function ( err, stats ) {\n\t\t\t\tif ( stats && stats.isDirectory() ) {\n\t\t\t\t\twalk( file, function ( err, res ) {\n\t\t\t\t\t\tresults = results.concat( res );\n\t\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresults.push( file );\n\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\nfunction lsr () {\n\tvar basedir = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\twalk( basedir, function ( err, result ) {\n\t\t\tif ( err ) return reject( err );\n\n\t\t\t// files should be relative to basedir\n\t\t\tvar index = basedir.length + 1;\n\t\t\tvar i = result.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tresult[i] = result[i].substring( index );\n\t\t\t}\n\n\t\t\tfulfil( result );\n\t\t});\n\t});\n}\n\nfunction lsrSync () {\n\tvar basedir = resolvePath( arguments );\n\n\tvar result = [];\n\n\tfunction processdir ( dir ) {\n\t\tfs$1.readdirSync( dir ).forEach( function ( file ) {\n\t\t\tvar filepath = dir + path.sep + file;\n\n\t\t\tif ( fs$1.statSync( filepath ).isDirectory() ) {\n\t\t\t\tprocessdir( filepath );\n\t\t\t} else {\n\t\t\t\tresult.push( filepath.replace( basedir + path.sep, '' ) );\n\t\t\t}\n\t\t});\n\t}\n\n\tprocessdir( basedir );\n\treturn result;\n}\n\nfunction rimraf () {\n\tvar target = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\t_rimraf( target, function ( err ) {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction rimrafSync () {\n\t_rimraf.sync( resolvePath( arguments ) );\n}\n\nvar isWindows = process.platform === 'win32';\n\nfunction symlinkOrCopy () {\n\tvar arguments$1 = arguments;\n\n\tif ( isWindows ) {\n\t\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\t\tvar copyDirOrFileTo = stat( src )\n\t\t\t.then( function ( stats ) {\n\t\t\t\treturn ( stats.isDirectory() ? copydir : copyFile )\n\t\t\t\t\t.apply( null, arguments$1 )\n\t\t\t\t\t.to;\n\t\t\t});\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar arguments$1 = arguments;\n\n\t\t\t\treturn copyDirOrFileTo\n\t\t\t\t\t.then(function ( fn ) {\n\t\t\t\t\t\treturn fn.apply(null, arguments$1);\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\treturn symlink.apply( null, arguments );\n}\n\nfunction symlinkOrCopySync () {\n\tif ( isWindows ) {\n\t\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\t\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\n\t}\n\n\treturn symlinkSync.apply( null, arguments );\n}\n\n// standard async methods\nvar chmod = asyncMethod( 'chmod' );\nvar chown = asyncMethod( 'chown' );\nvar lchmod = asyncMethod( 'lchmod' );\nvar lchown = asyncMethod( 'lchown' );\nvar lstat = asyncMethod( 'lstat' );\nvar readdir = asyncMethod( 'readdir' );\nvar readFile = asyncMethod( 'readFile' );\nvar readlink = asyncMethod( 'readlink' );\nvar realpath = asyncMethod( 'realpath' );\nvar rmdir = asyncMethod( 'rmdir' );\nvar stat = asyncMethod( 'stat' );\nvar truncate = asyncMethod( 'truncate' );\nvar unlink = asyncMethod( 'unlink' );\nvar utimes = asyncMethod( 'utimes' );\nvar unwatchFile = asyncMethod( 'unwatchFile' );\nvar watch = asyncMethod( 'watch' );\nvar watchFile = asyncMethod( 'watchFile' );\n\n// standard sync methods\nvar chmodSync = syncMethod( 'chmodSync' );\nvar chownSync = syncMethod( 'chownSync' );\nvar lchmodSync = syncMethod( 'lchmodSync' );\nvar lchownSync = syncMethod( 'lchownSync' );\nvar lstatSync = syncMethod( 'lstatSync' );\nvar readdirSync = syncMethod( 'readdirSync' );\nvar readFileSync = syncMethod( 'readFileSync' );\nvar readlinkSync = syncMethod( 'readlinkSync' );\nvar realpathSync = syncMethod( 'realpathSync' );\nvar rmdirSync = syncMethod( 'rmdirSync' );\nvar statSync = syncMethod( 'statSync' );\nvar truncateSync = syncMethod( 'truncateSync' );\nvar unlinkSync = syncMethod( 'unlinkSync' );\nvar utimesSync = syncMethod( 'utimesSync' );\n\n// file descriptor async methods\nvar close = asyncFileDescriptorMethod( 'close' );\nvar fchmod = asyncFileDescriptorMethod( 'fchmod' );\nvar fchown = asyncFileDescriptorMethod( 'fchown' );\nvar fstat = asyncFileDescriptorMethod( 'fstat' );\nvar fsync = asyncFileDescriptorMethod( 'fsync' );\nvar ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\nvar futimes = asyncFileDescriptorMethod( 'futimes' );\nvar read = asyncFileDescriptorMethod( 'read' );\n\n// file descriptor sync methods\nvar closeSync = fs.closeSync;\nvar fchmodSync = fs.fchmodSync;\nvar fchownSync = fs.fchownSync;\nvar fstatSync = fs.fstatSync;\nvar fsyncSync = fs.fsyncSync;\nvar ftruncateSync = fs.ftruncateSync;\nvar futimesSync = fs.futimesSync;\nvar readSync = fs.readSync;\n\n// expose Promise for convenience\n// https://github.com/esperantojs/esperanto/issues/161\nvar Promise$1 = es6Promise.Promise;\n\nexports.chmod = chmod;\nexports.chown = chown;\nexports.createReadStream = createReadStream$1;\nexports.createWriteStream = createWriteStream$1;\nexports.lchmod = lchmod;\nexports.lchown = lchown;\nexports.lstat = lstat;\nexports.readdir = readdir;\nexports.readFile = readFile;\nexports.readlink = readlink;\nexports.realpath = realpath;\nexports.rmdir = rmdir;\nexports.stat = stat;\nexports.truncate = truncate;\nexports.unlink = unlink;\nexports.utimes = utimes;\nexports.unwatchFile = unwatchFile;\nexports.watch = watch;\nexports.watchFile = watchFile;\nexports.chmodSync = chmodSync;\nexports.chownSync = chownSync;\nexports.lchmodSync = lchmodSync;\nexports.lchownSync = lchownSync;\nexports.lstatSync = lstatSync;\nexports.readdirSync = readdirSync;\nexports.readFileSync = readFileSync;\nexports.readlinkSync = readlinkSync;\nexports.realpathSync = realpathSync;\nexports.rmdirSync = rmdirSync;\nexports.statSync = statSync;\nexports.truncateSync = truncateSync;\nexports.unlinkSync = unlinkSync;\nexports.utimesSync = utimesSync;\nexports.close = close;\nexports.fchmod = fchmod;\nexports.fchown = fchown;\nexports.fstat = fstat;\nexports.fsync = fsync;\nexports.ftruncate = ftruncate;\nexports.futimes = futimes;\nexports.read = read;\nexports.closeSync = closeSync;\nexports.fchmodSync = fchmodSync;\nexports.fchownSync = fchownSync;\nexports.fstatSync = fstatSync;\nexports.fsyncSync = fsyncSync;\nexports.ftruncateSync = ftruncateSync;\nexports.futimesSync = futimesSync;\nexports.readSync = readSync;\nexports.Promise = Promise$1;\nexports.exists = exists;\nexports.existsSync = existsSync;\nexports.link = link;\nexports.linkSync = linkSync;\nexports.rename = rename;\nexports.renameSync = renameSync;\nexports.mkdir = mkdir;\nexports.mkdirSync = mkdirSync;\nexports.open = open;\nexports.openSync = openSync;\nexports.symlink = symlink;\nexports.symlinkSync = symlinkSync;\nexports.writeFile = writeFile;\nexports.writeFileSync = writeFileSync;\nexports.appendFile = appendFile;\nexports.appendFileSync = appendFileSync;\nexports.copydir = copydir;\nexports.copydirSync = copydirSync;\nexports.copyFile = copyFile;\nexports.copyFileSync = copyFileSync;\nexports.lsr = lsr;\nexports.lsrSync = lsrSync;\nexports.rimraf = rimraf;\nexports.rimrafSync = rimrafSync;\nexports.symlinkOrCopy = symlinkOrCopy;\nexports.symlinkOrCopySync = symlinkOrCopySync;\n//# sourceMappingURL=sander.cjs.js.map"}},"sander.cjs.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"sander.cjs.js\",\"sources\":[\"../src/utils/resolvePath.js\",\"../src/methodMakers/standardMethod.js\",\"../src/methodMakers/fileDescriptorMethod.js\",\"../src/utils/resolvePathAndOptions.js\",\"../src/specialMethods/createReadStream-createWriteStream.js\",\"../src/specialMethods/exists.js\",\"../src/specialMethods/link-rename.js\",\"../src/specialMethods/mkdir.js\",\"../src/specialMethods/open.js\",\"../src/specialMethods/symlink.js\",\"../src/specialMethods/writeFile-appendFile.js\",\"../src/extraMethods/copydir.js\",\"../src/extraMethods/copyFile.js\",\"../src/extraMethods/lsr.js\",\"../src/extraMethods/rimraf.js\",\"../src/extraMethods/symlinkOrCopy.js\",\"../src/sander.js\"],\"sourcesContent\":[\"import { resolve } from 'path';\\n\\nexport default function resolvePath ( args ) {\\n\\treturn resolve.apply( null, args );\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tconst len = args.length;\\n\\n\\tlet buildingPath = true;\\n\\tlet pathargs = [];\\n\\tlet normalised = [ null ]; // null is a placeholder for the resolved path\\n\\tlet i;\\n\\n\\tfor ( i = 0; i < len; i += 1 ) {\\n\\t\\tif ( buildingPath && typeof args[i] === 'string' ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t} else {\\n\\t\\t\\tbuildingPath = false;\\n\\t\\t\\tnormalised.push( args[i] );\\n\\t\\t}\\n\\t}\\n\\n\\tnormalised[0] = resolvePath( pathargs );\\n\\n\\treturn normalised;\\n}\\n\\nexport function asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\\n\\nexport function syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\t\\treturn fs[ methodName ].apply( fs, args );\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\n\\nexport function asyncFileDescriptorMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tlet args = [];\\n\\t\\tlet i = arguments.length;\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\",\"import { resolve } from 'path';\\n\\nexport default function resolvePathAndOptions ( args ) {\\n\\tlet options;\\n\\tlet pathargs;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\n\\t\\tlet i = args.length - 1;\\n\\t\\tpathargs = new Array( i );\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t}\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tpathargs = args;\\n\\t}\\n\\n\\tconst resolvedPath = resolve.apply( null, pathargs );\\n\\n\\treturn { options, resolvedPath };\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function createReadStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\treturn fs.createReadStream( resolvedPath, options );\\n}\\n\\nexport function createWriteStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\n\\tmkdirp.sync( dirname( resolvedPath ) );\\n\\treturn fs.createWriteStream( resolvedPath, options );\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function exists () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( fulfil => {\\n\\t\\tfs.exists( target, exists => fulfil( exists ) );\\n\\t});\\n}\\n\\nexport function existsSync () {\\n\\treturn fs.existsSync( resolvePath( arguments ) );\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const rename = asyncMethod( 'rename' );\\nexport const link = asyncMethod( 'link' );\\n\\nexport const renameSync = syncMethod( 'renameSync' );\\nexport const linkSync = syncMethod( 'linkSync' );\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfs[ methodName ]( src, dest, err => {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\t\\treturn fs[ methodName ]( src, dest );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\",\"import mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function mkdir () {\\n\\tconst dir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tmkdirp( dir, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function mkdirSync () {\\n\\tconst dir = resolvePath( arguments );\\n\\tmkdirp.sync( dir );\\n}\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tlet options;\\n\\tlet flags;\\n\\tlet i;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\t\\tflags = args[ args.length - 2 ];\\n\\t\\ti = args.length - 2;\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tflags = args[ args.length - 1 ];\\n\\t\\ti = args.length - 1;\\n\\t}\\n\\n\\tlet pathargs = new Array( i );\\n\\twhile ( i-- ) {\\n\\t\\tpathargs[i] = args[i];\\n\\t}\\n\\n\\tconst resolvedPath = resolvePath( pathargs );\\n\\n\\treturn { resolvedPath, options, flags };\\n}\\n\\nfunction bailIfExists ( src, flags, mode ) {\\n\\tlet alreadyExists;\\n\\n\\ttry {\\n\\t\\tfs.statSync( src );\\n\\t\\talreadyExists = true;\\n\\t} catch ( err ) {\\n\\t\\tif ( err.code !== 'ENOENT' ) {\\n\\t\\t\\tthrow err;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( alreadyExists ) {\\n\\t\\t// attempt the operation = that way, we get the intended error message\\n\\t\\t// TODO can't we just do this in the first place?\\n\\t\\tfs.openSync( src, flags, mode );\\n\\t}\\n}\\n\\nexport function open () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tfunction open () {\\n\\t\\t\\tfs.open( src, flags, options.mode, ( err, fd ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( fd );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// create dirs if necessary\\n\\t\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\t\\tmkdirp( dirname( src ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\topen();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\topen();\\n\\t\\t}\\n\\t});\\n}\\n\\n\\nexport function openSync () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\t// create dirs if necessary\\n\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\tmkdirp.sync( dirname( src ) );\\n\\t}\\n\\n\\treturn fs.openSync( src, flags, options.mode );\\n}\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function symlink () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfs.symlink( src, dest, options.type, err => {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function symlinkSync () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\treturn fs.symlinkSync( src, dest, options.type );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const writeFile = asyncMethod( 'writeFile' );\\nexport const appendFile = asyncMethod( 'appendFile' );\\n\\nexport const writeFileSync = syncMethod( 'writeFileSync' );\\nexport const appendFileSync = syncMethod( 'appendFileSync' );\\n\\nfunction normaliseArguments ( args ) {\\n\\targs = Array.prototype.slice.call( args, 0 );\\n\\tlet opts = {};\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\\n\\t\\topts = args.pop();\\n\\t}\\n\\n\\treturn { opts, data: args.pop(), dest: resolvePath( args ) };\\n}\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data, opts } = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfs[ methodName ]( dest, data, opts, err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfulfil( data );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data } = normaliseArguments( arguments );\\n\\n\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\treturn fs[ methodName ]( dest, data );\\n\\t};\\n}\\n\",\"import { sep } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copydir () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest, cb ) {\\n\\t\\t\\t\\tmkdirp( dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\tfs.readdir( src, ( err, files ) => {\\n\\t\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\t\\tlet remaining = files.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( !remaining ) return cb();\\n\\n\\t\\t\\t\\t\\t\\tfunction check ( err ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cb( err );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !--remaining ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcb();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfiles.forEach( function ( filename ) {\\n\\t\\t\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\t\\t\\tfs.stat( srcpath, ( err, stats ) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar readStream, writeStream;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( stats.isDirectory() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath, check );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream = fs.createReadStream( srcpath, readOptions );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream = fs.createWriteStream( destpath, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.on( 'error', cb );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'error', cb );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'close', check );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tcopydir( src, dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copydirSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest ) {\\n\\t\\t\\t\\tmkdirp.sync( dest );\\n\\n\\t\\t\\t\\tfs.readdirSync( src ).forEach( filename => {\\n\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\tif ( fs.statSync( srcpath ).isDirectory() ) {\\n\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconst data = fs.readFileSync( srcpath, readOptions );\\n\\t\\t\\t\\t\\tfs.writeFileSync( destpath, data, writeOptions );\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tcopydir( src, dest );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copyFile () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tconst readStream = fs.createReadStream( src, readOptions );\\n\\t\\t\\t\\t\\t\\tconst writeStream = fs.createWriteStream( dest, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\treadStream.on( 'error', reject );\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'error', reject );\\n\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'close', fulfil );\\n\\n\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copyFileSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tconst data = fs.readFileSync( src, readOptions );\\n\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\tfs.writeFileSync( dest, data, writeOptions );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'fs';\\nimport { resolve, sep } from 'path';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction walk ( dir, callback ) {\\n\\tlet results = [];\\n\\n\\tfs.readdir( dir, ( err, files ) => {\\n\\t\\tif ( err ) return callback( err );\\n\\n\\t\\tlet pending = files.length;\\n\\t\\tif ( !pending ) return callback( null, results );\\n\\n\\t\\tfiles.forEach( file => {\\n\\t\\t\\tfile = resolve( dir, file );\\n\\n\\t\\t\\tfs.stat( file, ( err, stats ) => {\\n\\t\\t\\t\\tif ( stats && stats.isDirectory() ) {\\n\\t\\t\\t\\t\\twalk( file, ( err, res ) => {\\n\\t\\t\\t\\t\\t\\tresults = results.concat( res );\\n\\t\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults.push( file );\\n\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t});\\n};\\n\\nexport function lsr () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\twalk( basedir, function ( err, result ) {\\n\\t\\t\\tif ( err ) return reject( err );\\n\\n\\t\\t\\t// files should be relative to basedir\\n\\t\\t\\tconst index = basedir.length + 1;\\n\\t\\t\\tlet i = result.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tresult[i] = result[i].substring( index );\\n\\t\\t\\t}\\n\\n\\t\\t\\tfulfil( result );\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function lsrSync () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\tlet result = [];\\n\\n\\tfunction processdir ( dir ) {\\n\\t\\tfs.readdirSync( dir ).forEach( file => {\\n\\t\\t\\tconst filepath = dir + sep + file;\\n\\n\\t\\t\\tif ( fs.statSync( filepath ).isDirectory() ) {\\n\\t\\t\\t\\tprocessdir( filepath );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.push( filepath.replace( basedir + sep, '' ) );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\tprocessdir( basedir );\\n\\treturn result;\\n}\",\"import _rimraf from 'rimraf';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function rimraf () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t_rimraf( target, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function rimrafSync () {\\n\\t_rimraf.sync( resolvePath( arguments ) );\\n}\",\"import { stat, statSync } from '../sander';\\nimport { copydir, copydirSync } from './copydir';\\nimport { copyFile, copyFileSync } from './copyFile';\\nimport { symlink, symlinkSync } from '../specialMethods/symlink';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nconst isWindows = process.platform === 'win32';\\n\\nexport function symlinkOrCopy () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\tlet copyDirOrFileTo = stat( src )\\n\\t\\t\\t.then( stats => {\\n\\t\\t\\t\\treturn ( stats.isDirectory() ? copydir : copyFile )\\n\\t\\t\\t\\t\\t.apply( null, arguments )\\n\\t\\t\\t\\t\\t.to;\\n\\t\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\treturn copyDirOrFileTo\\n\\t\\t\\t\\t\\t.then(fn => {\\n\\t\\t\\t\\t\\t\\treturn fn.apply(null, arguments);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\treturn symlink.apply( null, arguments );\\n}\\n\\nexport function symlinkOrCopySync () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\t\\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\\n\\t}\\n\\n\\treturn symlinkSync.apply( null, arguments );\\n}\",\"import * as fs from 'graceful-fs';\\nimport * as es6Promise from 'es6-promise';\\nimport { syncMethod, asyncMethod } from './methodMakers/standardMethod';\\nimport { asyncFileDescriptorMethod } from './methodMakers/fileDescriptorMethod';\\n\\n// standard async methods\\nexport const chmod = asyncMethod( 'chmod' );\\nexport const chown = asyncMethod( 'chown' );\\nexport const createReadStream = asyncMethod( 'createReadStream' );\\nexport const createWriteStream = asyncMethod( 'createWriteStream' );\\nexport const lchmod = asyncMethod( 'lchmod' );\\nexport const lchown = asyncMethod( 'lchown' );\\nexport const lstat = asyncMethod( 'lstat' );\\nexport const readdir = asyncMethod( 'readdir' );\\nexport const readFile = asyncMethod( 'readFile' );\\nexport const readlink = asyncMethod( 'readlink' );\\nexport const realpath = asyncMethod( 'realpath' );\\nexport const rmdir = asyncMethod( 'rmdir' );\\nexport const stat = asyncMethod( 'stat' );\\nexport const truncate = asyncMethod( 'truncate' );\\nexport const unlink = asyncMethod( 'unlink' );\\nexport const utimes = asyncMethod( 'utimes' );\\nexport const unwatchFile = asyncMethod( 'unwatchFile' );\\nexport const watch = asyncMethod( 'watch' );\\nexport const watchFile = asyncMethod( 'watchFile' );\\n\\n// standard sync methods\\nexport const chmodSync = syncMethod( 'chmodSync' );\\nexport const chownSync = syncMethod( 'chownSync' );\\nexport const lchmodSync = syncMethod( 'lchmodSync' );\\nexport const lchownSync = syncMethod( 'lchownSync' );\\nexport const lstatSync = syncMethod( 'lstatSync' );\\nexport const readdirSync = syncMethod( 'readdirSync' );\\nexport const readFileSync = syncMethod( 'readFileSync' );\\nexport const readlinkSync = syncMethod( 'readlinkSync' );\\nexport const realpathSync = syncMethod( 'realpathSync' );\\nexport const rmdirSync = syncMethod( 'rmdirSync' );\\nexport const statSync = syncMethod( 'statSync' );\\nexport const truncateSync = syncMethod( 'truncateSync' );\\nexport const unlinkSync = syncMethod( 'unlinkSync' );\\nexport const utimesSync = syncMethod( 'utimesSync' );\\n\\n// file descriptor async methods\\nexport const close = asyncFileDescriptorMethod( 'close' );\\nexport const fchmod = asyncFileDescriptorMethod( 'fchmod' );\\nexport const fchown = asyncFileDescriptorMethod( 'fchown' );\\nexport const fstat = asyncFileDescriptorMethod( 'fstat' );\\nexport const fsync = asyncFileDescriptorMethod( 'fsync' );\\nexport const ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\\nexport const futimes = asyncFileDescriptorMethod( 'futimes' );\\nexport const read = asyncFileDescriptorMethod( 'read' );\\n\\n// file descriptor sync methods\\nexport const closeSync = fs.closeSync;\\nexport const fchmodSync = fs.fchmodSync;\\nexport const fchownSync = fs.fchownSync;\\nexport const fstatSync = fs.fstatSync;\\nexport const fsyncSync = fs.fsyncSync;\\nexport const ftruncateSync = fs.ftruncateSync;\\nexport const futimesSync = fs.futimesSync;\\nexport const readSync = fs.readSync;\\n\\n// special methods\\nexport { createReadStream, createWriteStream } from './specialMethods/createReadStream-createWriteStream'; // TODO aren't these covered by the standard methods?\\nexport { exists, existsSync } from './specialMethods/exists';\\nexport { link, linkSync, rename, renameSync } from './specialMethods/link-rename';\\nexport { mkdir, mkdirSync } from './specialMethods/mkdir';\\nexport { open, openSync } from './specialMethods/open';\\nexport { symlink, symlinkSync } from './specialMethods/symlink';\\nexport { writeFile, writeFileSync, appendFile, appendFileSync } from './specialMethods/writeFile-appendFile';\\n\\n// extra methods\\nexport { copydir, copydirSync } from './extraMethods/copydir';\\nexport { copyFile, copyFileSync } from './extraMethods/copyFile';\\nexport { lsr, lsrSync } from './extraMethods/lsr';\\nexport { rimraf, rimrafSync } from './extraMethods/rimraf';\\nexport { symlinkOrCopy, symlinkOrCopySync } from './extraMethods/symlinkOrCopy';\\n\\n// expose Promise for convenience\\n// https://github.com/esperantojs/esperanto/issues/161\\nexport const Promise = es6Promise.Promise;\"],\"names\":[\"resolve\",\"const\",\"let\",\"arguments\",\"createReadStream\",\"createWriteStream\",\"dirname\",\"asyncMethod\",\"syncMethod\",\"normaliseArguments\",\"sep\",\"fs\",\"Promise\"],\"mappings\":\"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\"}"}},"sander.es.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport * as es6Promise from 'es6-promise';\nimport { resolve, dirname, sep } from 'path';\nimport mkdirp from 'mkdirp';\nimport * as fs$1 from 'fs';\nimport _rimraf from 'rimraf';\n\nfunction resolvePath ( args ) {\n\treturn resolve.apply( null, args );\n}\n\nfunction normaliseArguments ( args ) {\n\tvar len = args.length;\n\n\tvar buildingPath = true;\n\tvar pathargs = [];\n\tvar normalised = [ null ]; // null is a placeholder for the resolved path\n\tvar i;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( buildingPath && typeof args[i] === 'string' ) {\n\t\t\tpathargs[i] = args[i];\n\t\t} else {\n\t\t\tbuildingPath = false;\n\t\t\tnormalised.push( args[i] );\n\t\t}\n\t}\n\n\tnormalised[0] = resolvePath( pathargs );\n\n\treturn normalised;\n}\n\nfunction asyncMethod ( methodName ) {\n\treturn function () {\n\t\tvar args = normaliseArguments( arguments );\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\targs.push( function ( err, result ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}\n\nfunction syncMethod ( methodName ) {\n\treturn function () {\n\t\tvar args = normaliseArguments( arguments );\n\t\treturn fs[ methodName ].apply( fs, args );\n\t};\n}\n\nfunction asyncFileDescriptorMethod ( methodName ) {\n\treturn function () {\n\t\tvar arguments$1 = arguments;\n\n\t\tvar args = [];\n\t\tvar i = arguments.length;\n\n\t\twhile ( i-- ) {\n\t\t\targs[i] = arguments$1[i];\n\t\t}\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\targs.push( function ( err, result ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}\n\nfunction resolvePathAndOptions ( args ) {\n\tvar options;\n\tvar pathargs;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\n\t\tvar i = args.length - 1;\n\t\tpathargs = new Array( i );\n\n\t\twhile ( i-- ) {\n\t\t\tpathargs[i] = args[i];\n\t\t}\n\t} else {\n\t\toptions = {};\n\t\tpathargs = args;\n\t}\n\n\tvar resolvedPath = resolve.apply( null, pathargs );\n\n\treturn { options: options, resolvedPath: resolvedPath };\n}\n\nfunction createReadStream$1 () {\n\tvar ref = resolvePathAndOptions( arguments ), resolvedPath = ref.resolvedPath, options = ref.options;\n\treturn fs.createReadStream( resolvedPath, options );\n}\n\nfunction createWriteStream$1 () {\n\tvar ref = resolvePathAndOptions( arguments ), resolvedPath = ref.resolvedPath, options = ref.options;\n\n\tmkdirp.sync( dirname( resolvedPath ) );\n\treturn fs.createWriteStream( resolvedPath, options );\n}\n\nfunction exists () {\n\tvar target = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil ) {\n\t\tfs.exists( target, function ( exists ) { return fulfil( exists ); } );\n\t});\n}\n\nfunction existsSync () {\n\treturn fs.existsSync( resolvePath( arguments ) );\n}\n\nvar rename = asyncMethod$1( 'rename' );\nvar link = asyncMethod$1( 'link' );\n\nvar renameSync = syncMethod$1( 'renameSync' );\nvar linkSync = syncMethod$1( 'linkSync' );\n\nfunction asyncMethod$1 ( methodName ) {\n\treturn function () {\n\t\tvar src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar dest = resolvePath( arguments );\n\n\t\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\t\tmkdirp( dirname( dest ), function ( err ) {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs[ methodName ]( src, dest, function ( err ) {\n\t\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction syncMethod$1 ( methodName ) {\n\treturn function () {\n\t\tvar src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar dest = resolvePath( arguments );\n\n\t\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\t\treturn fs[ methodName ]( src, dest );\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction mkdir () {\n\tvar dir = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\tmkdirp( dir, function ( err ) {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction mkdirSync () {\n\tvar dir = resolvePath( arguments );\n\tmkdirp.sync( dir );\n}\n\nfunction normaliseArguments$1 ( args ) {\n\tvar options;\n\tvar flags;\n\tvar i;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\t\tflags = args[ args.length - 2 ];\n\t\ti = args.length - 2;\n\t} else {\n\t\toptions = {};\n\t\tflags = args[ args.length - 1 ];\n\t\ti = args.length - 1;\n\t}\n\n\tvar pathargs = new Array( i );\n\twhile ( i-- ) {\n\t\tpathargs[i] = args[i];\n\t}\n\n\tvar resolvedPath = resolvePath( pathargs );\n\n\treturn { resolvedPath: resolvedPath, options: options, flags: flags };\n}\n\nfunction bailIfExists ( src, flags, mode ) {\n\tvar alreadyExists;\n\n\ttry {\n\t\tfs.statSync( src );\n\t\talreadyExists = true;\n\t} catch ( err ) {\n\t\tif ( err.code !== 'ENOENT' ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif ( alreadyExists ) {\n\t\t// attempt the operation = that way, we get the intended error message\n\t\t// TODO can't we just do this in the first place?\n\t\tfs.openSync( src, flags, mode );\n\t}\n}\n\nfunction open () {\n\tvar ref = normaliseArguments$1( arguments ), src = ref.resolvedPath, options = ref.options, flags = ref.flags;\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\tfunction open () {\n\t\t\tfs.open( src, flags, options.mode, function ( err, fd ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( fd );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// create dirs if necessary\n\t\tif ( /^[wa]/.test( flags ) ) {\n\t\t\tmkdirp( dirname( src ), function ( err ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\topen();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\topen();\n\t\t}\n\t});\n}\n\n\nfunction openSync () {\n\tvar ref = normaliseArguments$1( arguments ), src = ref.resolvedPath, options = ref.options, flags = ref.flags;\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\t// create dirs if necessary\n\tif ( /^[wa]/.test( flags ) ) {\n\t\tmkdirp.sync( dirname( src ) );\n\t}\n\n\treturn fs.openSync( src, flags, options.mode );\n}\n\nfunction symlink () {\n\tvar src = resolvePath( arguments );\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), options = ref.options, dest = ref.resolvedPath;\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tmkdirp( dirname( dest ), function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.symlink( src, dest, options.type, function ( err ) {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction symlinkSync () {\n\tvar src = resolvePath( arguments );\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), options = ref.options, dest = ref.resolvedPath;\n\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\treturn fs.symlinkSync( src, dest, options.type );\n\t\t}\n\t};\n}\n\nvar writeFile = asyncMethod$2( 'writeFile' );\nvar appendFile = asyncMethod$2( 'appendFile' );\n\nvar writeFileSync = syncMethod$2( 'writeFileSync' );\nvar appendFileSync = syncMethod$2( 'appendFileSync' );\n\nfunction normaliseArguments$2 ( args ) {\n\targs = Array.prototype.slice.call( args, 0 );\n\tvar opts = {};\n\n\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\n\t\topts = args.pop();\n\t}\n\n\treturn { opts: opts, data: args.pop(), dest: resolvePath( args ) };\n}\n\nfunction asyncMethod$2 ( methodName ) {\n\treturn function () {\n\t\tvar ref = normaliseArguments$2( arguments ), dest = ref.dest, data = ref.data, opts = ref.opts;\n\n\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\tmkdirp( dirname( dest ), function ( err ) {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfs[ methodName ]( dest, data, opts, function ( err ) {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfulfil( data );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction syncMethod$2 ( methodName ) {\n\treturn function () {\n\t\tvar ref = normaliseArguments$2( arguments ), dest = ref.dest, data = ref.data;\n\n\t\tmkdirp.sync( dirname( dest ) );\n\t\treturn fs[ methodName ]( dest, data );\n\t};\n}\n\nfunction copydir () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tfunction copydir ( src, dest, cb ) {\n\t\t\t\tmkdirp( dest, function ( err ) {\n\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\tfs.readdir( src, function ( err, files ) {\n\t\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\t\tvar remaining = files.length;\n\n\t\t\t\t\t\tif ( !remaining ) return cb();\n\n\t\t\t\t\t\tfunction check ( err ) {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treturn cb( err );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( !--remaining ) {\n\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfiles.forEach( function ( filename ) {\n\t\t\t\t\t\t\tvar srcpath = src + sep + filename;\n\t\t\t\t\t\t\tvar destpath = dest + sep + filename;\n\n\t\t\t\t\t\t\tfs.stat( srcpath, function ( err, stats ) {\n\t\t\t\t\t\t\t\tvar readStream, writeStream;\n\n\t\t\t\t\t\t\t\tif ( stats.isDirectory() ) {\n\t\t\t\t\t\t\t\t\treturn copydir( srcpath, destpath, check );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treadStream = fs.createReadStream( srcpath, readOptions );\n\t\t\t\t\t\t\t\twriteStream = fs.createWriteStream( destpath, writeOptions );\n\n\t\t\t\t\t\t\t\treadStream.on( 'error', cb );\n\t\t\t\t\t\t\t\twriteStream.on( 'error', cb );\n\n\t\t\t\t\t\t\t\twriteStream.on( 'close', check );\n\n\t\t\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tcopydir( src, dest, function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfulfil();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copydirSync () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tfunction copydir ( src, dest ) {\n\t\t\t\tmkdirp.sync( dest );\n\n\t\t\t\tfs.readdirSync( src ).forEach( function ( filename ) {\n\t\t\t\t\tvar srcpath = src + sep + filename;\n\t\t\t\t\tvar destpath = dest + sep + filename;\n\n\t\t\t\t\tif ( fs.statSync( srcpath ).isDirectory() ) {\n\t\t\t\t\t\treturn copydir( srcpath, destpath );\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = fs.readFileSync( srcpath, readOptions );\n\t\t\t\t\tfs.writeFileSync( destpath, data, writeOptions );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcopydir( src, dest );\n\t\t}\n\t};\n}\n\nfunction copyFile () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\treturn new Promise( function ( fulfil, reject ) {\n\t\t\t\tmkdirp( dirname( dest ), function ( err ) {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar readStream = fs.createReadStream( src, readOptions );\n\t\t\t\t\t\tvar writeStream = fs.createWriteStream( dest, writeOptions );\n\n\t\t\t\t\t\treadStream.on( 'error', reject );\n\t\t\t\t\t\twriteStream.on( 'error', reject );\n\n\t\t\t\t\t\twriteStream.on( 'close', fulfil );\n\n\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copyFileSync () {\n\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\treturn {\n\t\tto: function to () {\n\t\t\tvar ref = resolvePathAndOptions( arguments ), dest = ref.resolvedPath, writeOptions = ref.options;\n\n\t\t\tvar data = fs.readFileSync( src, readOptions );\n\n\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\tfs.writeFileSync( dest, data, writeOptions );\n\t\t}\n\t};\n}\n\nfunction walk ( dir, callback ) {\n\tvar results = [];\n\n\tfs$1.readdir( dir, function ( err, files ) {\n\t\tif ( err ) return callback( err );\n\n\t\tvar pending = files.length;\n\t\tif ( !pending ) return callback( null, results );\n\n\t\tfiles.forEach( function ( file ) {\n\t\t\tfile = resolve( dir, file );\n\n\t\t\tfs$1.stat( file, function ( err, stats ) {\n\t\t\t\tif ( stats && stats.isDirectory() ) {\n\t\t\t\t\twalk( file, function ( err, res ) {\n\t\t\t\t\t\tresults = results.concat( res );\n\t\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresults.push( file );\n\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\nfunction lsr () {\n\tvar basedir = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\twalk( basedir, function ( err, result ) {\n\t\t\tif ( err ) return reject( err );\n\n\t\t\t// files should be relative to basedir\n\t\t\tvar index = basedir.length + 1;\n\t\t\tvar i = result.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tresult[i] = result[i].substring( index );\n\t\t\t}\n\n\t\t\tfulfil( result );\n\t\t});\n\t});\n}\n\nfunction lsrSync () {\n\tvar basedir = resolvePath( arguments );\n\n\tvar result = [];\n\n\tfunction processdir ( dir ) {\n\t\tfs$1.readdirSync( dir ).forEach( function ( file ) {\n\t\t\tvar filepath = dir + sep + file;\n\n\t\t\tif ( fs$1.statSync( filepath ).isDirectory() ) {\n\t\t\t\tprocessdir( filepath );\n\t\t\t} else {\n\t\t\t\tresult.push( filepath.replace( basedir + sep, '' ) );\n\t\t\t}\n\t\t});\n\t}\n\n\tprocessdir( basedir );\n\treturn result;\n}\n\nfunction rimraf () {\n\tvar target = resolvePath( arguments );\n\n\treturn new Promise( function ( fulfil, reject ) {\n\t\t_rimraf( target, function ( err ) {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction rimrafSync () {\n\t_rimraf.sync( resolvePath( arguments ) );\n}\n\nvar isWindows = process.platform === 'win32';\n\nfunction symlinkOrCopy () {\n\tvar arguments$1 = arguments;\n\n\tif ( isWindows ) {\n\t\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\n\t\tvar copyDirOrFileTo = stat( src )\n\t\t\t.then( function ( stats ) {\n\t\t\t\treturn ( stats.isDirectory() ? copydir : copyFile )\n\t\t\t\t\t.apply( null, arguments$1 )\n\t\t\t\t\t.to;\n\t\t\t});\n\n\t\treturn {\n\t\t\tto: function to () {\n\t\t\t\tvar arguments$1 = arguments;\n\n\t\t\t\treturn copyDirOrFileTo\n\t\t\t\t\t.then(function ( fn ) {\n\t\t\t\t\t\treturn fn.apply(null, arguments$1);\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\treturn symlink.apply( null, arguments );\n}\n\nfunction symlinkOrCopySync () {\n\tif ( isWindows ) {\n\t\tvar ref = resolvePathAndOptions( arguments ), src = ref.resolvedPath, readOptions = ref.options;\n\t\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\n\t}\n\n\treturn symlinkSync.apply( null, arguments );\n}\n\n// standard async methods\nvar chmod = asyncMethod( 'chmod' );\nvar chown = asyncMethod( 'chown' );\nvar lchmod = asyncMethod( 'lchmod' );\nvar lchown = asyncMethod( 'lchown' );\nvar lstat = asyncMethod( 'lstat' );\nvar readdir = asyncMethod( 'readdir' );\nvar readFile = asyncMethod( 'readFile' );\nvar readlink = asyncMethod( 'readlink' );\nvar realpath = asyncMethod( 'realpath' );\nvar rmdir = asyncMethod( 'rmdir' );\nvar stat = asyncMethod( 'stat' );\nvar truncate = asyncMethod( 'truncate' );\nvar unlink = asyncMethod( 'unlink' );\nvar utimes = asyncMethod( 'utimes' );\nvar unwatchFile = asyncMethod( 'unwatchFile' );\nvar watch = asyncMethod( 'watch' );\nvar watchFile = asyncMethod( 'watchFile' );\n\n// standard sync methods\nvar chmodSync = syncMethod( 'chmodSync' );\nvar chownSync = syncMethod( 'chownSync' );\nvar lchmodSync = syncMethod( 'lchmodSync' );\nvar lchownSync = syncMethod( 'lchownSync' );\nvar lstatSync = syncMethod( 'lstatSync' );\nvar readdirSync = syncMethod( 'readdirSync' );\nvar readFileSync = syncMethod( 'readFileSync' );\nvar readlinkSync = syncMethod( 'readlinkSync' );\nvar realpathSync = syncMethod( 'realpathSync' );\nvar rmdirSync = syncMethod( 'rmdirSync' );\nvar statSync = syncMethod( 'statSync' );\nvar truncateSync = syncMethod( 'truncateSync' );\nvar unlinkSync = syncMethod( 'unlinkSync' );\nvar utimesSync = syncMethod( 'utimesSync' );\n\n// file descriptor async methods\nvar close = asyncFileDescriptorMethod( 'close' );\nvar fchmod = asyncFileDescriptorMethod( 'fchmod' );\nvar fchown = asyncFileDescriptorMethod( 'fchown' );\nvar fstat = asyncFileDescriptorMethod( 'fstat' );\nvar fsync = asyncFileDescriptorMethod( 'fsync' );\nvar ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\nvar futimes = asyncFileDescriptorMethod( 'futimes' );\nvar read = asyncFileDescriptorMethod( 'read' );\n\n// file descriptor sync methods\nvar closeSync = fs.closeSync;\nvar fchmodSync = fs.fchmodSync;\nvar fchownSync = fs.fchownSync;\nvar fstatSync = fs.fstatSync;\nvar fsyncSync = fs.fsyncSync;\nvar ftruncateSync = fs.ftruncateSync;\nvar futimesSync = fs.futimesSync;\nvar readSync = fs.readSync;\n\n// expose Promise for convenience\n// https://github.com/esperantojs/esperanto/issues/161\nvar Promise$1 = es6Promise.Promise;\n\nexport { chmod, chown, createReadStream$1 as createReadStream, createWriteStream$1 as createWriteStream, lchmod, lchown, lstat, readdir, readFile, readlink, realpath, rmdir, stat, truncate, unlink, utimes, unwatchFile, watch, watchFile, chmodSync, chownSync, lchmodSync, lchownSync, lstatSync, readdirSync, readFileSync, readlinkSync, realpathSync, rmdirSync, statSync, truncateSync, unlinkSync, utimesSync, close, fchmod, fchown, fstat, fsync, ftruncate, futimes, read, closeSync, fchmodSync, fchownSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, readSync, Promise$1 as Promise, exists, existsSync, link, linkSync, rename, renameSync, mkdir, mkdirSync, open, openSync, symlink, symlinkSync, writeFile, writeFileSync, appendFile, appendFileSync, copydir, copydirSync, copyFile, copyFileSync, lsr, lsrSync, rimraf, rimrafSync, symlinkOrCopy, symlinkOrCopySync };\n//# sourceMappingURL=sander.es.js.map"}},"sander.es.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"sander.es.js\",\"sources\":[\"../src/utils/resolvePath.js\",\"../src/methodMakers/standardMethod.js\",\"../src/methodMakers/fileDescriptorMethod.js\",\"../src/utils/resolvePathAndOptions.js\",\"../src/specialMethods/createReadStream-createWriteStream.js\",\"../src/specialMethods/exists.js\",\"../src/specialMethods/link-rename.js\",\"../src/specialMethods/mkdir.js\",\"../src/specialMethods/open.js\",\"../src/specialMethods/symlink.js\",\"../src/specialMethods/writeFile-appendFile.js\",\"../src/extraMethods/copydir.js\",\"../src/extraMethods/copyFile.js\",\"../src/extraMethods/lsr.js\",\"../src/extraMethods/rimraf.js\",\"../src/extraMethods/symlinkOrCopy.js\",\"../src/sander.js\"],\"sourcesContent\":[\"import { resolve } from 'path';\\n\\nexport default function resolvePath ( args ) {\\n\\treturn resolve.apply( null, args );\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tconst len = args.length;\\n\\n\\tlet buildingPath = true;\\n\\tlet pathargs = [];\\n\\tlet normalised = [ null ]; // null is a placeholder for the resolved path\\n\\tlet i;\\n\\n\\tfor ( i = 0; i < len; i += 1 ) {\\n\\t\\tif ( buildingPath && typeof args[i] === 'string' ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t} else {\\n\\t\\t\\tbuildingPath = false;\\n\\t\\t\\tnormalised.push( args[i] );\\n\\t\\t}\\n\\t}\\n\\n\\tnormalised[0] = resolvePath( pathargs );\\n\\n\\treturn normalised;\\n}\\n\\nexport function asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\\n\\nexport function syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\t\\treturn fs[ methodName ].apply( fs, args );\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\n\\nexport function asyncFileDescriptorMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tlet args = [];\\n\\t\\tlet i = arguments.length;\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\",\"import { resolve } from 'path';\\n\\nexport default function resolvePathAndOptions ( args ) {\\n\\tlet options;\\n\\tlet pathargs;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\n\\t\\tlet i = args.length - 1;\\n\\t\\tpathargs = new Array( i );\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t}\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tpathargs = args;\\n\\t}\\n\\n\\tconst resolvedPath = resolve.apply( null, pathargs );\\n\\n\\treturn { options, resolvedPath };\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function createReadStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\treturn fs.createReadStream( resolvedPath, options );\\n}\\n\\nexport function createWriteStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\n\\tmkdirp.sync( dirname( resolvedPath ) );\\n\\treturn fs.createWriteStream( resolvedPath, options );\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function exists () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( fulfil => {\\n\\t\\tfs.exists( target, exists => fulfil( exists ) );\\n\\t});\\n}\\n\\nexport function existsSync () {\\n\\treturn fs.existsSync( resolvePath( arguments ) );\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const rename = asyncMethod( 'rename' );\\nexport const link = asyncMethod( 'link' );\\n\\nexport const renameSync = syncMethod( 'renameSync' );\\nexport const linkSync = syncMethod( 'linkSync' );\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfs[ methodName ]( src, dest, err => {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\t\\treturn fs[ methodName ]( src, dest );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\",\"import mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function mkdir () {\\n\\tconst dir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tmkdirp( dir, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function mkdirSync () {\\n\\tconst dir = resolvePath( arguments );\\n\\tmkdirp.sync( dir );\\n}\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tlet options;\\n\\tlet flags;\\n\\tlet i;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\t\\tflags = args[ args.length - 2 ];\\n\\t\\ti = args.length - 2;\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tflags = args[ args.length - 1 ];\\n\\t\\ti = args.length - 1;\\n\\t}\\n\\n\\tlet pathargs = new Array( i );\\n\\twhile ( i-- ) {\\n\\t\\tpathargs[i] = args[i];\\n\\t}\\n\\n\\tconst resolvedPath = resolvePath( pathargs );\\n\\n\\treturn { resolvedPath, options, flags };\\n}\\n\\nfunction bailIfExists ( src, flags, mode ) {\\n\\tlet alreadyExists;\\n\\n\\ttry {\\n\\t\\tfs.statSync( src );\\n\\t\\talreadyExists = true;\\n\\t} catch ( err ) {\\n\\t\\tif ( err.code !== 'ENOENT' ) {\\n\\t\\t\\tthrow err;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( alreadyExists ) {\\n\\t\\t// attempt the operation = that way, we get the intended error message\\n\\t\\t// TODO can't we just do this in the first place?\\n\\t\\tfs.openSync( src, flags, mode );\\n\\t}\\n}\\n\\nexport function open () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tfunction open () {\\n\\t\\t\\tfs.open( src, flags, options.mode, ( err, fd ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( fd );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// create dirs if necessary\\n\\t\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\t\\tmkdirp( dirname( src ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\topen();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\topen();\\n\\t\\t}\\n\\t});\\n}\\n\\n\\nexport function openSync () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\t// create dirs if necessary\\n\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\tmkdirp.sync( dirname( src ) );\\n\\t}\\n\\n\\treturn fs.openSync( src, flags, options.mode );\\n}\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function symlink () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfs.symlink( src, dest, options.type, err => {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function symlinkSync () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\treturn fs.symlinkSync( src, dest, options.type );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const writeFile = asyncMethod( 'writeFile' );\\nexport const appendFile = asyncMethod( 'appendFile' );\\n\\nexport const writeFileSync = syncMethod( 'writeFileSync' );\\nexport const appendFileSync = syncMethod( 'appendFileSync' );\\n\\nfunction normaliseArguments ( args ) {\\n\\targs = Array.prototype.slice.call( args, 0 );\\n\\tlet opts = {};\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\\n\\t\\topts = args.pop();\\n\\t}\\n\\n\\treturn { opts, data: args.pop(), dest: resolvePath( args ) };\\n}\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data, opts } = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfs[ methodName ]( dest, data, opts, err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfulfil( data );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data } = normaliseArguments( arguments );\\n\\n\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\treturn fs[ methodName ]( dest, data );\\n\\t};\\n}\\n\",\"import { sep } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copydir () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest, cb ) {\\n\\t\\t\\t\\tmkdirp( dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\tfs.readdir( src, ( err, files ) => {\\n\\t\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\t\\tlet remaining = files.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( !remaining ) return cb();\\n\\n\\t\\t\\t\\t\\t\\tfunction check ( err ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cb( err );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !--remaining ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcb();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfiles.forEach( function ( filename ) {\\n\\t\\t\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\t\\t\\tfs.stat( srcpath, ( err, stats ) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar readStream, writeStream;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( stats.isDirectory() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath, check );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream = fs.createReadStream( srcpath, readOptions );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream = fs.createWriteStream( destpath, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.on( 'error', cb );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'error', cb );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'close', check );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tcopydir( src, dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copydirSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest ) {\\n\\t\\t\\t\\tmkdirp.sync( dest );\\n\\n\\t\\t\\t\\tfs.readdirSync( src ).forEach( filename => {\\n\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\tif ( fs.statSync( srcpath ).isDirectory() ) {\\n\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconst data = fs.readFileSync( srcpath, readOptions );\\n\\t\\t\\t\\t\\tfs.writeFileSync( destpath, data, writeOptions );\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tcopydir( src, dest );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copyFile () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tconst readStream = fs.createReadStream( src, readOptions );\\n\\t\\t\\t\\t\\t\\tconst writeStream = fs.createWriteStream( dest, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\treadStream.on( 'error', reject );\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'error', reject );\\n\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'close', fulfil );\\n\\n\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copyFileSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tconst data = fs.readFileSync( src, readOptions );\\n\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\tfs.writeFileSync( dest, data, writeOptions );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'fs';\\nimport { resolve, sep } from 'path';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction walk ( dir, callback ) {\\n\\tlet results = [];\\n\\n\\tfs.readdir( dir, ( err, files ) => {\\n\\t\\tif ( err ) return callback( err );\\n\\n\\t\\tlet pending = files.length;\\n\\t\\tif ( !pending ) return callback( null, results );\\n\\n\\t\\tfiles.forEach( file => {\\n\\t\\t\\tfile = resolve( dir, file );\\n\\n\\t\\t\\tfs.stat( file, ( err, stats ) => {\\n\\t\\t\\t\\tif ( stats && stats.isDirectory() ) {\\n\\t\\t\\t\\t\\twalk( file, ( err, res ) => {\\n\\t\\t\\t\\t\\t\\tresults = results.concat( res );\\n\\t\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults.push( file );\\n\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t});\\n};\\n\\nexport function lsr () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\twalk( basedir, function ( err, result ) {\\n\\t\\t\\tif ( err ) return reject( err );\\n\\n\\t\\t\\t// files should be relative to basedir\\n\\t\\t\\tconst index = basedir.length + 1;\\n\\t\\t\\tlet i = result.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tresult[i] = result[i].substring( index );\\n\\t\\t\\t}\\n\\n\\t\\t\\tfulfil( result );\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function lsrSync () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\tlet result = [];\\n\\n\\tfunction processdir ( dir ) {\\n\\t\\tfs.readdirSync( dir ).forEach( file => {\\n\\t\\t\\tconst filepath = dir + sep + file;\\n\\n\\t\\t\\tif ( fs.statSync( filepath ).isDirectory() ) {\\n\\t\\t\\t\\tprocessdir( filepath );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.push( filepath.replace( basedir + sep, '' ) );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\tprocessdir( basedir );\\n\\treturn result;\\n}\",\"import _rimraf from 'rimraf';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function rimraf () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t_rimraf( target, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function rimrafSync () {\\n\\t_rimraf.sync( resolvePath( arguments ) );\\n}\",\"import { stat, statSync } from '../sander';\\nimport { copydir, copydirSync } from './copydir';\\nimport { copyFile, copyFileSync } from './copyFile';\\nimport { symlink, symlinkSync } from '../specialMethods/symlink';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nconst isWindows = process.platform === 'win32';\\n\\nexport function symlinkOrCopy () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\tlet copyDirOrFileTo = stat( src )\\n\\t\\t\\t.then( stats => {\\n\\t\\t\\t\\treturn ( stats.isDirectory() ? copydir : copyFile )\\n\\t\\t\\t\\t\\t.apply( null, arguments )\\n\\t\\t\\t\\t\\t.to;\\n\\t\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\treturn copyDirOrFileTo\\n\\t\\t\\t\\t\\t.then(fn => {\\n\\t\\t\\t\\t\\t\\treturn fn.apply(null, arguments);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\treturn symlink.apply( null, arguments );\\n}\\n\\nexport function symlinkOrCopySync () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\t\\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\\n\\t}\\n\\n\\treturn symlinkSync.apply( null, arguments );\\n}\",\"import * as fs from 'graceful-fs';\\nimport * as es6Promise from 'es6-promise';\\nimport { syncMethod, asyncMethod } from './methodMakers/standardMethod';\\nimport { asyncFileDescriptorMethod } from './methodMakers/fileDescriptorMethod';\\n\\n// standard async methods\\nexport const chmod = asyncMethod( 'chmod' );\\nexport const chown = asyncMethod( 'chown' );\\nexport const createReadStream = asyncMethod( 'createReadStream' );\\nexport const createWriteStream = asyncMethod( 'createWriteStream' );\\nexport const lchmod = asyncMethod( 'lchmod' );\\nexport const lchown = asyncMethod( 'lchown' );\\nexport const lstat = asyncMethod( 'lstat' );\\nexport const readdir = asyncMethod( 'readdir' );\\nexport const readFile = asyncMethod( 'readFile' );\\nexport const readlink = asyncMethod( 'readlink' );\\nexport const realpath = asyncMethod( 'realpath' );\\nexport const rmdir = asyncMethod( 'rmdir' );\\nexport const stat = asyncMethod( 'stat' );\\nexport const truncate = asyncMethod( 'truncate' );\\nexport const unlink = asyncMethod( 'unlink' );\\nexport const utimes = asyncMethod( 'utimes' );\\nexport const unwatchFile = asyncMethod( 'unwatchFile' );\\nexport const watch = asyncMethod( 'watch' );\\nexport const watchFile = asyncMethod( 'watchFile' );\\n\\n// standard sync methods\\nexport const chmodSync = syncMethod( 'chmodSync' );\\nexport const chownSync = syncMethod( 'chownSync' );\\nexport const lchmodSync = syncMethod( 'lchmodSync' );\\nexport const lchownSync = syncMethod( 'lchownSync' );\\nexport const lstatSync = syncMethod( 'lstatSync' );\\nexport const readdirSync = syncMethod( 'readdirSync' );\\nexport const readFileSync = syncMethod( 'readFileSync' );\\nexport const readlinkSync = syncMethod( 'readlinkSync' );\\nexport const realpathSync = syncMethod( 'realpathSync' );\\nexport const rmdirSync = syncMethod( 'rmdirSync' );\\nexport const statSync = syncMethod( 'statSync' );\\nexport const truncateSync = syncMethod( 'truncateSync' );\\nexport const unlinkSync = syncMethod( 'unlinkSync' );\\nexport const utimesSync = syncMethod( 'utimesSync' );\\n\\n// file descriptor async methods\\nexport const close = asyncFileDescriptorMethod( 'close' );\\nexport const fchmod = asyncFileDescriptorMethod( 'fchmod' );\\nexport const fchown = asyncFileDescriptorMethod( 'fchown' );\\nexport const fstat = asyncFileDescriptorMethod( 'fstat' );\\nexport const fsync = asyncFileDescriptorMethod( 'fsync' );\\nexport const ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\\nexport const futimes = asyncFileDescriptorMethod( 'futimes' );\\nexport const read = asyncFileDescriptorMethod( 'read' );\\n\\n// file descriptor sync methods\\nexport const closeSync = fs.closeSync;\\nexport const fchmodSync = fs.fchmodSync;\\nexport const fchownSync = fs.fchownSync;\\nexport const fstatSync = fs.fstatSync;\\nexport const fsyncSync = fs.fsyncSync;\\nexport const ftruncateSync = fs.ftruncateSync;\\nexport const futimesSync = fs.futimesSync;\\nexport const readSync = fs.readSync;\\n\\n// special methods\\nexport { createReadStream, createWriteStream } from './specialMethods/createReadStream-createWriteStream'; // TODO aren't these covered by the standard methods?\\nexport { exists, existsSync } from './specialMethods/exists';\\nexport { link, linkSync, rename, renameSync } from './specialMethods/link-rename';\\nexport { mkdir, mkdirSync } from './specialMethods/mkdir';\\nexport { open, openSync } from './specialMethods/open';\\nexport { symlink, symlinkSync } from './specialMethods/symlink';\\nexport { writeFile, writeFileSync, appendFile, appendFileSync } from './specialMethods/writeFile-appendFile';\\n\\n// extra methods\\nexport { copydir, copydirSync } from './extraMethods/copydir';\\nexport { copyFile, copyFileSync } from './extraMethods/copyFile';\\nexport { lsr, lsrSync } from './extraMethods/lsr';\\nexport { rimraf, rimrafSync } from './extraMethods/rimraf';\\nexport { symlinkOrCopy, symlinkOrCopySync } from './extraMethods/symlinkOrCopy';\\n\\n// expose Promise for convenience\\n// https://github.com/esperantojs/esperanto/issues/161\\nexport const Promise = es6Promise.Promise;\"],\"names\":[\"const\",\"let\",\"arguments\",\"createReadStream\",\"createWriteStream\",\"asyncMethod\",\"syncMethod\",\"normaliseArguments\",\"fs\",\"Promise\"],\"mappings\":\"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\"}"}},"sander.es6.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport * as es6Promise from 'es6-promise';\nimport { dirname, sep, resolve } from 'path';\nimport mkdirp from 'mkdirp';\nimport * as fs$1 from 'fs';\nimport _rimraf from 'rimraf';\n\nfunction resolvePath(args) {\n\treturn resolve.apply(null, args);\n}\n\nfunction normaliseArguments(args) {\n\tvar len = args.length;\n\n\tvar buildingPath = true;\n\tvar pathargs = [];\n\tvar normalised = [null]; // null is a placeholder for the resolved path\n\tvar i = undefined;\n\n\tfor (i = 0; i < len; i += 1) {\n\t\tif (buildingPath && typeof args[i] === 'string') {\n\t\t\tpathargs[i] = args[i];\n\t\t} else {\n\t\t\tbuildingPath = false;\n\t\t\tnormalised.push(args[i]);\n\t\t}\n\t}\n\n\tnormalised[0] = resolvePath(pathargs);\n\n\treturn normalised;\n}\n\nfunction asyncMethod(methodName) {\n\treturn function () {\n\t\tvar args = normaliseArguments(arguments);\n\n\t\treturn new Promise(function (fulfil, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tfulfil(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[methodName].apply(fs, args);\n\t\t});\n\t};\n}\n\nfunction syncMethod(methodName) {\n\treturn function () {\n\t\tvar args = normaliseArguments(arguments);\n\t\treturn fs[methodName].apply(fs, args);\n\t};\n}\n\nfunction asyncFileDescriptorMethod(methodName) {\n\treturn function () {\n\t\tvar args = [];\n\t\tvar i = arguments.length;\n\n\t\twhile (i--) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new Promise(function (fulfil, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tfulfil(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[methodName].apply(fs, args);\n\t\t});\n\t};\n}\n\nfunction resolvePathAndOptions(args) {\n\tvar options = undefined;\n\tvar pathargs = undefined;\n\n\tif (typeof args[args.length - 1] === 'object') {\n\t\toptions = args[args.length - 1];\n\n\t\tvar i = args.length - 1;\n\t\tpathargs = new Array(i);\n\n\t\twhile (i--) {\n\t\t\tpathargs[i] = args[i];\n\t\t}\n\t} else {\n\t\toptions = {};\n\t\tpathargs = args;\n\t}\n\n\tvar resolvedPath = resolve.apply(null, pathargs);\n\n\treturn { options: options, resolvedPath: resolvedPath };\n}\n\nfunction createReadStream$1() {\n\tvar _resolvePathAndOptions = resolvePathAndOptions(arguments);\n\n\tvar resolvedPath = _resolvePathAndOptions.resolvedPath;\n\tvar options = _resolvePathAndOptions.options;\n\n\treturn fs.createReadStream(resolvedPath, options);\n}\n\nfunction createWriteStream$1() {\n\tvar _resolvePathAndOptions2 = resolvePathAndOptions(arguments);\n\n\tvar resolvedPath = _resolvePathAndOptions2.resolvedPath;\n\tvar options = _resolvePathAndOptions2.options;\n\n\tmkdirp.sync(dirname(resolvedPath));\n\treturn fs.createWriteStream(resolvedPath, options);\n}\n\nfunction exists$1() {\n\tvar target = resolvePath(arguments);\n\n\treturn new Promise(function (fulfil) {\n\t\tfs.exists(target, function (exists) {\n\t\t\treturn fulfil(exists);\n\t\t});\n\t});\n}\n\nfunction existsSync$1() {\n\treturn fs.existsSync(resolvePath(arguments));\n}\n\nvar rename$1 = asyncMethod$1('rename');\nvar link$1 = asyncMethod$1('link');\n\nvar renameSync$1 = syncMethod$1('renameSync');\nvar linkSync$1 = syncMethod$1('linkSync');\n\nfunction asyncMethod$1(methodName) {\n\treturn function () {\n\t\tvar src = resolvePath(arguments);\n\n\t\treturn {\n\t\t\tto: function () {\n\t\t\t\tvar dest = resolvePath(arguments);\n\n\t\t\t\treturn new Promise(function (fulfil, reject) {\n\t\t\t\t\tmkdirp(dirname(dest), function (err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs[methodName](src, dest, function (err) {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction syncMethod$1(methodName) {\n\treturn function () {\n\t\tvar src = resolvePath(arguments);\n\n\t\treturn {\n\t\t\tto: function () {\n\t\t\t\tvar dest = resolvePath(arguments);\n\n\t\t\t\tmkdirp.sync(dirname(dest));\n\t\t\t\treturn fs[methodName](src, dest);\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction mkdir$1() {\n\tvar dir = resolvePath(arguments);\n\n\treturn new Promise(function (fulfil, reject) {\n\t\tmkdirp(dir, function (err) {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction mkdirSync$1() {\n\tvar dir = resolvePath(arguments);\n\tmkdirp.sync(dir);\n}\n\nfunction normaliseArguments$1(args) {\n\tvar options = undefined;\n\tvar flags = undefined;\n\tvar i = undefined;\n\n\tif (typeof args[args.length - 1] === 'object') {\n\t\toptions = args[args.length - 1];\n\t\tflags = args[args.length - 2];\n\t\ti = args.length - 2;\n\t} else {\n\t\toptions = {};\n\t\tflags = args[args.length - 1];\n\t\ti = args.length - 1;\n\t}\n\n\tvar pathargs = new Array(i);\n\twhile (i--) {\n\t\tpathargs[i] = args[i];\n\t}\n\n\tvar resolvedPath = resolvePath(pathargs);\n\n\treturn { resolvedPath: resolvedPath, options: options, flags: flags };\n}\n\nfunction bailIfExists(src, flags, mode) {\n\tvar alreadyExists = undefined;\n\n\ttry {\n\t\tfs.statSync(src);\n\t\talreadyExists = true;\n\t} catch (err) {\n\t\tif (err.code !== 'ENOENT') {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif (alreadyExists) {\n\t\t// attempt the operation = that way, we get the intended error message\n\t\t// TODO can't we just do this in the first place?\n\t\tfs.openSync(src, flags, mode);\n\t}\n}\n\nfunction open$1() {\n\tvar _normaliseArguments = normaliseArguments$1(arguments);\n\n\tvar src = _normaliseArguments.resolvedPath;\n\tvar options = _normaliseArguments.options;\n\tvar flags = _normaliseArguments.flags;\n\n\tif (/^.x/.test(flags)) {\n\t\tbailIfExists(src, flags, options.mode);\n\t}\n\n\treturn new Promise(function (fulfil, reject) {\n\t\tfunction open() {\n\t\t\tfs.open(src, flags, options.mode, function (err, fd) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tfulfil(fd);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// create dirs if necessary\n\t\tif (/^[wa]/.test(flags)) {\n\t\t\tmkdirp(dirname(src), function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\topen();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\topen();\n\t\t}\n\t});\n}\n\nfunction openSync$1() {\n\tvar _normaliseArguments2 = normaliseArguments$1(arguments);\n\n\tvar src = _normaliseArguments2.resolvedPath;\n\tvar options = _normaliseArguments2.options;\n\tvar flags = _normaliseArguments2.flags;\n\n\tif (/^.x/.test(flags)) {\n\t\tbailIfExists(src, flags, options.mode);\n\t}\n\n\t// create dirs if necessary\n\tif (/^[wa]/.test(flags)) {\n\t\tmkdirp.sync(dirname(src));\n\t}\n\n\treturn fs.openSync(src, flags, options.mode);\n}\n\nfunction symlink$1() {\n\tvar src = resolvePath(arguments);\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions = resolvePathAndOptions(arguments);\n\n\t\t\tvar options = _resolvePathAndOptions.options;\n\t\t\tvar dest = _resolvePathAndOptions.resolvedPath;\n\n\t\t\treturn new Promise(function (fulfil, reject) {\n\t\t\t\tmkdirp(dirname(dest), function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.symlink(src, dest, options.type, function (err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction symlinkSync$1() {\n\tvar src = resolvePath(arguments);\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions2 = resolvePathAndOptions(arguments);\n\n\t\t\tvar options = _resolvePathAndOptions2.options;\n\t\t\tvar dest = _resolvePathAndOptions2.resolvedPath;\n\n\t\t\tmkdirp.sync(dirname(dest));\n\t\t\treturn fs.symlinkSync(src, dest, options.type);\n\t\t}\n\t};\n}\n\nvar writeFile$1 = asyncMethod$2('writeFile');\nvar appendFile$1 = asyncMethod$2('appendFile');\n\nvar writeFileSync$1 = syncMethod$2('writeFileSync');\nvar appendFileSync$1 = syncMethod$2('appendFileSync');\n\nfunction normaliseArguments$2(args) {\n\targs = Array.prototype.slice.call(args, 0);\n\tvar opts = {};\n\n\tif (typeof args[args.length - 1] === 'object' && !(args[args.length - 1] instanceof Buffer)) {\n\t\topts = args.pop();\n\t}\n\n\treturn { opts: opts, data: args.pop(), dest: resolvePath(args) };\n}\n\nfunction asyncMethod$2(methodName) {\n\treturn function () {\n\t\tvar _normaliseArguments = normaliseArguments$2(arguments);\n\n\t\tvar dest = _normaliseArguments.dest;\n\t\tvar data = _normaliseArguments.data;\n\t\tvar opts = _normaliseArguments.opts;\n\n\t\treturn new Promise(function (fulfil, reject) {\n\t\t\tmkdirp(dirname(dest), function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tfs[methodName](dest, data, opts, function (err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfulfil(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction syncMethod$2(methodName) {\n\treturn function () {\n\t\tvar _normaliseArguments2 = normaliseArguments$2(arguments);\n\n\t\tvar dest = _normaliseArguments2.dest;\n\t\tvar data = _normaliseArguments2.data;\n\n\t\tmkdirp.sync(dirname(dest));\n\t\treturn fs[methodName](dest, data);\n\t};\n}\n\nfunction copydir$1() {\n\tvar _resolvePathAndOptions = resolvePathAndOptions(arguments);\n\n\tvar src = _resolvePathAndOptions.resolvedPath;\n\tvar readOptions = _resolvePathAndOptions.options;\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions2 = resolvePathAndOptions(arguments);\n\n\t\t\tvar dest = _resolvePathAndOptions2.resolvedPath;\n\t\t\tvar writeOptions = _resolvePathAndOptions2.options;\n\n\t\t\tfunction copydir(src, dest, cb) {\n\t\t\t\tmkdirp(dest, function (err) {\n\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\tfs.readdir(src, function (err, files) {\n\t\t\t\t\t\tif (err) return cb(err);\n\n\t\t\t\t\t\tvar remaining = files.length;\n\n\t\t\t\t\t\tif (!remaining) return cb();\n\n\t\t\t\t\t\tfunction check(err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (! --remaining) {\n\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfiles.forEach(function (filename) {\n\t\t\t\t\t\t\tvar srcpath = src + sep + filename;\n\t\t\t\t\t\t\tvar destpath = dest + sep + filename;\n\n\t\t\t\t\t\t\tfs.stat(srcpath, function (err, stats) {\n\t\t\t\t\t\t\t\tvar readStream, writeStream;\n\n\t\t\t\t\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\t\t\t\t\treturn copydir(srcpath, destpath, check);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treadStream = fs.createReadStream(srcpath, readOptions);\n\t\t\t\t\t\t\t\twriteStream = fs.createWriteStream(destpath, writeOptions);\n\n\t\t\t\t\t\t\t\treadStream.on('error', cb);\n\t\t\t\t\t\t\t\twriteStream.on('error', cb);\n\n\t\t\t\t\t\t\t\twriteStream.on('close', check);\n\n\t\t\t\t\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise(function (fulfil, reject) {\n\t\t\t\tcopydir(src, dest, function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfulfil();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copydirSync$1() {\n\tvar _resolvePathAndOptions3 = resolvePathAndOptions(arguments);\n\n\tvar src = _resolvePathAndOptions3.resolvedPath;\n\tvar readOptions = _resolvePathAndOptions3.options;\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions4 = resolvePathAndOptions(arguments);\n\n\t\t\tvar dest = _resolvePathAndOptions4.resolvedPath;\n\t\t\tvar writeOptions = _resolvePathAndOptions4.options;\n\n\t\t\tfunction copydir(src, dest) {\n\t\t\t\tmkdirp.sync(dest);\n\n\t\t\t\tfs.readdirSync(src).forEach(function (filename) {\n\t\t\t\t\tvar srcpath = src + sep + filename;\n\t\t\t\t\tvar destpath = dest + sep + filename;\n\n\t\t\t\t\tif (fs.statSync(srcpath).isDirectory()) {\n\t\t\t\t\t\treturn copydir(srcpath, destpath);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = fs.readFileSync(srcpath, readOptions);\n\t\t\t\t\tfs.writeFileSync(destpath, data, writeOptions);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcopydir(src, dest);\n\t\t}\n\t};\n}\n\nfunction copyFile$1() {\n\tvar _resolvePathAndOptions = resolvePathAndOptions(arguments);\n\n\tvar src = _resolvePathAndOptions.resolvedPath;\n\tvar readOptions = _resolvePathAndOptions.options;\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions2 = resolvePathAndOptions(arguments);\n\n\t\t\tvar dest = _resolvePathAndOptions2.resolvedPath;\n\t\t\tvar writeOptions = _resolvePathAndOptions2.options;\n\n\t\t\treturn new Promise(function (fulfil, reject) {\n\t\t\t\tmkdirp(dirname(dest), function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar readStream = fs.createReadStream(src, readOptions);\n\t\t\t\t\t\tvar writeStream = fs.createWriteStream(dest, writeOptions);\n\n\t\t\t\t\t\treadStream.on('error', reject);\n\t\t\t\t\t\twriteStream.on('error', reject);\n\n\t\t\t\t\t\twriteStream.on('close', fulfil);\n\n\t\t\t\t\t\treadStream.pipe(writeStream);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction copyFileSync$1() {\n\tvar _resolvePathAndOptions3 = resolvePathAndOptions(arguments);\n\n\tvar src = _resolvePathAndOptions3.resolvedPath;\n\tvar readOptions = _resolvePathAndOptions3.options;\n\n\treturn {\n\t\tto: function () {\n\t\t\tvar _resolvePathAndOptions4 = resolvePathAndOptions(arguments);\n\n\t\t\tvar dest = _resolvePathAndOptions4.resolvedPath;\n\t\t\tvar writeOptions = _resolvePathAndOptions4.options;\n\n\t\t\tvar data = fs.readFileSync(src, readOptions);\n\n\t\t\tmkdirp.sync(dirname(dest));\n\t\t\tfs.writeFileSync(dest, data, writeOptions);\n\t\t}\n\t};\n}\n\nfunction walk(dir, callback) {\n\tvar results = [];\n\n\tfs$1.readdir(dir, function (err, files) {\n\t\tif (err) return callback(err);\n\n\t\tvar pending = files.length;\n\t\tif (!pending) return callback(null, results);\n\n\t\tfiles.forEach(function (file) {\n\t\t\tfile = resolve(dir, file);\n\n\t\t\tfs$1.stat(file, function (err, stats) {\n\t\t\t\tif (stats && stats.isDirectory()) {\n\t\t\t\t\twalk(file, function (err, res) {\n\t\t\t\t\t\tresults = results.concat(res);\n\t\t\t\t\t\tif (! --pending) callback(null, results);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresults.push(file);\n\t\t\t\t\tif (! --pending) callback(null, results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\nfunction lsr$1() {\n\tvar basedir = resolvePath(arguments);\n\n\treturn new Promise(function (fulfil, reject) {\n\t\twalk(basedir, function (err, result) {\n\t\t\tif (err) return reject(err);\n\n\t\t\t// files should be relative to basedir\n\t\t\tvar index = basedir.length + 1;\n\t\t\tvar i = result.length;\n\t\t\twhile (i--) {\n\t\t\t\tresult[i] = result[i].substring(index);\n\t\t\t}\n\n\t\t\tfulfil(result);\n\t\t});\n\t});\n}\n\nfunction lsrSync$1() {\n\tvar basedir = resolvePath(arguments);\n\n\tvar result = [];\n\n\tfunction processdir(dir) {\n\t\tfs$1.readdirSync(dir).forEach(function (file) {\n\t\t\tvar filepath = dir + sep + file;\n\n\t\t\tif (fs$1.statSync(filepath).isDirectory()) {\n\t\t\t\tprocessdir(filepath);\n\t\t\t} else {\n\t\t\t\tresult.push(filepath.replace(basedir + sep, ''));\n\t\t\t}\n\t\t});\n\t}\n\n\tprocessdir(basedir);\n\treturn result;\n}\n\nfunction rimraf$1() {\n\tvar target = resolvePath(arguments);\n\n\treturn new Promise(function (fulfil, reject) {\n\t\t_rimraf(target, function (err) {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction rimrafSync$1() {\n\t_rimraf.sync(resolvePath(arguments));\n}\n\nvar isWindows = process.platform === 'win32';\n\nfunction symlinkOrCopy$1() {\n\tvar _arguments = arguments;\n\n\tif (isWindows) {\n\t\tvar _ret = (function () {\n\t\t\tvar _resolvePathAndOptions = resolvePathAndOptions(_arguments);\n\n\t\t\tvar src = _resolvePathAndOptions.resolvedPath;\n\t\t\tvar readOptions = _resolvePathAndOptions.options;\n\n\t\t\tvar copyDirOrFileTo = stat(src).then(function (stats) {\n\t\t\t\treturn (stats.isDirectory() ? copydir$1 : copyFile$1).apply(null, _arguments).to;\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tv: {\n\t\t\t\t\tto: function () {\n\t\t\t\t\t\tvar _arguments2 = arguments;\n\n\t\t\t\t\t\treturn copyDirOrFileTo.then(function (fn) {\n\t\t\t\t\t\t\treturn fn.apply(null, _arguments2);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})();\n\n\t\tif (typeof _ret === 'object') return _ret.v;\n\t}\n\n\treturn symlink$1.apply(null, arguments);\n}\n\nfunction symlinkOrCopySync$1() {\n\tif (isWindows) {\n\t\tvar _resolvePathAndOptions2 = resolvePathAndOptions(arguments);\n\n\t\tvar src = _resolvePathAndOptions2.resolvedPath;\n\t\tvar readOptions = _resolvePathAndOptions2.options;\n\n\t\treturn (statSync(src).isDirectory() ? copydirSync$1 : copyFileSync$1).apply(null, arguments);\n\t}\n\n\treturn symlinkSync$1.apply(null, arguments);\n}\n\n// standard async methods\nvar chmod = asyncMethod('chmod');\nvar chown = asyncMethod('chown');\nvar createReadStream = asyncMethod('createReadStream');\nvar createWriteStream = asyncMethod('createWriteStream');\nvar lchmod = asyncMethod('lchmod');\nvar lchown = asyncMethod('lchown');\nvar lstat = asyncMethod('lstat');\nvar readdir = asyncMethod('readdir');\nvar readFile = asyncMethod('readFile');\nvar readlink = asyncMethod('readlink');\nvar realpath = asyncMethod('realpath');\nvar rmdir = asyncMethod('rmdir');\nvar stat = asyncMethod('stat');\nvar truncate = asyncMethod('truncate');\nvar unlink = asyncMethod('unlink');\nvar utimes = asyncMethod('utimes');\nvar unwatchFile = asyncMethod('unwatchFile');\nvar watch = asyncMethod('watch');\nvar watchFile = asyncMethod('watchFile');\n\n// standard sync methods\nvar chmodSync = syncMethod('chmodSync');\nvar chownSync = syncMethod('chownSync');\nvar lchmodSync = syncMethod('lchmodSync');\nvar lchownSync = syncMethod('lchownSync');\nvar lstatSync = syncMethod('lstatSync');\nvar readdirSync = syncMethod('readdirSync');\nvar readFileSync = syncMethod('readFileSync');\nvar readlinkSync = syncMethod('readlinkSync');\nvar realpathSync = syncMethod('realpathSync');\nvar rmdirSync = syncMethod('rmdirSync');\nvar statSync = syncMethod('statSync');\nvar truncateSync = syncMethod('truncateSync');\nvar unlinkSync = syncMethod('unlinkSync');\nvar utimesSync = syncMethod('utimesSync');\n\n// file descriptor async methods\nvar close = asyncFileDescriptorMethod('close');\nvar fchmod = asyncFileDescriptorMethod('fchmod');\nvar fchown = asyncFileDescriptorMethod('fchown');\nvar fstat = asyncFileDescriptorMethod('fstat');\nvar fsync = asyncFileDescriptorMethod('fsync');\nvar ftruncate = asyncFileDescriptorMethod('ftruncate');\nvar futimes = asyncFileDescriptorMethod('futimes');\nvar read = asyncFileDescriptorMethod('read');\n\n// file descriptor sync methods\nvar closeSync = fs.closeSync;\nvar fchmodSync = fs.fchmodSync;\nvar fchownSync = fs.fchownSync;\nvar fstatSync = fs.fstatSync;\nvar fsyncSync = fs.fsyncSync;\nvar ftruncateSync = fs.ftruncateSync;\nvar futimesSync = fs.futimesSync;\nvar readSync = fs.readSync;\n\n// expose Promise for convenience\n// https://github.com/esperantojs/esperanto/issues/161\nvar Promise$1 = es6Promise.Promise;\n\nexport { chmod, chown, createReadStream$1 as createReadStream, createWriteStream$1 as createWriteStream, lchmod, lchown, lstat, readdir, readFile, readlink, realpath, rmdir, stat, truncate, unlink, utimes, unwatchFile, watch, watchFile, chmodSync, chownSync, lchmodSync, lchownSync, lstatSync, readdirSync, readFileSync, readlinkSync, realpathSync, rmdirSync, statSync, truncateSync, unlinkSync, utimesSync, close, fchmod, fchown, fstat, fsync, ftruncate, futimes, read, closeSync, fchmodSync, fchownSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, readSync, Promise$1 as Promise, exists$1 as exists, existsSync$1 as existsSync, link$1 as link, linkSync$1 as linkSync, rename$1 as rename, renameSync$1 as renameSync, mkdir$1 as mkdir, mkdirSync$1 as mkdirSync, open$1 as open, openSync$1 as openSync, symlink$1 as symlink, symlinkSync$1 as symlinkSync, writeFile$1 as writeFile, writeFileSync$1 as writeFileSync, appendFile$1 as appendFile, appendFileSync$1 as appendFileSync, copydir$1 as copydir, copydirSync$1 as copydirSync, copyFile$1 as copyFile, copyFileSync$1 as copyFileSync, lsr$1 as lsr, lsrSync$1 as lsrSync, rimraf$1 as rimraf, rimrafSync$1 as rimrafSync, symlinkOrCopy$1 as symlinkOrCopy, symlinkOrCopySync$1 as symlinkOrCopySync };\n//# sourceMappingURL=sander.es6.js.map\n"}},"sander.es6.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"sander.es6.js\",\"sources\":[\"../src/sander.js\",\"../src/extraMethods/symlinkOrCopy.js\",\"../src/extraMethods/rimraf.js\",\"../src/extraMethods/lsr.js\",\"../src/extraMethods/copyFile.js\",\"../src/extraMethods/copydir.js\",\"../src/specialMethods/writeFile-appendFile.js\",\"../src/specialMethods/symlink.js\",\"../src/specialMethods/open.js\",\"../src/specialMethods/mkdir.js\",\"../src/specialMethods/link-rename.js\",\"../src/specialMethods/exists.js\",\"../src/specialMethods/createReadStream-createWriteStream.js\",\"../src/utils/resolvePathAndOptions.js\",\"../src/methodMakers/fileDescriptorMethod.js\",\"../src/methodMakers/standardMethod.js\",\"../src/utils/resolvePath.js\"],\"sourcesContent\":[\"import * as fs from 'graceful-fs';\\nimport * as es6Promise from 'es6-promise';\\nimport { syncMethod, asyncMethod } from './methodMakers/standardMethod';\\nimport { asyncFileDescriptorMethod } from './methodMakers/fileDescriptorMethod';\\n\\n// standard async methods\\nexport const chmod = asyncMethod( 'chmod' );\\nexport const chown = asyncMethod( 'chown' );\\nexport const createReadStream = asyncMethod( 'createReadStream' );\\nexport const createWriteStream = asyncMethod( 'createWriteStream' );\\nexport const lchmod = asyncMethod( 'lchmod' );\\nexport const lchown = asyncMethod( 'lchown' );\\nexport const lstat = asyncMethod( 'lstat' );\\nexport const readdir = asyncMethod( 'readdir' );\\nexport const readFile = asyncMethod( 'readFile' );\\nexport const readlink = asyncMethod( 'readlink' );\\nexport const realpath = asyncMethod( 'realpath' );\\nexport const rmdir = asyncMethod( 'rmdir' );\\nexport const stat = asyncMethod( 'stat' );\\nexport const truncate = asyncMethod( 'truncate' );\\nexport const unlink = asyncMethod( 'unlink' );\\nexport const utimes = asyncMethod( 'utimes' );\\nexport const unwatchFile = asyncMethod( 'unwatchFile' );\\nexport const watch = asyncMethod( 'watch' );\\nexport const watchFile = asyncMethod( 'watchFile' );\\n\\n// standard sync methods\\nexport const chmodSync = syncMethod( 'chmodSync' );\\nexport const chownSync = syncMethod( 'chownSync' );\\nexport const lchmodSync = syncMethod( 'lchmodSync' );\\nexport const lchownSync = syncMethod( 'lchownSync' );\\nexport const lstatSync = syncMethod( 'lstatSync' );\\nexport const readdirSync = syncMethod( 'readdirSync' );\\nexport const readFileSync = syncMethod( 'readFileSync' );\\nexport const readlinkSync = syncMethod( 'readlinkSync' );\\nexport const realpathSync = syncMethod( 'realpathSync' );\\nexport const rmdirSync = syncMethod( 'rmdirSync' );\\nexport const statSync = syncMethod( 'statSync' );\\nexport const truncateSync = syncMethod( 'truncateSync' );\\nexport const unlinkSync = syncMethod( 'unlinkSync' );\\nexport const utimesSync = syncMethod( 'utimesSync' );\\n\\n// file descriptor async methods\\nexport const close = asyncFileDescriptorMethod( 'close' );\\nexport const fchmod = asyncFileDescriptorMethod( 'fchmod' );\\nexport const fchown = asyncFileDescriptorMethod( 'fchown' );\\nexport const fstat = asyncFileDescriptorMethod( 'fstat' );\\nexport const fsync = asyncFileDescriptorMethod( 'fsync' );\\nexport const ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\\nexport const futimes = asyncFileDescriptorMethod( 'futimes' );\\nexport const read = asyncFileDescriptorMethod( 'read' );\\n\\n// file descriptor sync methods\\nexport const closeSync = fs.closeSync;\\nexport const fchmodSync = fs.fchmodSync;\\nexport const fchownSync = fs.fchownSync;\\nexport const fstatSync = fs.fstatSync;\\nexport const fsyncSync = fs.fsyncSync;\\nexport const ftruncateSync = fs.ftruncateSync;\\nexport const futimesSync = fs.futimesSync;\\nexport const readSync = fs.readSync;\\n\\n// special methods\\nexport { createReadStream, createWriteStream } from './specialMethods/createReadStream-createWriteStream'; // TODO aren't these covered by the standard methods?\\nexport { exists, existsSync } from './specialMethods/exists';\\nexport { link, linkSync, rename, renameSync } from './specialMethods/link-rename';\\nexport { mkdir, mkdirSync } from './specialMethods/mkdir';\\nexport { open, openSync } from './specialMethods/open';\\nexport { symlink, symlinkSync } from './specialMethods/symlink';\\nexport { writeFile, writeFileSync, appendFile, appendFileSync } from './specialMethods/writeFile-appendFile';\\n\\n// extra methods\\nexport { copydir, copydirSync } from './extraMethods/copydir';\\nexport { copyFile, copyFileSync } from './extraMethods/copyFile';\\nexport { lsr, lsrSync } from './extraMethods/lsr';\\nexport { rimraf, rimrafSync } from './extraMethods/rimraf';\\nexport { symlinkOrCopy, symlinkOrCopySync } from './extraMethods/symlinkOrCopy';\\n\\n// expose Promise for convenience\\n// https://github.com/esperantojs/esperanto/issues/161\\nexport const Promise = es6Promise.Promise;\",\"import { stat, statSync } from '../sander';\\nimport { copydir, copydirSync } from './copydir';\\nimport { copyFile, copyFileSync } from './copyFile';\\nimport { symlink, symlinkSync } from '../specialMethods/symlink';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nconst isWindows = process.platform === 'win32';\\n\\nexport function symlinkOrCopy () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\tlet copyDirOrFileTo = stat( src )\\n\\t\\t\\t.then( stats => {\\n\\t\\t\\t\\treturn ( stats.isDirectory() ? copydir : copyFile )\\n\\t\\t\\t\\t\\t.apply( null, arguments )\\n\\t\\t\\t\\t\\t.to;\\n\\t\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\treturn copyDirOrFileTo\\n\\t\\t\\t\\t\\t.then(fn => {\\n\\t\\t\\t\\t\\t\\treturn fn.apply(null, arguments);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\treturn symlink.apply( null, arguments );\\n}\\n\\nexport function symlinkOrCopySync () {\\n\\tif ( isWindows ) {\\n\\t\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\t\\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\\n\\t}\\n\\n\\treturn symlinkSync.apply( null, arguments );\\n}\",\"import _rimraf from 'rimraf';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function rimraf () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t_rimraf( target, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function rimrafSync () {\\n\\t_rimraf.sync( resolvePath( arguments ) );\\n}\",\"import * as fs from 'fs';\\nimport { resolve, sep } from 'path';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction walk ( dir, callback ) {\\n\\tlet results = [];\\n\\n\\tfs.readdir( dir, ( err, files ) => {\\n\\t\\tif ( err ) return callback( err );\\n\\n\\t\\tlet pending = files.length;\\n\\t\\tif ( !pending ) return callback( null, results );\\n\\n\\t\\tfiles.forEach( file => {\\n\\t\\t\\tfile = resolve( dir, file );\\n\\n\\t\\t\\tfs.stat( file, ( err, stats ) => {\\n\\t\\t\\t\\tif ( stats && stats.isDirectory() ) {\\n\\t\\t\\t\\t\\twalk( file, ( err, res ) => {\\n\\t\\t\\t\\t\\t\\tresults = results.concat( res );\\n\\t\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults.push( file );\\n\\t\\t\\t\\t\\tif ( !--pending ) callback( null, results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t});\\n};\\n\\nexport function lsr () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\twalk( basedir, function ( err, result ) {\\n\\t\\t\\tif ( err ) return reject( err );\\n\\n\\t\\t\\t// files should be relative to basedir\\n\\t\\t\\tconst index = basedir.length + 1;\\n\\t\\t\\tlet i = result.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tresult[i] = result[i].substring( index );\\n\\t\\t\\t}\\n\\n\\t\\t\\tfulfil( result );\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function lsrSync () {\\n\\tconst basedir = resolvePath( arguments );\\n\\n\\tlet result = [];\\n\\n\\tfunction processdir ( dir ) {\\n\\t\\tfs.readdirSync( dir ).forEach( file => {\\n\\t\\t\\tconst filepath = dir + sep + file;\\n\\n\\t\\t\\tif ( fs.statSync( filepath ).isDirectory() ) {\\n\\t\\t\\t\\tprocessdir( filepath );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.push( filepath.replace( basedir + sep, '' ) );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\tprocessdir( basedir );\\n\\treturn result;\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copyFile () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tconst readStream = fs.createReadStream( src, readOptions );\\n\\t\\t\\t\\t\\t\\tconst writeStream = fs.createWriteStream( dest, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\treadStream.on( 'error', reject );\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'error', reject );\\n\\n\\t\\t\\t\\t\\t\\twriteStream.on( 'close', fulfil );\\n\\n\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copyFileSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tconst data = fs.readFileSync( src, readOptions );\\n\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\tfs.writeFileSync( dest, data, writeOptions );\\n\\t\\t}\\n\\t};\\n}\",\"import { sep } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function copydir () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest, cb ) {\\n\\t\\t\\t\\tmkdirp( dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\tfs.readdir( src, ( err, files ) => {\\n\\t\\t\\t\\t\\t\\tif ( err ) return cb( err );\\n\\n\\t\\t\\t\\t\\t\\tlet remaining = files.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( !remaining ) return cb();\\n\\n\\t\\t\\t\\t\\t\\tfunction check ( err ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cb( err );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( !--remaining ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcb();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfiles.forEach( function ( filename ) {\\n\\t\\t\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\t\\t\\tfs.stat( srcpath, ( err, stats ) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar readStream, writeStream;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( stats.isDirectory() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath, check );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream = fs.createReadStream( srcpath, readOptions );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream = fs.createWriteStream( destpath, writeOptions );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.on( 'error', cb );\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'error', cb );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\twriteStream.on( 'close', check );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\treadStream.pipe( writeStream );\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tcopydir( src, dest, err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function copydirSync () {\\n\\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\tfunction copydir ( src, dest ) {\\n\\t\\t\\t\\tmkdirp.sync( dest );\\n\\n\\t\\t\\t\\tfs.readdirSync( src ).forEach( filename => {\\n\\t\\t\\t\\t\\tconst srcpath = src + sep + filename;\\n\\t\\t\\t\\t\\tconst destpath = dest + sep + filename;\\n\\n\\t\\t\\t\\t\\tif ( fs.statSync( srcpath ).isDirectory() ) {\\n\\t\\t\\t\\t\\t\\treturn copydir( srcpath, destpath );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tconst data = fs.readFileSync( srcpath, readOptions );\\n\\t\\t\\t\\t\\tfs.writeFileSync( destpath, data, writeOptions );\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tcopydir( src, dest );\\n\\t\\t}\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const writeFile = asyncMethod( 'writeFile' );\\nexport const appendFile = asyncMethod( 'appendFile' );\\n\\nexport const writeFileSync = syncMethod( 'writeFileSync' );\\nexport const appendFileSync = syncMethod( 'appendFileSync' );\\n\\nfunction normaliseArguments ( args ) {\\n\\targs = Array.prototype.slice.call( args, 0 );\\n\\tlet opts = {};\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\\n\\t\\topts = args.pop();\\n\\t}\\n\\n\\treturn { opts, data: args.pop(), dest: resolvePath( args ) };\\n}\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data, opts } = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfs[ methodName ]( dest, data, opts, err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfulfil( data );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst { dest, data } = normaliseArguments( arguments );\\n\\n\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\treturn fs[ methodName ]( dest, data );\\n\\t};\\n}\\n\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function symlink () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\n\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfs.symlink( src, dest, options.type, err => {\\n\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nexport function symlinkSync () {\\n\\tconst src = resolvePath( arguments );\\n\\n\\treturn {\\n\\t\\tto () {\\n\\t\\t\\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\\n\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\treturn fs.symlinkSync( src, dest, options.type );\\n\\t\\t}\\n\\t};\\n}\",\"import { dirname } from 'path';\\nimport * as fs from 'graceful-fs';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tlet options;\\n\\tlet flags;\\n\\tlet i;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\t\\tflags = args[ args.length - 2 ];\\n\\t\\ti = args.length - 2;\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tflags = args[ args.length - 1 ];\\n\\t\\ti = args.length - 1;\\n\\t}\\n\\n\\tlet pathargs = new Array( i );\\n\\twhile ( i-- ) {\\n\\t\\tpathargs[i] = args[i];\\n\\t}\\n\\n\\tconst resolvedPath = resolvePath( pathargs );\\n\\n\\treturn { resolvedPath, options, flags };\\n}\\n\\nfunction bailIfExists ( src, flags, mode ) {\\n\\tlet alreadyExists;\\n\\n\\ttry {\\n\\t\\tfs.statSync( src );\\n\\t\\talreadyExists = true;\\n\\t} catch ( err ) {\\n\\t\\tif ( err.code !== 'ENOENT' ) {\\n\\t\\t\\tthrow err;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( alreadyExists ) {\\n\\t\\t// attempt the operation = that way, we get the intended error message\\n\\t\\t// TODO can't we just do this in the first place?\\n\\t\\tfs.openSync( src, flags, mode );\\n\\t}\\n}\\n\\nexport function open () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tfunction open () {\\n\\t\\t\\tfs.open( src, flags, options.mode, ( err, fd ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( fd );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t// create dirs if necessary\\n\\t\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\t\\tmkdirp( dirname( src ), err => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\topen();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\topen();\\n\\t\\t}\\n\\t});\\n}\\n\\n\\nexport function openSync () {\\n\\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\\n\\n\\tif ( /^.x/.test( flags ) ) {\\n\\t\\tbailIfExists( src, flags, options.mode );\\n\\t}\\n\\n\\t// create dirs if necessary\\n\\tif ( /^[wa]/.test( flags ) ) {\\n\\t\\tmkdirp.sync( dirname( src ) );\\n\\t}\\n\\n\\treturn fs.openSync( src, flags, options.mode );\\n}\",\"import mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function mkdir () {\\n\\tconst dir = resolvePath( arguments );\\n\\n\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\tmkdirp( dir, err => {\\n\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\treject( err );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfulfil();\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\nexport function mkdirSync () {\\n\\tconst dir = resolvePath( arguments );\\n\\tmkdirp.sync( dir );\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport const rename = asyncMethod( 'rename' );\\nexport const link = asyncMethod( 'link' );\\n\\nexport const renameSync = syncMethod( 'renameSync' );\\nexport const linkSync = syncMethod( 'linkSync' );\\n\\nfunction asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\t\\t\\tmkdirp( dirname( dest ), err => {\\n\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tfs[ methodName ]( src, dest, err => {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfulfil();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\\n\\nfunction syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst src = resolvePath( arguments );\\n\\n\\t\\treturn {\\n\\t\\t\\tto () {\\n\\t\\t\\t\\tconst dest = resolvePath( arguments );\\n\\n\\t\\t\\t\\tmkdirp.sync( dirname( dest ) );\\n\\t\\t\\t\\treturn fs[ methodName ]( src, dest );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nexport function exists () {\\n\\tconst target = resolvePath( arguments );\\n\\n\\treturn new Promise( fulfil => {\\n\\t\\tfs.exists( target, exists => fulfil( exists ) );\\n\\t});\\n}\\n\\nexport function existsSync () {\\n\\treturn fs.existsSync( resolvePath( arguments ) );\\n}\",\"import * as fs from 'graceful-fs';\\nimport { dirname } from 'path';\\nimport mkdirp from 'mkdirp';\\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\\n\\nexport function createReadStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\treturn fs.createReadStream( resolvedPath, options );\\n}\\n\\nexport function createWriteStream () {\\n\\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\\n\\n\\tmkdirp.sync( dirname( resolvedPath ) );\\n\\treturn fs.createWriteStream( resolvedPath, options );\\n}\",\"import { resolve } from 'path';\\n\\nexport default function resolvePathAndOptions ( args ) {\\n\\tlet options;\\n\\tlet pathargs;\\n\\n\\tif ( typeof args[ args.length - 1 ] === 'object' ) {\\n\\t\\toptions = args[ args.length - 1 ];\\n\\n\\t\\tlet i = args.length - 1;\\n\\t\\tpathargs = new Array( i );\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t}\\n\\t} else {\\n\\t\\toptions = {};\\n\\t\\tpathargs = args;\\n\\t}\\n\\n\\tconst resolvedPath = resolve.apply( null, pathargs );\\n\\n\\treturn { options, resolvedPath };\\n}\",\"import * as fs from 'graceful-fs';\\n\\nexport function asyncFileDescriptorMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tlet args = [];\\n\\t\\tlet i = arguments.length;\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\",\"import * as fs from 'graceful-fs';\\nimport resolvePath from '../utils/resolvePath';\\n\\nfunction normaliseArguments ( args ) {\\n\\tconst len = args.length;\\n\\n\\tlet buildingPath = true;\\n\\tlet pathargs = [];\\n\\tlet normalised = [ null ]; // null is a placeholder for the resolved path\\n\\tlet i;\\n\\n\\tfor ( i = 0; i < len; i += 1 ) {\\n\\t\\tif ( buildingPath && typeof args[i] === 'string' ) {\\n\\t\\t\\tpathargs[i] = args[i];\\n\\t\\t} else {\\n\\t\\t\\tbuildingPath = false;\\n\\t\\t\\tnormalised.push( args[i] );\\n\\t\\t}\\n\\t}\\n\\n\\tnormalised[0] = resolvePath( pathargs );\\n\\n\\treturn normalised;\\n}\\n\\nexport function asyncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\n\\t\\treturn new Promise( ( fulfil, reject ) => {\\n\\t\\t\\targs.push( ( err, result ) => {\\n\\t\\t\\t\\tif ( err ) {\\n\\t\\t\\t\\t\\treject( err );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfulfil( result );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfs[ methodName ].apply( fs, args );\\n\\t\\t});\\n\\t};\\n}\\n\\nexport function syncMethod ( methodName ) {\\n\\treturn function () {\\n\\t\\tconst args = normaliseArguments( arguments );\\n\\t\\treturn fs[ methodName ].apply( fs, args );\\n\\t};\\n}\",\"import { resolve } from 'path';\\n\\nexport default function resolvePath ( args ) {\\n\\treturn resolve.apply( null, args );\\n}\"],\"names\":[],\"mappings\":\"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\"}"}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"sander\",\n  \"description\": \"Promise-based power tool for common filesystem tasks\",\n  \"author\": \"Rich Harris\",\n  \"version\": \"0.5.1\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/rich-harris/sander\",\n  \"dependencies\": {\n    \"es6-promise\": \"^3.1.2\",\n    \"mkdirp\": \"^0.5.1\",\n    \"rimraf\": \"^2.5.2\",\n    \"graceful-fs\": \"^4.1.3\"\n  },\n  \"main\": \"dist/sander.cjs.js\",\n  \"jsnext:main\": \"dist/sander.es.js\",\n  \"devDependencies\": {\n    \"buffer-crc32\": \"^0.2.5\",\n    \"mocha\": \"^2.4.5\",\n    \"rollup\": \"^0.26.2\",\n    \"rollup-plugin-buble\": \"^0.7.0\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"pretest\": \"npm run build:cjs\",\n    \"build\": \"npm run build:cjs && npm run build:es\",\n    \"build:cjs\": \"rollup -c -f cjs -o dist/sander.cjs.js\",\n    \"build:es\": \"rollup -c -f es6 -o dist/sander.es.js\",\n    \"prepublish\": \"npm test && npm run build:es\"\n  },\n  \"files\": [\n    \"src\",\n    \"dist\",\n    \"README.md\"\n  ]\n}\n"}},"src":{"directory":{"extraMethods":{"directory":{"copydir.js":{"file":{"contents":"import { sep } from 'path';\nimport * as fs from 'graceful-fs';\nimport mkdirp from 'mkdirp';\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\n\nexport function copydir () {\n\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\n\n\t\t\tfunction copydir ( src, dest, cb ) {\n\t\t\t\tmkdirp( dest, err => {\n\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\tfs.readdir( src, ( err, files ) => {\n\t\t\t\t\t\tif ( err ) return cb( err );\n\n\t\t\t\t\t\tlet remaining = files.length;\n\n\t\t\t\t\t\tif ( !remaining ) return cb();\n\n\t\t\t\t\t\tfunction check ( err ) {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treturn cb( err );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( !--remaining ) {\n\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfiles.forEach( function ( filename ) {\n\t\t\t\t\t\t\tconst srcpath = src + sep + filename;\n\t\t\t\t\t\t\tconst destpath = dest + sep + filename;\n\n\t\t\t\t\t\t\tfs.stat( srcpath, ( err, stats ) => {\n\t\t\t\t\t\t\t\tvar readStream, writeStream;\n\n\t\t\t\t\t\t\t\tif ( stats.isDirectory() ) {\n\t\t\t\t\t\t\t\t\treturn copydir( srcpath, destpath, check );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treadStream = fs.createReadStream( srcpath, readOptions );\n\t\t\t\t\t\t\t\twriteStream = fs.createWriteStream( destpath, writeOptions );\n\n\t\t\t\t\t\t\t\treadStream.on( 'error', cb );\n\t\t\t\t\t\t\t\twriteStream.on( 'error', cb );\n\n\t\t\t\t\t\t\t\twriteStream.on( 'close', check );\n\n\t\t\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\t\tcopydir( src, dest, err => {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfulfil();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport function copydirSync () {\n\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\n\n\t\t\tfunction copydir ( src, dest ) {\n\t\t\t\tmkdirp.sync( dest );\n\n\t\t\t\tfs.readdirSync( src ).forEach( filename => {\n\t\t\t\t\tconst srcpath = src + sep + filename;\n\t\t\t\t\tconst destpath = dest + sep + filename;\n\n\t\t\t\t\tif ( fs.statSync( srcpath ).isDirectory() ) {\n\t\t\t\t\t\treturn copydir( srcpath, destpath );\n\t\t\t\t\t}\n\n\t\t\t\t\tconst data = fs.readFileSync( srcpath, readOptions );\n\t\t\t\t\tfs.writeFileSync( destpath, data, writeOptions );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcopydir( src, dest );\n\t\t}\n\t};\n}"}},"copyFile.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport { dirname } from 'path';\nimport mkdirp from 'mkdirp';\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\n\nexport function copyFile () {\n\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\n\n\t\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\t\tmkdirp( dirname( dest ), err => {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst readStream = fs.createReadStream( src, readOptions );\n\t\t\t\t\t\tconst writeStream = fs.createWriteStream( dest, writeOptions );\n\n\t\t\t\t\t\treadStream.on( 'error', reject );\n\t\t\t\t\t\twriteStream.on( 'error', reject );\n\n\t\t\t\t\t\twriteStream.on( 'close', fulfil );\n\n\t\t\t\t\t\treadStream.pipe( writeStream );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport function copyFileSync () {\n\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { resolvedPath: dest, options: writeOptions } = resolvePathAndOptions( arguments );\n\n\t\t\tconst data = fs.readFileSync( src, readOptions );\n\n\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\tfs.writeFileSync( dest, data, writeOptions );\n\t\t}\n\t};\n}"}},"lsr.js":{"file":{"contents":"import * as fs from 'fs';\nimport { resolve, sep } from 'path';\nimport resolvePath from '../utils/resolvePath';\n\nfunction walk ( dir, callback ) {\n\tlet results = [];\n\n\tfs.readdir( dir, ( err, files ) => {\n\t\tif ( err ) return callback( err );\n\n\t\tlet pending = files.length;\n\t\tif ( !pending ) return callback( null, results );\n\n\t\tfiles.forEach( file => {\n\t\t\tfile = resolve( dir, file );\n\n\t\t\tfs.stat( file, ( err, stats ) => {\n\t\t\t\tif ( stats && stats.isDirectory() ) {\n\t\t\t\t\twalk( file, ( err, res ) => {\n\t\t\t\t\t\tresults = results.concat( res );\n\t\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresults.push( file );\n\t\t\t\t\tif ( !--pending ) callback( null, results );\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\nexport function lsr () {\n\tconst basedir = resolvePath( arguments );\n\n\treturn new Promise( ( fulfil, reject ) => {\n\t\twalk( basedir, function ( err, result ) {\n\t\t\tif ( err ) return reject( err );\n\n\t\t\t// files should be relative to basedir\n\t\t\tconst index = basedir.length + 1;\n\t\t\tlet i = result.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tresult[i] = result[i].substring( index );\n\t\t\t}\n\n\t\t\tfulfil( result );\n\t\t});\n\t});\n}\n\nexport function lsrSync () {\n\tconst basedir = resolvePath( arguments );\n\n\tlet result = [];\n\n\tfunction processdir ( dir ) {\n\t\tfs.readdirSync( dir ).forEach( file => {\n\t\t\tconst filepath = dir + sep + file;\n\n\t\t\tif ( fs.statSync( filepath ).isDirectory() ) {\n\t\t\t\tprocessdir( filepath );\n\t\t\t} else {\n\t\t\t\tresult.push( filepath.replace( basedir + sep, '' ) );\n\t\t\t}\n\t\t});\n\t}\n\n\tprocessdir( basedir );\n\treturn result;\n}"}},"rimraf.js":{"file":{"contents":"import _rimraf from 'rimraf';\nimport resolvePath from '../utils/resolvePath';\n\nexport function rimraf () {\n\tconst target = resolvePath( arguments );\n\n\treturn new Promise( ( fulfil, reject ) => {\n\t\t_rimraf( target, err => {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function rimrafSync () {\n\t_rimraf.sync( resolvePath( arguments ) );\n}"}},"symlinkOrCopy.js":{"file":{"contents":"import { stat, statSync } from '../sander';\nimport { copydir, copydirSync } from './copydir';\nimport { copyFile, copyFileSync } from './copyFile';\nimport { symlink, symlinkSync } from '../specialMethods/symlink';\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\n\nconst isWindows = process.platform === 'win32';\n\nexport function symlinkOrCopy () {\n\tif ( isWindows ) {\n\t\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\n\t\tlet copyDirOrFileTo = stat( src )\n\t\t\t.then( stats => {\n\t\t\t\treturn ( stats.isDirectory() ? copydir : copyFile )\n\t\t\t\t\t.apply( null, arguments )\n\t\t\t\t\t.to;\n\t\t\t});\n\n\t\treturn {\n\t\t\tto () {\n\t\t\t\treturn copyDirOrFileTo\n\t\t\t\t\t.then(fn => {\n\t\t\t\t\t\treturn fn.apply(null, arguments);\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\treturn symlink.apply( null, arguments );\n}\n\nexport function symlinkOrCopySync () {\n\tif ( isWindows ) {\n\t\tconst { resolvedPath: src, options: readOptions } = resolvePathAndOptions( arguments );\n\t\treturn ( statSync( src ).isDirectory() ? copydirSync : copyFileSync ).apply( null, arguments );\n\t}\n\n\treturn symlinkSync.apply( null, arguments );\n}"}}}},"methodMakers":{"directory":{"fileDescriptorMethod.js":{"file":{"contents":"import * as fs from 'graceful-fs';\n\nexport function asyncFileDescriptorMethod ( methodName ) {\n\treturn function () {\n\t\tlet args = [];\n\t\tlet i = arguments.length;\n\n\t\twhile ( i-- ) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\targs.push( ( err, result ) => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}"}},"standardMethod.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport resolvePath from '../utils/resolvePath';\n\nfunction normaliseArguments ( args ) {\n\tconst len = args.length;\n\n\tlet buildingPath = true;\n\tlet pathargs = [];\n\tlet normalised = [ null ]; // null is a placeholder for the resolved path\n\tlet i;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( buildingPath && typeof args[i] === 'string' ) {\n\t\t\tpathargs[i] = args[i];\n\t\t} else {\n\t\t\tbuildingPath = false;\n\t\t\tnormalised.push( args[i] );\n\t\t}\n\t}\n\n\tnormalised[0] = resolvePath( pathargs );\n\n\treturn normalised;\n}\n\nexport function asyncMethod ( methodName ) {\n\treturn function () {\n\t\tconst args = normaliseArguments( arguments );\n\n\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\targs.push( ( err, result ) => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( result );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfs[ methodName ].apply( fs, args );\n\t\t});\n\t};\n}\n\nexport function syncMethod ( methodName ) {\n\treturn function () {\n\t\tconst args = normaliseArguments( arguments );\n\t\treturn fs[ methodName ].apply( fs, args );\n\t};\n}"}}}},"sander.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport * as es6Promise from 'es6-promise';\nimport { syncMethod, asyncMethod } from './methodMakers/standardMethod';\nimport { asyncFileDescriptorMethod } from './methodMakers/fileDescriptorMethod';\n\n// standard async methods\nexport const chmod = asyncMethod( 'chmod' );\nexport const chown = asyncMethod( 'chown' );\nexport const createReadStream = asyncMethod( 'createReadStream' );\nexport const createWriteStream = asyncMethod( 'createWriteStream' );\nexport const lchmod = asyncMethod( 'lchmod' );\nexport const lchown = asyncMethod( 'lchown' );\nexport const lstat = asyncMethod( 'lstat' );\nexport const readdir = asyncMethod( 'readdir' );\nexport const readFile = asyncMethod( 'readFile' );\nexport const readlink = asyncMethod( 'readlink' );\nexport const realpath = asyncMethod( 'realpath' );\nexport const rmdir = asyncMethod( 'rmdir' );\nexport const stat = asyncMethod( 'stat' );\nexport const truncate = asyncMethod( 'truncate' );\nexport const unlink = asyncMethod( 'unlink' );\nexport const utimes = asyncMethod( 'utimes' );\nexport const unwatchFile = asyncMethod( 'unwatchFile' );\nexport const watch = asyncMethod( 'watch' );\nexport const watchFile = asyncMethod( 'watchFile' );\n\n// standard sync methods\nexport const chmodSync = syncMethod( 'chmodSync' );\nexport const chownSync = syncMethod( 'chownSync' );\nexport const lchmodSync = syncMethod( 'lchmodSync' );\nexport const lchownSync = syncMethod( 'lchownSync' );\nexport const lstatSync = syncMethod( 'lstatSync' );\nexport const readdirSync = syncMethod( 'readdirSync' );\nexport const readFileSync = syncMethod( 'readFileSync' );\nexport const readlinkSync = syncMethod( 'readlinkSync' );\nexport const realpathSync = syncMethod( 'realpathSync' );\nexport const rmdirSync = syncMethod( 'rmdirSync' );\nexport const statSync = syncMethod( 'statSync' );\nexport const truncateSync = syncMethod( 'truncateSync' );\nexport const unlinkSync = syncMethod( 'unlinkSync' );\nexport const utimesSync = syncMethod( 'utimesSync' );\n\n// file descriptor async methods\nexport const close = asyncFileDescriptorMethod( 'close' );\nexport const fchmod = asyncFileDescriptorMethod( 'fchmod' );\nexport const fchown = asyncFileDescriptorMethod( 'fchown' );\nexport const fstat = asyncFileDescriptorMethod( 'fstat' );\nexport const fsync = asyncFileDescriptorMethod( 'fsync' );\nexport const ftruncate = asyncFileDescriptorMethod( 'ftruncate' );\nexport const futimes = asyncFileDescriptorMethod( 'futimes' );\nexport const read = asyncFileDescriptorMethod( 'read' );\n\n// file descriptor sync methods\nexport const closeSync = fs.closeSync;\nexport const fchmodSync = fs.fchmodSync;\nexport const fchownSync = fs.fchownSync;\nexport const fstatSync = fs.fstatSync;\nexport const fsyncSync = fs.fsyncSync;\nexport const ftruncateSync = fs.ftruncateSync;\nexport const futimesSync = fs.futimesSync;\nexport const readSync = fs.readSync;\n\n// special methods\nexport { createReadStream, createWriteStream } from './specialMethods/createReadStream-createWriteStream'; // TODO aren't these covered by the standard methods?\nexport { exists, existsSync } from './specialMethods/exists';\nexport { link, linkSync, rename, renameSync } from './specialMethods/link-rename';\nexport { mkdir, mkdirSync } from './specialMethods/mkdir';\nexport { open, openSync } from './specialMethods/open';\nexport { symlink, symlinkSync } from './specialMethods/symlink';\nexport { writeFile, writeFileSync, appendFile, appendFileSync } from './specialMethods/writeFile-appendFile';\n\n// extra methods\nexport { copydir, copydirSync } from './extraMethods/copydir';\nexport { copyFile, copyFileSync } from './extraMethods/copyFile';\nexport { lsr, lsrSync } from './extraMethods/lsr';\nexport { rimraf, rimrafSync } from './extraMethods/rimraf';\nexport { symlinkOrCopy, symlinkOrCopySync } from './extraMethods/symlinkOrCopy';\n\n// expose Promise for convenience\n// https://github.com/esperantojs/esperanto/issues/161\nexport const Promise = es6Promise.Promise;"}},"specialMethods":{"directory":{"createReadStream-createWriteStream.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport { dirname } from 'path';\nimport mkdirp from 'mkdirp';\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\n\nexport function createReadStream () {\n\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\n\treturn fs.createReadStream( resolvedPath, options );\n}\n\nexport function createWriteStream () {\n\tconst { resolvedPath, options } = resolvePathAndOptions( arguments );\n\n\tmkdirp.sync( dirname( resolvedPath ) );\n\treturn fs.createWriteStream( resolvedPath, options );\n}"}},"exists.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport resolvePath from '../utils/resolvePath';\n\nexport function exists () {\n\tconst target = resolvePath( arguments );\n\n\treturn new Promise( fulfil => {\n\t\tfs.exists( target, exists => fulfil( exists ) );\n\t});\n}\n\nexport function existsSync () {\n\treturn fs.existsSync( resolvePath( arguments ) );\n}"}},"link-rename.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport { dirname } from 'path';\nimport mkdirp from 'mkdirp';\nimport resolvePath from '../utils/resolvePath';\n\nexport const rename = asyncMethod( 'rename' );\nexport const link = asyncMethod( 'link' );\n\nexport const renameSync = syncMethod( 'renameSync' );\nexport const linkSync = syncMethod( 'linkSync' );\n\nfunction asyncMethod ( methodName ) {\n\treturn function () {\n\t\tconst src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto () {\n\t\t\t\tconst dest = resolvePath( arguments );\n\n\t\t\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\t\t\tmkdirp( dirname( dest ), err => {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs[ methodName ]( src, dest, err => {\n\t\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t};\n}\n\nfunction syncMethod ( methodName ) {\n\treturn function () {\n\t\tconst src = resolvePath( arguments );\n\n\t\treturn {\n\t\t\tto () {\n\t\t\t\tconst dest = resolvePath( arguments );\n\n\t\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\t\treturn fs[ methodName ]( src, dest );\n\t\t\t}\n\t\t};\n\t};\n}"}},"mkdir.js":{"file":{"contents":"import mkdirp from 'mkdirp';\nimport resolvePath from '../utils/resolvePath';\n\nexport function mkdir () {\n\tconst dir = resolvePath( arguments );\n\n\treturn new Promise( ( fulfil, reject ) => {\n\t\tmkdirp( dir, err => {\n\t\t\tif ( err ) {\n\t\t\t\treject( err );\n\t\t\t} else {\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport function mkdirSync () {\n\tconst dir = resolvePath( arguments );\n\tmkdirp.sync( dir );\n}"}},"open.js":{"file":{"contents":"import { dirname } from 'path';\nimport * as fs from 'graceful-fs';\nimport mkdirp from 'mkdirp';\nimport resolvePath from '../utils/resolvePath';\n\nfunction normaliseArguments ( args ) {\n\tlet options;\n\tlet flags;\n\tlet i;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\t\tflags = args[ args.length - 2 ];\n\t\ti = args.length - 2;\n\t} else {\n\t\toptions = {};\n\t\tflags = args[ args.length - 1 ];\n\t\ti = args.length - 1;\n\t}\n\n\tlet pathargs = new Array( i );\n\twhile ( i-- ) {\n\t\tpathargs[i] = args[i];\n\t}\n\n\tconst resolvedPath = resolvePath( pathargs );\n\n\treturn { resolvedPath, options, flags };\n}\n\nfunction bailIfExists ( src, flags, mode ) {\n\tlet alreadyExists;\n\n\ttry {\n\t\tfs.statSync( src );\n\t\talreadyExists = true;\n\t} catch ( err ) {\n\t\tif ( err.code !== 'ENOENT' ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif ( alreadyExists ) {\n\t\t// attempt the operation = that way, we get the intended error message\n\t\t// TODO can't we just do this in the first place?\n\t\tfs.openSync( src, flags, mode );\n\t}\n}\n\nexport function open () {\n\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\treturn new Promise( ( fulfil, reject ) => {\n\t\tfunction open () {\n\t\t\tfs.open( src, flags, options.mode, ( err, fd ) => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfulfil( fd );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// create dirs if necessary\n\t\tif ( /^[wa]/.test( flags ) ) {\n\t\t\tmkdirp( dirname( src ), err => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\topen();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\topen();\n\t\t}\n\t});\n}\n\n\nexport function openSync () {\n\tconst { resolvedPath: src, options, flags } = normaliseArguments( arguments );\n\n\tif ( /^.x/.test( flags ) ) {\n\t\tbailIfExists( src, flags, options.mode );\n\t}\n\n\t// create dirs if necessary\n\tif ( /^[wa]/.test( flags ) ) {\n\t\tmkdirp.sync( dirname( src ) );\n\t}\n\n\treturn fs.openSync( src, flags, options.mode );\n}"}},"symlink.js":{"file":{"contents":"import { dirname } from 'path';\nimport * as fs from 'graceful-fs';\nimport mkdirp from 'mkdirp';\nimport resolvePath from '../utils/resolvePath';\nimport resolvePathAndOptions from '../utils/resolvePathAndOptions';\n\nexport function symlink () {\n\tconst src = resolvePath( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\n\n\t\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\t\tmkdirp( dirname( dest ), err => {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\treject( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfs.symlink( src, dest, options.type, err => {\n\t\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfulfil();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport function symlinkSync () {\n\tconst src = resolvePath( arguments );\n\n\treturn {\n\t\tto () {\n\t\t\tconst { options, resolvedPath: dest } = resolvePathAndOptions( arguments );\n\t\t\tmkdirp.sync( dirname( dest ) );\n\t\t\treturn fs.symlinkSync( src, dest, options.type );\n\t\t}\n\t};\n}"}},"writeFile-appendFile.js":{"file":{"contents":"import * as fs from 'graceful-fs';\nimport { dirname } from 'path';\nimport mkdirp from 'mkdirp';\nimport resolvePath from '../utils/resolvePath';\n\nexport const writeFile = asyncMethod( 'writeFile' );\nexport const appendFile = asyncMethod( 'appendFile' );\n\nexport const writeFileSync = syncMethod( 'writeFileSync' );\nexport const appendFileSync = syncMethod( 'appendFileSync' );\n\nfunction normaliseArguments ( args ) {\n\targs = Array.prototype.slice.call( args, 0 );\n\tlet opts = {};\n\n\tif ( typeof args[ args.length - 1 ] === 'object' && !( args[ args.length - 1 ] instanceof Buffer ) ) {\n\t\topts = args.pop();\n\t}\n\n\treturn { opts, data: args.pop(), dest: resolvePath( args ) };\n}\n\nfunction asyncMethod ( methodName ) {\n\treturn function () {\n\t\tconst { dest, data, opts } = normaliseArguments( arguments );\n\n\t\treturn new Promise( ( fulfil, reject ) => {\n\t\t\tmkdirp( dirname( dest ), err => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t} else {\n\t\t\t\t\tfs[ methodName ]( dest, data, opts, err => {\n\t\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfulfil( data );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction syncMethod ( methodName ) {\n\treturn function () {\n\t\tconst { dest, data } = normaliseArguments( arguments );\n\n\t\tmkdirp.sync( dirname( dest ) );\n\t\treturn fs[ methodName ]( dest, data );\n\t};\n}\n"}}}},"utils":{"directory":{"resolvePath.js":{"file":{"contents":"import { resolve } from 'path';\n\nexport default function resolvePath ( args ) {\n\treturn resolve.apply( null, args );\n}"}},"resolvePathAndOptions.js":{"file":{"contents":"import { resolve } from 'path';\n\nexport default function resolvePathAndOptions ( args ) {\n\tlet options;\n\tlet pathargs;\n\n\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t\toptions = args[ args.length - 1 ];\n\n\t\tlet i = args.length - 1;\n\t\tpathargs = new Array( i );\n\n\t\twhile ( i-- ) {\n\t\t\tpathargs[i] = args[i];\n\t\t}\n\t} else {\n\t\toptions = {};\n\t\tpathargs = args;\n\t}\n\n\tconst resolvedPath = resolve.apply( null, pathargs );\n\n\treturn { options, resolvedPath };\n}"}}}}}}}}