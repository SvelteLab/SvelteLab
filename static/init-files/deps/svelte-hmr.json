{"directory":{"index.js":{"file":{"contents":"const createMakeHotFactory = require('./lib/make-hot.js')\nconst { resolve } = require('path')\nconst { name, version } = require('./package.json')\n\nconst resolveAbsoluteImport = target => resolve(__dirname, target)\n\nconst createMakeHot = createMakeHotFactory({\n  pkg: { name, version },\n  resolveAbsoluteImport,\n})\n\nmodule.exports = { createMakeHot }\n"}},"lib":{"directory":{"css-only.js":{"file":{"contents":"/**\n * Injects a `{}*` CSS rule to force Svelte compiler to scope every elements.\n */\nexport const injectScopeEverythingCssRule = (parse, code) => {\n  const { css } = parse(code)\n  if (!css) return code\n  const {\n    content: { end },\n  } = css\n  return code.slice(0, end) + '*{}' + code.slice(end)\n}\n\nexport const normalizeJsCode = code => {\n  // Svelte now adds locations in dev mode, code locations can change when\n  // CSS change, but we're unaffected (not real behaviour changes)\n  code = code.replace(/\\badd_location\\s*\\([^)]*\\)\\s*;?/g, '')\n  return code\n}\n"}},"make-hot.js":{"file":{"contents":"const globalName = '___SVELTE_HMR_HOT_API'\nconst globalAdapterName = '___SVELTE_HMR_HOT_API_PROXY_ADAPTER'\n\nconst defaultHotOptions = {\n  // preserve all local state\n  preserveLocalState: false,\n\n  // escape hatchs from preservation of local state\n  //\n  // disable preservation of state for this component\n  noPreserveStateKey: ['@hmr:reset', '@!hmr'],\n  // enable preservation of state for all variables in this component\n  preserveAllLocalStateKey: '@hmr:keep-all',\n  // enable preservation of state for a given variable (must be inline or\n  // above the target variable or variables; can be repeated)\n  preserveLocalStateKey: '@hmr:keep',\n\n  // don't reload on fatal error\n  noReload: false,\n  // try to recover after runtime errors during component init\n  // defaults to false because some runtime errors are fatal and require a full reload\n  optimistic: false,\n  // auto accept modules of components that have named exports (i.e. exports\n  // from context=\"module\")\n  acceptNamedExports: true,\n  // auto accept modules of components have accessors (either accessors compile\n  // option, or <svelte:option accessors={true} />) -- this means that if you\n  // set accessors compile option globally, you must also set this option to\n  // true, or no component will be hot reloaded (but there are a lot of edge\n  // cases that HMR can't support correctly with accessors)\n  acceptAccessors: true,\n  // only inject CSS instead of recreating components when only CSS changes\n  injectCss: false,\n  // to mitigate FOUC between dispose (remove stylesheet) and accept\n  cssEjectDelay: 100,\n\n  // Svelte Native mode\n  native: false,\n  // name of the adapter import binding\n  importAdapterName: globalAdapterName,\n\n  // disable runtime error overlay\n  noOverlay: false,\n\n  // set to true on systems that supports them, to avoid useless caught /\n  // managed (but still...) exceptions, by using Svelte's current_component\n  // instead of get_current_component\n  allowLiveBinding: false,\n\n  // use acceptExports instead of accept, to fix support of context:module\n  partialAccept: false,\n}\n\nconst defaultHotApi = 'hot-api-esm.js'\n\nconst json = JSON.stringify\n\nconst posixify = file => file.replace(/[/\\\\]/g, '/')\n\nconst renderApplyHmr = ({\n  id,\n  cssId,\n  nonCssHash,\n  hotOptions: {\n    injectCss,\n    partialAccept,\n    _accept = partialAccept ? \"acceptExports(['default'])\" : 'accept()',\n  },\n  hotOptionsJson,\n  hotApiImport,\n  adapterImport,\n  importAdapterName,\n  meta,\n  acceptable,\n  preserveLocalState,\n  emitCss,\n  imports = [\n    `import * as ${globalName} from '${hotApiImport}'`,\n    `import { adapter as ${importAdapterName} } from '${adapterImport}'`,\n  ],\n}) =>\n  // this silly formatting keeps all original characters in their position,\n  // thus saving us from having to provide a sourcemap\n  //\n  // NOTE the `if (false) accept()` line is for tools that wants to see the\n  // accept call in the actual accepted module to enable HMR (Vite and, I\n  // believe, Snowpack 3)\n  //\n  `${imports.join(';')};${`\n    if (${meta} && ${meta}.hot) {\n      ${acceptable ? `if (false) ${meta}.hot.${_accept};` : ''};\n      $2 = ${globalName}.applyHmr({\n        m: ${meta},\n        id: ${json(id)},\n        hotOptions: ${hotOptionsJson},\n        Component: $2,\n        ProxyAdapter: ${importAdapterName},\n        acceptable: ${json(acceptable)},\n        preserveLocalState: ${json(preserveLocalState)},\n        ${cssId ? `cssId: ${json(cssId)},` : ''}\n        ${nonCssHash ? `nonCssHash: ${json(nonCssHash)},` : ''}\n        emitCss: ${json(emitCss)},\n      });\n    }\n  `\n    .split('\\n')\n    .map(x => x.trim())\n    .filter(Boolean)\n    .join(' ')}\nexport default $2;\n${\n  // NOTE when doing CSS only voodoo, we have to inject the stylesheet as soon\n  // as the component is loaded because Svelte normally do that when a component\n  // is instantiated, but we might already have instances in the large when a\n  // component is loaded with HMR\n  cssId && injectCss && !emitCss\n    ? `\nif (typeof add_css !== 'undefined' && !document.getElementById(${json(\n        cssId\n      )})) add_css();`\n    : ``\n}\n`\n\n// replace from last occurrence of the splitter\nconst replaceLast = (string, splitter, regex, replacer) => {\n  const lastIndex = string.lastIndexOf(splitter)\n  return (\n    string.slice(0, lastIndex) +\n    string.slice(lastIndex).replace(regex, replacer)\n  )\n}\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n// (via https://github.com/sveltejs/svelte/blob/91d758e35b2b2154512ddd11e6b6d9d65708a99e/src/compiler/compile/utils/hash.ts#L2)\nconst stringHashcode = str => {\n  let hash = 5381\n  let i = str.length\n  while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i)\n  return (hash >>> 0).toString(36)\n}\n\nconst normalizeJsCode = (code, cssHash) =>\n  code\n    // ignore css hashes in the code (that have changed, necessarily)\n    .replace(new RegExp('\\\\b' + cssHash + '\\\\b', 'g'), '')\n    // Svelte now adds locations in dev mode, code locations can change when\n    // CSS change, but we're unaffected (not real behaviour changes)\n    .replace(/\\badd_location\\s*\\([^)]*\\)\\s*;?/g, '')\n\nconst parseCssId = (code, compileOptions = {}, parseHash, originalCode) => {\n  // the regex matching is very pretty conservative 'cause I don't want to\n  // match something else by error... I'm probably make it more lax if I have\n  // to fix it 3 times in a single week ¯\\_(ツ)_/¯\n  let match = /^function add_css\\(\\) \\{[\\s\\S]*?^}/m.exec(code)\n\n  if (!match) {\n    // guard: injectCss is off, no need to compute hashes\n    if (!parseHash) return {}\n    // guard: compile.css is true, so we should have found the add_css function,\n    //        something unexpected is unraveling here, fall back to caution\n    if (compileOptions.css) return {}\n    // trying to get CSS id the same way as Svelte does it\n    match = /<style[^>]*>([\\s\\S]*)<\\/\\s*style\\s*>/.exec(originalCode)\n    const cssHash = match && match[1] ? stringHashcode(match[1]) : null\n    if (!cssHash) return {}\n    return {\n      cssId: `svelte-${cssHash}-style`,\n      nonCssHash: stringHashcode(normalizeJsCode(code, cssHash)),\n    }\n  }\n\n  const codeExceptCSS =\n    code.slice(0, match.index) + code.slice(match.index + match[0].length)\n\n  match = /\\bstyle\\.id\\s*=\\s*(['\"])([^'\"]*)\\1/.exec(match[0])\n  const cssId = match ? match[2] : null\n\n  if (!parseHash || !cssId) return { cssId }\n\n  const cssHash = cssId.split('-')[1]\n  const nonCssHash = stringHashcode(normalizeJsCode(codeExceptCSS, cssHash))\n\n  return { cssId, nonCssHash }\n}\n\nconst isNamedExport = v => v.export_name && v.module\n\nconst isProp = v => v.export_name && !v.module\n\nconst resolvePackageImport = (name = 'svelte-hmr', version = '') => {\n  const versionSpec = version ? '@' + version : ''\n  return target => `${name}${versionSpec}/${target}`\n}\n\nconst createMakeHot = ({ resolveAbsoluteImport, pkg = {} }) => ({\n  // NOTE hotOptions can be customized by end user through plugin options, while\n  // options passed to this function can only customized by the plugin implementer\n  //\n  // meta can be 'import.meta' or 'module'\n  // const createMakeHot = (hotApi = defaultHotApi, options) => {\n  walk,\n  meta = 'import.meta',\n\n  hotApi: customHotApi = '',\n  adapter: customAdapter = '',\n  // use absolute file paths to import runtime deps of svelte-hmr\n  // - pnpm needs absolute paths because svelte-hmr, being a transitive dep via\n  //   the bundler plugin, is not directly importable from user's project\n  //   (see https://github.com/rixo/svelte-hmr/issues/11)\n  // - Snowpack source=remote needs a version number, otherwise it will try to\n  //   load import, resulting in a possible version mismatch between the code\n  //   transform and the runtime\n  //   (see: https://github.com/rixo/svelte-hmr/issues/27#issuecomment-800142127)\n  absoluteImports = true,\n  versionNonAbsoluteImports = true,\n\n  hotOptions: hotOptionsArg = {},\n}) => {\n  const hotOptions = { ...defaultHotOptions, ...hotOptionsArg }\n\n  const hotOptionsJson = JSON.stringify(hotOptions)\n\n  // NOTE Native adapter cannot be required in code (as opposed to this\n  // generated code) because it requires modules from NativeScript's code that\n  // are not resolvable for non-native users (and those missing modules would\n  // prevent webpack from building).\n  //\n  // careful with relative paths\n  // (see https://github.com/rixo/svelte-hmr/issues/11)\n  const defaultAdapter = hotOptions.native\n    ? 'svelte-native/proxy-adapter-native.js'\n    : 'proxy-adapter-dom.js'\n\n  const resolveImport = absoluteImports\n    ? resolveAbsoluteImport\n    : resolvePackageImport(pkg.name, versionNonAbsoluteImports && pkg.version)\n\n  const adapterImport = posixify(\n    customAdapter || resolveImport('runtime/' + defaultAdapter)\n  )\n\n  const hotApiImport = posixify(\n    customHotApi || resolveImport('runtime/' + defaultHotApi)\n  )\n\n  const resolvePreserveLocalStateKey = ({\n    preserveLocalStateKey,\n    compiled,\n  }) => {\n    const containsKey = comments =>\n      comments &&\n      comments.some(({ value }) => value.includes(preserveLocalStateKey))\n\n    const variables = new Set()\n\n    const addReference = node => {\n      if (!node.name) {\n        // eslint-disable-next-line no-console\n        console.warn('Incorrect identifier for preserveLocalStateKey')\n      }\n      variables.add(node.name)\n    }\n\n    const processNodes = targets => targets.forEach(processNode)\n\n    const processNode = node => {\n      switch (node.type) {\n        case 'Identifier':\n          variables.add(node.name)\n          return true\n        case 'UpdateExpression':\n          addReference(node.argument)\n          return true\n        case 'VariableDeclarator':\n          addReference(node.id)\n          return true\n        case 'AssignmentExpression':\n          processNode(node.left)\n          return true\n        case 'ExpressionStatement':\n          processNode(node.expression)\n          return true\n\n        case 'VariableDeclaration':\n          processNodes(node.declarations)\n          return true\n        case 'SequenceExpression': // ++, --\n          processNodes(node.expressions)\n          return true\n      }\n      return false\n    }\n\n    const stack = []\n\n    if (compiled.ast.instance) {\n      walk(compiled.ast.instance, {\n        leave() {\n          stack.shift()\n        },\n        enter(node) {\n          stack.unshift(node)\n          if (\n            containsKey(node.leadingComments) ||\n            containsKey(node.trailingComments)\n          ) {\n            stack\n              .slice(0, 3)\n              .reverse()\n              .some(processNode)\n          }\n        },\n      })\n    }\n\n    return [...variables]\n  }\n\n  const resolvePreserveLocalState = ({\n    hotOptions,\n    originalCode,\n    compiled,\n  }) => {\n    const {\n      preserveLocalState,\n      noPreserveStateKey,\n      preserveLocalStateKey,\n      preserveAllLocalStateKey,\n    } = hotOptions\n    if (originalCode) {\n      const hasKey = key => {\n        const test = k => originalCode.indexOf(k) !== -1\n        return Array.isArray(key) ? key.some(test) : test(key)\n      }\n      // noPreserveStateKey\n      if (noPreserveStateKey && hasKey(noPreserveStateKey)) {\n        return false\n      }\n      // preserveAllLocalStateKey\n      if (preserveAllLocalStateKey && hasKey(preserveAllLocalStateKey)) {\n        return true\n      }\n      // preserveLocalStateKey\n      if (preserveLocalStateKey && hasKey(preserveLocalStateKey)) {\n        // returns an array of variable names to preserve\n        return resolvePreserveLocalStateKey({ preserveLocalStateKey, compiled })\n      }\n    }\n    // preserveLocalState\n    if (preserveLocalState) {\n      return true\n    }\n    return false\n  }\n\n  const hasAccessorsOption = compiled => {\n    if (!compiled.ast || !compiled.ast.html) return\n    let accessors = false\n    walk(compiled.ast.html, {\n      enter(node) {\n        if (accessors) return\n        if (node.type !== 'Options') return\n        if (!node.attributes) return\n        accessors = node.attributes.some(\n          ({ name, value }) => name === 'accessors' && value\n        )\n      },\n    })\n    return accessors\n  }\n\n  const isAcceptable = (hotOptions, compileOptions, compiled) => {\n    if (!compiled || !compileOptions) {\n      // this should never happen, since it's the bundler plugins that control\n      // what version of svelte-hmr they embark, and they should be kept up to\n      // date with our API\n      //\n      // eslint-disable-next-line no-console\n      console.warn(\n        'WARNING Your bundler plugin is outdated for this version of svelte-hmr'\n      )\n      return true\n    }\n\n    const { vars } = compiled\n\n    // if the module has named exports (in context=\"module\"), then we can't\n    // auto accept the component, since all the consumers need to be aware of\n    // the change (e.g. rerender with the new exports value)\n    if (!hotOptions.acceptNamedExports && vars.some(isNamedExport)) {\n      return false\n    }\n\n    // ...same for accessors: if accessible props change, then we need to\n    // rerender/rerun all the consumers to reflect the change\n    //\n    // NOTE we can still accept components with no props, since they won't\n    // have accessors... this is actually all we can safely accept in this case\n    //\n    if (\n      !hotOptions.acceptAccessors &&\n      // we test is we have props first, because searching for the\n      // <svelte:options /> tag in the AST is probably the most expensive here\n      vars.some(isProp) &&\n      (compileOptions.accessors || hasAccessorsOption(compiled))\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  const parseMakeHotArgs = args => {\n    // case: named args (object)\n    if (args.length === 1) return args[0]\n    // case: legacy (positional)\n    const [\n      id,\n      compiledCode,\n      hotOptions,\n      compiled,\n      originalCode,\n      compileOptions,\n    ] = args\n    return {\n      id,\n      compiledCode,\n      hotOptions,\n      compiled,\n      originalCode,\n      compileOptions,\n    }\n  }\n\n  function makeHot(...args) {\n    const {\n      id,\n      compiledCode,\n      compiled,\n      originalCode,\n      compileOptions,\n    } = parseMakeHotArgs(args)\n\n    const { importAdapterName, injectCss } = hotOptions\n\n    const emitCss =\n      compileOptions &&\n      (compileOptions.css === false || compileOptions.css === 'external')\n\n    const preserveLocalState = resolvePreserveLocalState({\n      hotOptions,\n      originalCode,\n      compiled,\n    })\n\n    const replacement = renderApplyHmr({\n      id,\n      // adds cssId & nonCssHash\n      ...((injectCss || !emitCss) &&\n        parseCssId(compiledCode, compileOptions, injectCss, originalCode)),\n      hotOptions,\n      hotOptionsJson,\n      preserveLocalState,\n      hotApiImport,\n      adapterImport,\n      importAdapterName,\n      meta,\n      acceptable: isAcceptable(hotOptions, compileOptions, compiled),\n      // CSS is handled outside of Svelte: don't tamper with it!\n      emitCss,\n    })\n\n    // NOTE export default can appear in strings in use code\n    // see: https://github.com/rixo/svelte-hmr/issues/34\n    return replaceLast(\n      compiledCode,\n      'export default',\n      /(\\n?export default ([^;]*);)/,\n      (match, $1, $2) => replacement.replace(/\\$2/g, () => $2)\n    )\n  }\n\n  // rollup-plugin-svelte-hot needs hotApi path (for tests)\n  // makeHot.hotApi = hotApi\n  Object.defineProperty(makeHot, 'hotApi', {\n    get() {\n      // TODO makeHot.hotApi has been lost in 0.12 => 0.13... still needed?\n      debugger // eslint-disable-line no-debugger\n      return undefined\n    },\n  })\n\n  return makeHot\n}\n\nmodule.exports = createMakeHot\n"}}}},"LICENSE":{"file":{"contents":"Copyright 2019 - 2020, rixo and the svelte-hmr contributors.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\nOF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"svelte-hmr\",\n  \"version\": \"0.15.1\",\n  \"description\": \"Bundler agnostic HMR utils for Svelte 3\",\n  \"main\": \"index.js\",\n  \"author\": \"rixo <rixo@rixo.fr>\",\n  \"license\": \"ISC\",\n  \"homepage\": \"https://github.com/sveltejs/svelte-hmr\",\n  \"bugs\": {\n    \"url\": \"https://github.com/sveltejs/svelte-hmr/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sveltejs/svelte-hmr\",\n    \"directory\": \"packages/svelte-hmr\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"lib\",\n    \"runtime\"\n  ],\n  \"engines\": {\n    \"node\": \"^12.20 || ^14.13.1 || >= 16\"\n  },\n  \"peerDependencies\": {\n    \"svelte\": \">=3.19.0\"\n  },\n  \"devDependencies\": {\n    \"dotenv\": \"^10.0.0\",\n    \"prettier\": \"^1.19.1\",\n    \"svelte\": \"^3.50.1\",\n    \"tap-mocha-reporter\": \"^5.0.1\",\n    \"zoar\": \"^0.3.0\",\n    \"zorax\": \"^0.0.12\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint '**/*.{js,cjs,mjs}'\",\n    \"lint:fix\": \"pnpm run lint --fix\",\n    \"format\": \"prettier '**/*.{js,cjs,mjs}' --check\",\n    \"format:fix\": \"pnpm run format --write\",\n    \"test:fancy\": \"zoar --pipe 'tap-mocha-reporter spec'\",\n    \"test\": \"zoar --exit\"\n  }\n}"}},"README.md":{"file":{"contents":"# svelte-hmr\n\nHMR commons for Svelte 3.\n\nThis packages provides shared dependencies for implementing Svelte HMR in any bundler plugins.\n\nIf you want to _use_ HMR in your Svelte project, what you need is a HMR enabled plugin for your bundler (e.g. Rollup or Webpack). You'll find a list of available tools at the end of this doc.\n\nOn the other hand, if you are really developing a plugin... Sorry, no docs for now! Drop me a line, I'd be happy to help!\n\n## Features\n\n- update Svelte components in place\n\n- preservation of component state, including local state (i.e. `let` vars in your components)\n\n- inject CSS instead of doing a full replace when only the component's CSS has changed, with compatible HMR APIs (`rollup-plugin-hot`, Nollup, and Snowpack for now)\n\n## Options\n\nThose are the HMR options that are implemented by `svelte-hmr` itself, and so should be supported by any plugin listed bellow (especially if they include a link pointing to this section). How to pass those options is specific to each plugins, so refer to their specific docs on this point.\n\n#### noReload\n\nType: `bool`<br>\nDefault: `false`\n\nBy default, `svelte-hmr` will trigger a full browser reload when it detects an error that will prevent subsequent HMR updates to be applied correctly. Set this to `true` to prevent automatic reloads. Note that Svelte Native does _not_ execute in a browser, and so this option has no effect there.\n\n#### noPreserveState\n\n**Deprecated: removed and default changed from version 0.12. Use `preserveLocalState` instead.**\n\n#### preserveLocalState\n\nType: `bool`<br>\nDefault: `false`\n\nEnable [preservation of local state](#preservation-of-local-state) for all variables in all components.\n\n#### noPreserveStateKey\n\nType: `string`<br>\nDefault: `'@hmr:reset'` (also accepts legacy `'@!hmr'`)\n\nForce disable preservation of local state for this component.\n\nThis flag has priority over all other settings of state preservation. If it is present, all the state of the component will be reset on the next update, regardless of the value of all the other state preservation settings.\n\n```svelte\n<!-- @hmr:reset -->\n\n<script>\n  '@hmr:reset'\n\n  // @hmr:reset\n</script>\n```\n\n#### preserveAllLocalStateKey\n\nType: `string`<br>\nDefault: `'@hmr:keep-all'`\n\nForce preservation of all local variables of this component.\n\n```svelte\n<!-- @hmr:keep-all -->\n\n<script>\n  '@hmr:keep-all'\n\n  // @hmr:keep-all\n</script>\n```\n\n#### preserveLocalStateKey\n\nType: `string`<br>\nDefault: `'@hmr:keep'`\n\nForce preservation of a given local variable in this component.\n\n```svelte\n<script>\n  // @hmr:keep\n  let x = 0\n\n  let y = 0 // @hmr:keep\n\n  x = 1 // @hmr:keep\n</script>\n```\n\n#### optimistic\n\nType: `bool`<br>\nDefault: `false`\n\nWhen `false`, runtime errors during component init (i.e. when your `<script>` code is run) are considered fatal to HMR (hence worthy of a full reload if `noReload` option is not set). When `true`, `svelte-hmr` will try to render the next version of the component in the place of the one that has crashed instead of programming a full reload.\n\n## What's HMR, by the way?\n\n> **NOTE** To avoid repetition, the following text only mentions HMR in the context of browsers, but it can also be used in other platforms. For example `svelte-hmr` is also used in Svelte Native.\n\nHMR stands for Hot Module Replacement. It is a tool that is used during development to replace only the parts that have changed in a _running_ application, without the need to reload the whole browser page.\n\nIt's nice because it shortens your feedback loop (you don't lose the current state of the page you're working it with each code change), and it feels like magic! :sparkles:\n\nWell, since you're reading this, let me tell you a little more about HMR. Magic is actually not such a good think in software development, so if we can demystify HMR a bit, it will probably benefits you when it comes to answer setup questions or, generally, get the most out of your HMR experience.\n\nSo... There are multiple layers to HMR. The first one is the technical capacity to actually replace a JS _module_ (think ES module -- in practice a JS file) at runtime. This capacity is provided (or not) by your bundler or dev server (e.g. Webpack, Parcel, Vite, Snowpack...). A notable absent in the HMR capable bundlers is Rollup, but a HMR plugin exists, as well as a Rollup-compatible super fast dev bundler and server, Nollup (see links below).\n\nThe HMR capacity essentially revolves around watching your file system and sending events to the browser when this happens (and, of course, doing all the other bundler stuff, but they're not interesting for this discussion).\n\nIn the browser, we need something to receive and process those events. And so there is a HMR runtime (i.e. some JS code) that is injected in the browser when you enable HMR. This runtime exposes a HMR (or hot) API. The hot API differs with each bundler, even if there is some level of standardization. For example, `rollup-plugin-hot`'s API looks like this:\n\n```js\nif (imp‎ort.meta.hot) {\n  import.meta.hot.dispose(data => {\n    // do cleanup\n  })\n  import.meta.hot.accept(() => {\n    // adjust side effects\n  })\n}\n```\n\nWhy do we need a hot API?\n\nBecause just replacing a whole chunk of JS code doesn't really gets you what you want. Let's think about it: what does replacing a JS module really means? You can't unrun the previously executed module. So that's merely running the new version of the module.\n\nAnd that's about all what your HMR server will give you. But it's not enough. If your module was a helper function, new calls will go to the new version of the function, but the result of calling the previous version are still visible on the page. Same with a UI component: newly created components will be fresh, but existing components on the page are still from the previous versions...\n\nThat's why we need this hot API. We need to provide HMR handlers, that is HMR specific code to properly apply the effects of the code change in the app, and cleanup the effects of the previous module versions.\n\nActually, what should be done to reflect a code update is hyper specific to the content of the module. Typically, you'd need specific HMR handlers for each one of your modules (i.e. files). For most kind of contents, this cannot be automatized. Oh, and did I tell you that HMR handlers are pretty tedious things to write?\n\nOops. Does this makes HMR essentially worthless? No! Because, fortunately, there is one kind of content for which we know how to do automatic HMR handlers. Those are UI components. When a HMR update hits a component, we can destroy all existing instances of the component and replace them with new instances created with the updated version of the component. Bim. Well, there's also a part of dark magic involved because we need to recreate the new instances in the same state as the previous instance we're destroying. We need to pass the right props, transfer inner state, local state, event listeners, etc.\n\nThis kind of automatic HMR handlers for Svelte components -- and associated dark magic -- is what `svelte-hmr` provides! (For the sake of completeness, it also provides some Node utils to help bundlers apply the code transform needed to inject those HMR handlers into a Svelte component.)\n\nCool! So you can have HMR with a lot of your modules without having to write HMR handlers yourself, that's good news. And there are more. HMR APIs implements a _bubbling mechanism_. In HMR linguo, when a module has some HMR handlers, it is said to be \"accepted\". When a HMR update hits a module that is not accepted, this will not immediately translate into a full reload of the page. Instead, the HMR engine will check all the modules that imports the unaccepted module and, if they are all accepted, then it will refresh all those parent modules instead (refresh means running HMR handlers, here). If some of the parents are themselves unaccepted, the HMR update will continue to bubble up toward the app's entry point, stopping at accepted module on each branch. If an update hits the entry point (and the entry point itself is not accepted), then only will it command a full reload.\n\nIt makes sense: all those modules boast of being able to apply a code change to themselves so, if we refresh all of them, we should theoretically also see the updated effect of their dependencies, no? Well, unfortunately, it depends... If your updated module is exporting values or pure functions, it will work perfectly. If your module uses `setInterval` and there isn't a HMR handler to dispose that, the `setInterval` function will keep running (and each HMR update will probably add a new one). It all depends on how stateful or how much side effects your module has. But in many cases it can work and, in those cases, you'll also get HMR for free (since all HMR updates will probably be stopped by Svelte components). For the remaining cases... Well, you're probably left with [learning how to write HMR handlers](https://github.com/rixo/rollup-plugin-hot#api), or accept to manually reload the browser.\n\nHere you are. This is what HMR is, and how it works.\n\nI think the most important take away is that the component that is affected by a change will be recreated. Its state will be preserved but all its children will be recreated too, and their state not preserved. This is a necessity because the elements / child components structure of a component can be entirely different after the file has been modified (and we don't really have the technical capacity to track children).\n\nNow, the best way to see what it can do for you is probably to checkout the template bellow and get your hands at it! (Add 500 components and try Nollup, you should love the speed!)\n\n### Preservation of local state\n\n**From version 0.12** this behaviour has been deemed too confusing and hard to anticipate, so preservation of state is now disabled by default, and some escape hatches to preserve the state of some given variables have been added.\n\nLocal state can be preserved by Svelte HMR, that is any state that Svelte itself tracks as reactive (basically any root scope `let` vars, exported or not).\n\nThis means that in code like this:\n\n```svelte\n<script>\n  let x = 1\n  x++ // x is now 2\n</script>\n\n<p>{x}</p>\n```\n\nIf you replace `let x = 1` by `let x = 10` and save, the previous value of `x` will be preserved. That is, `x` will be 2 and not 10. The restoration of previous state happens _after_ the init code of the component has run, so the value will not be 11 either, despite the `x++` that is still here.\n\nIf you want this behaviour for all the state of all your components, you can enable it by setting the `preserveLocalState` option to `true`.\n\nIf you then want to disable it for just one particular file, or just temporarily, you can turn it off by adding a `// @hmr:reset` comment somewhere in your component.\n\nOn the contrary, if you keep the default `preserveLocalState` to `false`, you can enable preservation of all the local state of a given component by adding the following comment: `// @hmr:keep-all`. You can also preserve only the state of some specific variables, by annotating them with: `// @hmr:keep`.\n\nFor example:\n\n```svelte\n<script>\n  let x = 0 // @hmr:keep\n\n  // or:\n\n  // @hmr:keep\n  let y = 1,\n      z = 2\n</script>\n```\n\n## Svelte HMR tools\n\n### Vite\n\nThe [official Svelte plugin for Vite][vite-plugin-svelte] has HMR support.\n\n### Webpack\n\nThe [official loader for Webpack][svelte-loader] now has HMR support.\n\n### Rollup\n\nRollup does not natively support HMR, so we recommend using Vite. However, if you'd like to add HMR support to Rollup, the best way to get started is to refer to [svelte-template-hot], which demonstrates usage of both [rollup-plugin-hot] and [rollup-plugin-svelte-hot].\n\n### Svelte Native\n\nThe official [Svelte Native template][svelte-native-template] already includes HMR support.\n\n## License\n\n[ISC](LICENSE)\n\n[vite-plugin-svelte]: https://www.npmjs.com/package/@sveltejs/vite-plugin-svelte\n[svelte-loader]: https://github.com/sveltejs/svelte-loader\n[rollup-plugin-hot]: https://github.com/rixo/rollup-plugin-hot\n[rollup-plugin-svelte-hot]: https://github.com/rixo/rollup-plugin-svelte-hot\n[rollup-plugin-svelte]: https://github.com/rollup/rollup-plugin-svelte\n[svelte-template-hot]: https://github.com/rixo/svelte-template-hot\n[svelte-template]: https://github.com/sveltejs/template\n[svelte-native-template]: https://github.com/halfnelson/svelte-native-template\n[svelte-loader-hot]: https://github.com/rixo/svelte-loader-hot\n[svelte-template-webpack-hot]: https://github.com/rixo/svelte-template-webpack-hot\n"}},"runtime":{"directory":{"hot-api-esm.js":{"file":{"contents":"import { makeApplyHmr } from '../runtime/index.js'\n\nexport const applyHmr = makeApplyHmr(args =>\n  Object.assign({}, args, {\n    hot: args.m.hot,\n  })\n)\n"}},"hot-api.js":{"file":{"contents":"/* eslint-env browser */\n\nimport { createProxy, hasFatalError } from './proxy.js'\n\nconst logPrefix = '[HMR:Svelte]'\n\n// eslint-disable-next-line no-console\nconst log = (...args) => console.log(logPrefix, ...args)\n\nconst domReload = () => {\n  // eslint-disable-next-line no-undef\n  const win = typeof window !== 'undefined' && window\n  if (win && win.location && win.location.reload) {\n    log('Reload')\n    win.location.reload()\n  } else {\n    log('Full reload required')\n  }\n}\n\nconst replaceCss = (previousId, newId) => {\n  if (typeof document === 'undefined') return false\n  if (!previousId) return false\n  if (!newId) return false\n  // svelte-xxx-style => svelte-xxx\n  const previousClass = previousId.slice(0, -6)\n  const newClass = newId.slice(0, -6)\n  // eslint-disable-next-line no-undef\n  document.querySelectorAll('.' + previousClass).forEach(el => {\n    el.classList.remove(previousClass)\n    el.classList.add(newClass)\n  })\n  return true\n}\n\nconst removeStylesheet = cssId => {\n  if (cssId == null) return\n  if (typeof document === 'undefined') return\n  // eslint-disable-next-line no-undef\n  const el = document.getElementById(cssId)\n  if (el) el.remove()\n  return\n}\n\nconst defaultArgs = {\n  reload: domReload,\n}\n\nexport const makeApplyHmr = transformArgs => args => {\n  const allArgs = transformArgs({ ...defaultArgs, ...args })\n  return applyHmr(allArgs)\n}\n\nlet needsReload = false\n\nfunction applyHmr(args) {\n  const {\n    id,\n    cssId,\n    nonCssHash,\n    reload = domReload,\n    // normalized hot API (must conform to rollup-plugin-hot)\n    hot,\n    hotOptions,\n    Component,\n    acceptable, // some types of components are impossible to HMR correctly\n    preserveLocalState,\n    ProxyAdapter,\n    emitCss,\n  } = args\n\n  const existing = hot.data && hot.data.record\n\n  const canAccept = acceptable && (!existing || existing.current.canAccept)\n\n  const r =\n    existing ||\n    createProxy({\n      Adapter: ProxyAdapter,\n      id,\n      Component,\n      hotOptions,\n      canAccept,\n      preserveLocalState,\n    })\n\n  const cssOnly =\n    hotOptions.injectCss &&\n    existing &&\n    nonCssHash &&\n    existing.current.nonCssHash === nonCssHash\n\n  r.update({\n    Component,\n    hotOptions,\n    canAccept,\n    nonCssHash,\n    cssId,\n    previousCssId: r.current.cssId,\n    cssOnly,\n    preserveLocalState,\n  })\n\n  hot.dispose(data => {\n    // handle previous fatal errors\n    if (needsReload || hasFatalError()) {\n      if (hotOptions && hotOptions.noReload) {\n        log('Full reload required')\n      } else {\n        reload()\n      }\n    }\n\n    // 2020-09-21 Snowpack master doesn't pass data as arg to dispose handler\n    data = data || hot.data\n\n    data.record = r\n\n    if (!emitCss && cssId && r.current.cssId !== cssId) {\n      if (hotOptions.cssEjectDelay) {\n        setTimeout(() => removeStylesheet(cssId), hotOptions.cssEjectDelay)\n      } else {\n        removeStylesheet(cssId)\n      }\n    }\n  })\n\n  if (canAccept) {\n    hot.accept(async arg => {\n      const { bubbled } = arg || {}\n\n      // NOTE Snowpack registers accept handlers only once, so we can NOT rely\n      // on the surrounding scope variables -- they're not the last version!\n      const { cssId: newCssId, previousCssId } = r.current\n      const cssChanged = newCssId !== previousCssId\n      // ensure old style sheet has been removed by now\n      if (!emitCss && cssChanged) removeStylesheet(previousCssId)\n      // guard: css only change\n      if (\n        // NOTE bubbled is provided only by rollup-plugin-hot, and we\n        // can't safely assume a CSS only change without it... this means we\n        // can't support CSS only injection with Nollup or Webpack currently\n        bubbled === false && // WARNING check false, not falsy!\n        r.current.cssOnly &&\n        (!cssChanged || replaceCss(previousCssId, newCssId))\n      ) {\n        return\n      }\n\n      const success = await r.reload()\n\n      if (hasFatalError() || (!success && !hotOptions.optimistic)) {\n        needsReload = true\n      }\n    })\n  }\n\n  // well, endgame... we won't be able to render next updates, even successful,\n  // if we don't have proxies in svelte's tree\n  //\n  // since we won't return the proxy and the app will expect a svelte component,\n  // it's gonna crash... so it's best to report the real cause\n  //\n  // full reload required\n  //\n  const proxyOk = r && r.proxy\n  if (!proxyOk) {\n    throw new Error(`Failed to create HMR proxy for Svelte component ${id}`)\n  }\n\n  return r.proxy\n}\n"}},"index.js":{"file":{"contents":"export { makeApplyHmr } from './hot-api.js'\n"}},"overlay.js":{"file":{"contents":"/* eslint-env browser */\n\nconst removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)\n\nconst ErrorOverlay = () => {\n  let errors = []\n  let compileError = null\n\n  const errorsTitle = 'Failed to init component'\n  const compileErrorTitle = 'Failed to compile'\n\n  const style = {\n    section: `\n      position: fixed;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      padding: 32px;\n      background: rgba(0, 0, 0, .85);\n      font-family: Menlo, Consolas, monospace;\n      font-size: large;\n      color: rgb(232, 232, 232);\n      overflow: auto;\n      z-index: 2147483647;\n    `,\n    h1: `\n      margin-top: 0;\n      color: #E36049;\n      font-size: large;\n      font-weight: normal;\n    `,\n    h2: `\n      margin: 32px 0 0;\n      font-size: large;\n      font-weight: normal;\n    `,\n    pre: ``,\n  }\n\n  const createOverlay = () => {\n    const h1 = document.createElement('h1')\n    h1.style = style.h1\n    const section = document.createElement('section')\n    section.appendChild(h1)\n    section.style = style.section\n    const body = document.createElement('div')\n    section.appendChild(body)\n    return { h1, el: section, body }\n  }\n\n  const setTitle = title => {\n    overlay.h1.textContent = title\n  }\n\n  const show = () => {\n    const { el } = overlay\n    if (!el.parentNode) {\n      const target = document.body\n      target.appendChild(overlay.el)\n    }\n  }\n\n  const hide = () => {\n    const { el } = overlay\n    if (el.parentNode) {\n      overlay.el.remove()\n    }\n  }\n\n  const update = () => {\n    if (compileError) {\n      overlay.body.innerHTML = ''\n      setTitle(compileErrorTitle)\n      const errorEl = renderError(compileError)\n      overlay.body.appendChild(errorEl)\n      show()\n    } else if (errors.length > 0) {\n      overlay.body.innerHTML = ''\n      setTitle(errorsTitle)\n      errors.forEach(({ title, message }) => {\n        const errorEl = renderError(message, title)\n        overlay.body.appendChild(errorEl)\n      })\n      show()\n    } else {\n      hide()\n    }\n  }\n\n  const renderError = (message, title) => {\n    const div = document.createElement('div')\n    if (title) {\n      const h2 = document.createElement('h2')\n      h2.textContent = title\n      h2.style = style.h2\n      div.appendChild(h2)\n    }\n    const pre = document.createElement('pre')\n    pre.textContent = message\n    div.appendChild(pre)\n    return div\n  }\n\n  const addError = (error, title) => {\n    const message = (error && error.stack) || error\n    errors.push({ title, message })\n    update()\n  }\n\n  const clearErrors = () => {\n    errors.forEach(({ element }) => {\n      removeElement(element)\n    })\n    errors = []\n    update()\n  }\n\n  const setCompileError = message => {\n    compileError = message\n    update()\n  }\n\n  const overlay = createOverlay()\n\n  return {\n    addError,\n    clearErrors,\n    setCompileError,\n  }\n}\n\nexport default ErrorOverlay\n"}},"proxy-adapter-dom.js":{"file":{"contents":"/* global window, document */\nimport * as svelteInternal from 'svelte/internal'\n// NOTE from 3.38.3 (or so), insert was carrying the hydration logic, that must\n// be used because DOM elements are reused more (and so insertion points are not\n// necessarily added in order); then in 3.40 the logic was moved to\n// insert_hydration, which is the one we must use for HMR\nconst svelteInsert = svelteInternal.insert_hydration || svelteInternal.insert\nif (!svelteInsert) {\n  throw new Error(\n    'failed to find insert_hydration and insert in svelte/internal'\n  )\n}\n\nimport ErrorOverlay from './overlay.js'\n\nconst removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)\n\nexport const adapter = class ProxyAdapterDom {\n  constructor(instance) {\n    this.instance = instance\n    this.insertionPoint = null\n\n    this.afterMount = this.afterMount.bind(this)\n    this.rerender = this.rerender.bind(this)\n\n    this._noOverlay = !!instance.hotOptions.noOverlay\n  }\n\n  // NOTE overlay is only created before being actually shown to help test\n  // runner (it won't have to account for error overlay when running assertions\n  // about the contents of the rendered page)\n  static getErrorOverlay(noCreate = false) {\n    if (!noCreate && !this.errorOverlay) {\n      this.errorOverlay = ErrorOverlay()\n    }\n    return this.errorOverlay\n  }\n\n  // TODO this is probably unused now: remove in next breaking release\n  static renderCompileError(message) {\n    const noCreate = !message\n    const overlay = this.getErrorOverlay(noCreate)\n    if (!overlay) return\n    overlay.setCompileError(message)\n  }\n\n  dispose() {\n    // Component is being destroyed, detaching is not optional in Svelte3's\n    // component API, so we can dispose of the insertion point in every case.\n    if (this.insertionPoint) {\n      removeElement(this.insertionPoint)\n      this.insertionPoint = null\n    }\n    this.clearError()\n  }\n\n  // NOTE afterMount CAN be called multiple times (e.g. keyed list)\n  afterMount(target, anchor) {\n    const {\n      instance: { debugName },\n    } = this\n    if (!this.insertionPoint) {\n      this.insertionPoint = document.createComment(debugName)\n    }\n    svelteInsert(target, this.insertionPoint, anchor)\n  }\n\n  rerender() {\n    this.clearError()\n    const {\n      instance: { refreshComponent },\n      insertionPoint,\n    } = this\n    if (!insertionPoint) {\n      throw new Error('Cannot rerender: missing insertion point')\n    }\n    refreshComponent(insertionPoint.parentNode, insertionPoint)\n  }\n\n  renderError(err) {\n    if (this._noOverlay) return\n    const {\n      instance: { debugName },\n    } = this\n    const title = debugName || err.moduleName || 'Error'\n    this.constructor.getErrorOverlay().addError(err, title)\n  }\n\n  clearError() {\n    if (this._noOverlay) return\n    const overlay = this.constructor.getErrorOverlay(true)\n    if (!overlay) return\n    overlay.clearErrors()\n  }\n}\n\n// TODO this is probably unused now: remove in next breaking release\nif (typeof window !== 'undefined') {\n  window.__SVELTE_HMR_ADAPTER = adapter\n}\n\n// mitigate situation with Snowpack remote source pulling latest of runtime,\n// but using previous version of the Node code transform in the plugin\n// see: https://github.com/rixo/svelte-hmr/issues/27\nexport default adapter\n"}},"proxy.js":{"file":{"contents":"/* eslint-env browser */\n/**\n * The HMR proxy is a component-like object whose task is to sit in the\n * component tree in place of the proxied component, and rerender each\n * successive versions of said component.\n */\n\nimport { createProxiedComponent } from './svelte-hooks.js'\n\nconst handledMethods = ['constructor', '$destroy']\nconst forwardedMethods = ['$set', '$on']\n\nconst logError = (msg, err) => {\n  // eslint-disable-next-line no-console\n  console.error('[HMR][Svelte]', msg)\n  if (err) {\n    // NOTE avoid too much wrapping around user errors\n    // eslint-disable-next-line no-console\n    console.error(err)\n  }\n}\n\nconst posixify = file => file.replace(/[/\\\\]/g, '/')\n\nconst getBaseName = id =>\n  id\n    .split('/')\n    .pop()\n    .split('.')\n    .slice(0, -1)\n    .join('.')\n\nconst capitalize = str => str[0].toUpperCase() + str.slice(1)\n\nconst getFriendlyName = id => capitalize(getBaseName(posixify(id)))\n\nconst getDebugName = id => `<${getFriendlyName(id)}>`\n\nconst relayCalls = (getTarget, names, dest = {}) => {\n  for (const key of names) {\n    dest[key] = function(...args) {\n      const target = getTarget()\n      if (!target) {\n        return\n      }\n      return target[key] && target[key].call(this, ...args)\n    }\n  }\n  return dest\n}\n\nconst isInternal = key => key !== '$$' && key.slice(0, 2) === '$$'\n\n// This is intented as a somewhat generic / prospective fix to the situation\n// that arised with the introduction of $$set in Svelte 3.24.1 -- trying to\n// avoid giving full knowledge (like its name) of this implementation detail\n// to the proxy. The $$set method can be present or not on the component, and\n// its presence impacts the behaviour (but with HMR it will be tested if it is\n// present _on the proxy_). So the idea here is to expose exactly the same $$\n// props as the current version of the component and, for those that are\n// functions, proxy the calls to the current component.\nconst relayInternalMethods = (proxy, cmp) => {\n  // delete any previously added $$ prop\n  Object.keys(proxy)\n    .filter(isInternal)\n    .forEach(key => {\n      delete proxy[key]\n    })\n  // guard: no component\n  if (!cmp) return\n  // proxy current $$ props to the actual component\n  Object.keys(cmp)\n    .filter(isInternal)\n    .forEach(key => {\n      Object.defineProperty(proxy, key, {\n        configurable: true,\n        get() {\n          const value = cmp[key]\n          if (typeof value !== 'function') return value\n          return (\n            value &&\n            function(...args) {\n              return value.apply(this, args)\n            }\n          )\n        },\n      })\n    })\n}\n\n// proxy custom methods\nconst copyComponentProperties = (proxy, cmp, previous) => {\n  if (previous) {\n    previous.forEach(prop => {\n      delete proxy[prop]\n    })\n  }\n\n  const props = Object.getOwnPropertyNames(Object.getPrototypeOf(cmp))\n  const wrappedProps = props.filter(prop => {\n    if (!handledMethods.includes(prop) && !forwardedMethods.includes(prop)) {\n      Object.defineProperty(proxy, prop, {\n        configurable: true,\n        get() {\n          return cmp[prop]\n        },\n        set(value) {\n          // we're changing it on the real component first to see what it\n          // gives... if it throws an error, we want to throw the same error in\n          // order to most closely follow non-hmr behaviour.\n          cmp[prop] = value\n        },\n      })\n      return true\n    }\n  })\n\n  return wrappedProps\n}\n\n// everything in the constructor!\n//\n// so we don't polute the component class with new members\n//\nclass ProxyComponent {\n  constructor(\n    {\n      Adapter,\n      id,\n      debugName,\n      current, // { Component, hotOptions: { preserveLocalState, ... } }\n      register,\n    },\n    options // { target, anchor, ... }\n  ) {\n    let cmp\n    let disposed = false\n    let lastError = null\n\n    const setComponent = _cmp => {\n      cmp = _cmp\n      relayInternalMethods(this, cmp)\n    }\n\n    const getComponent = () => cmp\n\n    const destroyComponent = () => {\n      // destroyComponent is tolerant (don't crash on no cmp) because it\n      // is possible that reload/rerender is called after a previous\n      // createComponent has failed (hence we have a proxy, but no cmp)\n      if (cmp) {\n        cmp.$destroy()\n        setComponent(null)\n      }\n    }\n\n    const refreshComponent = (target, anchor, conservativeDestroy) => {\n      if (lastError) {\n        lastError = null\n        adapter.rerender()\n      } else {\n        try {\n          const replaceOptions = {\n            target,\n            anchor,\n            preserveLocalState: current.preserveLocalState,\n          }\n          if (conservativeDestroy) {\n            replaceOptions.conservativeDestroy = true\n          }\n          cmp.$replace(current.Component, replaceOptions)\n        } catch (err) {\n          setError(err, target, anchor)\n          if (\n            !current.hotOptions.optimistic ||\n            // non acceptable components (that is components that have to defer\n            // to their parent for rerender -- e.g. accessors, named exports)\n            // are most tricky, and they havent been considered when most of the\n            // code has been written... as a result, they are especially tricky\n            // to deal with, it's better to consider any error with them to be\n            // fatal to avoid odities\n            !current.canAccept ||\n            (err && err.hmrFatal)\n          ) {\n            throw err\n          } else {\n            // const errString = String((err && err.stack) || err)\n            logError(`Error during component init: ${debugName}`, err)\n          }\n        }\n      }\n    }\n\n    const setError = err => {\n      lastError = err\n      adapter.renderError(err)\n    }\n\n    const instance = {\n      hotOptions: current.hotOptions,\n      proxy: this,\n      id,\n      debugName,\n      refreshComponent,\n    }\n\n    const adapter = new Adapter(instance)\n\n    const { afterMount, rerender } = adapter\n\n    // $destroy is not called when a child component is disposed, so we\n    // need to hook from fragment.\n    const onDestroy = () => {\n      // NOTE do NOT call $destroy on the cmp from here; the cmp is already\n      //   dead, this would not work\n      if (!disposed) {\n        disposed = true\n        adapter.dispose()\n        unregister()\n      }\n    }\n\n    // ---- register proxy instance ----\n\n    const unregister = register(rerender)\n\n    // ---- augmented methods ----\n\n    this.$destroy = () => {\n      destroyComponent()\n      onDestroy()\n    }\n\n    // ---- forwarded methods ----\n\n    relayCalls(getComponent, forwardedMethods, this)\n\n    // ---- create & mount target component instance ---\n\n    try {\n      let lastProperties\n      createProxiedComponent(current.Component, options, {\n        allowLiveBinding: current.hotOptions.allowLiveBinding,\n        onDestroy,\n        onMount: afterMount,\n        onInstance: comp => {\n          setComponent(comp)\n          // WARNING the proxy MUST use the same $$ object as its component\n          // instance, because a lot of wiring happens during component\n          // initialisation... lots of references to $$ and $$.fragment have\n          // already been distributed around when the component constructor\n          // returns, before we have a chance to wrap them (and so we can't\n          // wrap them no more, because existing references would become\n          // invalid)\n          this.$$ = comp.$$\n          lastProperties = copyComponentProperties(this, comp, lastProperties)\n        },\n      })\n    } catch (err) {\n      const { target, anchor } = options\n      setError(err, target, anchor)\n      throw err\n    }\n  }\n}\n\nconst syncStatics = (component, proxy, previousKeys) => {\n  // remove previously copied keys\n  if (previousKeys) {\n    for (const key of previousKeys) {\n      delete proxy[key]\n    }\n  }\n\n  // forward static properties and methods\n  const keys = []\n  for (const key in component) {\n    keys.push(key)\n    proxy[key] = component[key]\n  }\n\n  return keys\n}\n\nconst globalListeners = {}\n\nconst onGlobal = (event, fn) => {\n  event = event.toLowerCase()\n  if (!globalListeners[event]) globalListeners[event] = []\n  globalListeners[event].push(fn)\n}\n\nconst fireGlobal = (event, ...args) => {\n  const listeners = globalListeners[event]\n  if (!listeners) return\n  for (const fn of listeners) {\n    fn(...args)\n  }\n}\n\nconst fireBeforeUpdate = () => fireGlobal('beforeupdate')\n\nconst fireAfterUpdate = () => fireGlobal('afterupdate')\n\nif (typeof window !== 'undefined') {\n  window.__SVELTE_HMR = {\n    on: onGlobal,\n  }\n  window.dispatchEvent(new CustomEvent('svelte-hmr:ready'))\n}\n\nlet fatalError = false\n\nexport const hasFatalError = () => fatalError\n\n/**\n * Creates a HMR proxy and its associated `reload` function that pushes a new\n * version to all existing instances of the component.\n */\nexport function createProxy({\n  Adapter,\n  id,\n  Component,\n  hotOptions,\n  canAccept,\n  preserveLocalState,\n}) {\n  const debugName = getDebugName(id)\n  const instances = []\n\n  // current object will be updated, proxy instances will keep a ref\n  const current = {\n    Component,\n    hotOptions,\n    canAccept,\n    preserveLocalState,\n  }\n\n  const name = `Proxy${debugName}`\n\n  // this trick gives the dynamic name Proxy<MyComponent> to the concrete\n  // proxy class... unfortunately, this doesn't shows in dev tools, but\n  // it stills allow to inspect cmp.constructor.name to confirm an instance\n  // is a proxy\n  const proxy = {\n    [name]: class extends ProxyComponent {\n      constructor(options) {\n        try {\n          super(\n            {\n              Adapter,\n              id,\n              debugName,\n              current,\n              register: rerender => {\n                instances.push(rerender)\n                const unregister = () => {\n                  const i = instances.indexOf(rerender)\n                  instances.splice(i, 1)\n                }\n                return unregister\n              },\n            },\n            options\n          )\n        } catch (err) {\n          // If we fail to create a proxy instance, any instance, that means\n          // that we won't be able to fix this instance when it is updated.\n          // Recovering to normal state will be impossible. HMR's dead.\n          //\n          // Fatal error will trigger a full reload on next update (reloading\n          // right now is kinda pointless since buggy code still exists).\n          //\n          // NOTE Only report first error to avoid too much polution -- following\n          // errors are probably caused by the first one, or they will show up\n          // in turn when the first one is fixed ¯\\_(ツ)_/¯\n          //\n          if (!fatalError) {\n            fatalError = true\n            logError(\n              `Unrecoverable HMR error in ${debugName}: ` +\n                `next update will trigger a full reload`\n            )\n          }\n          throw err\n        }\n      }\n    },\n  }[name]\n\n  // initialize static members\n  let previousStatics = syncStatics(current.Component, proxy)\n\n  const update = newState => Object.assign(current, newState)\n\n  // reload all existing instances of this component\n  const reload = () => {\n    fireBeforeUpdate()\n\n    // copy statics before doing anything because a static prop/method\n    // could be used somewhere in the create/render call\n    previousStatics = syncStatics(current.Component, proxy, previousStatics)\n\n    const errors = []\n\n    instances.forEach(rerender => {\n      try {\n        rerender()\n      } catch (err) {\n        logError(`Failed to rerender ${debugName}`, err)\n        errors.push(err)\n      }\n    })\n\n    if (errors.length > 0) {\n      return false\n    }\n\n    fireAfterUpdate()\n\n    return true\n  }\n\n  const hasFatalError = () => fatalError\n\n  return { id, proxy, update, reload, hasFatalError, current }\n}\n"}},"svelte-hooks.js":{"file":{"contents":"/**\n * Emulates forthcoming HMR hooks in Svelte.\n *\n * All references to private component state ($$) are now isolated in this\n * module.\n */\nimport {\n  current_component,\n  get_current_component,\n  set_current_component,\n} from 'svelte/internal'\n\nconst captureState = cmp => {\n  // sanity check: propper behaviour here is to crash noisily so that\n  // user knows that they're looking at something broken\n  if (!cmp) {\n    throw new Error('Missing component')\n  }\n  if (!cmp.$$) {\n    throw new Error('Invalid component')\n  }\n\n  const {\n    $$: { callbacks, bound, ctx, props },\n  } = cmp\n\n  const state = cmp.$capture_state()\n\n  // capturing current value of props (or we'll recreate the component with the\n  // initial prop values, that may have changed -- and would not be reflected in\n  // options.props)\n  const hmr_props_values = {}\n  Object.keys(cmp.$$.props).forEach(prop => {\n    hmr_props_values[prop] = ctx[props[prop]]\n  })\n\n  return {\n    ctx,\n    props,\n    callbacks,\n    bound,\n    state,\n    hmr_props_values,\n  }\n}\n\n// remapping all existing bindings (including hmr_future_foo ones) to the\n// new version's props indexes, and refresh them with the new value from\n// context\nconst restoreBound = (cmp, restore) => {\n  // reverse prop:ctxIndex in $$.props to ctxIndex:prop\n  //\n  // ctxIndex can be either a regular index in $$.ctx or a hmr_future_ prop\n  //\n  const propsByIndex = {}\n  for (const [name, i] of Object.entries(restore.props)) {\n    propsByIndex[i] = name\n  }\n\n  // NOTE $$.bound cannot change in the HMR lifetime of a component, because\n  //      if bindings changes, that means the parent component has changed,\n  //      which means the child (current) component will be wholly recreated\n  for (const [oldIndex, updateBinding] of Object.entries(restore.bound)) {\n    // can be either regular prop, or future_hmr_ prop\n    const propName = propsByIndex[oldIndex]\n\n    // this should never happen if remembering of future props is enabled...\n    // in any case, there's nothing we can do about it if we have lost prop\n    // name knowledge at this point\n    if (propName == null) continue\n\n    // NOTE $$.props[propName] also propagates knowledge of a possible\n    //      future prop to the new $$.props (via $$.props being a Proxy)\n    const newIndex = cmp.$$.props[propName]\n    cmp.$$.bound[newIndex] = updateBinding\n\n    // NOTE if the prop doesn't exist or doesn't exist anymore in the new\n    //      version of the component, clearing the binding is the expected\n    //      behaviour (since that's what would happen in non HMR code)\n    const newValue = cmp.$$.ctx[newIndex]\n    updateBinding(newValue)\n  }\n}\n\n// restoreState\n//\n// It is too late to restore context at this point because component instance\n// function has already been called (and so context has already been read).\n// Instead, we rely on setting current_component to the same value it has when\n// the component was first rendered -- which fix support for context, and is\n// also generally more respectful of normal operation.\n//\nconst restoreState = (cmp, restore) => {\n  if (!restore) return\n\n  if (restore.callbacks) {\n    cmp.$$.callbacks = restore.callbacks\n  }\n\n  if (restore.bound) {\n    restoreBound(cmp, restore)\n  }\n\n  // props, props.$$slots are restored at component creation (works\n  // better -- well, at all actually)\n}\n\nconst get_current_component_safe = () => {\n  // NOTE relying on dynamic bindings (current_component) makes us dependent on\n  // bundler config (and apparently it does not work in demo-svelte-nollup)\n  try {\n    // unfortunately, unlike current_component, get_current_component() can\n    // crash in the normal path (when there is really no parent)\n    return get_current_component()\n  } catch (err) {\n    // ... so we need to consider that this error means that there is no parent\n    //\n    // that makes us tightly coupled to the error message but, at least, we\n    // won't mute an unexpected error, which is quite a horrible thing to do\n    if (err.message === 'Function called outside component initialization') {\n      // who knows...\n      return current_component\n    } else {\n      throw err\n    }\n  }\n}\n\nexport const createProxiedComponent = (\n  Component,\n  initialOptions,\n  { allowLiveBinding, onInstance, onMount, onDestroy }\n) => {\n  let cmp\n  let options = initialOptions\n\n  const isCurrent = _cmp => cmp === _cmp\n\n  const assignOptions = (target, anchor, restore, preserveLocalState) => {\n    const props = Object.assign({}, options.props)\n\n    // Filtering props to avoid \"unexpected prop\" warning\n    // NOTE this is based on props present in initial options, but it should\n    //      always works, because props that are passed from the parent can't\n    //      change without a code change to the parent itself -- hence, the\n    //      child component will be fully recreated, and initial options should\n    //      always represent props that are currnetly passed by the parent\n    if (options.props && restore.hmr_props_values) {\n      for (const prop of Object.keys(options.props)) {\n        if (restore.hmr_props_values.hasOwnProperty(prop)) {\n          props[prop] = restore.hmr_props_values[prop]\n        }\n      }\n    }\n\n    if (preserveLocalState && restore.state) {\n      if (Array.isArray(preserveLocalState)) {\n        // form ['a', 'b'] => preserve only 'a' and 'b'\n        props.$$inject = {}\n        for (const key of preserveLocalState) {\n          props.$$inject[key] = restore.state[key]\n        }\n      } else {\n        props.$$inject = restore.state\n      }\n    } else {\n      delete props.$$inject\n    }\n    options = Object.assign({}, initialOptions, {\n      target,\n      anchor,\n      props,\n      hydrate: false,\n    })\n  }\n\n  // Preserving knowledge of \"future props\" -- very hackish version (maybe\n  // there should be an option to opt out of this)\n  //\n  // The use case is bind:something where something doesn't exist yet in the\n  // target component, but comes to exist later, after a HMR update.\n  //\n  // If Svelte can't map a prop in the current version of the component, it\n  // will just completely discard it:\n  // https://github.com/sveltejs/svelte/blob/1632bca34e4803d6b0e0b0abd652ab5968181860/src/runtime/internal/Component.ts#L46\n  //\n  const rememberFutureProps = cmp => {\n    if (typeof Proxy === 'undefined') return\n\n    cmp.$$.props = new Proxy(cmp.$$.props, {\n      get(target, name) {\n        if (target[name] === undefined) {\n          target[name] = 'hmr_future_' + name\n        }\n        return target[name]\n      },\n      set(target, name, value) {\n        target[name] = value\n      },\n    })\n  }\n\n  const instrument = targetCmp => {\n    const createComponent = (Component, restore, previousCmp) => {\n      set_current_component(parentComponent || previousCmp)\n      const comp = new Component(options)\n      // NOTE must be instrumented before restoreState, because restoring\n      // bindings relies on hacked $$.props\n      instrument(comp)\n      restoreState(comp, restore)\n      return comp\n    }\n\n    rememberFutureProps(targetCmp)\n\n    targetCmp.$$.on_hmr = []\n\n    // `conservative: true` means we want to be sure that the new component has\n    // actually been successfuly created before destroying the old instance.\n    // This could be useful for preventing runtime errors in component init to\n    // bring down the whole HMR. Unfortunately the implementation bellow is\n    // broken (FIXME), but that remains an interesting target for when HMR hooks\n    // will actually land in Svelte itself.\n    //\n    // The goal would be to render an error inplace in case of error, to avoid\n    // losing the navigation stack (especially annoying in native, that is not\n    // based on URL navigation, so we lose the current page on each error).\n    //\n    targetCmp.$replace = (\n      Component,\n      {\n        target = options.target,\n        anchor = options.anchor,\n        preserveLocalState,\n        conservative = false,\n      }\n    ) => {\n      const restore = captureState(targetCmp)\n      assignOptions(\n        target || options.target,\n        anchor,\n        restore,\n        preserveLocalState\n      )\n\n      const callbacks = cmp ? cmp.$$.on_hmr : []\n\n      const afterCallbacks = callbacks.map(fn => fn(cmp)).filter(Boolean)\n\n      const previous = cmp\n      if (conservative) {\n        try {\n          const next = createComponent(Component, restore, previous)\n          // prevents on_destroy from firing on non-final cmp instance\n          cmp = null\n          previous.$destroy()\n          cmp = next\n        } catch (err) {\n          cmp = previous\n          throw err\n        }\n      } else {\n        // prevents on_destroy from firing on non-final cmp instance\n        cmp = null\n        if (previous) {\n          // previous can be null if last constructor has crashed\n          previous.$destroy()\n        }\n        cmp = createComponent(Component, restore, cmp)\n      }\n\n      cmp.$$.hmr_cmp = cmp\n\n      for (const fn of afterCallbacks) {\n        fn(cmp)\n      }\n\n      cmp.$$.on_hmr = callbacks\n\n      return cmp\n    }\n\n    // NOTE onMount must provide target & anchor (for us to be able to determinate\n    // \t\t\tactual DOM insertion point)\n    //\n    // \t\t\tAnd also, to support keyed list, it needs to be called each time the\n    // \t\t\tcomponent is moved (same as $$.fragment.m)\n    if (onMount) {\n      const m = targetCmp.$$.fragment.m\n      targetCmp.$$.fragment.m = (...args) => {\n        const result = m(...args)\n        onMount(...args)\n        return result\n      }\n    }\n\n    // NOTE onDestroy must be called even if the call doesn't pass through the\n    //      component's $destroy method (that we can hook onto by ourselves, since\n    //      it's public API) -- this happens a lot in svelte's internals, that\n    //      manipulates cmp.$$.fragment directly, often binding to fragment.d,\n    //      for example\n    if (onDestroy) {\n      targetCmp.$$.on_destroy.push(() => {\n        if (isCurrent(targetCmp)) {\n          onDestroy()\n        }\n      })\n    }\n\n    if (onInstance) {\n      onInstance(targetCmp)\n    }\n\n    // Svelte 3 creates and mount components from their constructor if\n    // options.target is present.\n    //\n    // This means that at this point, the component's `fragment.c` and,\n    // most notably, `fragment.m` will already have been called _from inside\n    // createComponent_. That is: before we have a chance to hook on it.\n    //\n    // Proxy's constructor\n    //   -> createComponent\n    //     -> component constructor\n    //       -> component.$$.fragment.c(...) (or l, if hydrate:true)\n    //       -> component.$$.fragment.m(...)\n    //\n    //   -> you are here <-\n    //\n    if (onMount) {\n      const { target, anchor } = options\n      if (target) {\n        onMount(target, anchor)\n      }\n    }\n  }\n\n  const parentComponent = allowLiveBinding\n    ? current_component\n    : get_current_component_safe()\n\n  cmp = new Component(options)\n  cmp.$$.hmr_cmp = cmp\n\n  instrument(cmp)\n\n  return cmp\n}\n"}},"svelte-native":{"directory":{"patch-page-show-modal.js":{"file":{"contents":"// This module monkey patches Page#showModal in order to be able to\n// access from the HMR proxy data passed to `showModal` in svelte-native.\n//\n// Data are stored in a opaque prop accessible with `getModalData`.\n//\n// It also switches the `closeCallback` option with a custom brewed one\n// in order to give the proxy control over when its own instance will be\n// destroyed.\n//\n// Obviously this method suffer from extreme coupling with the target code\n// in svelte-native. So it would be wise to recheck compatibility on SN\n// version upgrades.\n//\n// Relevant code is there (last checked version):\n//\n// https://github.com/halfnelson/svelte-native/blob/48fdc97d2eb4d3958cfcb4ff6cf5755a220829eb/src/dom/navigation.ts#L132\n//\n\n// FIXME should we override ViewBase#showModal instead?\n// eslint-disable-next-line import/no-unresolved\nimport { Page } from '@nativescript/core'\n\nconst prop =\n  typeof Symbol !== 'undefined'\n    ? Symbol('hmr_svelte_native_modal')\n    : '___HMR_SVELTE_NATIVE_MODAL___'\n\nconst sup = Page.prototype.showModal\n\nlet patched = false\n\nexport const patchShowModal = () => {\n  // guard: already patched\n  if (patched) return\n  patched = true\n\n  Page.prototype.showModal = function(modalView, options) {\n    const modalData = {\n      originalOptions: options,\n      closeCallback: options.closeCallback,\n    }\n\n    modalView[prop] = modalData\n\n    // Proxies to a function that can be swapped on the fly by HMR proxy.\n    //\n    // The default is still to call the original closeCallback from svelte\n    // navtive, which will destroy the modal view & component. This way, if\n    // no HMR happens on the modal content, normal behaviour is preserved\n    // without the proxy having any work to do.\n    //\n    const closeCallback = (...args) => {\n      return modalData.closeCallback(...args)\n    }\n\n    const tamperedOptions = Object.assign({}, options, { closeCallback })\n\n    return sup.call(this, modalView, tamperedOptions)\n  }\n}\n\nexport const getModalData = modalView => modalView[prop]\n"}},"proxy-adapter-native.js":{"file":{"contents":"/* global document */\n\nimport { adapter as ProxyAdapterDom } from '../proxy-adapter-dom'\n\nimport { patchShowModal, getModalData } from './patch-page-show-modal'\n\npatchShowModal()\n\n// Svelte Native support\n// =====================\n//\n// Rerendering Svelte Native page proves challenging...\n//\n// In NativeScript, pages are the top level component. They are normally\n// introduced into NativeScript's runtime by its `navigate` function. This\n// is how Svelte Natives handles it: it renders the Page component to a\n// dummy fragment, and \"navigate\" to the page element thus created.\n//\n// As long as modifications only impact child components of the page, then\n// we can keep the existing page and replace its content for HMR.\n//\n// However, if the page component itself is modified (including its system\n// title bar), things get hairy...\n//\n// Apparently, the sole way of introducing a new page in a NS application is\n// to navigate to it (no way to just replace it in its parent \"element\", for\n// example). This is how it is done in NS's own \"core\" HMR.\n//\n// NOTE The last paragraph has not really been confirmed with NS6.\n//\n// Unfortunately the API they're using to do that is not public... Its various\n// parts remain exposed though (but documented as private), so this exploratory\n// work now relies on it. It might be fragile...\n//\n// The problem is that there is no public API that can navigate to a page and\n// replace (like location.replace) the current history entry. Actually there\n// is an active issue at NS asking for that. Incidentally, members of\n// NativeScript-Vue have commented on the issue to weight in for it -- they\n// probably face some similar challenge.\n//\n// https://github.com/NativeScript/NativeScript/issues/6283\n\nconst getNavTransition = ({ transition }) => {\n  if (typeof transition === 'string') {\n    transition = { name: transition }\n  }\n  return transition ? { animated: true, transition } : { animated: false }\n}\n\n// copied from TNS FrameBase.replacePage\n//\n// it is not public but there is a comment in there indicating it is for\n// HMR (probably their own core HMR though)\n//\n// NOTE this \"worked\" in TNS 5, but not anymore in TNS 6: updated version bellow\n//\n// eslint-disable-next-line no-unused-vars\nconst replacePage_tns5 = (frame, newPageElement, hotOptions) => {\n  const currentBackstackEntry = frame._currentEntry\n  frame.navigationType = 2\n  frame.performNavigation({\n    isBackNavigation: false,\n    entry: {\n      resolvedPage: newPageElement.nativeView,\n      //\n      // entry: currentBackstackEntry.entry,\n      entry: Object.assign(\n        currentBackstackEntry.entry,\n        getNavTransition(hotOptions)\n      ),\n      navDepth: currentBackstackEntry.navDepth,\n      fragmentTag: currentBackstackEntry.fragmentTag,\n      frameId: currentBackstackEntry.frameId,\n    },\n  })\n}\n\n// Updated for TNS v6\n//\n// https://github.com/NativeScript/NativeScript/blob/6.1.1/tns-core-modules/ui/frame/frame-common.ts#L656\nconst replacePage = (frame, newPageElement) => {\n  const currentBackstackEntry = frame._currentEntry\n  const newPage = newPageElement.nativeView\n  const newBackstackEntry = {\n    entry: currentBackstackEntry.entry,\n    resolvedPage: newPage,\n    navDepth: currentBackstackEntry.navDepth,\n    fragmentTag: currentBackstackEntry.fragmentTag,\n    frameId: currentBackstackEntry.frameId,\n  }\n  const navigationContext = {\n    entry: newBackstackEntry,\n    isBackNavigation: false,\n    navigationType: 2 /* NavigationType replace */,\n  }\n  frame._navigationQueue.push(navigationContext)\n  frame._processNextNavigationEntry()\n}\n\nexport const adapter = class ProxyAdapterNative extends ProxyAdapterDom {\n  constructor(instance) {\n    super(instance)\n\n    this.nativePageElement = null\n    this.originalNativeView = null\n    this.navigatedFromHandler = null\n\n    this.relayNativeNavigatedFrom = this.relayNativeNavigatedFrom.bind(this)\n  }\n\n  dispose() {\n    super.dispose()\n    this.releaseNativePageElement()\n  }\n\n  releaseNativePageElement() {\n    if (this.nativePageElement) {\n      // native cleaning will happen when navigating back from the page\n      this.nativePageElement = null\n    }\n  }\n\n  // svelte-native uses navigateFrom event + e.isBackNavigation to know\n  // when to $destroy the component -- but we don't want our proxy instance\n  // destroyed when we renavigate to the same page for navigation purposes!\n  interceptPageNavigation(pageElement) {\n    const originalNativeView = pageElement.nativeView\n    const { on } = originalNativeView\n    const ownOn = originalNativeView.hasOwnProperty('on')\n    // tricks svelte-native into giving us its handler\n    originalNativeView.on = function(type, handler) {\n      if (type === 'navigatedFrom') {\n        this.navigatedFromHandler = handler\n        if (ownOn) {\n          originalNativeView.on = on\n        } else {\n          delete originalNativeView.on\n        }\n      } else {\n        //some other handler wireup, we will just pass it on.\n        if (on) {\n          on(type, handler)\n        }\n      }\n    }\n  }\n\n  afterMount(target, anchor) {\n    // nativePageElement needs to be updated each time (only for page\n    // components, native component that are not pages follow normal flow)\n    //\n    // TODO quid of components that are initially a page, but then have the\n    // <page> tag removed while running? or the opposite?\n    //\n    // insertionPoint needs to be updated _only when the target changes_ --\n    // i.e. when the component is mount, i.e. (in svelte3) when the component\n    // is _created_, and svelte3 doesn't allow it to move afterward -- that\n    // is, insertionPoint only needs to be created once when the component is\n    // first mounted.\n    //\n    // TODO is it really true that components' elements cannot move in the\n    // DOM? what about keyed list?\n    //\n\n    const isNativePage =\n      (target.tagName === 'fragment' || target.tagName === 'frame') &&\n      target.firstChild &&\n      target.firstChild.tagName == 'page'\n    if (isNativePage) {\n      const nativePageElement = target.firstChild\n      this.interceptPageNavigation(nativePageElement)\n      this.nativePageElement = nativePageElement\n    } else {\n      // try to protect against components changing from page to no-page\n      // or vice versa -- see DEBUG 1 above. NOT TESTED so prolly not working\n      this.nativePageElement = null\n      super.afterMount(target, anchor)\n    }\n  }\n\n  rerender() {\n    const { nativePageElement } = this\n    if (nativePageElement) {\n      this.rerenderNative()\n    } else {\n      super.rerender()\n    }\n  }\n\n  rerenderNative() {\n    const { nativePageElement: oldPageElement } = this\n    const nativeView = oldPageElement.nativeView\n    const frame = nativeView.frame\n    if (frame) {\n      return this.rerenderPage(frame, nativeView)\n    }\n    const modalParent = nativeView._modalParent // FIXME private API\n    if (modalParent) {\n      return this.rerenderModal(modalParent, nativeView)\n    }\n    // wtf? hopefully a race condition with a destroyed component, so\n    // we have nothing more to do here\n    //\n    // for once, it happens when hot reloading dev deps, like this file\n    //\n  }\n\n  rerenderPage(frame, previousPageView) {\n    const isCurrentPage = frame.currentPage === previousPageView\n    if (isCurrentPage) {\n      const {\n        instance: { hotOptions },\n      } = this\n      const newPageElement = this.createPage()\n      if (!newPageElement) {\n        throw new Error('Failed to create updated page')\n      }\n      const isFirstPage = !frame.canGoBack()\n\n      if (isFirstPage) {\n        // NOTE not so sure of bellow with the new NS6 method for replace\n        //\n        // The \"replacePage\" strategy does not work on the first page\n        // of the stack.\n        //\n        // Resulting bug:\n        // - launch\n        // - change first page => HMR\n        // - navigate to other page\n        // - back\n        //   => actual: back to OS\n        //   => expected: back to page 1\n        //\n        // Fortunately, we can overwrite history in this case.\n        //\n        const nativeView = newPageElement.nativeView\n        frame.navigate(\n          Object.assign(\n            {},\n            {\n              create: () => nativeView,\n              clearHistory: true,\n            },\n            getNavTransition(hotOptions)\n          )\n        )\n      } else {\n        replacePage(frame, newPageElement, hotOptions)\n      }\n    } else {\n      const backEntry = frame.backStack.find(\n        ({ resolvedPage: page }) => page === previousPageView\n      )\n      if (!backEntry) {\n        // well... looks like we didn't make it to history after all\n        return\n      }\n      // replace existing nativeView\n      const newPageElement = this.createPage()\n      if (newPageElement) {\n        backEntry.resolvedPage = newPageElement.nativeView\n      } else {\n        throw new Error('Failed to create updated page')\n      }\n    }\n  }\n\n  // modalParent is the page on which showModal(...) was called\n  // oldPageElement is the modal content, that we're actually trying to reload\n  rerenderModal(modalParent, modalView) {\n    const modalData = getModalData(modalView)\n\n    modalData.closeCallback = () => {\n      const nativePageElement = this.createPage()\n      if (!nativePageElement) {\n        throw new Error('Failed to created updated modal page')\n      }\n      const { nativeView } = nativePageElement\n      const { originalOptions } = modalData\n      // Options will get monkey patched again, the only work left for us\n      // is to try to reduce visual disturbances.\n      //\n      // FIXME Even that proves too much unfortunately... Apparently TNS\n      // does not respect the `animated` option in this context:\n      // https://docs.nativescript.org/api-reference/interfaces/_ui_core_view_base_.showmodaloptions#animated\n      //\n      const options = Object.assign({}, originalOptions, { animated: false })\n      modalParent.showModal(nativeView, options)\n    }\n\n    modalView.closeModal()\n  }\n\n  createPage() {\n    const {\n      instance: { refreshComponent },\n    } = this\n    const { nativePageElement, relayNativeNavigatedFrom } = this\n    const oldNativeView = nativePageElement.nativeView\n    // rerender\n    const target = document.createElement('fragment')\n    // not using conservative for now, since there's nothing in place here to\n    // leverage it (yet?) -- and it might be easier to miss breakages in native\n    // only code paths\n    refreshComponent(target, null)\n    // this.nativePageElement is updated in afterMount, triggered by proxy / hooks\n    const newPageElement = this.nativePageElement\n    // update event proxy\n    oldNativeView.off('navigatedFrom', relayNativeNavigatedFrom)\n    nativePageElement.nativeView.on('navigatedFrom', relayNativeNavigatedFrom)\n    return newPageElement\n  }\n\n  relayNativeNavigatedFrom({ isBackNavigation }) {\n    const { originalNativeView, navigatedFromHandler } = this\n    if (!isBackNavigation) {\n      return\n    }\n    if (originalNativeView) {\n      const { off } = originalNativeView\n      const ownOff = originalNativeView.hasOwnProperty('off')\n      originalNativeView.off = function() {\n        this.navigatedFromHandler = null\n        if (ownOff) {\n          originalNativeView.off = off\n        } else {\n          delete originalNativeView.off\n        }\n      }\n    }\n    if (navigatedFromHandler) {\n      return navigatedFromHandler.apply(this, arguments)\n    }\n  }\n\n  renderError(err /* , target, anchor */) {\n    // TODO fallback on TNS error handler for now... at least our error\n    // is more informative\n    throw err\n  }\n}\n"}}}}}}}}