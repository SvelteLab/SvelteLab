{"directory":{"LICENSE":{"file":{"contents":"The MIT License (MIT)\n\nCopyright (c) Denis Malinochkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"out":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport * as taskManager from './managers/tasks';\r\nimport { Options as OptionsInternal } from './settings';\r\nimport { Entry as EntryInternal, FileSystemAdapter as FileSystemAdapterInternal, Pattern as PatternInternal } from './types';\r\ndeclare type EntryObjectModePredicate = {\r\n    [TKey in keyof Pick<OptionsInternal, 'objectMode'>]-?: true;\r\n};\r\ndeclare type EntryStatsPredicate = {\r\n    [TKey in keyof Pick<OptionsInternal, 'stats'>]-?: true;\r\n};\r\ndeclare type EntryObjectPredicate = EntryObjectModePredicate | EntryStatsPredicate;\r\ndeclare function FastGlob(source: PatternInternal | PatternInternal[], options: OptionsInternal & EntryObjectPredicate): Promise<EntryInternal[]>;\r\ndeclare function FastGlob(source: PatternInternal | PatternInternal[], options?: OptionsInternal): Promise<string[]>;\r\ndeclare namespace FastGlob {\r\n    type Options = OptionsInternal;\r\n    type Entry = EntryInternal;\r\n    type Task = taskManager.Task;\r\n    type Pattern = PatternInternal;\r\n    type FileSystemAdapter = FileSystemAdapterInternal;\r\n    function sync(source: PatternInternal | PatternInternal[], options: OptionsInternal & EntryObjectPredicate): EntryInternal[];\r\n    function sync(source: PatternInternal | PatternInternal[], options?: OptionsInternal): string[];\r\n    function stream(source: PatternInternal | PatternInternal[], options?: OptionsInternal): NodeJS.ReadableStream;\r\n    function generateTasks(source: PatternInternal | PatternInternal[], options?: OptionsInternal): Task[];\r\n    function isDynamicPattern(source: PatternInternal, options?: OptionsInternal): boolean;\r\n    function escapePath(source: PatternInternal): PatternInternal;\r\n}\r\nexport = FastGlob;\r\n"}},"index.js":{"file":{"contents":"\"use strict\";\r\nconst taskManager = require(\"./managers/tasks\");\r\nconst patternManager = require(\"./managers/patterns\");\r\nconst async_1 = require(\"./providers/async\");\r\nconst stream_1 = require(\"./providers/stream\");\r\nconst sync_1 = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nconst utils = require(\"./utils\");\r\nasync function FastGlob(source, options) {\r\n    assertPatternsInput(source);\r\n    const works = getWorks(source, async_1.default, options);\r\n    const result = await Promise.all(works);\r\n    return utils.array.flatten(result);\r\n}\r\n// https://github.com/typescript-eslint/typescript-eslint/issues/60\r\n// eslint-disable-next-line no-redeclare\r\n(function (FastGlob) {\r\n    function sync(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, sync_1.default, options);\r\n        return utils.array.flatten(works);\r\n    }\r\n    FastGlob.sync = sync;\r\n    function stream(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, stream_1.default, options);\r\n        /**\r\n         * The stream returned by the provider cannot work with an asynchronous iterator.\r\n         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\r\n         * This affects performance (+25%). I don't see best solution right now.\r\n         */\r\n        return utils.stream.merge(works);\r\n    }\r\n    FastGlob.stream = stream;\r\n    function generateTasks(source, options) {\r\n        assertPatternsInput(source);\r\n        const patterns = patternManager.transform([].concat(source));\r\n        const settings = new settings_1.default(options);\r\n        return taskManager.generate(patterns, settings);\r\n    }\r\n    FastGlob.generateTasks = generateTasks;\r\n    function isDynamicPattern(source, options) {\r\n        assertPatternsInput(source);\r\n        const settings = new settings_1.default(options);\r\n        return utils.pattern.isDynamicPattern(source, settings);\r\n    }\r\n    FastGlob.isDynamicPattern = isDynamicPattern;\r\n    function escapePath(source) {\r\n        assertPatternsInput(source);\r\n        return utils.path.escape(source);\r\n    }\r\n    FastGlob.escapePath = escapePath;\r\n})(FastGlob || (FastGlob = {}));\r\nfunction getWorks(source, _Provider, options) {\r\n    const patterns = patternManager.transform([].concat(source));\r\n    const settings = new settings_1.default(options);\r\n    const tasks = taskManager.generate(patterns, settings);\r\n    const provider = new _Provider(settings);\r\n    return tasks.map(provider.read, provider);\r\n}\r\nfunction assertPatternsInput(input) {\r\n    const source = [].concat(input);\r\n    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\r\n    if (!isValidSource) {\r\n        throw new TypeError('Patterns must be a string (non empty) or an array of strings');\r\n    }\r\n}\r\nmodule.exports = FastGlob;\r\n"}},"managers":{"directory":{"patterns.d.ts":{"file":{"contents":"export declare function transform(patterns: string[]): string[];\r\n/**\r\n * This package only works with forward slashes as a path separator.\r\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\r\n */\r\nexport declare function removeDuplicateSlashes(pattern: string): string;\r\n"}},"patterns.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.removeDuplicateSlashes = exports.transform = void 0;\r\n/**\r\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\r\n * The latter is due to the presence of the device path at the beginning of the UNC path.\r\n * @todo rewrite to negative lookbehind with the next major release.\r\n */\r\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\r\nfunction transform(patterns) {\r\n    return patterns.map((pattern) => removeDuplicateSlashes(pattern));\r\n}\r\nexports.transform = transform;\r\n/**\r\n * This package only works with forward slashes as a path separator.\r\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\r\n */\r\nfunction removeDuplicateSlashes(pattern) {\r\n    return pattern.replace(DOUBLE_SLASH_RE, '/');\r\n}\r\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\r\n"}},"tasks.d.ts":{"file":{"contents":"import Settings from '../settings';\r\nimport { Pattern, PatternsGroup } from '../types';\r\nexport declare type Task = {\r\n    base: string;\r\n    dynamic: boolean;\r\n    patterns: Pattern[];\r\n    positive: Pattern[];\r\n    negative: Pattern[];\r\n};\r\nexport declare function generate(patterns: Pattern[], settings: Settings): Task[];\r\n/**\r\n * Returns tasks grouped by basic pattern directories.\r\n *\r\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\r\n * This is necessary because directory traversal starts at the base directory and goes deeper.\r\n */\r\nexport declare function convertPatternsToTasks(positive: Pattern[], negative: Pattern[], dynamic: boolean): Task[];\r\nexport declare function getPositivePatterns(patterns: Pattern[]): Pattern[];\r\nexport declare function getNegativePatternsAsPositive(patterns: Pattern[], ignore: Pattern[]): Pattern[];\r\nexport declare function groupPatternsByBaseDirectory(patterns: Pattern[]): PatternsGroup;\r\nexport declare function convertPatternGroupsToTasks(positive: PatternsGroup, negative: Pattern[], dynamic: boolean): Task[];\r\nexport declare function convertPatternGroupToTask(base: string, positive: Pattern[], negative: Pattern[], dynamic: boolean): Task;\r\n"}},"tasks.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\r\nconst utils = require(\"../utils\");\r\nfunction generate(patterns, settings) {\r\n    const positivePatterns = getPositivePatterns(patterns);\r\n    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);\r\n    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\r\n    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\r\n    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\r\n    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\r\n    return staticTasks.concat(dynamicTasks);\r\n}\r\nexports.generate = generate;\r\n/**\r\n * Returns tasks grouped by basic pattern directories.\r\n *\r\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\r\n * This is necessary because directory traversal starts at the base directory and goes deeper.\r\n */\r\nfunction convertPatternsToTasks(positive, negative, dynamic) {\r\n    const tasks = [];\r\n    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\r\n    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\r\n    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\r\n    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\r\n    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\r\n    /*\r\n     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\r\n     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\r\n     */\r\n    if ('.' in insideCurrentDirectoryGroup) {\r\n        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\r\n    }\r\n    else {\r\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\r\n    }\r\n    return tasks;\r\n}\r\nexports.convertPatternsToTasks = convertPatternsToTasks;\r\nfunction getPositivePatterns(patterns) {\r\n    return utils.pattern.getPositivePatterns(patterns);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getNegativePatternsAsPositive(patterns, ignore) {\r\n    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\r\n    const positive = negative.map(utils.pattern.convertToPositivePattern);\r\n    return positive;\r\n}\r\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\r\nfunction groupPatternsByBaseDirectory(patterns) {\r\n    const group = {};\r\n    return patterns.reduce((collection, pattern) => {\r\n        const base = utils.pattern.getBaseDirectory(pattern);\r\n        if (base in collection) {\r\n            collection[base].push(pattern);\r\n        }\r\n        else {\r\n            collection[base] = [pattern];\r\n        }\r\n        return collection;\r\n    }, group);\r\n}\r\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\r\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\r\n    return Object.keys(positive).map((base) => {\r\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\r\n    });\r\n}\r\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\r\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\r\n    return {\r\n        dynamic,\r\n        positive,\r\n        negative,\r\n        base,\r\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\r\n    };\r\n}\r\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\r\n"}}}},"providers":{"directory":{"async.d.ts":{"file":{"contents":"import { Task } from '../managers/tasks';\r\nimport { Entry, EntryItem, ReaderOptions } from '../types';\r\nimport ReaderAsync from '../readers/async';\r\nimport Provider from './provider';\r\nexport default class ProviderAsync extends Provider<Promise<EntryItem[]>> {\r\n    protected _reader: ReaderAsync;\r\n    read(task: Task): Promise<EntryItem[]>;\r\n    api(root: string, task: Task, options: ReaderOptions): Promise<Entry[]>;\r\n}\r\n"}},"async.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst async_1 = require(\"../readers/async\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderAsync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new async_1.default(this._settings);\r\n    }\r\n    async read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = await this.api(root, task, options);\r\n        return entries.map((entry) => options.transform(entry));\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderAsync;\r\n"}},"filters":{"directory":{"deep.d.ts":{"file":{"contents":"import { MicromatchOptions, EntryFilterFunction, Pattern } from '../../types';\r\nimport Settings from '../../settings';\r\nexport default class DeepFilter {\r\n    private readonly _settings;\r\n    private readonly _micromatchOptions;\r\n    constructor(_settings: Settings, _micromatchOptions: MicromatchOptions);\r\n    getFilter(basePath: string, positive: Pattern[], negative: Pattern[]): EntryFilterFunction;\r\n    private _getMatcher;\r\n    private _getNegativePatternsRe;\r\n    private _filter;\r\n    private _isSkippedByDeep;\r\n    private _getEntryLevel;\r\n    private _isSkippedSymbolicLink;\r\n    private _isSkippedByPositivePatterns;\r\n    private _isSkippedByNegativePatterns;\r\n}\r\n"}},"deep.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nconst partial_1 = require(\"../matchers/partial\");\r\nclass DeepFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n    }\r\n    getFilter(basePath, positive, negative) {\r\n        const matcher = this._getMatcher(positive);\r\n        const negativeRe = this._getNegativePatternsRe(negative);\r\n        return (entry) => this._filter(basePath, entry, matcher, negativeRe);\r\n    }\r\n    _getMatcher(patterns) {\r\n        return new partial_1.default(patterns, this._settings, this._micromatchOptions);\r\n    }\r\n    _getNegativePatternsRe(patterns) {\r\n        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\r\n        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\r\n    }\r\n    _filter(basePath, entry, matcher, negativeRe) {\r\n        if (this._isSkippedByDeep(basePath, entry.path)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedSymbolicLink(entry)) {\r\n            return false;\r\n        }\r\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\r\n        if (this._isSkippedByPositivePatterns(filepath, matcher)) {\r\n            return false;\r\n        }\r\n        return this._isSkippedByNegativePatterns(filepath, negativeRe);\r\n    }\r\n    _isSkippedByDeep(basePath, entryPath) {\r\n        /**\r\n         * Avoid unnecessary depth calculations when it doesn't matter.\r\n         */\r\n        if (this._settings.deep === Infinity) {\r\n            return false;\r\n        }\r\n        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\r\n    }\r\n    _getEntryLevel(basePath, entryPath) {\r\n        const entryPathDepth = entryPath.split('/').length;\r\n        if (basePath === '') {\r\n            return entryPathDepth;\r\n        }\r\n        const basePathDepth = basePath.split('/').length;\r\n        return entryPathDepth - basePathDepth;\r\n    }\r\n    _isSkippedSymbolicLink(entry) {\r\n        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\r\n    }\r\n    _isSkippedByPositivePatterns(entryPath, matcher) {\r\n        return !this._settings.baseNameMatch && !matcher.match(entryPath);\r\n    }\r\n    _isSkippedByNegativePatterns(entryPath, patternsRe) {\r\n        return !utils.pattern.matchAny(entryPath, patternsRe);\r\n    }\r\n}\r\nexports.default = DeepFilter;\r\n"}},"entry.d.ts":{"file":{"contents":"import Settings from '../../settings';\r\nimport { EntryFilterFunction, MicromatchOptions, Pattern } from '../../types';\r\nexport default class EntryFilter {\r\n    private readonly _settings;\r\n    private readonly _micromatchOptions;\r\n    readonly index: Map<string, undefined>;\r\n    constructor(_settings: Settings, _micromatchOptions: MicromatchOptions);\r\n    getFilter(positive: Pattern[], negative: Pattern[]): EntryFilterFunction;\r\n    private _filter;\r\n    private _isDuplicateEntry;\r\n    private _createIndexRecord;\r\n    private _onlyFileFilter;\r\n    private _onlyDirectoryFilter;\r\n    private _isSkippedByAbsoluteNegativePatterns;\r\n    private _isMatchToPatterns;\r\n}\r\n"}},"entry.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass EntryFilter {\r\n    constructor(_settings, _micromatchOptions) {\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this.index = new Map();\r\n    }\r\n    getFilter(positive, negative) {\r\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\r\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\r\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\r\n    }\r\n    _filter(entry, positiveRe, negativeRe) {\r\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\r\n            return false;\r\n        }\r\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\r\n            return false;\r\n        }\r\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\r\n            return false;\r\n        }\r\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\r\n        const isDirectory = entry.dirent.isDirectory();\r\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);\r\n        if (this._settings.unique && isMatched) {\r\n            this._createIndexRecord(entry);\r\n        }\r\n        return isMatched;\r\n    }\r\n    _isDuplicateEntry(entry) {\r\n        return this.index.has(entry.path);\r\n    }\r\n    _createIndexRecord(entry) {\r\n        this.index.set(entry.path, undefined);\r\n    }\r\n    _onlyFileFilter(entry) {\r\n        return this._settings.onlyFiles && !entry.dirent.isFile();\r\n    }\r\n    _onlyDirectoryFilter(entry) {\r\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\r\n    }\r\n    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\r\n        if (!this._settings.absolute) {\r\n            return false;\r\n        }\r\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\r\n        return utils.pattern.matchAny(fullpath, patternsRe);\r\n    }\r\n    _isMatchToPatterns(entryPath, patternsRe, isDirectory) {\r\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\r\n        // Trying to match files and directories by patterns.\r\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\r\n        // A pattern with a trailling slash can be used for directory matching.\r\n        // To apply such pattern, we need to add a tralling slash to the path.\r\n        if (!isMatched && isDirectory) {\r\n            return utils.pattern.matchAny(filepath + '/', patternsRe);\r\n        }\r\n        return isMatched;\r\n    }\r\n}\r\nexports.default = EntryFilter;\r\n"}},"error.d.ts":{"file":{"contents":"import Settings from '../../settings';\r\nimport { ErrorFilterFunction } from '../../types';\r\nexport default class ErrorFilter {\r\n    private readonly _settings;\r\n    constructor(_settings: Settings);\r\n    getFilter(): ErrorFilterFunction;\r\n    private _isNonFatalError;\r\n}\r\n"}},"error.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass ErrorFilter {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getFilter() {\r\n        return (error) => this._isNonFatalError(error);\r\n    }\r\n    _isNonFatalError(error) {\r\n        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\r\n    }\r\n}\r\nexports.default = ErrorFilter;\r\n"}}}},"matchers":{"directory":{"matcher.d.ts":{"file":{"contents":"import { Pattern, MicromatchOptions, PatternRe } from '../../types';\r\nimport Settings from '../../settings';\r\nexport declare type PatternSegment = StaticPatternSegment | DynamicPatternSegment;\r\ndeclare type StaticPatternSegment = {\r\n    dynamic: false;\r\n    pattern: Pattern;\r\n};\r\ndeclare type DynamicPatternSegment = {\r\n    dynamic: true;\r\n    pattern: Pattern;\r\n    patternRe: PatternRe;\r\n};\r\nexport declare type PatternSection = PatternSegment[];\r\nexport declare type PatternInfo = {\r\n    /**\r\n     * Indicates that the pattern has a globstar (more than a single section).\r\n     */\r\n    complete: boolean;\r\n    pattern: Pattern;\r\n    segments: PatternSegment[];\r\n    sections: PatternSection[];\r\n};\r\nexport default abstract class Matcher {\r\n    private readonly _patterns;\r\n    private readonly _settings;\r\n    private readonly _micromatchOptions;\r\n    protected readonly _storage: PatternInfo[];\r\n    constructor(_patterns: Pattern[], _settings: Settings, _micromatchOptions: MicromatchOptions);\r\n    private _fillStorage;\r\n    private _getPatternSegments;\r\n    private _splitSegmentsIntoSections;\r\n}\r\nexport {};\r\n"}},"matcher.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports.default = Matcher;\r\n"}},"partial.d.ts":{"file":{"contents":"import Matcher from './matcher';\r\nexport default class PartialMatcher extends Matcher {\r\n    match(filepath: string): boolean;\r\n}\r\n"}},"partial.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst matcher_1 = require(\"./matcher\");\r\nclass PartialMatcher extends matcher_1.default {\r\n    match(filepath) {\r\n        const parts = filepath.split('/');\r\n        const levels = parts.length;\r\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\r\n        for (const pattern of patterns) {\r\n            const section = pattern.sections[0];\r\n            /**\r\n             * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n             * but only if the level has reached the end of the first group.\r\n             *\r\n             * fixtures/{a,b}/**\r\n             *  ^ true/false  ^ always true\r\n            */\r\n            if (!pattern.complete && levels > section.length) {\r\n                return true;\r\n            }\r\n            const match = parts.every((part, index) => {\r\n                const segment = pattern.segments[index];\r\n                if (segment.dynamic && segment.patternRe.test(part)) {\r\n                    return true;\r\n                }\r\n                if (!segment.dynamic && segment.pattern === part) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (match) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.default = PartialMatcher;\r\n"}}}},"provider.d.ts":{"file":{"contents":"import { Task } from '../managers/tasks';\r\nimport Settings from '../settings';\r\nimport { MicromatchOptions, ReaderOptions } from '../types';\r\nimport DeepFilter from './filters/deep';\r\nimport EntryFilter from './filters/entry';\r\nimport ErrorFilter from './filters/error';\r\nimport EntryTransformer from './transformers/entry';\r\nexport default abstract class Provider<T> {\r\n    protected readonly _settings: Settings;\r\n    readonly errorFilter: ErrorFilter;\r\n    readonly entryFilter: EntryFilter;\r\n    readonly deepFilter: DeepFilter;\r\n    readonly entryTransformer: EntryTransformer;\r\n    constructor(_settings: Settings);\r\n    abstract read(_task: Task): T;\r\n    protected _getRootDirectory(task: Task): string;\r\n    protected _getReaderOptions(task: Task): ReaderOptions;\r\n    protected _getMicromatchOptions(): MicromatchOptions;\r\n}\r\n"}},"provider.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst deep_1 = require(\"./filters/deep\");\r\nconst entry_1 = require(\"./filters/entry\");\r\nconst error_1 = require(\"./filters/error\");\r\nconst entry_2 = require(\"./transformers/entry\");\r\nclass Provider {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this.errorFilter = new error_1.default(this._settings);\r\n        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\r\n        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\r\n        this.entryTransformer = new entry_2.default(this._settings);\r\n    }\r\n    _getRootDirectory(task) {\r\n        return path.resolve(this._settings.cwd, task.base);\r\n    }\r\n    _getReaderOptions(task) {\r\n        const basePath = task.base === '.' ? '' : task.base;\r\n        return {\r\n            basePath,\r\n            pathSegmentSeparator: '/',\r\n            concurrency: this._settings.concurrency,\r\n            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\r\n            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\r\n            errorFilter: this.errorFilter.getFilter(),\r\n            followSymbolicLinks: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            stats: this._settings.stats,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\r\n            transform: this.entryTransformer.getTransformer()\r\n        };\r\n    }\r\n    _getMicromatchOptions() {\r\n        return {\r\n            dot: this._settings.dot,\r\n            matchBase: this._settings.baseNameMatch,\r\n            nobrace: !this._settings.braceExpansion,\r\n            nocase: !this._settings.caseSensitiveMatch,\r\n            noext: !this._settings.extglob,\r\n            noglobstar: !this._settings.globstar,\r\n            posix: true,\r\n            strictSlashes: false\r\n        };\r\n    }\r\n}\r\nexports.default = Provider;\r\n"}},"stream.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport { Readable } from 'stream';\r\nimport { Task } from '../managers/tasks';\r\nimport ReaderStream from '../readers/stream';\r\nimport { ReaderOptions } from '../types';\r\nimport Provider from './provider';\r\nexport default class ProviderStream extends Provider<Readable> {\r\n    protected _reader: ReaderStream;\r\n    read(task: Task): Readable;\r\n    api(root: string, task: Task, options: ReaderOptions): Readable;\r\n}\r\n"}},"stream.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"stream\");\r\nconst stream_2 = require(\"../readers/stream\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderStream extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new stream_2.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const source = this.api(root, task, options);\r\n        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });\r\n        source\r\n            .once('error', (error) => destination.emit('error', error))\r\n            .on('data', (entry) => destination.emit('data', options.transform(entry)))\r\n            .once('end', () => destination.emit('end'));\r\n        destination\r\n            .once('close', () => source.destroy());\r\n        return destination;\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderStream;\r\n"}},"sync.d.ts":{"file":{"contents":"import { Task } from '../managers/tasks';\r\nimport ReaderSync from '../readers/sync';\r\nimport { Entry, EntryItem, ReaderOptions } from '../types';\r\nimport Provider from './provider';\r\nexport default class ProviderSync extends Provider<EntryItem[]> {\r\n    protected _reader: ReaderSync;\r\n    read(task: Task): EntryItem[];\r\n    api(root: string, task: Task, options: ReaderOptions): Entry[];\r\n}\r\n"}},"sync.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sync_1 = require(\"../readers/sync\");\r\nconst provider_1 = require(\"./provider\");\r\nclass ProviderSync extends provider_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._reader = new sync_1.default(this._settings);\r\n    }\r\n    read(task) {\r\n        const root = this._getRootDirectory(task);\r\n        const options = this._getReaderOptions(task);\r\n        const entries = this.api(root, task, options);\r\n        return entries.map(options.transform);\r\n    }\r\n    api(root, task, options) {\r\n        if (task.dynamic) {\r\n            return this._reader.dynamic(root, options);\r\n        }\r\n        return this._reader.static(task.patterns, options);\r\n    }\r\n}\r\nexports.default = ProviderSync;\r\n"}},"transformers":{"directory":{"entry.d.ts":{"file":{"contents":"import Settings from '../../settings';\r\nimport { EntryTransformerFunction } from '../../types';\r\nexport default class EntryTransformer {\r\n    private readonly _settings;\r\n    constructor(_settings: Settings);\r\n    getTransformer(): EntryTransformerFunction;\r\n    private _transform;\r\n}\r\n"}},"entry.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass EntryTransformer {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n    }\r\n    getTransformer() {\r\n        return (entry) => this._transform(entry);\r\n    }\r\n    _transform(entry) {\r\n        let filepath = entry.path;\r\n        if (this._settings.absolute) {\r\n            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\r\n            filepath = utils.path.unixify(filepath);\r\n        }\r\n        if (this._settings.markDirectories && entry.dirent.isDirectory()) {\r\n            filepath += '/';\r\n        }\r\n        if (!this._settings.objectMode) {\r\n            return filepath;\r\n        }\r\n        return Object.assign(Object.assign({}, entry), { path: filepath });\r\n    }\r\n}\r\nexports.default = EntryTransformer;\r\n"}}}}}},"readers":{"directory":{"async.d.ts":{"file":{"contents":"import * as fsWalk from '@nodelib/fs.walk';\r\nimport { Entry, ReaderOptions, Pattern } from '../types';\r\nimport Reader from './reader';\r\nimport ReaderStream from './stream';\r\nexport default class ReaderAsync extends Reader<Promise<Entry[]>> {\r\n    protected _walkAsync: typeof fsWalk.walk;\r\n    protected _readerStream: ReaderStream;\r\n    dynamic(root: string, options: ReaderOptions): Promise<Entry[]>;\r\n    static(patterns: Pattern[], options: ReaderOptions): Promise<Entry[]>;\r\n}\r\n"}},"async.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsWalk = require(\"@nodelib/fs.walk\");\r\nconst reader_1 = require(\"./reader\");\r\nconst stream_1 = require(\"./stream\");\r\nclass ReaderAsync extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkAsync = fsWalk.walk;\r\n        this._readerStream = new stream_1.default(this._settings);\r\n    }\r\n    dynamic(root, options) {\r\n        return new Promise((resolve, reject) => {\r\n            this._walkAsync(root, options, (error, entries) => {\r\n                if (error === null) {\r\n                    resolve(entries);\r\n                }\r\n                else {\r\n                    reject(error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async static(patterns, options) {\r\n        const entries = [];\r\n        const stream = this._readerStream.static(patterns, options);\r\n        // After #235, replace it with an asynchronous iterator.\r\n        return new Promise((resolve, reject) => {\r\n            stream.once('error', reject);\r\n            stream.on('data', (entry) => entries.push(entry));\r\n            stream.once('end', () => resolve(entries));\r\n        });\r\n    }\r\n}\r\nexports.default = ReaderAsync;\r\n"}},"reader.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport * as fs from 'fs';\r\nimport * as fsStat from '@nodelib/fs.stat';\r\nimport Settings from '../settings';\r\nimport { Entry, ErrnoException, Pattern, ReaderOptions } from '../types';\r\nexport default abstract class Reader<T> {\r\n    protected readonly _settings: Settings;\r\n    protected readonly _fsStatSettings: fsStat.Settings;\r\n    constructor(_settings: Settings);\r\n    abstract dynamic(root: string, options: ReaderOptions): T;\r\n    abstract static(patterns: Pattern[], options: ReaderOptions): T;\r\n    protected _getFullEntryPath(filepath: string): string;\r\n    protected _makeEntry(stats: fs.Stats, pattern: Pattern): Entry;\r\n    protected _isFatalError(error: ErrnoException): boolean;\r\n}\r\n"}},"reader.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst utils = require(\"../utils\");\r\nclass Reader {\r\n    constructor(_settings) {\r\n        this._settings = _settings;\r\n        this._fsStatSettings = new fsStat.Settings({\r\n            followSymbolicLink: this._settings.followSymbolicLinks,\r\n            fs: this._settings.fs,\r\n            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\r\n        });\r\n    }\r\n    _getFullEntryPath(filepath) {\r\n        return path.resolve(this._settings.cwd, filepath);\r\n    }\r\n    _makeEntry(stats, pattern) {\r\n        const entry = {\r\n            name: pattern,\r\n            path: pattern,\r\n            dirent: utils.fs.createDirentFromStats(pattern, stats)\r\n        };\r\n        if (this._settings.stats) {\r\n            entry.stats = stats;\r\n        }\r\n        return entry;\r\n    }\r\n    _isFatalError(error) {\r\n        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\r\n    }\r\n}\r\nexports.default = Reader;\r\n"}},"stream.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport { Readable } from 'stream';\r\nimport * as fsStat from '@nodelib/fs.stat';\r\nimport * as fsWalk from '@nodelib/fs.walk';\r\nimport { Pattern, ReaderOptions } from '../types';\r\nimport Reader from './reader';\r\nexport default class ReaderStream extends Reader<Readable> {\r\n    protected _walkStream: typeof fsWalk.walkStream;\r\n    protected _stat: typeof fsStat.stat;\r\n    dynamic(root: string, options: ReaderOptions): Readable;\r\n    static(patterns: Pattern[], options: ReaderOptions): Readable;\r\n    private _getEntry;\r\n    private _getStat;\r\n}\r\n"}},"stream.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst stream_1 = require(\"stream\");\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst fsWalk = require(\"@nodelib/fs.walk\");\r\nconst reader_1 = require(\"./reader\");\r\nclass ReaderStream extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkStream = fsWalk.walkStream;\r\n        this._stat = fsStat.stat;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkStream(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const filepaths = patterns.map(this._getFullEntryPath, this);\r\n        const stream = new stream_1.PassThrough({ objectMode: true });\r\n        stream._write = (index, _enc, done) => {\r\n            return this._getEntry(filepaths[index], patterns[index], options)\r\n                .then((entry) => {\r\n                if (entry !== null && options.entryFilter(entry)) {\r\n                    stream.push(entry);\r\n                }\r\n                if (index === filepaths.length - 1) {\r\n                    stream.end();\r\n                }\r\n                done();\r\n            })\r\n                .catch(done);\r\n        };\r\n        for (let i = 0; i < filepaths.length; i++) {\r\n            stream.write(i);\r\n        }\r\n        return stream;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        return this._getStat(filepath)\r\n            .then((stats) => this._makeEntry(stats, pattern))\r\n            .catch((error) => {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        });\r\n    }\r\n    _getStat(filepath) {\r\n        return new Promise((resolve, reject) => {\r\n            this._stat(filepath, this._fsStatSettings, (error, stats) => {\r\n                return error === null ? resolve(stats) : reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.default = ReaderStream;\r\n"}},"sync.d.ts":{"file":{"contents":"import * as fsStat from '@nodelib/fs.stat';\r\nimport * as fsWalk from '@nodelib/fs.walk';\r\nimport { Entry, Pattern, ReaderOptions } from '../types';\r\nimport Reader from './reader';\r\nexport default class ReaderSync extends Reader<Entry[]> {\r\n    protected _walkSync: typeof fsWalk.walkSync;\r\n    protected _statSync: typeof fsStat.statSync;\r\n    dynamic(root: string, options: ReaderOptions): Entry[];\r\n    static(patterns: Pattern[], options: ReaderOptions): Entry[];\r\n    private _getEntry;\r\n    private _getStat;\r\n}\r\n"}},"sync.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fsStat = require(\"@nodelib/fs.stat\");\r\nconst fsWalk = require(\"@nodelib/fs.walk\");\r\nconst reader_1 = require(\"./reader\");\r\nclass ReaderSync extends reader_1.default {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._walkSync = fsWalk.walkSync;\r\n        this._statSync = fsStat.statSync;\r\n    }\r\n    dynamic(root, options) {\r\n        return this._walkSync(root, options);\r\n    }\r\n    static(patterns, options) {\r\n        const entries = [];\r\n        for (const pattern of patterns) {\r\n            const filepath = this._getFullEntryPath(pattern);\r\n            const entry = this._getEntry(filepath, pattern, options);\r\n            if (entry === null || !options.entryFilter(entry)) {\r\n                continue;\r\n            }\r\n            entries.push(entry);\r\n        }\r\n        return entries;\r\n    }\r\n    _getEntry(filepath, pattern, options) {\r\n        try {\r\n            const stats = this._getStat(filepath);\r\n            return this._makeEntry(stats, pattern);\r\n        }\r\n        catch (error) {\r\n            if (options.errorFilter(error)) {\r\n                return null;\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    _getStat(filepath) {\r\n        return this._statSync(filepath, this._fsStatSettings);\r\n    }\r\n}\r\nexports.default = ReaderSync;\r\n"}}}},"settings.d.ts":{"file":{"contents":"import { FileSystemAdapter, Pattern } from './types';\r\nexport declare const DEFAULT_FILE_SYSTEM_ADAPTER: FileSystemAdapter;\r\nexport declare type Options = {\r\n    /**\r\n     * Return the absolute path for entries.\r\n     *\r\n     * @default false\r\n     */\r\n    absolute?: boolean;\r\n    /**\r\n     * If set to `true`, then patterns without slashes will be matched against\r\n     * the basename of the path if it contains slashes.\r\n     *\r\n     * @default false\r\n     */\r\n    baseNameMatch?: boolean;\r\n    /**\r\n     * Enables Bash-like brace expansion.\r\n     *\r\n     * @default true\r\n     */\r\n    braceExpansion?: boolean;\r\n    /**\r\n     * Enables a case-sensitive mode for matching files.\r\n     *\r\n     * @default true\r\n     */\r\n    caseSensitiveMatch?: boolean;\r\n    /**\r\n     * Specifies the maximum number of concurrent requests from a reader to read\r\n     * directories.\r\n     *\r\n     * @default os.cpus().length\r\n     */\r\n    concurrency?: number;\r\n    /**\r\n     * The current working directory in which to search.\r\n     *\r\n     * @default process.cwd()\r\n     */\r\n    cwd?: string;\r\n    /**\r\n     * Specifies the maximum depth of a read directory relative to the start\r\n     * directory.\r\n     *\r\n     * @default Infinity\r\n     */\r\n    deep?: number;\r\n    /**\r\n     * Allow patterns to match entries that begin with a period (`.`).\r\n     *\r\n     * @default false\r\n     */\r\n    dot?: boolean;\r\n    /**\r\n     * Enables Bash-like `extglob` functionality.\r\n     *\r\n     * @default true\r\n     */\r\n    extglob?: boolean;\r\n    /**\r\n     * Indicates whether to traverse descendants of symbolic link directories.\r\n     *\r\n     * @default true\r\n     */\r\n    followSymbolicLinks?: boolean;\r\n    /**\r\n     * Custom implementation of methods for working with the file system.\r\n     *\r\n     * @default fs.*\r\n     */\r\n    fs?: Partial<FileSystemAdapter>;\r\n    /**\r\n     * Enables recursively repeats a pattern containing `**`.\r\n     * If `false`, `**` behaves exactly like `*`.\r\n     *\r\n     * @default true\r\n     */\r\n    globstar?: boolean;\r\n    /**\r\n     * An array of glob patterns to exclude matches.\r\n     * This is an alternative way to use negative patterns.\r\n     *\r\n     * @default []\r\n     */\r\n    ignore?: Pattern[];\r\n    /**\r\n     * Mark the directory path with the final slash.\r\n     *\r\n     * @default false\r\n     */\r\n    markDirectories?: boolean;\r\n    /**\r\n     * Returns objects (instead of strings) describing entries.\r\n     *\r\n     * @default false\r\n     */\r\n    objectMode?: boolean;\r\n    /**\r\n     * Return only directories.\r\n     *\r\n     * @default false\r\n     */\r\n    onlyDirectories?: boolean;\r\n    /**\r\n     * Return only files.\r\n     *\r\n     * @default true\r\n     */\r\n    onlyFiles?: boolean;\r\n    /**\r\n     * Enables an object mode (`objectMode`) with an additional `stats` field.\r\n     *\r\n     * @default false\r\n     */\r\n    stats?: boolean;\r\n    /**\r\n     * By default this package suppress only `ENOENT` errors.\r\n     * Set to `true` to suppress any error.\r\n     *\r\n     * @default false\r\n     */\r\n    suppressErrors?: boolean;\r\n    /**\r\n     * Throw an error when symbolic link is broken if `true` or safely\r\n     * return `lstat` call if `false`.\r\n     *\r\n     * @default false\r\n     */\r\n    throwErrorOnBrokenSymbolicLink?: boolean;\r\n    /**\r\n     * Ensures that the returned entries are unique.\r\n     *\r\n     * @default true\r\n     */\r\n    unique?: boolean;\r\n};\r\nexport default class Settings {\r\n    private readonly _options;\r\n    readonly absolute: boolean;\r\n    readonly baseNameMatch: boolean;\r\n    readonly braceExpansion: boolean;\r\n    readonly caseSensitiveMatch: boolean;\r\n    readonly concurrency: number;\r\n    readonly cwd: string;\r\n    readonly deep: number;\r\n    readonly dot: boolean;\r\n    readonly extglob: boolean;\r\n    readonly followSymbolicLinks: boolean;\r\n    readonly fs: FileSystemAdapter;\r\n    readonly globstar: boolean;\r\n    readonly ignore: Pattern[];\r\n    readonly markDirectories: boolean;\r\n    readonly objectMode: boolean;\r\n    readonly onlyDirectories: boolean;\r\n    readonly onlyFiles: boolean;\r\n    readonly stats: boolean;\r\n    readonly suppressErrors: boolean;\r\n    readonly throwErrorOnBrokenSymbolicLink: boolean;\r\n    readonly unique: boolean;\r\n    constructor(_options?: Options);\r\n    private _getValue;\r\n    private _getFileSystemMethods;\r\n}\r\n"}},"settings.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\r\nconst fs = require(\"fs\");\r\nconst os = require(\"os\");\r\n/**\r\n * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.\r\n * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107\r\n */\r\nconst CPU_COUNT = Math.max(os.cpus().length, 1);\r\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = {\r\n    lstat: fs.lstat,\r\n    lstatSync: fs.lstatSync,\r\n    stat: fs.stat,\r\n    statSync: fs.statSync,\r\n    readdir: fs.readdir,\r\n    readdirSync: fs.readdirSync\r\n};\r\nclass Settings {\r\n    constructor(_options = {}) {\r\n        this._options = _options;\r\n        this.absolute = this._getValue(this._options.absolute, false);\r\n        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\r\n        this.braceExpansion = this._getValue(this._options.braceExpansion, true);\r\n        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\r\n        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\r\n        this.cwd = this._getValue(this._options.cwd, process.cwd());\r\n        this.deep = this._getValue(this._options.deep, Infinity);\r\n        this.dot = this._getValue(this._options.dot, false);\r\n        this.extglob = this._getValue(this._options.extglob, true);\r\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\r\n        this.fs = this._getFileSystemMethods(this._options.fs);\r\n        this.globstar = this._getValue(this._options.globstar, true);\r\n        this.ignore = this._getValue(this._options.ignore, []);\r\n        this.markDirectories = this._getValue(this._options.markDirectories, false);\r\n        this.objectMode = this._getValue(this._options.objectMode, false);\r\n        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\r\n        this.onlyFiles = this._getValue(this._options.onlyFiles, true);\r\n        this.stats = this._getValue(this._options.stats, false);\r\n        this.suppressErrors = this._getValue(this._options.suppressErrors, false);\r\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\r\n        this.unique = this._getValue(this._options.unique, true);\r\n        if (this.onlyDirectories) {\r\n            this.onlyFiles = false;\r\n        }\r\n        if (this.stats) {\r\n            this.objectMode = true;\r\n        }\r\n    }\r\n    _getValue(option, value) {\r\n        return option === undefined ? value : option;\r\n    }\r\n    _getFileSystemMethods(methods = {}) {\r\n        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\r\n    }\r\n}\r\nexports.default = Settings;\r\n"}},"types":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport * as fsWalk from '@nodelib/fs.walk';\r\nexport declare type ErrnoException = NodeJS.ErrnoException;\r\nexport declare type Entry = fsWalk.Entry;\r\nexport declare type EntryItem = string | Entry;\r\nexport declare type Pattern = string;\r\nexport declare type PatternRe = RegExp;\r\nexport declare type PatternsGroup = Record<string, Pattern[]>;\r\nexport declare type ReaderOptions = fsWalk.Options & {\r\n    transform(entry: Entry): EntryItem;\r\n    deepFilter: DeepFilterFunction;\r\n    entryFilter: EntryFilterFunction;\r\n    errorFilter: ErrorFilterFunction;\r\n    fs: FileSystemAdapter;\r\n    stats: boolean;\r\n};\r\nexport declare type ErrorFilterFunction = fsWalk.ErrorFilterFunction;\r\nexport declare type EntryFilterFunction = fsWalk.EntryFilterFunction;\r\nexport declare type DeepFilterFunction = fsWalk.DeepFilterFunction;\r\nexport declare type EntryTransformerFunction = (entry: Entry) => EntryItem;\r\nexport declare type MicromatchOptions = {\r\n    dot?: boolean;\r\n    matchBase?: boolean;\r\n    nobrace?: boolean;\r\n    nocase?: boolean;\r\n    noext?: boolean;\r\n    noglobstar?: boolean;\r\n    posix?: boolean;\r\n    strictSlashes?: boolean;\r\n};\r\nexport declare type FileSystemAdapter = fsWalk.FileSystemAdapter;\r\n"}},"index.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"}}}},"utils":{"directory":{"array.d.ts":{"file":{"contents":"export declare function flatten<T>(items: T[][]): T[];\r\nexport declare function splitWhen<T>(items: T[], predicate: (item: T) => boolean): T[][];\r\n"}},"array.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.splitWhen = exports.flatten = void 0;\r\nfunction flatten(items) {\r\n    return items.reduce((collection, item) => [].concat(collection, item), []);\r\n}\r\nexports.flatten = flatten;\r\nfunction splitWhen(items, predicate) {\r\n    const result = [[]];\r\n    let groupIndex = 0;\r\n    for (const item of items) {\r\n        if (predicate(item)) {\r\n            groupIndex++;\r\n            result[groupIndex] = [];\r\n        }\r\n        else {\r\n            result[groupIndex].push(item);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.splitWhen = splitWhen;\r\n"}},"errno.d.ts":{"file":{"contents":"import { ErrnoException } from '../types';\r\nexport declare function isEnoentCodeError(error: ErrnoException): boolean;\r\n"}},"errno.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isEnoentCodeError = void 0;\r\nfunction isEnoentCodeError(error) {\r\n    return error.code === 'ENOENT';\r\n}\r\nexports.isEnoentCodeError = isEnoentCodeError;\r\n"}},"fs.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport * as fs from 'fs';\r\nimport { Dirent } from '@nodelib/fs.walk';\r\nexport declare function createDirentFromStats(name: string, stats: fs.Stats): Dirent;\r\n"}},"fs.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createDirentFromStats = void 0;\r\nclass DirentFromStats {\r\n    constructor(name, stats) {\r\n        this.name = name;\r\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\r\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\r\n        this.isDirectory = stats.isDirectory.bind(stats);\r\n        this.isFIFO = stats.isFIFO.bind(stats);\r\n        this.isFile = stats.isFile.bind(stats);\r\n        this.isSocket = stats.isSocket.bind(stats);\r\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\r\n    }\r\n}\r\nfunction createDirentFromStats(name, stats) {\r\n    return new DirentFromStats(name, stats);\r\n}\r\nexports.createDirentFromStats = createDirentFromStats;\r\n"}},"index.d.ts":{"file":{"contents":"import * as array from './array';\r\nimport * as errno from './errno';\r\nimport * as fs from './fs';\r\nimport * as path from './path';\r\nimport * as pattern from './pattern';\r\nimport * as stream from './stream';\r\nimport * as string from './string';\r\nexport { array, errno, fs, path, pattern, stream, string };\r\n"}},"index.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;\r\nconst array = require(\"./array\");\r\nexports.array = array;\r\nconst errno = require(\"./errno\");\r\nexports.errno = errno;\r\nconst fs = require(\"./fs\");\r\nexports.fs = fs;\r\nconst path = require(\"./path\");\r\nexports.path = path;\r\nconst pattern = require(\"./pattern\");\r\nexports.pattern = pattern;\r\nconst stream = require(\"./stream\");\r\nexports.stream = stream;\r\nconst string = require(\"./string\");\r\nexports.string = string;\r\n"}},"path.d.ts":{"file":{"contents":"import { Pattern } from '../types';\r\n/**\r\n * Designed to work only with simple paths: `dir\\\\file`.\r\n */\r\nexport declare function unixify(filepath: string): string;\r\nexport declare function makeAbsolute(cwd: string, filepath: string): string;\r\nexport declare function escape(pattern: Pattern): Pattern;\r\nexport declare function removeLeadingDotSegment(entry: string): string;\r\n"}},"path.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;\r\nconst path = require(\"path\");\r\nconst LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\\\\r\nconst UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\())/g;\r\n/**\r\n * Designed to work only with simple paths: `dir\\\\file`.\r\n */\r\nfunction unixify(filepath) {\r\n    return filepath.replace(/\\\\/g, '/');\r\n}\r\nexports.unixify = unixify;\r\nfunction makeAbsolute(cwd, filepath) {\r\n    return path.resolve(cwd, filepath);\r\n}\r\nexports.makeAbsolute = makeAbsolute;\r\nfunction escape(pattern) {\r\n    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\\\$2');\r\n}\r\nexports.escape = escape;\r\nfunction removeLeadingDotSegment(entry) {\r\n    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.\r\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\r\n    if (entry.charAt(0) === '.') {\r\n        const secondCharactery = entry.charAt(1);\r\n        if (secondCharactery === '/' || secondCharactery === '\\\\') {\r\n            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\r\n        }\r\n    }\r\n    return entry;\r\n}\r\nexports.removeLeadingDotSegment = removeLeadingDotSegment;\r\n"}},"pattern.d.ts":{"file":{"contents":"import { MicromatchOptions, Pattern, PatternRe } from '../types';\r\ndeclare type PatternTypeOptions = {\r\n    braceExpansion?: boolean;\r\n    caseSensitiveMatch?: boolean;\r\n    extglob?: boolean;\r\n};\r\nexport declare function isStaticPattern(pattern: Pattern, options?: PatternTypeOptions): boolean;\r\nexport declare function isDynamicPattern(pattern: Pattern, options?: PatternTypeOptions): boolean;\r\nexport declare function convertToPositivePattern(pattern: Pattern): Pattern;\r\nexport declare function convertToNegativePattern(pattern: Pattern): Pattern;\r\nexport declare function isNegativePattern(pattern: Pattern): boolean;\r\nexport declare function isPositivePattern(pattern: Pattern): boolean;\r\nexport declare function getNegativePatterns(patterns: Pattern[]): Pattern[];\r\nexport declare function getPositivePatterns(patterns: Pattern[]): Pattern[];\r\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nexport declare function getPatternsInsideCurrentDirectory(patterns: Pattern[]): Pattern[];\r\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nexport declare function getPatternsOutsideCurrentDirectory(patterns: Pattern[]): Pattern[];\r\nexport declare function isPatternRelatedToParentDirectory(pattern: Pattern): boolean;\r\nexport declare function getBaseDirectory(pattern: Pattern): string;\r\nexport declare function hasGlobStar(pattern: Pattern): boolean;\r\nexport declare function endsWithSlashGlobStar(pattern: Pattern): boolean;\r\nexport declare function isAffectDepthOfReadingPattern(pattern: Pattern): boolean;\r\nexport declare function expandPatternsWithBraceExpansion(patterns: Pattern[]): Pattern[];\r\nexport declare function expandBraceExpansion(pattern: Pattern): Pattern[];\r\nexport declare function getPatternParts(pattern: Pattern, options: MicromatchOptions): Pattern[];\r\nexport declare function makeRe(pattern: Pattern, options: MicromatchOptions): PatternRe;\r\nexport declare function convertPatternsToRe(patterns: Pattern[], options: MicromatchOptions): PatternRe[];\r\nexport declare function matchAny(entry: string, patternsRe: PatternRe[]): boolean;\r\nexport {};\r\n"}},"pattern.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = require(\"path\");\r\nconst globParent = require(\"glob-parent\");\r\nconst micromatch = require(\"micromatch\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\r\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction hasBraceExpansion(pattern) {\r\n    const openingBraceIndex = pattern.indexOf('{');\r\n    if (openingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\r\n    if (closingBraceIndex === -1) {\r\n        return false;\r\n    }\r\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\r\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\r\n}\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\n/**\r\n * Returns patterns that can be applied inside the current directory.\r\n *\r\n * @example\r\n * // ['./*', '*', 'a/*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsInsideCurrentDirectory(patterns) {\r\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\r\n}\r\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\r\n/**\r\n * Returns patterns to be expanded relative to (outside) the current directory.\r\n *\r\n * @example\r\n * // ['../*', './../*']\r\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\r\n */\r\nfunction getPatternsOutsideCurrentDirectory(patterns) {\r\n    return patterns.filter(isPatternRelatedToParentDirectory);\r\n}\r\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\r\nfunction isPatternRelatedToParentDirectory(pattern) {\r\n    return pattern.startsWith('..') || pattern.startsWith('./..');\r\n}\r\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n"}},"stream.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\r\nimport { Readable } from 'stream';\r\nexport declare function merge(streams: Readable[]): NodeJS.ReadableStream;\r\n"}},"stream.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.merge = void 0;\r\nconst merge2 = require(\"merge2\");\r\nfunction merge(streams) {\r\n    const mergedStream = merge2(streams);\r\n    streams.forEach((stream) => {\r\n        stream.once('error', (error) => mergedStream.emit('error', error));\r\n    });\r\n    mergedStream.once('close', () => propagateCloseEventToSources(streams));\r\n    mergedStream.once('end', () => propagateCloseEventToSources(streams));\r\n    return mergedStream;\r\n}\r\nexports.merge = merge;\r\nfunction propagateCloseEventToSources(streams) {\r\n    streams.forEach((stream) => stream.emit('close'));\r\n}\r\n"}},"string.d.ts":{"file":{"contents":"export declare function isString(input: unknown): input is string;\r\nexport declare function isEmpty(input: string): boolean;\r\n"}},"string.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isEmpty = exports.isString = void 0;\r\nfunction isString(input) {\r\n    return typeof input === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isEmpty(input) {\r\n    return input === '';\r\n}\r\nexports.isEmpty = isEmpty;\r\n"}}}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"fast-glob\",\n  \"version\": \"3.2.12\",\n  \"description\": \"It's a very fast and efficient glob library for Node.js\",\n  \"license\": \"MIT\",\n  \"repository\": \"mrmlnc/fast-glob\",\n  \"author\": {\n    \"name\": \"Denis Malinochkin\",\n    \"url\": \"https://mrmlnc.com\"\n  },\n  \"engines\": {\n    \"node\": \">=8.6.0\"\n  },\n  \"main\": \"out/index.js\",\n  \"typings\": \"out/index.d.ts\",\n  \"files\": [\n    \"out\",\n    \"!out/{benchmark,tests}\",\n    \"!out/**/*.map\",\n    \"!out/**/*.spec.*\"\n  ],\n  \"keywords\": [\n    \"glob\",\n    \"patterns\",\n    \"fast\",\n    \"implementation\"\n  ],\n  \"devDependencies\": {\n    \"@nodelib/fs.macchiato\": \"^1.0.1\",\n    \"@types/compute-stdev\": \"^1.0.0\",\n    \"@types/easy-table\": \"^0.0.32\",\n    \"@types/glob\": \"^7.1.1\",\n    \"@types/glob-parent\": \"^5.1.0\",\n    \"@types/is-ci\": \"^2.0.0\",\n    \"@types/merge2\": \"^1.1.4\",\n    \"@types/micromatch\": \"^4.0.0\",\n    \"@types/minimist\": \"^1.2.0\",\n    \"@types/mocha\": \"^5.2.7\",\n    \"@types/node\": \"^12.7.8\",\n    \"@types/rimraf\": \"^2.0.2\",\n    \"@types/sinon\": \"^7.5.0\",\n    \"compute-stdev\": \"^1.0.0\",\n    \"easy-table\": \"^1.1.1\",\n    \"eslint\": \"^6.5.1\",\n    \"eslint-config-mrmlnc\": \"^1.1.0\",\n    \"execa\": \"^2.0.4\",\n    \"fast-glob\": \"^3.0.4\",\n    \"fdir\": \"^5.1.0\",\n    \"glob\": \"^7.1.4\",\n    \"is-ci\": \"^2.0.0\",\n    \"log-update\": \"^4.0.0\",\n    \"minimist\": \"^1.2.0\",\n    \"mocha\": \"^6.2.1\",\n    \"rimraf\": \"^3.0.0\",\n    \"sinon\": \"^7.5.0\",\n    \"tiny-glob\": \"^0.2.6\",\n    \"typescript\": \"^3.6.3\"\n  },\n  \"dependencies\": {\n    \"@nodelib/fs.stat\": \"^2.0.2\",\n    \"@nodelib/fs.walk\": \"^1.2.3\",\n    \"glob-parent\": \"^5.1.2\",\n    \"merge2\": \"^1.3.0\",\n    \"micromatch\": \"^4.0.4\"\n  },\n  \"scripts\": {\n    \"clean\": \"rimraf out\",\n    \"lint\": \"eslint \\\"src/**/*.ts\\\" --cache\",\n    \"compile\": \"tsc\",\n    \"test\": \"mocha \\\"out/**/*.spec.js\\\" -s 0\",\n    \"smoke\": \"mocha \\\"out/**/*.smoke.js\\\" -s 0\",\n    \"smoke:sync\": \"mocha \\\"out/**/*.smoke.js\\\" -s 0 --grep \\\"\\\\(sync\\\\)\\\"\",\n    \"smoke:async\": \"mocha \\\"out/**/*.smoke.js\\\" -s 0 --grep \\\"\\\\(async\\\\)\\\"\",\n    \"smoke:stream\": \"mocha \\\"out/**/*.smoke.js\\\" -s 0 --grep \\\"\\\\(stream\\\\)\\\"\",\n    \"build\": \"npm run clean && npm run compile && npm run lint && npm test\",\n    \"watch\": \"npm run clean && npm run compile -- --sourceMap --watch\",\n    \"bench\": \"npm run bench-async && npm run bench-stream && npm run bench-sync\",\n    \"bench-async\": \"npm run bench-async-flatten && npm run bench-async-deep && npm run bench-async-partial-flatten && npm run bench-async-partial-deep\",\n    \"bench-stream\": \"npm run bench-stream-flatten && npm run bench-stream-deep && npm run bench-stream-partial-flatten && npm run bench-stream-partial-deep\",\n    \"bench-sync\": \"npm run bench-sync-flatten && npm run bench-sync-deep && npm run bench-sync-partial-flatten && npm run bench-sync-partial-deep\",\n    \"bench-async-flatten\": \"node ./out/benchmark --mode async --pattern \\\"*\\\"\",\n    \"bench-async-deep\": \"node ./out/benchmark --mode async --pattern \\\"**\\\"\",\n    \"bench-async-partial-flatten\": \"node ./out/benchmark --mode async --pattern \\\"{fixtures,out}/{first,second}/*\\\"\",\n    \"bench-async-partial-deep\": \"node ./out/benchmark --mode async --pattern \\\"{fixtures,out}/**\\\"\",\n    \"bench-stream-flatten\": \"node ./out/benchmark --mode stream --pattern \\\"*\\\"\",\n    \"bench-stream-deep\": \"node ./out/benchmark --mode stream --pattern \\\"**\\\"\",\n    \"bench-stream-partial-flatten\": \"node ./out/benchmark --mode stream --pattern \\\"{fixtures,out}/{first,second}/*\\\"\",\n    \"bench-stream-partial-deep\": \"node ./out/benchmark --mode stream --pattern \\\"{fixtures,out}/**\\\"\",\n    \"bench-sync-flatten\": \"node ./out/benchmark --mode sync --pattern \\\"*\\\"\",\n    \"bench-sync-deep\": \"node ./out/benchmark --mode sync --pattern \\\"**\\\"\",\n    \"bench-sync-partial-flatten\": \"node ./out/benchmark --mode sync --pattern \\\"{fixtures,out}/{first,second}/*\\\"\",\n    \"bench-sync-partial-deep\": \"node ./out/benchmark --mode sync --pattern \\\"{fixtures,out}/**\\\"\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# fast-glob\n\n> It's a very fast and efficient [glob][glob_definition] library for [Node.js][node_js].\n\nThis package provides methods for traversing the file system and returning pathnames that matched a defined set of a specified pattern according to the rules used by the Unix Bash shell with some simplifications, meanwhile results are returned in **arbitrary order**. Quick, simple, effective.\n\n## Table of Contents\n\n<details>\n<summary><strong>Details</strong></summary>\n\n* [Highlights](#highlights)\n* [Donation](#donation)\n* [Old and modern mode](#old-and-modern-mode)\n* [Pattern syntax](#pattern-syntax)\n  * [Basic syntax](#basic-syntax)\n  * [Advanced syntax](#advanced-syntax)\n* [Installation](#installation)\n* [API](#api)\n  * [Asynchronous](#asynchronous)\n  * [Synchronous](#synchronous)\n  * [Stream](#stream)\n    * [patterns](#patterns)\n    * [[options]](#options)\n  * [Helpers](#helpers)\n    * [generateTasks](#generatetaskspatterns-options)\n    * [isDynamicPattern](#isdynamicpatternpattern-options)\n    * [escapePath](#escapepathpattern)\n* [Options](#options-3)\n  * [Common](#common)\n    * [concurrency](#concurrency)\n    * [cwd](#cwd)\n    * [deep](#deep)\n    * [followSymbolicLinks](#followsymboliclinks)\n    * [fs](#fs)\n    * [ignore](#ignore)\n    * [suppressErrors](#suppresserrors)\n    * [throwErrorOnBrokenSymbolicLink](#throwerroronbrokensymboliclink)\n  * [Output control](#output-control)\n    * [absolute](#absolute)\n    * [markDirectories](#markdirectories)\n    * [objectMode](#objectmode)\n    * [onlyDirectories](#onlydirectories)\n    * [onlyFiles](#onlyfiles)\n    * [stats](#stats)\n    * [unique](#unique)\n  * [Matching control](#matching-control)\n    * [braceExpansion](#braceexpansion)\n    * [caseSensitiveMatch](#casesensitivematch)\n    * [dot](#dot)\n    * [extglob](#extglob)\n    * [globstar](#globstar)\n    * [baseNameMatch](#basenamematch)\n* [FAQ](#faq)\n  * [What is a static or dynamic pattern?](#what-is-a-static-or-dynamic-pattern)\n  * [How to write patterns on Windows?](#how-to-write-patterns-on-windows)\n  * [Why are parentheses match wrong?](#why-are-parentheses-match-wrong)\n  * [How to exclude directory from reading?](#how-to-exclude-directory-from-reading)\n  * [How to use UNC path?](#how-to-use-unc-path)\n  * [Compatible with `node-glob`?](#compatible-with-node-glob)\n* [Benchmarks](#benchmarks)\n  * [Server](#server)\n  * [Nettop](#nettop)\n* [Changelog](#changelog)\n* [License](#license)\n\n</details>\n\n## Highlights\n\n* Fast. Probably the fastest.\n* Supports multiple and negative patterns.\n* Synchronous, Promise and Stream API.\n* Object mode. Can return more than just strings.\n* Error-tolerant.\n\n## Donation\n\nDo you like this project? Support it by donating, creating an issue or pull request.\n\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)][paypal_mrmlnc]\n\n## Old and modern mode\n\nThis package works in two modes, depending on the environment in which it is used.\n\n* **Old mode**. Node.js below 10.10 or when the [`stats`](#stats) option is *enabled*.\n* **Modern mode**. Node.js 10.10+ and the [`stats`](#stats) option is *disabled*.\n\nThe modern mode is faster. Learn more about the [internal mechanism][nodelib_fs_scandir_old_and_modern_modern].\n\n## Pattern syntax\n\n> :warning: Always use forward-slashes in glob expressions (patterns and [`ignore`](#ignore) option). Use backslashes for escaping characters.\n\nThere is more than one form of syntax: basic and advanced. Below is a brief overview of the supported features. Also pay attention to our [FAQ](#faq).\n\n> :book: This package uses a [`micromatch`][micromatch] as a library for pattern matching.\n\n### Basic syntax\n\n* An asterisk (`*`) — matches everything except slashes (path separators), hidden files (names starting with `.`).\n* A double star or globstar (`**`) — matches zero or more directories.\n* Question mark (`?`) – matches any single character except slashes (path separators).\n* Sequence (`[seq]`) — matches any character in sequence.\n\n> :book: A few additional words about the [basic matching behavior][picomatch_matching_behavior].\n\nSome examples:\n\n* `src/**/*.js` — matches all files in the `src` directory (any level of nesting) that have the `.js` extension.\n* `src/*.??` — matches all files in the `src` directory (only first level of nesting) that have a two-character extension.\n* `file-[01].js` — matches files: `file-0.js`, `file-1.js`.\n\n### Advanced syntax\n\n* [Escapes characters][micromatch_backslashes] (`\\\\`) — matching special characters (`$^*+?()[]`) as literals.\n* [POSIX character classes][picomatch_posix_brackets] (`[[:digit:]]`).\n* [Extended globs][micromatch_extglobs] (`?(pattern-list)`).\n* [Bash style brace expansions][micromatch_braces] (`{}`).\n* [Regexp character classes][micromatch_regex_character_classes] (`[1-5]`).\n* [Regex groups][regular_expressions_brackets] (`(a|b)`).\n\n> :book: A few additional words about the [advanced matching behavior][micromatch_extended_globbing].\n\nSome examples:\n\n* `src/**/*.{css,scss}` — matches all files in the `src` directory (any level of nesting) that have the `.css` or `.scss` extension.\n* `file-[[:digit:]].js` — matches files: `file-0.js`, `file-1.js`, …, `file-9.js`.\n* `file-{1..3}.js` — matches files: `file-1.js`, `file-2.js`, `file-3.js`.\n* `file-(1|2)` — matches files: `file-1.js`, `file-2.js`.\n\n## Installation\n\n```console\nnpm install fast-glob\n```\n\n## API\n\n### Asynchronous\n\n```js\nfg(patterns, [options])\n```\n\nReturns a `Promise` with an array of matching entries.\n\n```js\nconst fg = require('fast-glob');\n\nconst entries = await fg(['.editorconfig', '**/index.js'], { dot: true });\n\n// ['.editorconfig', 'services/index.js']\n```\n\n### Synchronous\n\n```js\nfg.sync(patterns, [options])\n```\n\nReturns an array of matching entries.\n\n```js\nconst fg = require('fast-glob');\n\nconst entries = fg.sync(['.editorconfig', '**/index.js'], { dot: true });\n\n// ['.editorconfig', 'services/index.js']\n```\n\n### Stream\n\n```js\nfg.stream(patterns, [options])\n```\n\nReturns a [`ReadableStream`][node_js_stream_readable_streams] when the `data` event will be emitted with matching entry.\n\n```js\nconst fg = require('fast-glob');\n\nconst stream = fg.stream(['.editorconfig', '**/index.js'], { dot: true });\n\nfor await (const entry of stream) {\n\t// .editorconfig\n\t// services/index.js\n}\n```\n\n#### patterns\n\n* Required: `true`\n* Type: `string | string[]`\n\nAny correct pattern(s).\n\n> :1234: [Pattern syntax](#pattern-syntax)\n>\n> :warning: This package does not respect the order of patterns. First, all the negative patterns are applied, and only then the positive patterns. If you want to get a certain order of records, use sorting or split calls.\n\n#### [options]\n\n* Required: `false`\n* Type: [`Options`](#options-3)\n\nSee [Options](#options-3) section.\n\n### Helpers\n\n#### `generateTasks(patterns, [options])`\n\nReturns the internal representation of patterns ([`Task`](./src/managers/tasks.ts) is a combining patterns by base directory).\n\n```js\nfg.generateTasks('*');\n\n[{\n    base: '.', // Parent directory for all patterns inside this task\n    dynamic: true, // Dynamic or static patterns are in this task\n    patterns: ['*'],\n    positive: ['*'],\n    negative: []\n}]\n```\n\n##### patterns\n\n* Required: `true`\n* Type: `string | string[]`\n\nAny correct pattern(s).\n\n##### [options]\n\n* Required: `false`\n* Type: [`Options`](#options-3)\n\nSee [Options](#options-3) section.\n\n#### `isDynamicPattern(pattern, [options])`\n\nReturns `true` if the passed pattern is a dynamic pattern.\n\n> :1234: [What is a static or dynamic pattern?](#what-is-a-static-or-dynamic-pattern)\n\n```js\nfg.isDynamicPattern('*'); // true\nfg.isDynamicPattern('abc'); // false\n```\n\n##### pattern\n\n* Required: `true`\n* Type: `string`\n\nAny correct pattern.\n\n##### [options]\n\n* Required: `false`\n* Type: [`Options`](#options-3)\n\nSee [Options](#options-3) section.\n\n#### `escapePath(pattern)`\n\nReturns a path with escaped special characters (`*?|(){}[]`, `!` at the beginning of line, `@+!` before the opening parenthesis).\n\n```js\nfg.escapePath('!abc'); // \\\\!abc\nfg.escapePath('C:/Program Files (x86)'); // C:/Program Files \\\\(x86\\\\)\n```\n\n##### pattern\n\n* Required: `true`\n* Type: `string`\n\nAny string, for example, a path to a file.\n\n## Options\n\n### Common options\n\n#### concurrency\n\n* Type: `number`\n* Default: `os.cpus().length`\n\nSpecifies the maximum number of concurrent requests from a reader to read directories.\n\n> :book: The higher the number, the higher the performance and load on the file system. If you want to read in quiet mode, set the value to a comfortable number or `1`.\n\n#### cwd\n\n* Type: `string`\n* Default: `process.cwd()`\n\nThe current working directory in which to search.\n\n#### deep\n\n* Type: `number`\n* Default: `Infinity`\n\nSpecifies the maximum depth of a read directory relative to the start directory.\n\nFor example, you have the following tree:\n\n```js\ndir/\n└── one/            // 1\n    └── two/        // 2\n        └── file.js // 3\n```\n\n```js\n// With base directory\nfg.sync('dir/**', { onlyFiles: false, deep: 1 }); // ['dir/one']\nfg.sync('dir/**', { onlyFiles: false, deep: 2 }); // ['dir/one', 'dir/one/two']\n\n// With cwd option\nfg.sync('**', { onlyFiles: false, cwd: 'dir', deep: 1 }); // ['one']\nfg.sync('**', { onlyFiles: false, cwd: 'dir', deep: 2 }); // ['one', 'one/two']\n```\n\n> :book: If you specify a pattern with some base directory, this directory will not participate in the calculation of the depth of the found directories. Think of it as a [`cwd`](#cwd) option.\n\n#### followSymbolicLinks\n\n* Type: `boolean`\n* Default: `true`\n\nIndicates whether to traverse descendants of symbolic link directories when expanding `**` patterns.\n\n> :book: Note that this option does not affect the base directory of the pattern. For example, if `./a` is a symlink to directory `./b` and you specified `['./a**', './b/**']` patterns, then directory `./a` will still be read.\n\n> :book: If the [`stats`](#stats) option is specified, the information about the symbolic link (`fs.lstat`) will be replaced with information about the entry (`fs.stat`) behind it.\n\n#### fs\n\n* Type: `FileSystemAdapter`\n* Default: `fs.*`\n\nCustom implementation of methods for working with the file system.\n\n```ts\nexport interface FileSystemAdapter {\n    lstat?: typeof fs.lstat;\n    stat?: typeof fs.stat;\n    lstatSync?: typeof fs.lstatSync;\n    statSync?: typeof fs.statSync;\n    readdir?: typeof fs.readdir;\n    readdirSync?: typeof fs.readdirSync;\n}\n```\n\n#### ignore\n\n* Type: `string[]`\n* Default: `[]`\n\nAn array of glob patterns to exclude matches. This is an alternative way to use negative patterns.\n\n```js\ndir/\n├── package-lock.json\n└── package.json\n```\n\n```js\nfg.sync(['*.json', '!package-lock.json']);            // ['package.json']\nfg.sync('*.json', { ignore: ['package-lock.json'] }); // ['package.json']\n```\n\n#### suppressErrors\n\n* Type: `boolean`\n* Default: `false`\n\nBy default this package suppress only `ENOENT` errors. Set to `true` to suppress any error.\n\n> :book: Can be useful when the directory has entries with a special level of access.\n\n#### throwErrorOnBrokenSymbolicLink\n\n* Type: `boolean`\n* Default: `false`\n\nThrow an error when symbolic link is broken if `true` or safely return `lstat` call if `false`.\n\n> :book: This option has no effect on errors when reading the symbolic link directory.\n\n### Output control\n\n#### absolute\n\n* Type: `boolean`\n* Default: `false`\n\nReturn the absolute path for entries.\n\n```js\nfg.sync('*.js', { absolute: false }); // ['index.js']\nfg.sync('*.js', { absolute: true });  // ['/home/user/index.js']\n```\n\n> :book: This option is required if you want to use negative patterns with absolute path, for example, `!${__dirname}/*.js`.\n\n#### markDirectories\n\n* Type: `boolean`\n* Default: `false`\n\nMark the directory path with the final slash.\n\n```js\nfg.sync('*', { onlyFiles: false, markDirectories: false }); // ['index.js', 'controllers']\nfg.sync('*', { onlyFiles: false, markDirectories: true });  // ['index.js', 'controllers/']\n```\n\n#### objectMode\n\n* Type: `boolean`\n* Default: `false`\n\nReturns objects (instead of strings) describing entries.\n\n```js\nfg.sync('*', { objectMode: false }); // ['src/index.js']\nfg.sync('*', { objectMode: true });  // [{ name: 'index.js', path: 'src/index.js', dirent: <fs.Dirent> }]\n```\n\nThe object has the following fields:\n\n* name (`string`) — the last part of the path (basename)\n* path (`string`) — full path relative to the pattern base directory\n* dirent ([`fs.Dirent`][node_js_fs_class_fs_dirent]) — instance of `fs.Dirent`\n\n> :book: An object is an internal representation of entry, so getting it does not affect performance.\n\n#### onlyDirectories\n\n* Type: `boolean`\n* Default: `false`\n\nReturn only directories.\n\n```js\nfg.sync('*', { onlyDirectories: false }); // ['index.js', 'src']\nfg.sync('*', { onlyDirectories: true });  // ['src']\n```\n\n> :book: If `true`, the [`onlyFiles`](#onlyfiles) option is automatically `false`.\n\n#### onlyFiles\n\n* Type: `boolean`\n* Default: `true`\n\nReturn only files.\n\n```js\nfg.sync('*', { onlyFiles: false }); // ['index.js', 'src']\nfg.sync('*', { onlyFiles: true });  // ['index.js']\n```\n\n#### stats\n\n* Type: `boolean`\n* Default: `false`\n\nEnables an [object mode](#objectmode) with an additional field:\n\n* stats ([`fs.Stats`][node_js_fs_class_fs_stats]) — instance of `fs.Stats`\n\n```js\nfg.sync('*', { stats: false }); // ['src/index.js']\nfg.sync('*', { stats: true });  // [{ name: 'index.js', path: 'src/index.js', dirent: <fs.Dirent>, stats: <fs.Stats> }]\n```\n\n> :book: Returns `fs.stat` instead of `fs.lstat` for symbolic links when the [`followSymbolicLinks`](#followsymboliclinks) option is specified.\n>\n> :warning: Unlike [object mode](#objectmode) this mode requires additional calls to the file system. On average, this mode is slower at least twice. See [old and modern mode](#old-and-modern-mode) for more details.\n\n#### unique\n\n* Type: `boolean`\n* Default: `true`\n\nEnsures that the returned entries are unique.\n\n```js\nfg.sync(['*.json', 'package.json'], { unique: false }); // ['package.json', 'package.json']\nfg.sync(['*.json', 'package.json'], { unique: true });  // ['package.json']\n```\n\nIf `true` and similar entries are found, the result is the first found.\n\n### Matching control\n\n#### braceExpansion\n\n* Type: `boolean`\n* Default: `true`\n\nEnables Bash-like brace expansion.\n\n> :1234: [Syntax description][bash_hackers_syntax_expansion_brace] or more [detailed description][micromatch_braces].\n\n```js\ndir/\n├── abd\n├── acd\n└── a{b,c}d\n```\n\n```js\nfg.sync('a{b,c}d', { braceExpansion: false }); // ['a{b,c}d']\nfg.sync('a{b,c}d', { braceExpansion: true });  // ['abd', 'acd']\n```\n\n#### caseSensitiveMatch\n\n* Type: `boolean`\n* Default: `true`\n\nEnables a [case-sensitive][wikipedia_case_sensitivity] mode for matching files.\n\n```js\ndir/\n├── file.txt\n└── File.txt\n```\n\n```js\nfg.sync('file.txt', { caseSensitiveMatch: false }); // ['file.txt', 'File.txt']\nfg.sync('file.txt', { caseSensitiveMatch: true });  // ['file.txt']\n```\n\n#### dot\n\n* Type: `boolean`\n* Default: `false`\n\nAllow patterns to match entries that begin with a period (`.`).\n\n> :book: Note that an explicit dot in a portion of the pattern will always match dot files.\n\n```js\ndir/\n├── .editorconfig\n└── package.json\n```\n\n```js\nfg.sync('*', { dot: false }); // ['package.json']\nfg.sync('*', { dot: true });  // ['.editorconfig', 'package.json']\n```\n\n#### extglob\n\n* Type: `boolean`\n* Default: `true`\n\nEnables Bash-like `extglob` functionality.\n\n> :1234: [Syntax description][micromatch_extglobs].\n\n```js\ndir/\n├── README.md\n└── package.json\n```\n\n```js\nfg.sync('*.+(json|md)', { extglob: false }); // []\nfg.sync('*.+(json|md)', { extglob: true });  // ['README.md', 'package.json']\n```\n\n#### globstar\n\n* Type: `boolean`\n* Default: `true`\n\nEnables recursively repeats a pattern containing `**`. If `false`, `**` behaves exactly like `*`.\n\n```js\ndir/\n└── a\n    └── b\n```\n\n```js\nfg.sync('**', { onlyFiles: false, globstar: false }); // ['a']\nfg.sync('**', { onlyFiles: false, globstar: true });  // ['a', 'a/b']\n```\n\n#### baseNameMatch\n\n* Type: `boolean`\n* Default: `false`\n\nIf set to `true`, then patterns without slashes will be matched against the basename of the path if it contains slashes.\n\n```js\ndir/\n└── one/\n    └── file.md\n```\n\n```js\nfg.sync('*.md', { baseNameMatch: false }); // []\nfg.sync('*.md', { baseNameMatch: true });  // ['one/file.md']\n```\n\n## FAQ\n\n## What is a static or dynamic pattern?\n\nAll patterns can be divided into two types:\n\n* **static**. A pattern is considered static if it can be used to get an entry on the file system without using matching mechanisms. For example, the `file.js` pattern is a static pattern because we can just verify that it exists on the file system.\n* **dynamic**. A pattern is considered dynamic if it cannot be used directly to find occurrences without using a matching mechanisms. For example, the `*` pattern is a dynamic pattern because we cannot use this pattern directly.\n\nA pattern is considered dynamic if it contains the following characters (`…` — any characters or their absence) or options:\n\n* The [`caseSensitiveMatch`](#casesensitivematch) option is disabled\n* `\\\\` (the escape character)\n* `*`, `?`, `!` (at the beginning of line)\n* `[…]`\n* `(…|…)`\n* `@(…)`, `!(…)`, `*(…)`, `?(…)`, `+(…)` (respects the [`extglob`](#extglob) option)\n* `{…,…}`, `{…..…}` (respects the [`braceExpansion`](#braceexpansion) option)\n\n## How to write patterns on Windows?\n\nAlways use forward-slashes in glob expressions (patterns and [`ignore`](#ignore) option). Use backslashes for escaping characters. With the [`cwd`](#cwd) option use a convenient format.\n\n**Bad**\n\n```ts\n[\n\t'directory\\\\*',\n\tpath.join(process.cwd(), '**')\n]\n```\n\n**Good**\n\n```ts\n[\n\t'directory/*',\n\tpath.join(process.cwd(), '**').replace(/\\\\/g, '/')\n]\n```\n\n> :book: Use the [`normalize-path`][npm_normalize_path] or the [`unixify`][npm_unixify] package to convert Windows-style path to a Unix-style path.\n\nRead more about [matching with backslashes][micromatch_backslashes].\n\n## Why are parentheses match wrong?\n\n```js\ndir/\n└── (special-*file).txt\n```\n\n```js\nfg.sync(['(special-*file).txt']) // []\n```\n\nRefers to Bash. You need to escape special characters:\n\n```js\nfg.sync(['\\\\(special-*file\\\\).txt']) // ['(special-*file).txt']\n```\n\nRead more about [matching special characters as literals][picomatch_matching_special_characters_as_literals].\n\n## How to exclude directory from reading?\n\nYou can use a negative pattern like this: `!**/node_modules` or `!**/node_modules/**`. Also you can use [`ignore`](#ignore) option. Just look at the example below.\n\n```js\nfirst/\n├── file.md\n└── second/\n    └── file.txt\n```\n\nIf you don't want to read the `second` directory, you must write the following pattern: `!**/second` or `!**/second/**`.\n\n```js\nfg.sync(['**/*.md', '!**/second']);                 // ['first/file.md']\nfg.sync(['**/*.md'], { ignore: ['**/second/**'] }); // ['first/file.md']\n```\n\n> :warning: When you write `!**/second/**/*` it means that the directory will be **read**, but all the entries will not be included in the results.\n\nYou have to understand that if you write the pattern to exclude directories, then the directory will not be read under any circumstances.\n\n## How to use UNC path?\n\nYou cannot use [Uniform Naming Convention (UNC)][unc_path] paths as patterns (due to syntax), but you can use them as [`cwd`](#cwd) directory.\n\n```ts\nfg.sync('*', { cwd: '\\\\\\\\?\\\\C:\\\\Python27' /* or //?/C:/Python27 */ });\nfg.sync('Python27/*', { cwd: '\\\\\\\\?\\\\C:\\\\' /* or //?/C:/ */ });\n```\n\n## Compatible with `node-glob`?\n\n| node-glob    | fast-glob |\n| :----------: | :-------: |\n| `cwd`        | [`cwd`](#cwd) |\n| `root`       | – |\n| `dot`        | [`dot`](#dot) |\n| `nomount`    | – |\n| `mark`       | [`markDirectories`](#markdirectories) |\n| `nosort`     | – |\n| `nounique`   | [`unique`](#unique) |\n| `nobrace`    | [`braceExpansion`](#braceexpansion) |\n| `noglobstar` | [`globstar`](#globstar) |\n| `noext`      | [`extglob`](#extglob) |\n| `nocase`     | [`caseSensitiveMatch`](#casesensitivematch) |\n| `matchBase`  | [`baseNameMatch`](#basenamematch) |\n| `nodir`      | [`onlyFiles`](#onlyfiles) |\n| `ignore`     | [`ignore`](#ignore) |\n| `follow`     | [`followSymbolicLinks`](#followsymboliclinks) |\n| `realpath`   | – |\n| `absolute`   | [`absolute`](#absolute) |\n\n## Benchmarks\n\n### Server\n\nLink: [Vultr Bare Metal][vultr_pricing_baremetal]\n\n* Processor: E3-1270v6 (8 CPU)\n* RAM: 32GB\n* Disk: SSD ([Intel DC S3520 SSDSC2BB240G7][intel_ssd])\n\nYou can see results [here][github_gist_benchmark_server] for latest release.\n\n### Nettop\n\nLink: [Zotac bi323][zotac_bi323]\n\n* Processor: Intel N3150 (4 CPU)\n* RAM: 8GB\n* Disk: SSD ([Silicon Power SP060GBSS3S55S25][silicon_power_ssd])\n\nYou can see results [here][github_gist_benchmark_nettop] for latest release.\n\n## Changelog\n\nSee the [Releases section of our GitHub project][github_releases] for changelog for each release version.\n\n## License\n\nThis software is released under the terms of the MIT license.\n\n[bash_hackers_syntax_expansion_brace]: https://wiki.bash-hackers.org/syntax/expansion/brace\n[github_gist_benchmark_nettop]: https://gist.github.com/mrmlnc/f06246b197f53c356895fa35355a367c#file-fg-benchmark-nettop-product-txt\n[github_gist_benchmark_server]: https://gist.github.com/mrmlnc/f06246b197f53c356895fa35355a367c#file-fg-benchmark-server-product-txt\n[github_releases]: https://github.com/mrmlnc/fast-glob/releases\n[glob_definition]: https://en.wikipedia.org/wiki/Glob_(programming)\n[glob_linux_man]: http://man7.org/linux/man-pages/man3/glob.3.html\n[intel_ssd]: https://ark.intel.com/content/www/us/en/ark/products/93012/intel-ssd-dc-s3520-series-240gb-2-5in-sata-6gb-s-3d1-mlc.html\n[micromatch_backslashes]: https://github.com/micromatch/micromatch#backslashes\n[micromatch_braces]: https://github.com/micromatch/braces\n[micromatch_extended_globbing]: https://github.com/micromatch/micromatch#extended-globbing\n[micromatch_extglobs]: https://github.com/micromatch/micromatch#extglobs\n[micromatch_regex_character_classes]: https://github.com/micromatch/micromatch#regex-character-classes\n[micromatch]: https://github.com/micromatch/micromatch\n[node_js_fs_class_fs_dirent]: https://nodejs.org/api/fs.html#fs_class_fs_dirent\n[node_js_fs_class_fs_stats]: https://nodejs.org/api/fs.html#fs_class_fs_stats\n[node_js_stream_readable_streams]: https://nodejs.org/api/stream.html#stream_readable_streams\n[node_js]: https://nodejs.org/en\n[nodelib_fs_scandir_old_and_modern_modern]: https://github.com/nodelib/nodelib/blob/master/packages/fs/fs.scandir/README.md#old-and-modern-mode\n[npm_normalize_path]: https://www.npmjs.com/package/normalize-path\n[npm_unixify]: https://www.npmjs.com/package/unixify\n[paypal_mrmlnc]:https://paypal.me/mrmlnc\n[picomatch_matching_behavior]: https://github.com/micromatch/picomatch#matching-behavior-vs-bash\n[picomatch_matching_special_characters_as_literals]: https://github.com/micromatch/picomatch#matching-special-characters-as-literals\n[picomatch_posix_brackets]: https://github.com/micromatch/picomatch#posix-brackets\n[regular_expressions_brackets]: https://www.regular-expressions.info/brackets.html\n[silicon_power_ssd]: https://www.silicon-power.com/web/product-1\n[unc_path]: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/62e862f4-2a51-452e-8eeb-dc4ff5ee33cc\n[vultr_pricing_baremetal]: https://www.vultr.com/pricing/baremetal\n[wikipedia_case_sensitivity]: https://en.wikipedia.org/wiki/Case_sensitivity\n[zotac_bi323]: https://www.zotac.com/ee/product/mini_pcs/zbox-bi323\n"}}}}