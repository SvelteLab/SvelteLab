{"directory":{"index.d.ts":{"file":{"contents":"// TypeScript Version: 3.2\n\n/// <reference types=\"node\" lib=\"esnext\" />\n\nimport * as fs from 'fs';\nimport { Readable } from 'stream';\n\ndeclare namespace readdir {\n  interface EntryInfo {\n    path: string;\n    fullPath: string;\n    basename: string;\n    stats?: fs.Stats;\n    dirent?: fs.Dirent;\n  }\n\n  interface ReaddirpOptions {\n    root?: string;\n    fileFilter?: string | string[] | ((entry: EntryInfo) => boolean);\n    directoryFilter?: string | string[] | ((entry: EntryInfo) => boolean);\n    type?: 'files' | 'directories' | 'files_directories' | 'all';\n    lstat?: boolean;\n    depth?: number;\n    alwaysStat?: boolean;\n  }\n\n  interface ReaddirpStream extends Readable, AsyncIterable<EntryInfo> {\n    read(): EntryInfo;\n    [Symbol.asyncIterator](): AsyncIterableIterator<EntryInfo>;\n  }\n\n  function promise(\n    root: string,\n    options?: ReaddirpOptions\n  ): Promise<EntryInfo[]>;\n}\n\ndeclare function readdir(\n  root: string,\n  options?: readdir.ReaddirpOptions\n): readdir.ReaddirpStream;\n\nexport = readdir;\n"}},"index.js":{"file":{"contents":"'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n"}},"LICENSE":{"file":{"contents":"MIT License\n\nCopyright (c) 2012-2019 Thorsten Lorenz, Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"readdirp\",\n  \"description\": \"Recursive version of fs.readdir with streaming API.\",\n  \"version\": \"3.6.0\",\n  \"homepage\": \"https://github.com/paulmillr/readdirp\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/paulmillr/readdirp.git\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/paulmillr/readdirp/issues\"\n  },\n  \"author\": \"Thorsten Lorenz <thlorenz@gmx.de> (thlorenz.com)\",\n  \"contributors\": [\n    \"Thorsten Lorenz <thlorenz@gmx.de> (thlorenz.com)\",\n    \"Paul Miller (https://paulmillr.com)\"\n  ],\n  \"main\": \"index.js\",\n  \"engines\": {\n    \"node\": \">=8.10.0\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\"\n  ],\n  \"keywords\": [\n    \"recursive\",\n    \"fs\",\n    \"stream\",\n    \"streams\",\n    \"readdir\",\n    \"filesystem\",\n    \"find\",\n    \"filter\"\n  ],\n  \"scripts\": {\n    \"dtslint\": \"dtslint\",\n    \"nyc\": \"nyc\",\n    \"mocha\": \"mocha --exit\",\n    \"lint\": \"eslint --report-unused-disable-directives --ignore-path .gitignore .\",\n    \"test\": \"npm run lint && nyc npm run mocha\"\n  },\n  \"dependencies\": {\n    \"picomatch\": \"^2.2.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^14\",\n    \"chai\": \"^4.2\",\n    \"chai-subset\": \"^1.6\",\n    \"dtslint\": \"^3.3.0\",\n    \"eslint\": \"^7.0.0\",\n    \"mocha\": \"^7.1.1\",\n    \"nyc\": \"^15.0.0\",\n    \"rimraf\": \"^3.0.0\",\n    \"typescript\": \"^4.0.3\"\n  },\n  \"nyc\": {\n    \"reporter\": [\n      \"html\",\n      \"text\"\n    ]\n  },\n  \"eslintConfig\": {\n    \"root\": true,\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n      \"ecmaVersion\": 9,\n      \"sourceType\": \"script\"\n    },\n    \"env\": {\n      \"node\": true,\n      \"es6\": true\n    },\n    \"rules\": {\n      \"array-callback-return\": \"error\",\n      \"no-empty\": [\n        \"error\",\n        {\n          \"allowEmptyCatch\": true\n        }\n      ],\n      \"no-else-return\": [\n        \"error\",\n        {\n          \"allowElseIf\": false\n        }\n      ],\n      \"no-lonely-if\": \"error\",\n      \"no-var\": \"error\",\n      \"object-shorthand\": \"error\",\n      \"prefer-arrow-callback\": [\n        \"error\",\n        {\n          \"allowNamedFunctions\": true\n        }\n      ],\n      \"prefer-const\": [\n        \"error\",\n        {\n          \"ignoreReadBeforeAssign\": true\n        }\n      ],\n      \"prefer-destructuring\": [\n        \"error\",\n        {\n          \"object\": true,\n          \"array\": false\n        }\n      ],\n      \"prefer-spread\": \"error\",\n      \"prefer-template\": \"error\",\n      \"radix\": \"error\",\n      \"semi\": \"error\",\n      \"strict\": \"error\",\n      \"quotes\": [\n        \"error\",\n        \"single\"\n      ]\n    }\n  }\n}\n"}},"README.md":{"file":{"contents":"# readdirp [![Weekly downloads](https://img.shields.io/npm/dw/readdirp.svg)](https://github.com/paulmillr/readdirp)\n\nRecursive version of [fs.readdir](https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback). Exposes a **stream API** and a **promise API**.\n\n\n```sh\nnpm install readdirp\n```\n\n```javascript\nconst readdirp = require('readdirp');\n\n// Use streams to achieve small RAM & CPU footprint.\n// 1) Streams example with for-await.\nfor await (const entry of readdirp('.')) {\n  const {path} = entry;\n  console.log(`${JSON.stringify({path})}`);\n}\n\n// 2) Streams example, non for-await.\n// Print out all JS files along with their size within the current folder & subfolders.\nreaddirp('.', {fileFilter: '*.js', alwaysStat: true})\n  .on('data', (entry) => {\n    const {path, stats: {size}} = entry;\n    console.log(`${JSON.stringify({path, size})}`);\n  })\n  // Optionally call stream.destroy() in `warn()` in order to abort and cause 'close' to be emitted\n  .on('warn', error => console.error('non-fatal error', error))\n  .on('error', error => console.error('fatal error', error))\n  .on('end', () => console.log('done'));\n\n// 3) Promise example. More RAM and CPU than streams / for-await.\nconst files = await readdirp.promise('.');\nconsole.log(files.map(file => file.path));\n\n// Other options.\nreaddirp('test', {\n  fileFilter: '*.js',\n  directoryFilter: ['!.git', '!*modules']\n  // directoryFilter: (di) => di.basename.length === 9\n  type: 'files_directories',\n  depth: 1\n});\n```\n\nFor more examples, check out `examples` directory.\n\n## API\n\n`const stream = readdirp(root[, options])` — **Stream API**\n\n- Reads given root recursively and returns a `stream` of [entry infos](#entryinfo)\n- Optionally can be used like `for await (const entry of stream)` with node.js 10+ (`asyncIterator`).\n- `on('data', (entry) => {})` [entry info](#entryinfo) for every file / dir.\n- `on('warn', (error) => {})` non-fatal `Error` that prevents a file / dir from being processed. Example: inaccessible to the user.\n- `on('error', (error) => {})` fatal `Error` which also ends the stream. Example: illegal options where passed.\n- `on('end')` — we are done. Called when all entries were found and no more will be emitted.\n- `on('close')` — stream is destroyed via `stream.destroy()`.\n  Could be useful if you want to manually abort even on a non fatal error.\n  At that point the stream is no longer `readable` and no more entries, warning or errors are emitted\n- To learn more about streams, consult the very detailed [nodejs streams documentation](https://nodejs.org/api/stream.html)\n  or the [stream-handbook](https://github.com/substack/stream-handbook)\n\n`const entries = await readdirp.promise(root[, options])` — **Promise API**. Returns a list of [entry infos](#entryinfo).\n\nFirst argument is awalys `root`, path in which to start reading and recursing into subdirectories.\n\n### options\n\n- `fileFilter: [\"*.js\"]`: filter to include or exclude files. A `Function`, Glob string or Array of glob strings.\n    - **Function**: a function that takes an entry info as a parameter and returns true to include or false to exclude the entry\n    - **Glob string**: a string (e.g., `*.js`) which is matched using [picomatch](https://github.com/micromatch/picomatch), so go there for more\n        information. Globstars (`**`) are not supported since specifying a recursive pattern for an already recursive function doesn't make sense. Negated globs (as explained in the minimatch documentation) are allowed, e.g., `!*.txt` matches everything but text files.\n    - **Array of glob strings**: either need to be all inclusive or all exclusive (negated) patterns otherwise an error is thrown.\n        `['*.json', '*.js']` includes all JavaScript and Json files.\n        `['!.git', '!node_modules']` includes all directories except the '.git' and 'node_modules'.\n    - Directories that do not pass a filter will not be recursed into.\n- `directoryFilter: ['!.git']`: filter to include/exclude directories found and to recurse into. Directories that do not pass a filter will not be recursed into.\n- `depth: 5`: depth at which to stop recursing even if more subdirectories are found\n- `type: 'files'`: determines if data events on the stream should be emitted for `'files'` (default), `'directories'`, `'files_directories'`, or `'all'`. Setting to `'all'` will also include entries for other types of file descriptors like character devices, unix sockets and named pipes.\n- `alwaysStat: false`: always return `stats` property for every file. Default is `false`, readdirp will return `Dirent` entries. Setting it to `true` can double readdir execution time - use it only when you need file `size`, `mtime` etc. Cannot be enabled on node <10.10.0.\n- `lstat: false`: include symlink entries in the stream along with files. When `true`, `fs.lstat` would be used instead of `fs.stat`\n\n### `EntryInfo`\n\nHas the following properties:\n\n- `path: 'assets/javascripts/react.js'`: path to the file/directory (relative to given root)\n- `fullPath: '/Users/dev/projects/app/assets/javascripts/react.js'`: full path to the file/directory found\n- `basename: 'react.js'`: name of the file/directory\n- `dirent: fs.Dirent`: built-in [dir entry object](https://nodejs.org/api/fs.html#fs_class_fs_dirent) - only with `alwaysStat: false`\n- `stats: fs.Stats`: built in [stat object](https://nodejs.org/api/fs.html#fs_class_fs_stats) - only with `alwaysStat: true`\n\n## Changelog\n\n- 3.5 (Oct 13, 2020) disallows recursive directory-based symlinks.\n  Before, it could have entered infinite loop.\n- 3.4 (Mar 19, 2020) adds support for directory-based symlinks.\n- 3.3 (Dec 6, 2019) stabilizes RAM consumption and enables perf management with `highWaterMark` option. Fixes race conditions related to `for-await` looping.\n- 3.2 (Oct 14, 2019) improves performance by 250% and makes streams implementation more idiomatic.\n- 3.1 (Jul 7, 2019) brings `bigint` support to `stat` output on Windows. This is backwards-incompatible for some cases. Be careful. It you use it incorrectly, you'll see \"TypeError: Cannot mix BigInt and other types, use explicit conversions\".\n- 3.0 brings huge performance improvements and stream backpressure support.\n- Upgrading 2.x to 3.x:\n    - Signature changed from `readdirp(options)` to `readdirp(root, options)`\n    - Replaced callback API with promise API.\n    - Renamed `entryType` option to `type`\n    - Renamed `entryType: 'both'` to `'files_directories'`\n    - `EntryInfo`\n        - Renamed `stat` to `stats`\n            - Emitted only when `alwaysStat: true`\n            - `dirent` is emitted instead of `stats` by default with `alwaysStat: false`\n        - Renamed `name` to `basename`\n        - Removed `parentDir` and `fullParentDir` properties\n- Supported node.js versions:\n    - 3.x: node 8+\n    - 2.x: node 0.6+\n\n## License\n\nCopyright (c) 2012-2019 Thorsten Lorenz, Paul Miller (<https://paulmillr.com>)\n\nMIT License, see [LICENSE](LICENSE) file.\n"}}}}