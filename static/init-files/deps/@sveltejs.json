{"directory":{"adapter-auto":{"directory":{"adapters.js":{"file":{"contents":"// List of adapters to check for. `version` is used to pin the installed adapter version and should point\n// to the latest version of the adapter that is compatible with adapter-auto's current peerDependency version of SvelteKit.\nexport const adapters = [\n\t{\n\t\tname: 'Vercel',\n\t\ttest: () => !!process.env.VERCEL,\n\t\tmodule: '@sveltejs/adapter-vercel',\n\t\tversion: '2'\n\t},\n\t{\n\t\tname: 'Cloudflare Pages',\n\t\ttest: () => !!process.env.CF_PAGES,\n\t\tmodule: '@sveltejs/adapter-cloudflare',\n\t\tversion: '2'\n\t},\n\t{\n\t\tname: 'Netlify',\n\t\ttest: () => !!process.env.NETLIFY,\n\t\tmodule: '@sveltejs/adapter-netlify',\n\t\tversion: '2'\n\t},\n\t{\n\t\tname: 'Azure Static Web Apps',\n\t\ttest: () => process.env.GITHUB_ACTION_REPOSITORY === 'Azure/static-web-apps-deploy',\n\t\tmodule: 'svelte-adapter-azure-swa',\n\t\tversion: '0.13'\n\t}\n];\n"}},"index.d.ts":{"file":{"contents":"import { Adapter } from '@sveltejs/kit';\n\nexport default function plugin(): Adapter;\n"}},"index.js":{"file":{"contents":"import { execSync } from 'child_process';\nimport { pathToFileURL } from 'url';\nimport { resolve } from 'import-meta-resolve';\nimport { adapters } from './adapters.js';\nimport { dirname, join } from 'path';\nimport { existsSync } from 'fs';\n\n/** @type {Record<string, (name: string, version: string) => string>} */\nconst commands = {\n\tnpm: (name, version) => `npm install -D ${name}@${version}`,\n\tpnpm: (name, version) => `pnpm add -D ${name}@${version}`,\n\tyarn: (name, version) => `yarn add -D ${name}@${version}`\n};\n\nfunction detect_lockfile() {\n\tlet dir = process.cwd();\n\n\tdo {\n\t\tif (existsSync(join(dir, 'pnpm-lock.yaml'))) return 'pnpm';\n\t\tif (existsSync(join(dir, 'yarn.lock'))) return 'yarn';\n\t\tif (existsSync(join(dir, 'package-lock.json'))) return 'npm';\n\t} while (dir !== (dir = dirname(dir)));\n\n\treturn 'npm';\n}\n\nfunction detect_package_manager() {\n\tconst manager = detect_lockfile();\n\n\ttry {\n\t\texecSync(`${manager} --version`);\n\t\treturn manager;\n\t} catch {\n\t\treturn 'npm';\n\t}\n}\n\n/** @param {string} name */\nasync function import_from_cwd(name) {\n\tconst cwd = pathToFileURL(process.cwd()).href;\n\tconst url = await resolve(name, cwd + '/x.js');\n\n\treturn import(url);\n}\n\n/** @typedef {import('@sveltejs/kit').Adapter} Adapter */\n\n/**\n * @returns {Promise<Adapter | undefined>} The corresponding adapter for the current environment if found otherwise undefined\n */\nasync function get_adapter() {\n\tconst match = adapters.find((candidate) => candidate.test());\n\n\tif (!match) return;\n\n\t/** @type {{ default: () => Adapter }} */\n\tlet module;\n\n\ttry {\n\t\tmodule = await import_from_cwd(match.module);\n\t} catch (error) {\n\t\tif (\n\t\t\terror.code === 'ERR_MODULE_NOT_FOUND' &&\n\t\t\terror.message.startsWith(`Cannot find package '${match.module}'`)\n\t\t) {\n\t\t\tconst package_manager = detect_package_manager();\n\t\t\tconst command = commands[package_manager](match.module, match.version);\n\n\t\t\ttry {\n\t\t\t\tconsole.log(`Installing ${match.module}...`);\n\n\t\t\t\texecSync(command, {\n\t\t\t\t\tstdio: 'inherit',\n\t\t\t\t\tenv: {\n\t\t\t\t\t\t...process.env,\n\t\t\t\t\t\tNODE_ENV: undefined\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmodule = await import_from_cwd(match.module);\n\n\t\t\t\tconsole.log(`Successfully installed ${match.module}.`);\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`\\nIf you plan on staying on this deployment platform, consider replacing @sveltejs/adapter-auto with ${match.module}. This will give you faster and more robust installs, and more control over deployment configuration.\\n`\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Could not install ${match.module}. Please install it yourself by adding it to your package.json's devDependencies and try building your project again.`,\n\t\t\t\t\t{ cause: e }\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tconst adapter = module.default();\n\n\treturn {\n\t\t...adapter,\n\t\tadapt: (builder) => {\n\t\t\tbuilder.log.info(`Detected environment: ${match.name}. Using ${match.module}`);\n\t\t\treturn adapter.adapt(builder);\n\t\t}\n\t};\n}\n\n/** @type {() => Adapter} */\nexport default () => ({\n\tname: '@sveltejs/adapter-auto',\n\tadapt: async (builder) => {\n\t\tconst adapter = await get_adapter();\n\n\t\tif (adapter) return adapter.adapt(builder);\n\n\t\tbuilder.log.warn(\n\t\t\t'Could not detect a supported production environment. See https://kit.svelte.dev/docs/adapters to learn how to configure your app to run on the platform of your choosing'\n\t\t);\n\t}\n});\n"}},"LICENSE":{"file":{"contents":"Copyright (c) 2020 [these people](https://github.com/sveltejs/kit/graphs/contributors)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."}},"package.json":{"file":{"contents":"{\n  \"name\": \"@sveltejs/adapter-auto\",\n  \"version\": \"2.0.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sveltejs/kit\",\n    \"directory\": \"packages/adapter-auto\"\n  },\n  \"license\": \"MIT\",\n  \"homepage\": \"https://kit.svelte.dev\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"import\": \"./index.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"types\": \"index.d.ts\",\n  \"files\": [\n    \"files\",\n    \"index.js\",\n    \"index.d.ts\",\n    \"adapters.js\"\n  ],\n  \"devDependencies\": {\n    \"@types/node\": \"^16.18.6\",\n    \"typescript\": \"^4.9.4\",\n    \"@sveltejs/kit\": \"^1.5.0\"\n  },\n  \"dependencies\": {\n    \"import-meta-resolve\": \"^2.2.0\"\n  },\n  \"peerDependencies\": {\n    \"@sveltejs/kit\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"lint\": \"prettier --check . --config ../../.prettierrc --ignore-path .gitignore\",\n    \"format\": \"pnpm lint --write\",\n    \"check\": \"tsc\"\n  }\n}"}},"README.md":{"file":{"contents":"# adapter-auto\n\nAutomatically chooses the SvelteKit adapter for your current environment, if possible.\n\n## Docs\n\n[Docs](https://kit.svelte.dev/docs/adapter-auto)\n\n## Changelog\n\n[The Changelog for this package is available on GitHub](https://github.com/sveltejs/kit/blob/master/packages/adapter-auto/CHANGELOG.md).\n"}}}},"kit":{"directory":{"LICENSE":{"file":{"contents":"Copyright (c) 2020 [these people](https://github.com/sveltejs/kit/graphs/contributors)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."}},"package.json":{"file":{"contents":"{\n  \"name\": \"@sveltejs/kit\",\n  \"version\": \"1.10.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sveltejs/kit\",\n    \"directory\": \"packages/kit\"\n  },\n  \"license\": \"MIT\",\n  \"homepage\": \"https://kit.svelte.dev\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@sveltejs/vite-plugin-svelte\": \"^2.0.0\",\n    \"@types/cookie\": \"^0.5.1\",\n    \"cookie\": \"^0.5.0\",\n    \"devalue\": \"^4.3.0\",\n    \"esm-env\": \"^1.0.0\",\n    \"kleur\": \"^4.1.5\",\n    \"magic-string\": \"^0.30.0\",\n    \"mime\": \"^3.0.0\",\n    \"sade\": \"^1.8.1\",\n    \"set-cookie-parser\": \"^2.5.1\",\n    \"sirv\": \"^2.0.2\",\n    \"tiny-glob\": \"^0.2.9\",\n    \"undici\": \"5.20.0\"\n  },\n  \"devDependencies\": {\n    \"@playwright/test\": \"^1.29.2\",\n    \"@types/connect\": \"^3.4.35\",\n    \"@types/marked\": \"^4.0.7\",\n    \"@types/mime\": \"^3.0.1\",\n    \"@types/node\": \"^16.18.6\",\n    \"@types/sade\": \"^1.7.4\",\n    \"@types/set-cookie-parser\": \"^2.4.2\",\n    \"marked\": \"^4.2.3\",\n    \"rollup\": \"^3.7.0\",\n    \"svelte\": \"^3.55.1\",\n    \"svelte-preprocess\": \"^5.0.0\",\n    \"typescript\": \"^4.9.4\",\n    \"uvu\": \"^0.5.6\",\n    \"vite\": \"^4.1.1\"\n  },\n  \"peerDependencies\": {\n    \"svelte\": \"^3.54.0\",\n    \"vite\": \"^4.0.0\"\n  },\n  \"bin\": {\n    \"svelte-kit\": \"svelte-kit.js\"\n  },\n  \"files\": [\n    \"src\",\n    \"!src/**/*.spec.js\",\n    \"!src/core/**/fixtures\",\n    \"!src/core/**/test\",\n    \"types\",\n    \"svelte-kit.js\",\n    \"postinstall.js\"\n  ],\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": {\n      \"types\": \"./types/index.d.ts\",\n      \"import\": \"./src/exports/index.js\"\n    },\n    \"./node\": {\n      \"import\": \"./src/exports/node/index.js\"\n    },\n    \"./node/polyfills\": {\n      \"import\": \"./src/exports/node/polyfills.js\"\n    },\n    \"./hooks\": {\n      \"import\": \"./src/exports/hooks/index.js\"\n    },\n    \"./vite\": {\n      \"import\": \"./src/exports/vite/index.js\"\n    }\n  },\n  \"types\": \"types/index.d.ts\",\n  \"engines\": {\n    \"node\": \"^16.14 || >=18\"\n  },\n  \"scripts\": {\n    \"lint\": \"prettier --check . --config ../../.prettierrc --ignore-path .gitignore\",\n    \"check\": \"tsc\",\n    \"check:all\": \"tsc && pnpm -r --filter=\\\"./**\\\" check\",\n    \"format\": \"prettier --write . --config ../../.prettierrc --ignore-path .gitignore\",\n    \"test\": \"pnpm test:unit && pnpm test:integration\",\n    \"test:integration\": \"pnpm -r --workspace-concurrency 1 --filter=\\\"./test/**\\\" test\",\n    \"test:cross-platform:dev\": \"pnpm -r --workspace-concurrency 1 --filter=\\\"./test/**\\\" test:cross-platform:dev\",\n    \"test:cross-platform:build\": \"pnpm test:unit && pnpm -r --workspace-concurrency 1 --filter=\\\"./test/**\\\" test:cross-platform:build\",\n    \"test:unit\": \"uvu src \\\"(spec\\\\.js|test[\\\\\\\\/]index\\\\.js)\\\"\",\n    \"postinstall\": \"node postinstall.js\"\n  }\n}"}},"postinstall.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport glob from 'tiny-glob/sync.js';\nimport { load_config } from './src/core/config/index.js';\nimport * as sync from './src/core/sync/sync.js';\n\ntry {\n\tconst cwd = process.env.INIT_CWD ?? process.cwd();\n\tprocess.chdir(cwd);\n\n\tif (fs.existsSync('package.json')) {\n\t\tconst pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));\n\n\t\tconst directories = [];\n\n\t\tif (pkg.workspaces) {\n\t\t\t// we have to do this because of https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\n\t\t\tconst packages = Array.isArray(pkg.workspaces) ? pkg.workspaces : pkg.workspaces.packages;\n\n\t\t\tfor (const directory of packages) {\n\t\t\t\tdirectories.push(...glob(directory, { cwd }).map((dir) => path.resolve(cwd, dir)));\n\t\t\t}\n\t\t} else {\n\t\t\tdirectories.push(cwd);\n\t\t}\n\n\t\tfor (const cwd of directories) {\n\t\t\tprocess.chdir(cwd);\n\n\t\t\tif (!fs.existsSync('package.json')) continue;\n\t\t\tif (!fs.existsSync('svelte.config.js')) continue;\n\n\t\t\tconst pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));\n\t\t\tif (!pkg.dependencies?.['@sveltejs/kit'] && !pkg.devDependencies?.['@sveltejs/kit']) continue;\n\n\t\t\ttry {\n\t\t\t\tconst config = await load_config();\n\t\t\t\tawait sync.all(config, 'development');\n\t\t\t} catch (error) {\n\t\t\t\tconsole.log('Error while trying to sync SvelteKit config');\n\t\t\t\tconsole.log(error.stack);\n\t\t\t}\n\t\t}\n\t}\n} catch (error) {\n\tconsole.error(error.stack);\n}\n"}},"README.md":{"file":{"contents":"# The fastest way to build Svelte apps\n\nThis is the [SvelteKit](https://kit.svelte.dev) framework and CLI.\n\nThe quickest way to get started is via the [create-svelte](https://github.com/sveltejs/kit/tree/master/packages/create-svelte) package:\n\n```bash\nnpm create svelte@latest my-app\ncd my-app\nnpm install\nnpm run dev\n```\n\nSee the [documentation](https://kit.svelte.dev/docs) to learn more.\n\n## Changelog\n\n[The Changelog for this package is available on GitHub](https://github.com/sveltejs/kit/blob/master/packages/kit/CHANGELOG.md).\n"}},"src":{"directory":{"cli.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport colors from 'kleur';\nimport sade from 'sade';\nimport { load_config } from './core/config/index.js';\nimport { coalesce_to_error } from './utils/error.js';\n\n/** @param {unknown} e */\nfunction handle_error(e) {\n\tconst error = coalesce_to_error(e);\n\n\tif (error.name === 'SyntaxError') throw error;\n\n\tconsole.error(colors.bold().red(`> ${error.message}`));\n\tif (error.stack) {\n\t\tconsole.error(colors.gray(error.stack.split('\\n').slice(1).join('\\n')));\n\t}\n\n\tprocess.exit(1);\n}\n\nconst pkg = JSON.parse(fs.readFileSync(new URL('../package.json', import.meta.url), 'utf-8'));\nconst prog = sade('svelte-kit').version(pkg.version);\n\nprog\n\t.command('sync')\n\t.describe('Synchronise generated type definitions')\n\t.option('--mode', 'Specify a mode for loading environment variables', 'development')\n\t.action(async ({ mode }) => {\n\t\tif (!fs.existsSync('svelte.config.js')) {\n\t\t\tconsole.warn(`Missing ${path.resolve('svelte.config.js')} — skipping`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst config = await load_config();\n\t\t\tconst sync = await import('./core/sync/sync.js');\n\t\t\tawait sync.all_types(config, mode);\n\t\t} catch (error) {\n\t\t\thandle_error(error);\n\t\t}\n\t});\n\nprog.parse(process.argv, { unknown: (arg) => `Unknown option: ${arg}` });\n"}},"constants.js":{"file":{"contents":"/**\n * A fake asset path used in `vite dev` and `vite preview`, so that we can\n * serve local assets while verifying that requests are correctly prefixed\n */\nexport const SVELTE_KIT_ASSETS = '/_svelte_kit_assets';\n\nexport const GENERATED_COMMENT = '// this file is generated — do not edit it\\n';\n"}},"core":{"directory":{"adapt":{"directory":{"builder.js":{"file":{"contents":"import { existsSync, statSync, createReadStream, createWriteStream } from 'node:fs';\nimport { join } from 'node:path/posix';\nimport { pipeline } from 'node:stream';\nimport { promisify } from 'node:util';\nimport zlib from 'node:zlib';\nimport glob from 'tiny-glob';\nimport { copy, rimraf, mkdirp } from '../../utils/filesystem.js';\nimport { generate_manifest } from '../generate_manifest/index.js';\nimport { get_route_segments } from '../../utils/routing.js';\nimport { get_env } from '../../exports/vite/utils.js';\nimport generate_fallback from '../postbuild/fallback.js';\nimport { write } from '../sync/utils.js';\n\nconst pipe = promisify(pipeline);\n\n/**\n * Creates the Builder which is passed to adapters for building the application.\n * @param {{\n *   config: import('types').ValidatedConfig;\n *   build_data: import('types').BuildData;\n *   server_metadata: import('types').ServerMetadata;\n *   route_data: import('types').RouteData[];\n *   prerendered: import('types').Prerendered;\n *   prerender_map: import('types').PrerenderMap;\n *   log: import('types').Logger;\n * }} opts\n * @returns {import('types').Builder}\n */\nexport function create_builder({\n\tconfig,\n\tbuild_data,\n\tserver_metadata,\n\troute_data,\n\tprerendered,\n\tprerender_map,\n\tlog\n}) {\n\t/** @type {Map<import('types').RouteDefinition, import('types').RouteData>} */\n\tconst lookup = new Map();\n\n\t/**\n\t * Rather than exposing the internal `RouteData` type, which is subject to change,\n\t * we expose a stable type that adapters can use to group/filter routes\n\t */\n\tconst routes = route_data.map((route) => {\n\t\tconst { config, methods, page, api } = /** @type {import('types').ServerMetadataRoute} */ (\n\t\t\tserver_metadata.routes.get(route.id)\n\t\t);\n\n\t\t/** @type {import('types').RouteDefinition} */\n\t\tconst facade = {\n\t\t\tid: route.id,\n\t\t\tapi,\n\t\t\tpage,\n\t\t\tsegments: get_route_segments(route.id).map((segment) => ({\n\t\t\t\tdynamic: segment.includes('['),\n\t\t\t\trest: segment.includes('[...'),\n\t\t\t\tcontent: segment\n\t\t\t})),\n\t\t\tpattern: route.pattern,\n\t\t\tprerender: prerender_map.get(route.id) ?? false,\n\t\t\tmethods,\n\t\t\tconfig\n\t\t};\n\n\t\tlookup.set(facade, route);\n\n\t\treturn facade;\n\t});\n\n\treturn {\n\t\tlog,\n\t\trimraf,\n\t\tmkdirp,\n\t\tcopy,\n\n\t\tconfig,\n\t\tprerendered,\n\t\troutes,\n\n\t\tasync compress(directory) {\n\t\t\tif (!existsSync(directory)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst files = await glob('**/*.{html,js,mjs,json,css,svg,xml,wasm}', {\n\t\t\t\tcwd: directory,\n\t\t\t\tdot: true,\n\t\t\t\tabsolute: true,\n\t\t\t\tfilesOnly: true\n\t\t\t});\n\n\t\t\tawait Promise.all(\n\t\t\t\tfiles.map((file) => Promise.all([compress_file(file, 'gz'), compress_file(file, 'br')]))\n\t\t\t);\n\t\t},\n\n\t\tasync createEntries(fn) {\n\t\t\tconst seen = new Set();\n\n\t\t\tfor (let i = 0; i < route_data.length; i += 1) {\n\t\t\t\tconst route = route_data[i];\n\t\t\t\tif (prerender_map.get(route.id) === true) continue;\n\t\t\t\tconst { id, filter, complete } = fn(routes[i]);\n\n\t\t\t\tif (seen.has(id)) continue;\n\t\t\t\tseen.add(id);\n\n\t\t\t\tconst group = [route];\n\n\t\t\t\t// figure out which lower priority routes should be considered fallbacks\n\t\t\t\tfor (let j = i + 1; j < route_data.length; j += 1) {\n\t\t\t\t\tif (prerender_map.get(routes[j].id) === true) continue;\n\t\t\t\t\tif (filter(routes[j])) {\n\t\t\t\t\t\tgroup.push(route_data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst filtered = new Set(group);\n\n\t\t\t\t// heuristic: if /foo/[bar] is included, /foo/[bar].json should\n\t\t\t\t// also be included, since the page likely needs the endpoint\n\t\t\t\t// TODO is this still necessary, given the new way of doing things?\n\t\t\t\tfiltered.forEach((route) => {\n\t\t\t\t\tif (route.page) {\n\t\t\t\t\t\tconst endpoint = route_data.find((candidate) => candidate.id === route.id + '.json');\n\n\t\t\t\t\t\tif (endpoint) {\n\t\t\t\t\t\t\tfiltered.add(endpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (filtered.size > 0) {\n\t\t\t\t\tawait complete({\n\t\t\t\t\t\tgenerateManifest: ({ relativePath }) =>\n\t\t\t\t\t\t\tgenerate_manifest({\n\t\t\t\t\t\t\t\tbuild_data,\n\t\t\t\t\t\t\t\trelative_path: relativePath,\n\t\t\t\t\t\t\t\troutes: Array.from(filtered)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tasync generateFallback(dest) {\n\t\t\tconst manifest_path = `${config.kit.outDir}/output/server/manifest-full.js`;\n\t\t\tconst env = get_env(config.kit.env, 'production');\n\n\t\t\tconst fallback = await generate_fallback({\n\t\t\t\tmanifest_path,\n\t\t\t\tenv: { ...env.private, ...env.public }\n\t\t\t});\n\n\t\t\twrite(dest, fallback);\n\t\t},\n\n\t\tgenerateManifest: ({ relativePath, routes: subset }) => {\n\t\t\treturn generate_manifest({\n\t\t\t\tbuild_data,\n\t\t\t\trelative_path: relativePath,\n\t\t\t\troutes: subset\n\t\t\t\t\t? subset.map((route) => /** @type {import('types').RouteData} */ (lookup.get(route)))\n\t\t\t\t\t: route_data\n\t\t\t});\n\t\t},\n\n\t\tgetBuildDirectory(name) {\n\t\t\treturn `${config.kit.outDir}/${name}`;\n\t\t},\n\n\t\tgetClientDirectory() {\n\t\t\treturn `${config.kit.outDir}/output/client`;\n\t\t},\n\n\t\tgetServerDirectory() {\n\t\t\treturn `${config.kit.outDir}/output/server`;\n\t\t},\n\n\t\tgetAppPath() {\n\t\t\treturn build_data.app_path;\n\t\t},\n\n\t\twriteClient(dest) {\n\t\t\tconst server_assets = copy(\n\t\t\t\t`${config.kit.outDir}/output/server/${config.kit.appDir}/immutable/assets`,\n\t\t\t\tjoin(dest, config.kit.appDir, 'immutable/assets')\n\t\t\t).map((filename) => join(config.kit.appDir, 'immutable/assets', filename));\n\t\t\tconst client_assets = copy(`${config.kit.outDir}/output/client`, dest);\n\t\t\treturn Array.from(new Set([...server_assets, ...client_assets]));\n\t\t},\n\n\t\t// @ts-expect-error\n\t\twritePrerendered(dest, opts) {\n\t\t\t// TODO remove for 1.0\n\t\t\tif (opts?.fallback) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The fallback option no longer exists — use builder.generateFallback(fallback) instead'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst source = `${config.kit.outDir}/output/prerendered`;\n\t\t\treturn [...copy(`${source}/pages`, dest), ...copy(`${source}/dependencies`, dest)];\n\t\t},\n\n\t\twriteServer(dest) {\n\t\t\treturn copy(`${config.kit.outDir}/output/server`, dest);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} file\n * @param {'gz' | 'br'} format\n */\nasync function compress_file(file, format = 'gz') {\n\tconst compress =\n\t\tformat == 'br'\n\t\t\t? zlib.createBrotliCompress({\n\t\t\t\t\tparams: {\n\t\t\t\t\t\t[zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT,\n\t\t\t\t\t\t[zlib.constants.BROTLI_PARAM_QUALITY]: zlib.constants.BROTLI_MAX_QUALITY,\n\t\t\t\t\t\t[zlib.constants.BROTLI_PARAM_SIZE_HINT]: statSync(file).size\n\t\t\t\t\t}\n\t\t\t  })\n\t\t\t: zlib.createGzip({ level: zlib.constants.Z_BEST_COMPRESSION });\n\n\tconst source = createReadStream(file);\n\tconst destination = createWriteStream(`${file}.${format}`);\n\n\tawait pipe(source, compress, destination);\n}\n"}},"index.js":{"file":{"contents":"import colors from 'kleur';\nimport { create_builder } from './builder.js';\n\n/**\n * @param {import('types').ValidatedConfig} config\n * @param {import('types').BuildData} build_data\n * @param {import('types').ServerMetadata} server_metadata\n * @param {import('types').Prerendered} prerendered\n * @param {import('types').PrerenderMap} prerender_map\n * @param {import('types').Logger} log\n */\nexport async function adapt(config, build_data, server_metadata, prerendered, prerender_map, log) {\n\tconst { name, adapt } = config.kit.adapter;\n\n\tconsole.log(colors.bold().cyan(`\\n> Using ${name}`));\n\n\tconst builder = create_builder({\n\t\tconfig,\n\t\tbuild_data,\n\t\tserver_metadata,\n\t\troute_data: build_data.manifest_data.routes.filter((route) => route.page || route.endpoint),\n\t\tprerendered,\n\t\tprerender_map,\n\t\tlog\n\t});\n\tawait adapt(builder);\n\n\tlog.success('done');\n}\n"}}}},"config":{"directory":{"default-error.html":{"file":{"contents":"<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title>%sveltekit.error.message%</title>\n\n\t\t<style>\n\t\t\tbody {\n\t\t\t\tfont-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,\n\t\t\t\t\tUbuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tjustify-content: center;\n\t\t\t\theight: 100vh;\n\t\t\t}\n\n\t\t\t.error {\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tmax-width: 32rem;\n\t\t\t\tmargin: 0 1rem;\n\t\t\t}\n\n\t\t\t.status {\n\t\t\t\tfont-weight: 200;\n\t\t\t\tfont-size: 3rem;\n\t\t\t\tline-height: 1;\n\t\t\t\tposition: relative;\n\t\t\t\ttop: -0.05rem;\n\t\t\t}\n\n\t\t\t.message {\n\t\t\t\tborder-left: 1px solid #ccc;\n\t\t\t\tpadding: 0 0 0 1rem;\n\t\t\t\tmargin: 0 0 0 1rem;\n\t\t\t\tmin-height: 2.5rem;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t}\n\n\t\t\t.message h1 {\n\t\t\t\tfont-weight: 400;\n\t\t\t\tfont-size: 1em;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"error\">\n\t\t\t<span class=\"status\">%sveltekit.status%</span>\n\t\t\t<div class=\"message\">\n\t\t\t\t<h1>%sveltekit.error.message%</h1>\n\t\t\t</div>\n\t\t</div>\n\t</body>\n</html>\n"}},"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport * as url from 'node:url';\nimport options from './options.js';\n\n/**\n * Loads the template (src/app.html by default) and validates that it has the\n * required content.\n * @param {string} cwd\n * @param {import('types').ValidatedConfig} config\n */\nexport function load_template(cwd, { kit }) {\n\tconst { env, files } = kit;\n\n\tconst relative = path.relative(cwd, files.appTemplate);\n\n\tif (!fs.existsSync(files.appTemplate)) {\n\t\tthrow new Error(`${relative} does not exist`);\n\t}\n\n\tconst contents = fs.readFileSync(files.appTemplate, 'utf8');\n\n\tconst expected_tags = ['%sveltekit.head%', '%sveltekit.body%'];\n\texpected_tags.forEach((tag) => {\n\t\tif (contents.indexOf(tag) === -1) {\n\t\t\tthrow new Error(`${relative} is missing ${tag}`);\n\t\t}\n\t});\n\n\tfor (const match of contents.matchAll(/%sveltekit\\.env\\.([^%]+)%/g)) {\n\t\tif (!match[1].startsWith(env.publicPrefix)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Environment variables in ${relative} must start with ${env.publicPrefix} (saw %sveltekit.env.${match[1]}%)`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn contents;\n}\n\n/**\n * Loads the error page (src/error.html by default) if it exists.\n * Falls back to a generic error page content.\n * @param {import('types').ValidatedConfig} config\n */\nexport function load_error_page(config) {\n\tlet { errorTemplate } = config.kit.files;\n\n\t// Don't do this inside resolving the config, because that would mean\n\t// adding/removing error.html isn't detected and would require a restart.\n\tif (!fs.existsSync(config.kit.files.errorTemplate)) {\n\t\terrorTemplate = url.fileURLToPath(new URL('./default-error.html', import.meta.url));\n\t}\n\n\treturn fs.readFileSync(errorTemplate, 'utf-8');\n}\n\n/**\n * Loads and validates svelte.config.js\n * @param {{ cwd?: string }} options\n * @returns {Promise<import('types').ValidatedConfig>}\n */\nexport async function load_config({ cwd = process.cwd() } = {}) {\n\tconst config_file = path.join(cwd, 'svelte.config.js');\n\n\tif (!fs.existsSync(config_file)) {\n\t\treturn process_config({}, { cwd });\n\t}\n\n\tconst config = await import(`${url.pathToFileURL(config_file).href}?ts=${Date.now()}`);\n\n\treturn process_config(config.default, { cwd });\n}\n\n/**\n * @param {import('types').Config} config\n * @returns {import('types').ValidatedConfig}\n */\nfunction process_config(config, { cwd = process.cwd() } = {}) {\n\tconst validated = validate_config(config);\n\n\tvalidated.kit.outDir = path.resolve(cwd, validated.kit.outDir);\n\n\tfor (const key in validated.kit.files) {\n\t\tif (key === 'hooks') {\n\t\t\tvalidated.kit.files.hooks.client = path.resolve(cwd, validated.kit.files.hooks.client);\n\t\t\tvalidated.kit.files.hooks.server = path.resolve(cwd, validated.kit.files.hooks.server);\n\t\t} else {\n\t\t\t// @ts-expect-error\n\t\t\tvalidated.kit.files[key] = path.resolve(cwd, validated.kit.files[key]);\n\t\t}\n\t}\n\n\treturn validated;\n}\n\n/**\n * @param {import('types').Config} config\n * @returns {import('types').ValidatedConfig}\n */\nexport function validate_config(config) {\n\tif (typeof config !== 'object') {\n\t\tthrow new Error(\n\t\t\t'svelte.config.js must have a configuration object as its default export. See https://kit.svelte.dev/docs/configuration'\n\t\t);\n\t}\n\n\treturn options(config, 'config');\n}\n"}},"options.js":{"file":{"contents":"import { join } from 'node:path';\n\n/** @typedef {import('./types').Validator} Validator */\n\nconst directives = object({\n\t'child-src': string_array(),\n\t'default-src': string_array(),\n\t'frame-src': string_array(),\n\t'worker-src': string_array(),\n\t'connect-src': string_array(),\n\t'font-src': string_array(),\n\t'img-src': string_array(),\n\t'manifest-src': string_array(),\n\t'media-src': string_array(),\n\t'object-src': string_array(),\n\t'prefetch-src': string_array(),\n\t'script-src': string_array(),\n\t'script-src-elem': string_array(),\n\t'script-src-attr': string_array(),\n\t'style-src': string_array(),\n\t'style-src-elem': string_array(),\n\t'style-src-attr': string_array(),\n\t'base-uri': string_array(),\n\tsandbox: string_array(),\n\t'form-action': string_array(),\n\t'frame-ancestors': string_array(),\n\t'navigate-to': string_array(),\n\t'report-uri': string_array(),\n\t'report-to': string_array(),\n\t'require-trusted-types-for': string_array(),\n\t'trusted-types': string_array(),\n\t'upgrade-insecure-requests': boolean(false),\n\t'require-sri-for': string_array(),\n\t'block-all-mixed-content': boolean(false),\n\t'plugin-types': string_array(),\n\treferrer: string_array()\n});\n\n/** @type {Validator} */\nconst options = object(\n\t{\n\t\textensions: validate(['.svelte'], (input, keypath) => {\n\t\t\tif (!Array.isArray(input) || !input.every((page) => typeof page === 'string')) {\n\t\t\t\tthrow new Error(`${keypath} must be an array of strings`);\n\t\t\t}\n\n\t\t\tinput.forEach((extension) => {\n\t\t\t\tif (extension[0] !== '.') {\n\t\t\t\t\tthrow new Error(`Each member of ${keypath} must start with '.' — saw '${extension}'`);\n\t\t\t\t}\n\n\t\t\t\tif (!/^(\\.[a-z0-9]+)+$/i.test(extension)) {\n\t\t\t\t\tthrow new Error(`File extensions must be alphanumeric — saw '${extension}'`);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn input;\n\t\t}),\n\n\t\tkit: object({\n\t\t\tadapter: validate(null, (input, keypath) => {\n\t\t\t\tif (typeof input !== 'object' || !input.adapt) {\n\t\t\t\t\tlet message = `${keypath} should be an object with an \"adapt\" method`;\n\n\t\t\t\t\tif (Array.isArray(input) || typeof input === 'string') {\n\t\t\t\t\t\t// for the early adapter adopters\n\t\t\t\t\t\tmessage += ', rather than the name of an adapter';\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(`${message}. See https://kit.svelte.dev/docs/adapters`);\n\t\t\t\t}\n\n\t\t\t\treturn input;\n\t\t\t}),\n\n\t\t\talias: validate({}, (input, keypath) => {\n\t\t\t\tif (typeof input !== 'object') {\n\t\t\t\t\tthrow new Error(`${keypath} should be an object`);\n\t\t\t\t}\n\n\t\t\t\tfor (const key in input) {\n\t\t\t\t\tassert_string(input[key], `${keypath}.${key}`);\n\t\t\t\t}\n\n\t\t\t\treturn input;\n\t\t\t}),\n\n\t\t\tappDir: validate('_app', (input, keypath) => {\n\t\t\t\tassert_string(input, keypath);\n\n\t\t\t\tif (input) {\n\t\t\t\t\tif (input.startsWith('/') || input.endsWith('/')) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"config.kit.appDir cannot start or end with '/'. See https://kit.svelte.dev/docs/configuration\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`${keypath} cannot be empty`);\n\t\t\t\t}\n\n\t\t\t\treturn input;\n\t\t\t}),\n\n\t\t\tcsp: object({\n\t\t\t\tmode: list(['auto', 'hash', 'nonce']),\n\t\t\t\tdirectives,\n\t\t\t\treportOnly: directives\n\t\t\t}),\n\n\t\t\tcsrf: object({\n\t\t\t\tcheckOrigin: boolean(true)\n\t\t\t}),\n\n\t\t\tembedded: boolean(false),\n\n\t\t\tenv: object({\n\t\t\t\tdir: string(process.cwd()),\n\t\t\t\tpublicPrefix: string('PUBLIC_')\n\t\t\t}),\n\n\t\t\tfiles: object({\n\t\t\t\tassets: string('static'),\n\t\t\t\thooks: object({\n\t\t\t\t\tclient: string(join('src', 'hooks.client')),\n\t\t\t\t\tserver: string(join('src', 'hooks.server'))\n\t\t\t\t}),\n\t\t\t\tlib: string(join('src', 'lib')),\n\t\t\t\tparams: string(join('src', 'params')),\n\t\t\t\troutes: string(join('src', 'routes')),\n\t\t\t\tserviceWorker: string(join('src', 'service-worker')),\n\t\t\t\tappTemplate: string(join('src', 'app.html')),\n\t\t\t\terrorTemplate: string(join('src', 'error.html'))\n\t\t\t}),\n\n\t\t\tinlineStyleThreshold: number(0),\n\n\t\t\tmoduleExtensions: string_array(['.js', '.ts']),\n\n\t\t\toutDir: string('.svelte-kit'),\n\n\t\t\toutput: object({\n\t\t\t\tpreloadStrategy: list(['modulepreload', 'preload-js', 'preload-mjs'], 'modulepreload')\n\t\t\t}),\n\n\t\t\tpaths: object({\n\t\t\t\tbase: validate('', (input, keypath) => {\n\t\t\t\t\tassert_string(input, keypath);\n\n\t\t\t\t\tif (input !== '' && (input.endsWith('/') || !input.startsWith('/'))) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${keypath} option must either be the empty string or a root-relative path that starts but doesn't end with '/'. See https://kit.svelte.dev/docs/configuration#paths`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn input;\n\t\t\t\t}),\n\t\t\t\tassets: validate('', (input, keypath) => {\n\t\t\t\t\tassert_string(input, keypath);\n\n\t\t\t\t\tif (input) {\n\t\t\t\t\t\tif (!/^[a-z]+:\\/\\//.test(input)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${keypath} option must be an absolute path, if specified. See https://kit.svelte.dev/docs/configuration#paths`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input.endsWith('/')) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${keypath} option must not end with '/'. See https://kit.svelte.dev/docs/configuration#paths`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn input;\n\t\t\t\t}),\n\t\t\t\trelative: validate(undefined, (input, keypath) => {\n\t\t\t\t\tif (typeof input !== 'boolean') {\n\t\t\t\t\t\tthrow new Error(`${keypath} option must be a boolean or undefined`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn input;\n\t\t\t\t})\n\t\t\t}),\n\n\t\t\tprerender: object({\n\t\t\t\tconcurrency: number(1),\n\t\t\t\tcrawl: boolean(true),\n\t\t\t\tentries: validate(['*'], (input, keypath) => {\n\t\t\t\t\tif (!Array.isArray(input) || !input.every((page) => typeof page === 'string')) {\n\t\t\t\t\t\tthrow new Error(`${keypath} must be an array of strings`);\n\t\t\t\t\t}\n\n\t\t\t\t\tinput.forEach((page) => {\n\t\t\t\t\t\tif (page !== '*' && page[0] !== '/') {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Each member of ${keypath} must be either '*' or an absolute path beginning with '/' — saw '${page}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn input;\n\t\t\t\t}),\n\n\t\t\t\thandleHttpError: validate('fail', (input, keypath) => {\n\t\t\t\t\tif (typeof input === 'function') return input;\n\t\t\t\t\tif (['fail', 'warn', 'ignore'].includes(input)) return input;\n\t\t\t\t\tthrow new Error(`${keypath} should be \"fail\", \"warn\", \"ignore\" or a custom function`);\n\t\t\t\t}),\n\n\t\t\t\thandleMissingId: validate('fail', (input, keypath) => {\n\t\t\t\t\tif (typeof input === 'function') return input;\n\t\t\t\t\tif (['fail', 'warn', 'ignore'].includes(input)) return input;\n\t\t\t\t\tthrow new Error(`${keypath} should be \"fail\", \"warn\", \"ignore\" or a custom function`);\n\t\t\t\t}),\n\n\t\t\t\torigin: validate('http://sveltekit-prerender', (input, keypath) => {\n\t\t\t\t\tassert_string(input, keypath);\n\n\t\t\t\t\tlet origin;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\torigin = new URL(input).origin;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthrow new Error(`${keypath} must be a valid origin`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (input !== origin) {\n\t\t\t\t\t\tthrow new Error(`${keypath} must be a valid origin (${origin} rather than ${input})`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn origin;\n\t\t\t\t})\n\t\t\t}),\n\n\t\t\tserviceWorker: object({\n\t\t\t\tregister: boolean(true),\n\t\t\t\tfiles: fun((filename) => !/\\.DS_Store/.test(filename))\n\t\t\t}),\n\n\t\t\ttypescript: object({\n\t\t\t\tconfig: fun((config) => config)\n\t\t\t}),\n\n\t\t\tversion: object({\n\t\t\t\tname: string(Date.now().toString()),\n\t\t\t\tpollInterval: number(0)\n\t\t\t})\n\t\t})\n\t},\n\ttrue\n);\n\n/**\n * @param {Record<string, Validator>} children\n * @param {boolean} [allow_unknown]\n * @returns {Validator}\n */\nfunction object(children, allow_unknown = false) {\n\treturn (input, keypath) => {\n\t\t/** @type {Record<string, any>} */\n\t\tconst output = {};\n\n\t\tif ((input && typeof input !== 'object') || Array.isArray(input)) {\n\t\t\tthrow new Error(`${keypath} should be an object`);\n\t\t}\n\n\t\tfor (const key in input) {\n\t\t\tif (!(key in children)) {\n\t\t\t\tif (allow_unknown) {\n\t\t\t\t\toutput[key] = input[key];\n\t\t\t\t} else {\n\t\t\t\t\tlet message = `Unexpected option ${keypath}.${key}`;\n\n\t\t\t\t\t// special case\n\t\t\t\t\tif (keypath === 'config.kit' && key in options) {\n\t\t\t\t\t\tmessage += ` (did you mean config.${key}?)`;\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in children) {\n\t\t\tconst validator = children[key];\n\t\t\toutput[key] = validator(input && input[key], `${keypath}.${key}`);\n\t\t}\n\n\t\treturn output;\n\t};\n}\n\n/**\n * @param {any} fallback\n * @param {(value: any, keypath: string) => any} fn\n * @returns {Validator}\n */\nfunction validate(fallback, fn) {\n\treturn (input, keypath) => {\n\t\treturn input === undefined ? fallback : fn(input, keypath);\n\t};\n}\n\n/**\n * @param {string | null} fallback\n * @param {boolean} allow_empty\n * @returns {Validator}\n */\nfunction string(fallback, allow_empty = true) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tassert_string(input, keypath);\n\n\t\tif (!allow_empty && input === '') {\n\t\t\tthrow new Error(`${keypath} cannot be empty`);\n\t\t}\n\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {string[] | undefined} [fallback]\n * @returns {Validator}\n */\nfunction string_array(fallback) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tif (!Array.isArray(input) || input.some((value) => typeof value !== 'string')) {\n\t\t\tthrow new Error(`${keypath} must be an array of strings, if specified`);\n\t\t}\n\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {number} fallback\n * @returns {Validator}\n */\nfunction number(fallback) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tif (typeof input !== 'number') {\n\t\t\tthrow new Error(`${keypath} should be a number, if specified`);\n\t\t}\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {boolean} fallback\n * @returns {Validator}\n */\nfunction boolean(fallback) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tif (typeof input !== 'boolean') {\n\t\t\tthrow new Error(`${keypath} should be true or false, if specified`);\n\t\t}\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {string[]} options\n * @returns {Validator}\n */\nfunction list(options, fallback = options[0]) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tif (!options.includes(input)) {\n\t\t\t// prettier-ignore\n\t\t\tconst msg = options.length > 2\n\t\t\t\t? `${keypath} should be one of ${options.slice(0, -1).map(input => `\"${input}\"`).join(', ')} or \"${options[options.length - 1]}\"`\n\t\t\t\t: `${keypath} should be either \"${options[0]}\" or \"${options[1]}\"`;\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {(...args: any) => any} fallback\n * @returns {Validator}\n */\nfunction fun(fallback) {\n\treturn validate(fallback, (input, keypath) => {\n\t\tif (typeof input !== 'function') {\n\t\t\tthrow new Error(`${keypath} should be a function, if specified`);\n\t\t}\n\t\treturn input;\n\t});\n}\n\n/**\n * @param {string} input\n * @param {string} keypath\n */\nfunction assert_string(input, keypath) {\n\tif (typeof input !== 'string') {\n\t\tthrow new Error(`${keypath} should be a string, if specified`);\n\t}\n}\n\nexport default options;\n"}},"types.d.ts":{"file":{"contents":"export type Validator<T = any> = (input: T, keypath: string) => T;\n"}}}},"env.js":{"file":{"contents":"import { GENERATED_COMMENT } from '../constants.js';\nimport { dedent } from './sync/utils.js';\nimport { runtime_base } from './utils.js';\n\n/**\n * @typedef {'public' | 'private'} EnvType\n */\n\n/**\n * @param {string} id\n * @param {Record<string, string>} env\n * @returns {string}\n */\nexport function create_static_module(id, env) {\n\t/** @type {string[]} */\n\tconst declarations = [];\n\n\tfor (const key in env) {\n\t\tif (!valid_identifier.test(key) || reserved.has(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst comment = `/** @type {import('${id}').${key}} */`;\n\t\tconst declaration = `export const ${key} = ${JSON.stringify(env[key])};`;\n\n\t\tdeclarations.push(`${comment}\\n${declaration}`);\n\t}\n\n\treturn GENERATED_COMMENT + declarations.join('\\n\\n');\n}\n\n/**\n * @param {EnvType} type\n * @param {Record<string, string> | undefined} dev_values If in a development mode, values to pre-populate the module with.\n */\nexport function create_dynamic_module(type, dev_values) {\n\tif (dev_values) {\n\t\tconst keys = Object.entries(dev_values).map(\n\t\t\t([k, v]) => `${JSON.stringify(k)}: ${JSON.stringify(v)}`\n\t\t);\n\t\treturn `export const env = {\\n${keys.join(',\\n')}\\n}`;\n\t}\n\treturn `export { ${type}_env as env } from '${runtime_base}/shared-server.js';`;\n}\n\n/**\n * @param {EnvType} id\n * @param {import('types').Env} env\n * @returns {string}\n */\nexport function create_static_types(id, env) {\n\tconst declarations = Object.keys(env[id])\n\t\t.filter((k) => valid_identifier.test(k))\n\t\t.map((k) => `export const ${k}: string;`);\n\n\treturn dedent`\n\t\tdeclare module '$env/static/${id}' {\n\t\t\t${declarations.join('\\n')}\n\t\t}\n\t`;\n}\n\n/**\n * @param {EnvType} id\n * @param {import('types').Env} env\n * @param {string} prefix\n * @returns {string}\n */\nexport function create_dynamic_types(id, env, prefix) {\n\tconst properties = Object.keys(env[id])\n\t\t.filter((k) => valid_identifier.test(k))\n\t\t.map((k) => `${k}: string;`);\n\n\tconst prefixed = `[key: \\`${prefix}\\${string}\\`]`;\n\n\tif (id === 'private') {\n\t\tproperties.push(`${prefixed}: undefined;`);\n\t\tproperties.push(`[key: string]: string | undefined;`);\n\t} else {\n\t\tproperties.push(`${prefixed}: string | undefined;`);\n\t}\n\n\treturn dedent`\n\t\tdeclare module '$env/dynamic/${id}' {\n\t\t\texport const env: {\n\t\t\t\t${properties.join('\\n')}\n\t\t\t}\n\t\t}\n\t`;\n}\n\nexport const reserved = new Set([\n\t'do',\n\t'if',\n\t'in',\n\t'for',\n\t'let',\n\t'new',\n\t'try',\n\t'var',\n\t'case',\n\t'else',\n\t'enum',\n\t'eval',\n\t'null',\n\t'this',\n\t'true',\n\t'void',\n\t'with',\n\t'await',\n\t'break',\n\t'catch',\n\t'class',\n\t'const',\n\t'false',\n\t'super',\n\t'throw',\n\t'while',\n\t'yield',\n\t'delete',\n\t'export',\n\t'import',\n\t'public',\n\t'return',\n\t'static',\n\t'switch',\n\t'typeof',\n\t'default',\n\t'extends',\n\t'finally',\n\t'package',\n\t'private',\n\t'continue',\n\t'debugger',\n\t'function',\n\t'arguments',\n\t'interface',\n\t'protected',\n\t'implements',\n\t'instanceof'\n]);\n\nexport const valid_identifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n"}},"generate_manifest":{"directory":{"index.js":{"file":{"contents":"import { s } from '../../utils/misc.js';\nimport { get_mime_lookup } from '../utils.js';\nimport { resolve_symlinks } from '../../exports/vite/build/utils.js';\nimport { compact } from '../../utils/array.js';\nimport { join_relative } from '../../utils/filesystem.js';\nimport { dedent } from '../sync/utils.js';\n\n/**\n * Generates the data used to write the server-side manifest.js file. This data is used in the Vite\n * build process, to power routing, etc.\n * @param {{\n *   build_data: import('types').BuildData;\n *   relative_path: string;\n *   routes: import('types').RouteData[];\n * }} opts\n */\nexport function generate_manifest({ build_data, relative_path, routes }) {\n\t/**\n\t * @type {Map<any, number>} The new index of each node in the filtered nodes array\n\t */\n\tconst reindexed = new Map();\n\t/**\n\t * All nodes actually used in the routes definition (prerendered routes are omitted).\n\t * Root layout/error is always included as they are needed for 404 and root errors.\n\t * @type {Set<any>}\n\t */\n\tconst used_nodes = new Set([0, 1]);\n\n\tfor (const route of routes) {\n\t\tif (route.page) {\n\t\t\tfor (const i of route.page.layouts) used_nodes.add(i);\n\t\t\tfor (const i of route.page.errors) used_nodes.add(i);\n\t\t\tused_nodes.add(route.page.leaf);\n\t\t}\n\t}\n\n\tconst node_paths = compact(\n\t\tbuild_data.manifest_data.nodes.map((_, i) => {\n\t\t\tif (used_nodes.has(i)) {\n\t\t\t\treindexed.set(i, reindexed.size);\n\t\t\t\treturn join_relative(relative_path, `/nodes/${i}.js`);\n\t\t\t}\n\t\t})\n\t);\n\n\t/** @typedef {{ index: number, path: string }} LookupEntry */\n\t/** @type {Map<import('types').PageNode, LookupEntry>} */\n\tconst bundled_nodes = new Map();\n\n\tbuild_data.manifest_data.nodes.forEach((node, i) => {\n\t\tbundled_nodes.set(node, {\n\t\t\tpath: join_relative(relative_path, `/nodes/${i}.js`),\n\t\t\tindex: i\n\t\t});\n\t});\n\n\t/** @type {(path: string) => string} */\n\tconst loader = (path) => `() => import('${path}')`;\n\n\tconst assets = build_data.manifest_data.assets.map((asset) => asset.file);\n\tif (build_data.service_worker) {\n\t\tassets.push(build_data.service_worker);\n\t}\n\n\tconst matchers = new Set();\n\n\t/** @param {Array<number | undefined>} indexes */\n\tfunction get_nodes(indexes) {\n\t\tlet string = indexes.map((n) => reindexed.get(n) ?? '').join(',');\n\n\t\tif (indexes.at(-1) === undefined) {\n\t\t\t// since JavaScript ignores trailing commas, we need to insert a dummy\n\t\t\t// comma so that the array has the correct length if the last item\n\t\t\t// is undefined\n\t\t\tstring += ',';\n\t\t}\n\n\t\treturn `[${string}]`;\n\t}\n\n\t// prettier-ignore\n\t// String representation of\n\t/** @type {import('types').SSRManifest} */\n\treturn dedent`\n\t\t{\n\t\t\tappDir: ${s(build_data.app_dir)},\n\t\t\tappPath: ${s(build_data.app_path)},\n\t\t\tassets: new Set(${s(assets)}),\n\t\t\tmimeTypes: ${s(get_mime_lookup(build_data.manifest_data))},\n\t\t\t_: {\n\t\t\t\tclient: ${s(build_data.client)},\n\t\t\t\tnodes: [\n\t\t\t\t\t${(node_paths).map(loader).join(',\\n')}\n\t\t\t\t],\n\t\t\t\troutes: [\n\t\t\t\t\t${routes.map(route => {\n\t\t\t\t\t\troute.params.forEach(param => {\n\t\t\t\t\t\t\tif (param.matcher) matchers.add(param.matcher);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!route.page && !route.endpoint) return;\n\n\t\t\t\t\t\treturn dedent`\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid: ${s(route.id)},\n\t\t\t\t\t\t\t\tpattern: ${route.pattern},\n\t\t\t\t\t\t\t\tparams: ${s(route.params)},\n\t\t\t\t\t\t\t\tpage: ${route.page ? `{ layouts: ${get_nodes(route.page.layouts)}, errors: ${get_nodes(route.page.errors)}, leaf: ${reindexed.get(route.page.leaf)} }` : 'null'},\n\t\t\t\t\t\t\t\tendpoint: ${route.endpoint ? loader(join_relative(relative_path, resolve_symlinks(build_data.server_manifest, route.endpoint.file).chunk.file)) : 'null'}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t`;\n\t\t\t\t\t}).filter(Boolean).join(',\\n')}\n\t\t\t\t],\n\t\t\t\tmatchers: async () => {\n\t\t\t\t\t${Array.from(matchers).map(type => `const { match: ${type} } = await import ('${(join_relative(relative_path, `/entries/matchers/${type}.js`))}')`).join('\\n')}\n\t\t\t\t\treturn { ${Array.from(matchers).join(', ')} };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`;\n}\n"}}}},"postbuild":{"directory":{"analyse.js":{"file":{"contents":"import { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { get_option } from '../../utils/options.js';\nimport {\n\tvalidate_common_exports,\n\tvalidate_page_server_exports,\n\tvalidate_server_exports\n} from '../../utils/exports.js';\nimport { load_config } from '../config/index.js';\nimport { forked } from '../../utils/fork.js';\nimport { should_polyfill } from '../../utils/platform.js';\nimport { installPolyfills } from '../../exports/node/polyfills.js';\n\nexport default forked(import.meta.url, analyse);\n\n/**\n * @param {{\n *   manifest_path: string;\n *   env: Record<string, string>\n * }} opts\n */\nasync function analyse({ manifest_path, env }) {\n\t/** @type {import('types').SSRManifest} */\n\tconst manifest = (await import(pathToFileURL(manifest_path).href)).manifest;\n\n\t/** @type {import('types').ValidatedKitConfig} */\n\tconst config = (await load_config()).kit;\n\n\tconst server_root = join(config.outDir, 'output');\n\n\t/** @type {import('types').ServerInternalModule} */\n\tconst internal = await import(pathToFileURL(`${server_root}/server/internal.js`).href);\n\n\tif (should_polyfill) {\n\t\tinstallPolyfills();\n\t}\n\n\t// configure `import { building } from '$app/environment'` —\n\t// essential we do this before analysing the code\n\tinternal.set_building(true);\n\n\t// set env, in case it's used in initialisation\n\tconst entries = Object.entries(env);\n\tconst prefix = config.env.publicPrefix;\n\tinternal.set_private_env(Object.fromEntries(entries.filter(([k]) => !k.startsWith(prefix))));\n\tinternal.set_public_env(Object.fromEntries(entries.filter(([k]) => k.startsWith(prefix))));\n\n\t/** @type {import('types').ServerMetadata} */\n\tconst metadata = {\n\t\tnodes: [],\n\t\troutes: new Map()\n\t};\n\n\t// analyse nodes\n\tfor (const loader of manifest._.nodes) {\n\t\tconst node = await loader();\n\n\t\tmetadata.nodes[node.index] = {\n\t\t\thas_server_load: node.server?.load !== undefined\n\t\t};\n\t}\n\n\t// analyse routes\n\tfor (const route of manifest._.routes) {\n\t\t/** @type {Array<'GET' | 'POST'>} */\n\t\tconst page_methods = [];\n\n\t\t/** @type {import('types').HttpMethod[]} */\n\t\tconst api_methods = [];\n\n\t\t/** @type {import('types').PrerenderOption | undefined} */\n\t\tlet prerender = undefined;\n\t\t/** @type {any} */\n\t\tlet config = undefined;\n\n\t\tif (route.endpoint) {\n\t\t\tconst mod = await route.endpoint();\n\t\t\tif (mod.prerender !== undefined) {\n\t\t\t\tvalidate_server_exports(mod, route.id);\n\n\t\t\t\tif (mod.prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot prerender a +server file with POST, PATCH, PUT, or DELETE (${route.id})`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tprerender = mod.prerender;\n\t\t\t}\n\n\t\t\tif (mod.GET) api_methods.push('GET');\n\t\t\tif (mod.POST) api_methods.push('POST');\n\t\t\tif (mod.PUT) api_methods.push('PUT');\n\t\t\tif (mod.PATCH) api_methods.push('PATCH');\n\t\t\tif (mod.DELETE) api_methods.push('DELETE');\n\t\t\tif (mod.OPTIONS) api_methods.push('OPTIONS');\n\n\t\t\tconfig = mod.config;\n\t\t}\n\n\t\tif (route.page) {\n\t\t\tconst nodes = await Promise.all(\n\t\t\t\t[...route.page.layouts, route.page.leaf].map((n) => {\n\t\t\t\t\tif (n !== undefined) return manifest._.nodes[n]();\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tconst layouts = nodes.slice(0, -1);\n\t\t\tconst page = nodes.at(-1);\n\n\t\t\tfor (const layout of layouts) {\n\t\t\t\tif (layout) {\n\t\t\t\t\tvalidate_common_exports(layout.server, layout.server_id);\n\t\t\t\t\tvalidate_common_exports(layout.universal, layout.universal_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (page) {\n\t\t\t\tpage_methods.push('GET');\n\t\t\t\tif (page.server?.actions) page_methods.push('POST');\n\n\t\t\t\tvalidate_page_server_exports(page.server, page.server_id);\n\t\t\t\tvalidate_common_exports(page.universal, page.universal_id);\n\t\t\t}\n\n\t\t\tconst should_prerender = get_option(nodes, 'prerender');\n\t\t\tprerender =\n\t\t\t\tshould_prerender === true ||\n\t\t\t\t// Try prerendering if ssr is false and no server needed. Set it to 'auto' so that\n\t\t\t\t// the route is not removed from the manifest, there could be a server load function.\n\t\t\t\t// People can opt out of this behavior by explicitly setting prerender to false\n\t\t\t\t(should_prerender !== false && get_option(nodes, 'ssr') === false && !page?.server?.actions\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: should_prerender ?? false);\n\n\t\t\tconfig = get_config(nodes);\n\t\t}\n\n\t\tmetadata.routes.set(route.id, {\n\t\t\tconfig,\n\t\t\tmethods: Array.from(new Set([...page_methods, ...api_methods])),\n\t\t\tpage: {\n\t\t\t\tmethods: page_methods\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\tmethods: api_methods\n\t\t\t},\n\t\t\tprerender\n\t\t});\n\t}\n\n\treturn metadata;\n}\n\n/**\n * Do a shallow merge (first level) of the config object\n * @param {Array<import('types').SSRNode | undefined>} nodes\n */\nfunction get_config(nodes) {\n\tlet current = {};\n\tfor (const node of nodes) {\n\t\tconst config = node?.universal?.config ?? node?.server?.config;\n\t\tif (config) {\n\t\t\tcurrent = {\n\t\t\t\t...current,\n\t\t\t\t...config\n\t\t\t};\n\t\t}\n\t}\n\n\treturn Object.keys(current).length ? current : undefined;\n}\n"}},"crawl.js":{"file":{"contents":"import { decode } from './entities.js';\n\nconst DOCTYPE = 'DOCTYPE';\nconst CDATA_OPEN = '[CDATA[';\nconst CDATA_CLOSE = ']]>';\nconst COMMENT_OPEN = '--';\nconst COMMENT_CLOSE = '-->';\n\nconst TAG_OPEN = /[a-zA-Z]/;\nconst TAG_CHAR = /[a-zA-Z0-9]/;\nconst ATTRIBUTE_NAME = /[^\\t\\n\\f />\"'=]/;\n\nconst WHITESPACE = /[\\s\\n\\r]/;\n\n/** @param {string} html */\nexport function crawl(html) {\n\t/** @type {string[]} */\n\tconst ids = [];\n\n\t/** @type {string[]} */\n\tconst hrefs = [];\n\n\tlet i = 0;\n\tmain: while (i < html.length) {\n\t\tconst char = html[i];\n\n\t\tif (char === '<') {\n\t\t\tif (html[i + 1] === '!') {\n\t\t\t\ti += 2;\n\n\t\t\t\tif (html.slice(i, i + DOCTYPE.length).toUpperCase() === DOCTYPE) {\n\t\t\t\t\ti += DOCTYPE.length;\n\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\tif (html[i++] === '>') {\n\t\t\t\t\t\t\tcontinue main;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// skip cdata\n\t\t\t\tif (html.slice(i, i + CDATA_OPEN.length) === CDATA_OPEN) {\n\t\t\t\t\ti += CDATA_OPEN.length;\n\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\tif (html.slice(i, i + CDATA_CLOSE.length) === CDATA_CLOSE) {\n\t\t\t\t\t\t\ti += CDATA_CLOSE.length;\n\t\t\t\t\t\t\tcontinue main;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// skip comments\n\t\t\t\tif (html.slice(i, i + COMMENT_OPEN.length) === COMMENT_OPEN) {\n\t\t\t\t\ti += COMMENT_OPEN.length;\n\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\tif (html.slice(i, i + COMMENT_CLOSE.length) === COMMENT_CLOSE) {\n\t\t\t\t\t\t\ti += COMMENT_CLOSE.length;\n\t\t\t\t\t\t\tcontinue main;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// parse opening tags\n\t\t\tconst start = ++i;\n\t\t\tif (TAG_OPEN.test(html[start])) {\n\t\t\t\twhile (i < html.length) {\n\t\t\t\t\tif (!TAG_CHAR.test(html[i])) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\n\t\t\t\tconst tag = html.slice(start, i).toUpperCase();\n\n\t\t\t\tif (tag === 'SCRIPT' || tag === 'STYLE') {\n\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thtml[i] === '<' &&\n\t\t\t\t\t\t\thtml[i + 1] === '/' &&\n\t\t\t\t\t\t\thtml.slice(i + 2, i + 2 + tag.length).toUpperCase() === tag\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue main;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet href = '';\n\t\t\t\tlet rel = '';\n\n\t\t\t\twhile (i < html.length) {\n\t\t\t\t\tconst start = i;\n\n\t\t\t\t\tconst char = html[start];\n\t\t\t\t\tif (char === '>') break;\n\n\t\t\t\t\tif (ATTRIBUTE_NAME.test(char)) {\n\t\t\t\t\t\ti += 1;\n\n\t\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\t\tif (!ATTRIBUTE_NAME.test(html[i])) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst name = html.slice(start, i).toLowerCase();\n\n\t\t\t\t\t\twhile (WHITESPACE.test(html[i])) i += 1;\n\n\t\t\t\t\t\tif (html[i] === '=') {\n\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t\twhile (WHITESPACE.test(html[i])) i += 1;\n\n\t\t\t\t\t\t\tlet value;\n\n\t\t\t\t\t\t\tif (html[i] === \"'\" || html[i] === '\"') {\n\t\t\t\t\t\t\t\tconst quote = html[i++];\n\n\t\t\t\t\t\t\t\tconst start = i;\n\t\t\t\t\t\t\t\tlet escaped = false;\n\n\t\t\t\t\t\t\t\twhile (i < html.length) {\n\t\t\t\t\t\t\t\t\tif (escaped) {\n\t\t\t\t\t\t\t\t\t\tescaped = false;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst char = html[i];\n\n\t\t\t\t\t\t\t\t\t\tif (html[i] === quote) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (char === '\\\\') {\n\t\t\t\t\t\t\t\t\t\t\tescaped = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvalue = html.slice(start, i);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst start = i;\n\t\t\t\t\t\t\t\twhile (html[i] !== '>' && !WHITESPACE.test(html[i])) i += 1;\n\t\t\t\t\t\t\t\tvalue = html.slice(start, i);\n\n\t\t\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalue = decode(value);\n\n\t\t\t\t\t\t\tif (name === 'href') {\n\t\t\t\t\t\t\t\thref = value;\n\t\t\t\t\t\t\t} else if (name === 'id') {\n\t\t\t\t\t\t\t\tids.push(value);\n\t\t\t\t\t\t\t} else if (name === 'name') {\n\t\t\t\t\t\t\t\tif (tag === 'A') ids.push(value);\n\t\t\t\t\t\t\t} else if (name === 'rel') {\n\t\t\t\t\t\t\t\trel = value;\n\t\t\t\t\t\t\t} else if (name === 'src') {\n\t\t\t\t\t\t\t\tif (value) hrefs.push(value);\n\t\t\t\t\t\t\t} else if (name === 'srcset') {\n\t\t\t\t\t\t\t\tconst candidates = [];\n\t\t\t\t\t\t\t\tlet insideURL = true;\n\t\t\t\t\t\t\t\tvalue = value.trim();\n\t\t\t\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\t\t\t\tif (value[i] === ',' && (!insideURL || (insideURL && value[i + 1] === ' '))) {\n\t\t\t\t\t\t\t\t\t\tcandidates.push(value.slice(0, i));\n\t\t\t\t\t\t\t\t\t\tvalue = value.substring(i + 1).trim();\n\t\t\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t\t\t\tinsideURL = true;\n\t\t\t\t\t\t\t\t\t} else if (value[i] === ' ') {\n\t\t\t\t\t\t\t\t\t\tinsideURL = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcandidates.push(value);\n\t\t\t\t\t\t\t\tfor (const candidate of candidates) {\n\t\t\t\t\t\t\t\t\tconst src = candidate.split(WHITESPACE)[0];\n\t\t\t\t\t\t\t\t\tif (src) hrefs.push(src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\n\t\t\t\tif (href && !/\\bexternal\\b/i.test(rel)) {\n\t\t\t\t\threfs.push(href);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti += 1;\n\t}\n\n\treturn { ids, hrefs };\n}\n"}},"entities.js":{"file":{"contents":"/**\n * A list of all named HTML entities, from https://html.spec.whatwg.org/multipage/named-characters.html\n * @type {Record<string, string>}\n */\nconst entities = {\n\tAElig: 'Æ',\n\t'AElig;': 'Æ',\n\tAMP: '&',\n\t'AMP;': '&',\n\tAacute: 'Á',\n\t'Aacute;': 'Á',\n\t'Abreve;': 'Ă',\n\tAcirc: 'Â',\n\t'Acirc;': 'Â',\n\t'Acy;': 'А',\n\t'Afr;': '𝔄',\n\tAgrave: 'À',\n\t'Agrave;': 'À',\n\t'Alpha;': 'Α',\n\t'Amacr;': 'Ā',\n\t'And;': '⩓',\n\t'Aogon;': 'Ą',\n\t'Aopf;': '𝔸',\n\t'ApplyFunction;': '⁡',\n\tAring: 'Å',\n\t'Aring;': 'Å',\n\t'Ascr;': '𝒜',\n\t'Assign;': '≔',\n\tAtilde: 'Ã',\n\t'Atilde;': 'Ã',\n\tAuml: 'Ä',\n\t'Auml;': 'Ä',\n\t'Backslash;': '∖',\n\t'Barv;': '⫧',\n\t'Barwed;': '⌆',\n\t'Bcy;': 'Б',\n\t'Because;': '∵',\n\t'Bernoullis;': 'ℬ',\n\t'Beta;': 'Β',\n\t'Bfr;': '𝔅',\n\t'Bopf;': '𝔹',\n\t'Breve;': '˘',\n\t'Bscr;': 'ℬ',\n\t'Bumpeq;': '≎',\n\t'CHcy;': 'Ч',\n\tCOPY: '©',\n\t'COPY;': '©',\n\t'Cacute;': 'Ć',\n\t'Cap;': '⋒',\n\t'CapitalDifferentialD;': 'ⅅ',\n\t'Cayleys;': 'ℭ',\n\t'Ccaron;': 'Č',\n\tCcedil: 'Ç',\n\t'Ccedil;': 'Ç',\n\t'Ccirc;': 'Ĉ',\n\t'Cconint;': '∰',\n\t'Cdot;': 'Ċ',\n\t'Cedilla;': '¸',\n\t'CenterDot;': '·',\n\t'Cfr;': 'ℭ',\n\t'Chi;': 'Χ',\n\t'CircleDot;': '⊙',\n\t'CircleMinus;': '⊖',\n\t'CirclePlus;': '⊕',\n\t'CircleTimes;': '⊗',\n\t'ClockwiseContourIntegral;': '∲',\n\t'CloseCurlyDoubleQuote;': '”',\n\t'CloseCurlyQuote;': '’',\n\t'Colon;': '∷',\n\t'Colone;': '⩴',\n\t'Congruent;': '≡',\n\t'Conint;': '∯',\n\t'ContourIntegral;': '∮',\n\t'Copf;': 'ℂ',\n\t'Coproduct;': '∐',\n\t'CounterClockwiseContourIntegral;': '∳',\n\t'Cross;': '⨯',\n\t'Cscr;': '𝒞',\n\t'Cup;': '⋓',\n\t'CupCap;': '≍',\n\t'DD;': 'ⅅ',\n\t'DDotrahd;': '⤑',\n\t'DJcy;': 'Ђ',\n\t'DScy;': 'Ѕ',\n\t'DZcy;': 'Џ',\n\t'Dagger;': '‡',\n\t'Darr;': '↡',\n\t'Dashv;': '⫤',\n\t'Dcaron;': 'Ď',\n\t'Dcy;': 'Д',\n\t'Del;': '∇',\n\t'Delta;': 'Δ',\n\t'Dfr;': '𝔇',\n\t'DiacriticalAcute;': '´',\n\t'DiacriticalDot;': '˙',\n\t'DiacriticalDoubleAcute;': '˝',\n\t'DiacriticalGrave;': '`',\n\t'DiacriticalTilde;': '˜',\n\t'Diamond;': '⋄',\n\t'DifferentialD;': 'ⅆ',\n\t'Dopf;': '𝔻',\n\t'Dot;': '¨',\n\t'DotDot;': '⃜',\n\t'DotEqual;': '≐',\n\t'DoubleContourIntegral;': '∯',\n\t'DoubleDot;': '¨',\n\t'DoubleDownArrow;': '⇓',\n\t'DoubleLeftArrow;': '⇐',\n\t'DoubleLeftRightArrow;': '⇔',\n\t'DoubleLeftTee;': '⫤',\n\t'DoubleLongLeftArrow;': '⟸',\n\t'DoubleLongLeftRightArrow;': '⟺',\n\t'DoubleLongRightArrow;': '⟹',\n\t'DoubleRightArrow;': '⇒',\n\t'DoubleRightTee;': '⊨',\n\t'DoubleUpArrow;': '⇑',\n\t'DoubleUpDownArrow;': '⇕',\n\t'DoubleVerticalBar;': '∥',\n\t'DownArrow;': '↓',\n\t'DownArrowBar;': '⤓',\n\t'DownArrowUpArrow;': '⇵',\n\t'DownBreve;': '̑',\n\t'DownLeftRightVector;': '⥐',\n\t'DownLeftTeeVector;': '⥞',\n\t'DownLeftVector;': '↽',\n\t'DownLeftVectorBar;': '⥖',\n\t'DownRightTeeVector;': '⥟',\n\t'DownRightVector;': '⇁',\n\t'DownRightVectorBar;': '⥗',\n\t'DownTee;': '⊤',\n\t'DownTeeArrow;': '↧',\n\t'Downarrow;': '⇓',\n\t'Dscr;': '𝒟',\n\t'Dstrok;': 'Đ',\n\t'ENG;': 'Ŋ',\n\tETH: 'Ð',\n\t'ETH;': 'Ð',\n\tEacute: 'É',\n\t'Eacute;': 'É',\n\t'Ecaron;': 'Ě',\n\tEcirc: 'Ê',\n\t'Ecirc;': 'Ê',\n\t'Ecy;': 'Э',\n\t'Edot;': 'Ė',\n\t'Efr;': '𝔈',\n\tEgrave: 'È',\n\t'Egrave;': 'È',\n\t'Element;': '∈',\n\t'Emacr;': 'Ē',\n\t'EmptySmallSquare;': '◻',\n\t'EmptyVerySmallSquare;': '▫',\n\t'Eogon;': 'Ę',\n\t'Eopf;': '𝔼',\n\t'Epsilon;': 'Ε',\n\t'Equal;': '⩵',\n\t'EqualTilde;': '≂',\n\t'Equilibrium;': '⇌',\n\t'Escr;': 'ℰ',\n\t'Esim;': '⩳',\n\t'Eta;': 'Η',\n\tEuml: 'Ë',\n\t'Euml;': 'Ë',\n\t'Exists;': '∃',\n\t'ExponentialE;': 'ⅇ',\n\t'Fcy;': 'Ф',\n\t'Ffr;': '𝔉',\n\t'FilledSmallSquare;': '◼',\n\t'FilledVerySmallSquare;': '▪',\n\t'Fopf;': '𝔽',\n\t'ForAll;': '∀',\n\t'Fouriertrf;': 'ℱ',\n\t'Fscr;': 'ℱ',\n\t'GJcy;': 'Ѓ',\n\tGT: '>',\n\t'GT;': '>',\n\t'Gamma;': 'Γ',\n\t'Gammad;': 'Ϝ',\n\t'Gbreve;': 'Ğ',\n\t'Gcedil;': 'Ģ',\n\t'Gcirc;': 'Ĝ',\n\t'Gcy;': 'Г',\n\t'Gdot;': 'Ġ',\n\t'Gfr;': '𝔊',\n\t'Gg;': '⋙',\n\t'Gopf;': '𝔾',\n\t'GreaterEqual;': '≥',\n\t'GreaterEqualLess;': '⋛',\n\t'GreaterFullEqual;': '≧',\n\t'GreaterGreater;': '⪢',\n\t'GreaterLess;': '≷',\n\t'GreaterSlantEqual;': '⩾',\n\t'GreaterTilde;': '≳',\n\t'Gscr;': '𝒢',\n\t'Gt;': '≫',\n\t'HARDcy;': 'Ъ',\n\t'Hacek;': 'ˇ',\n\t'Hat;': '^',\n\t'Hcirc;': 'Ĥ',\n\t'Hfr;': 'ℌ',\n\t'HilbertSpace;': 'ℋ',\n\t'Hopf;': 'ℍ',\n\t'HorizontalLine;': '─',\n\t'Hscr;': 'ℋ',\n\t'Hstrok;': 'Ħ',\n\t'HumpDownHump;': '≎',\n\t'HumpEqual;': '≏',\n\t'IEcy;': 'Е',\n\t'IJlig;': 'Ĳ',\n\t'IOcy;': 'Ё',\n\tIacute: 'Í',\n\t'Iacute;': 'Í',\n\tIcirc: 'Î',\n\t'Icirc;': 'Î',\n\t'Icy;': 'И',\n\t'Idot;': 'İ',\n\t'Ifr;': 'ℑ',\n\tIgrave: 'Ì',\n\t'Igrave;': 'Ì',\n\t'Im;': 'ℑ',\n\t'Imacr;': 'Ī',\n\t'ImaginaryI;': 'ⅈ',\n\t'Implies;': '⇒',\n\t'Int;': '∬',\n\t'Integral;': '∫',\n\t'Intersection;': '⋂',\n\t'InvisibleComma;': '⁣',\n\t'InvisibleTimes;': '⁢',\n\t'Iogon;': 'Į',\n\t'Iopf;': '𝕀',\n\t'Iota;': 'Ι',\n\t'Iscr;': 'ℐ',\n\t'Itilde;': 'Ĩ',\n\t'Iukcy;': 'І',\n\tIuml: 'Ï',\n\t'Iuml;': 'Ï',\n\t'Jcirc;': 'Ĵ',\n\t'Jcy;': 'Й',\n\t'Jfr;': '𝔍',\n\t'Jopf;': '𝕁',\n\t'Jscr;': '𝒥',\n\t'Jsercy;': 'Ј',\n\t'Jukcy;': 'Є',\n\t'KHcy;': 'Х',\n\t'KJcy;': 'Ќ',\n\t'Kappa;': 'Κ',\n\t'Kcedil;': 'Ķ',\n\t'Kcy;': 'К',\n\t'Kfr;': '𝔎',\n\t'Kopf;': '𝕂',\n\t'Kscr;': '𝒦',\n\t'LJcy;': 'Љ',\n\tLT: '<',\n\t'LT;': '<',\n\t'Lacute;': 'Ĺ',\n\t'Lambda;': 'Λ',\n\t'Lang;': '⟪',\n\t'Laplacetrf;': 'ℒ',\n\t'Larr;': '↞',\n\t'Lcaron;': 'Ľ',\n\t'Lcedil;': 'Ļ',\n\t'Lcy;': 'Л',\n\t'LeftAngleBracket;': '⟨',\n\t'LeftArrow;': '←',\n\t'LeftArrowBar;': '⇤',\n\t'LeftArrowRightArrow;': '⇆',\n\t'LeftCeiling;': '⌈',\n\t'LeftDoubleBracket;': '⟦',\n\t'LeftDownTeeVector;': '⥡',\n\t'LeftDownVector;': '⇃',\n\t'LeftDownVectorBar;': '⥙',\n\t'LeftFloor;': '⌊',\n\t'LeftRightArrow;': '↔',\n\t'LeftRightVector;': '⥎',\n\t'LeftTee;': '⊣',\n\t'LeftTeeArrow;': '↤',\n\t'LeftTeeVector;': '⥚',\n\t'LeftTriangle;': '⊲',\n\t'LeftTriangleBar;': '⧏',\n\t'LeftTriangleEqual;': '⊴',\n\t'LeftUpDownVector;': '⥑',\n\t'LeftUpTeeVector;': '⥠',\n\t'LeftUpVector;': '↿',\n\t'LeftUpVectorBar;': '⥘',\n\t'LeftVector;': '↼',\n\t'LeftVectorBar;': '⥒',\n\t'Leftarrow;': '⇐',\n\t'Leftrightarrow;': '⇔',\n\t'LessEqualGreater;': '⋚',\n\t'LessFullEqual;': '≦',\n\t'LessGreater;': '≶',\n\t'LessLess;': '⪡',\n\t'LessSlantEqual;': '⩽',\n\t'LessTilde;': '≲',\n\t'Lfr;': '𝔏',\n\t'Ll;': '⋘',\n\t'Lleftarrow;': '⇚',\n\t'Lmidot;': 'Ŀ',\n\t'LongLeftArrow;': '⟵',\n\t'LongLeftRightArrow;': '⟷',\n\t'LongRightArrow;': '⟶',\n\t'Longleftarrow;': '⟸',\n\t'Longleftrightarrow;': '⟺',\n\t'Longrightarrow;': '⟹',\n\t'Lopf;': '𝕃',\n\t'LowerLeftArrow;': '↙',\n\t'LowerRightArrow;': '↘',\n\t'Lscr;': 'ℒ',\n\t'Lsh;': '↰',\n\t'Lstrok;': 'Ł',\n\t'Lt;': '≪',\n\t'Map;': '⤅',\n\t'Mcy;': 'М',\n\t'MediumSpace;': ' ',\n\t'Mellintrf;': 'ℳ',\n\t'Mfr;': '𝔐',\n\t'MinusPlus;': '∓',\n\t'Mopf;': '𝕄',\n\t'Mscr;': 'ℳ',\n\t'Mu;': 'Μ',\n\t'NJcy;': 'Њ',\n\t'Nacute;': 'Ń',\n\t'Ncaron;': 'Ň',\n\t'Ncedil;': 'Ņ',\n\t'Ncy;': 'Н',\n\t'NegativeMediumSpace;': '​',\n\t'NegativeThickSpace;': '​',\n\t'NegativeThinSpace;': '​',\n\t'NegativeVeryThinSpace;': '​',\n\t'NestedGreaterGreater;': '≫',\n\t'NestedLessLess;': '≪',\n\t'NewLine;': '\\n',\n\t'Nfr;': '𝔑',\n\t'NoBreak;': '⁠',\n\t'NonBreakingSpace;': ' ',\n\t'Nopf;': 'ℕ',\n\t'Not;': '⫬',\n\t'NotCongruent;': '≢',\n\t'NotCupCap;': '≭',\n\t'NotDoubleVerticalBar;': '∦',\n\t'NotElement;': '∉',\n\t'NotEqual;': '≠',\n\t'NotEqualTilde;': '≂̸',\n\t'NotExists;': '∄',\n\t'NotGreater;': '≯',\n\t'NotGreaterEqual;': '≱',\n\t'NotGreaterFullEqual;': '≧̸',\n\t'NotGreaterGreater;': '≫̸',\n\t'NotGreaterLess;': '≹',\n\t'NotGreaterSlantEqual;': '⩾̸',\n\t'NotGreaterTilde;': '≵',\n\t'NotHumpDownHump;': '≎̸',\n\t'NotHumpEqual;': '≏̸',\n\t'NotLeftTriangle;': '⋪',\n\t'NotLeftTriangleBar;': '⧏̸',\n\t'NotLeftTriangleEqual;': '⋬',\n\t'NotLess;': '≮',\n\t'NotLessEqual;': '≰',\n\t'NotLessGreater;': '≸',\n\t'NotLessLess;': '≪̸',\n\t'NotLessSlantEqual;': '⩽̸',\n\t'NotLessTilde;': '≴',\n\t'NotNestedGreaterGreater;': '⪢̸',\n\t'NotNestedLessLess;': '⪡̸',\n\t'NotPrecedes;': '⊀',\n\t'NotPrecedesEqual;': '⪯̸',\n\t'NotPrecedesSlantEqual;': '⋠',\n\t'NotReverseElement;': '∌',\n\t'NotRightTriangle;': '⋫',\n\t'NotRightTriangleBar;': '⧐̸',\n\t'NotRightTriangleEqual;': '⋭',\n\t'NotSquareSubset;': '⊏̸',\n\t'NotSquareSubsetEqual;': '⋢',\n\t'NotSquareSuperset;': '⊐̸',\n\t'NotSquareSupersetEqual;': '⋣',\n\t'NotSubset;': '⊂⃒',\n\t'NotSubsetEqual;': '⊈',\n\t'NotSucceeds;': '⊁',\n\t'NotSucceedsEqual;': '⪰̸',\n\t'NotSucceedsSlantEqual;': '⋡',\n\t'NotSucceedsTilde;': '≿̸',\n\t'NotSuperset;': '⊃⃒',\n\t'NotSupersetEqual;': '⊉',\n\t'NotTilde;': '≁',\n\t'NotTildeEqual;': '≄',\n\t'NotTildeFullEqual;': '≇',\n\t'NotTildeTilde;': '≉',\n\t'NotVerticalBar;': '∤',\n\t'Nscr;': '𝒩',\n\tNtilde: 'Ñ',\n\t'Ntilde;': 'Ñ',\n\t'Nu;': 'Ν',\n\t'OElig;': 'Œ',\n\tOacute: 'Ó',\n\t'Oacute;': 'Ó',\n\tOcirc: 'Ô',\n\t'Ocirc;': 'Ô',\n\t'Ocy;': 'О',\n\t'Odblac;': 'Ő',\n\t'Ofr;': '𝔒',\n\tOgrave: 'Ò',\n\t'Ograve;': 'Ò',\n\t'Omacr;': 'Ō',\n\t'Omega;': 'Ω',\n\t'Omicron;': 'Ο',\n\t'Oopf;': '𝕆',\n\t'OpenCurlyDoubleQuote;': '“',\n\t'OpenCurlyQuote;': '‘',\n\t'Or;': '⩔',\n\t'Oscr;': '𝒪',\n\tOslash: 'Ø',\n\t'Oslash;': 'Ø',\n\tOtilde: 'Õ',\n\t'Otilde;': 'Õ',\n\t'Otimes;': '⨷',\n\tOuml: 'Ö',\n\t'Ouml;': 'Ö',\n\t'OverBar;': '‾',\n\t'OverBrace;': '⏞',\n\t'OverBracket;': '⎴',\n\t'OverParenthesis;': '⏜',\n\t'PartialD;': '∂',\n\t'Pcy;': 'П',\n\t'Pfr;': '𝔓',\n\t'Phi;': 'Φ',\n\t'Pi;': 'Π',\n\t'PlusMinus;': '±',\n\t'Poincareplane;': 'ℌ',\n\t'Popf;': 'ℙ',\n\t'Pr;': '⪻',\n\t'Precedes;': '≺',\n\t'PrecedesEqual;': '⪯',\n\t'PrecedesSlantEqual;': '≼',\n\t'PrecedesTilde;': '≾',\n\t'Prime;': '″',\n\t'Product;': '∏',\n\t'Proportion;': '∷',\n\t'Proportional;': '∝',\n\t'Pscr;': '𝒫',\n\t'Psi;': 'Ψ',\n\tQUOT: '\"',\n\t'QUOT;': '\"',\n\t'Qfr;': '𝔔',\n\t'Qopf;': 'ℚ',\n\t'Qscr;': '𝒬',\n\t'RBarr;': '⤐',\n\tREG: '®',\n\t'REG;': '®',\n\t'Racute;': 'Ŕ',\n\t'Rang;': '⟫',\n\t'Rarr;': '↠',\n\t'Rarrtl;': '⤖',\n\t'Rcaron;': 'Ř',\n\t'Rcedil;': 'Ŗ',\n\t'Rcy;': 'Р',\n\t'Re;': 'ℜ',\n\t'ReverseElement;': '∋',\n\t'ReverseEquilibrium;': '⇋',\n\t'ReverseUpEquilibrium;': '⥯',\n\t'Rfr;': 'ℜ',\n\t'Rho;': 'Ρ',\n\t'RightAngleBracket;': '⟩',\n\t'RightArrow;': '→',\n\t'RightArrowBar;': '⇥',\n\t'RightArrowLeftArrow;': '⇄',\n\t'RightCeiling;': '⌉',\n\t'RightDoubleBracket;': '⟧',\n\t'RightDownTeeVector;': '⥝',\n\t'RightDownVector;': '⇂',\n\t'RightDownVectorBar;': '⥕',\n\t'RightFloor;': '⌋',\n\t'RightTee;': '⊢',\n\t'RightTeeArrow;': '↦',\n\t'RightTeeVector;': '⥛',\n\t'RightTriangle;': '⊳',\n\t'RightTriangleBar;': '⧐',\n\t'RightTriangleEqual;': '⊵',\n\t'RightUpDownVector;': '⥏',\n\t'RightUpTeeVector;': '⥜',\n\t'RightUpVector;': '↾',\n\t'RightUpVectorBar;': '⥔',\n\t'RightVector;': '⇀',\n\t'RightVectorBar;': '⥓',\n\t'Rightarrow;': '⇒',\n\t'Ropf;': 'ℝ',\n\t'RoundImplies;': '⥰',\n\t'Rrightarrow;': '⇛',\n\t'Rscr;': 'ℛ',\n\t'Rsh;': '↱',\n\t'RuleDelayed;': '⧴',\n\t'SHCHcy;': 'Щ',\n\t'SHcy;': 'Ш',\n\t'SOFTcy;': 'Ь',\n\t'Sacute;': 'Ś',\n\t'Sc;': '⪼',\n\t'Scaron;': 'Š',\n\t'Scedil;': 'Ş',\n\t'Scirc;': 'Ŝ',\n\t'Scy;': 'С',\n\t'Sfr;': '𝔖',\n\t'ShortDownArrow;': '↓',\n\t'ShortLeftArrow;': '←',\n\t'ShortRightArrow;': '→',\n\t'ShortUpArrow;': '↑',\n\t'Sigma;': 'Σ',\n\t'SmallCircle;': '∘',\n\t'Sopf;': '𝕊',\n\t'Sqrt;': '√',\n\t'Square;': '□',\n\t'SquareIntersection;': '⊓',\n\t'SquareSubset;': '⊏',\n\t'SquareSubsetEqual;': '⊑',\n\t'SquareSuperset;': '⊐',\n\t'SquareSupersetEqual;': '⊒',\n\t'SquareUnion;': '⊔',\n\t'Sscr;': '𝒮',\n\t'Star;': '⋆',\n\t'Sub;': '⋐',\n\t'Subset;': '⋐',\n\t'SubsetEqual;': '⊆',\n\t'Succeeds;': '≻',\n\t'SucceedsEqual;': '⪰',\n\t'SucceedsSlantEqual;': '≽',\n\t'SucceedsTilde;': '≿',\n\t'SuchThat;': '∋',\n\t'Sum;': '∑',\n\t'Sup;': '⋑',\n\t'Superset;': '⊃',\n\t'SupersetEqual;': '⊇',\n\t'Supset;': '⋑',\n\tTHORN: 'Þ',\n\t'THORN;': 'Þ',\n\t'TRADE;': '™',\n\t'TSHcy;': 'Ћ',\n\t'TScy;': 'Ц',\n\t'Tab;': '\\t',\n\t'Tau;': 'Τ',\n\t'Tcaron;': 'Ť',\n\t'Tcedil;': 'Ţ',\n\t'Tcy;': 'Т',\n\t'Tfr;': '𝔗',\n\t'Therefore;': '∴',\n\t'Theta;': 'Θ',\n\t'ThickSpace;': '  ',\n\t'ThinSpace;': ' ',\n\t'Tilde;': '∼',\n\t'TildeEqual;': '≃',\n\t'TildeFullEqual;': '≅',\n\t'TildeTilde;': '≈',\n\t'Topf;': '𝕋',\n\t'TripleDot;': '⃛',\n\t'Tscr;': '𝒯',\n\t'Tstrok;': 'Ŧ',\n\tUacute: 'Ú',\n\t'Uacute;': 'Ú',\n\t'Uarr;': '↟',\n\t'Uarrocir;': '⥉',\n\t'Ubrcy;': 'Ў',\n\t'Ubreve;': 'Ŭ',\n\tUcirc: 'Û',\n\t'Ucirc;': 'Û',\n\t'Ucy;': 'У',\n\t'Udblac;': 'Ű',\n\t'Ufr;': '𝔘',\n\tUgrave: 'Ù',\n\t'Ugrave;': 'Ù',\n\t'Umacr;': 'Ū',\n\t'UnderBar;': '_',\n\t'UnderBrace;': '⏟',\n\t'UnderBracket;': '⎵',\n\t'UnderParenthesis;': '⏝',\n\t'Union;': '⋃',\n\t'UnionPlus;': '⊎',\n\t'Uogon;': 'Ų',\n\t'Uopf;': '𝕌',\n\t'UpArrow;': '↑',\n\t'UpArrowBar;': '⤒',\n\t'UpArrowDownArrow;': '⇅',\n\t'UpDownArrow;': '↕',\n\t'UpEquilibrium;': '⥮',\n\t'UpTee;': '⊥',\n\t'UpTeeArrow;': '↥',\n\t'Uparrow;': '⇑',\n\t'Updownarrow;': '⇕',\n\t'UpperLeftArrow;': '↖',\n\t'UpperRightArrow;': '↗',\n\t'Upsi;': 'ϒ',\n\t'Upsilon;': 'Υ',\n\t'Uring;': 'Ů',\n\t'Uscr;': '𝒰',\n\t'Utilde;': 'Ũ',\n\tUuml: 'Ü',\n\t'Uuml;': 'Ü',\n\t'VDash;': '⊫',\n\t'Vbar;': '⫫',\n\t'Vcy;': 'В',\n\t'Vdash;': '⊩',\n\t'Vdashl;': '⫦',\n\t'Vee;': '⋁',\n\t'Verbar;': '‖',\n\t'Vert;': '‖',\n\t'VerticalBar;': '∣',\n\t'VerticalLine;': '|',\n\t'VerticalSeparator;': '❘',\n\t'VerticalTilde;': '≀',\n\t'VeryThinSpace;': ' ',\n\t'Vfr;': '𝔙',\n\t'Vopf;': '𝕍',\n\t'Vscr;': '𝒱',\n\t'Vvdash;': '⊪',\n\t'Wcirc;': 'Ŵ',\n\t'Wedge;': '⋀',\n\t'Wfr;': '𝔚',\n\t'Wopf;': '𝕎',\n\t'Wscr;': '𝒲',\n\t'Xfr;': '𝔛',\n\t'Xi;': 'Ξ',\n\t'Xopf;': '𝕏',\n\t'Xscr;': '𝒳',\n\t'YAcy;': 'Я',\n\t'YIcy;': 'Ї',\n\t'YUcy;': 'Ю',\n\tYacute: 'Ý',\n\t'Yacute;': 'Ý',\n\t'Ycirc;': 'Ŷ',\n\t'Ycy;': 'Ы',\n\t'Yfr;': '𝔜',\n\t'Yopf;': '𝕐',\n\t'Yscr;': '𝒴',\n\t'Yuml;': 'Ÿ',\n\t'ZHcy;': 'Ж',\n\t'Zacute;': 'Ź',\n\t'Zcaron;': 'Ž',\n\t'Zcy;': 'З',\n\t'Zdot;': 'Ż',\n\t'ZeroWidthSpace;': '​',\n\t'Zeta;': 'Ζ',\n\t'Zfr;': 'ℨ',\n\t'Zopf;': 'ℤ',\n\t'Zscr;': '𝒵',\n\taacute: 'á',\n\t'aacute;': 'á',\n\t'abreve;': 'ă',\n\t'ac;': '∾',\n\t'acE;': '∾̳',\n\t'acd;': '∿',\n\tacirc: 'â',\n\t'acirc;': 'â',\n\tacute: '´',\n\t'acute;': '´',\n\t'acy;': 'а',\n\taelig: 'æ',\n\t'aelig;': 'æ',\n\t'af;': '⁡',\n\t'afr;': '𝔞',\n\tagrave: 'à',\n\t'agrave;': 'à',\n\t'alefsym;': 'ℵ',\n\t'aleph;': 'ℵ',\n\t'alpha;': 'α',\n\t'amacr;': 'ā',\n\t'amalg;': '⨿',\n\tamp: '&',\n\t'amp;': '&',\n\t'and;': '∧',\n\t'andand;': '⩕',\n\t'andd;': '⩜',\n\t'andslope;': '⩘',\n\t'andv;': '⩚',\n\t'ang;': '∠',\n\t'ange;': '⦤',\n\t'angle;': '∠',\n\t'angmsd;': '∡',\n\t'angmsdaa;': '⦨',\n\t'angmsdab;': '⦩',\n\t'angmsdac;': '⦪',\n\t'angmsdad;': '⦫',\n\t'angmsdae;': '⦬',\n\t'angmsdaf;': '⦭',\n\t'angmsdag;': '⦮',\n\t'angmsdah;': '⦯',\n\t'angrt;': '∟',\n\t'angrtvb;': '⊾',\n\t'angrtvbd;': '⦝',\n\t'angsph;': '∢',\n\t'angst;': 'Å',\n\t'angzarr;': '⍼',\n\t'aogon;': 'ą',\n\t'aopf;': '𝕒',\n\t'ap;': '≈',\n\t'apE;': '⩰',\n\t'apacir;': '⩯',\n\t'ape;': '≊',\n\t'apid;': '≋',\n\t'apos;': \"'\",\n\t'approx;': '≈',\n\t'approxeq;': '≊',\n\taring: 'å',\n\t'aring;': 'å',\n\t'ascr;': '𝒶',\n\t'ast;': '*',\n\t'asymp;': '≈',\n\t'asympeq;': '≍',\n\tatilde: 'ã',\n\t'atilde;': 'ã',\n\tauml: 'ä',\n\t'auml;': 'ä',\n\t'awconint;': '∳',\n\t'awint;': '⨑',\n\t'bNot;': '⫭',\n\t'backcong;': '≌',\n\t'backepsilon;': '϶',\n\t'backprime;': '‵',\n\t'backsim;': '∽',\n\t'backsimeq;': '⋍',\n\t'barvee;': '⊽',\n\t'barwed;': '⌅',\n\t'barwedge;': '⌅',\n\t'bbrk;': '⎵',\n\t'bbrktbrk;': '⎶',\n\t'bcong;': '≌',\n\t'bcy;': 'б',\n\t'bdquo;': '„',\n\t'becaus;': '∵',\n\t'because;': '∵',\n\t'bemptyv;': '⦰',\n\t'bepsi;': '϶',\n\t'bernou;': 'ℬ',\n\t'beta;': 'β',\n\t'beth;': 'ℶ',\n\t'between;': '≬',\n\t'bfr;': '𝔟',\n\t'bigcap;': '⋂',\n\t'bigcirc;': '◯',\n\t'bigcup;': '⋃',\n\t'bigodot;': '⨀',\n\t'bigoplus;': '⨁',\n\t'bigotimes;': '⨂',\n\t'bigsqcup;': '⨆',\n\t'bigstar;': '★',\n\t'bigtriangledown;': '▽',\n\t'bigtriangleup;': '△',\n\t'biguplus;': '⨄',\n\t'bigvee;': '⋁',\n\t'bigwedge;': '⋀',\n\t'bkarow;': '⤍',\n\t'blacklozenge;': '⧫',\n\t'blacksquare;': '▪',\n\t'blacktriangle;': '▴',\n\t'blacktriangledown;': '▾',\n\t'blacktriangleleft;': '◂',\n\t'blacktriangleright;': '▸',\n\t'blank;': '␣',\n\t'blk12;': '▒',\n\t'blk14;': '░',\n\t'blk34;': '▓',\n\t'block;': '█',\n\t'bne;': '=⃥',\n\t'bnequiv;': '≡⃥',\n\t'bnot;': '⌐',\n\t'bopf;': '𝕓',\n\t'bot;': '⊥',\n\t'bottom;': '⊥',\n\t'bowtie;': '⋈',\n\t'boxDL;': '╗',\n\t'boxDR;': '╔',\n\t'boxDl;': '╖',\n\t'boxDr;': '╓',\n\t'boxH;': '═',\n\t'boxHD;': '╦',\n\t'boxHU;': '╩',\n\t'boxHd;': '╤',\n\t'boxHu;': '╧',\n\t'boxUL;': '╝',\n\t'boxUR;': '╚',\n\t'boxUl;': '╜',\n\t'boxUr;': '╙',\n\t'boxV;': '║',\n\t'boxVH;': '╬',\n\t'boxVL;': '╣',\n\t'boxVR;': '╠',\n\t'boxVh;': '╫',\n\t'boxVl;': '╢',\n\t'boxVr;': '╟',\n\t'boxbox;': '⧉',\n\t'boxdL;': '╕',\n\t'boxdR;': '╒',\n\t'boxdl;': '┐',\n\t'boxdr;': '┌',\n\t'boxh;': '─',\n\t'boxhD;': '╥',\n\t'boxhU;': '╨',\n\t'boxhd;': '┬',\n\t'boxhu;': '┴',\n\t'boxminus;': '⊟',\n\t'boxplus;': '⊞',\n\t'boxtimes;': '⊠',\n\t'boxuL;': '╛',\n\t'boxuR;': '╘',\n\t'boxul;': '┘',\n\t'boxur;': '└',\n\t'boxv;': '│',\n\t'boxvH;': '╪',\n\t'boxvL;': '╡',\n\t'boxvR;': '╞',\n\t'boxvh;': '┼',\n\t'boxvl;': '┤',\n\t'boxvr;': '├',\n\t'bprime;': '‵',\n\t'breve;': '˘',\n\tbrvbar: '¦',\n\t'brvbar;': '¦',\n\t'bscr;': '𝒷',\n\t'bsemi;': '⁏',\n\t'bsim;': '∽',\n\t'bsime;': '⋍',\n\t'bsol;': '\\\\',\n\t'bsolb;': '⧅',\n\t'bsolhsub;': '⟈',\n\t'bull;': '•',\n\t'bullet;': '•',\n\t'bump;': '≎',\n\t'bumpE;': '⪮',\n\t'bumpe;': '≏',\n\t'bumpeq;': '≏',\n\t'cacute;': 'ć',\n\t'cap;': '∩',\n\t'capand;': '⩄',\n\t'capbrcup;': '⩉',\n\t'capcap;': '⩋',\n\t'capcup;': '⩇',\n\t'capdot;': '⩀',\n\t'caps;': '∩︀',\n\t'caret;': '⁁',\n\t'caron;': 'ˇ',\n\t'ccaps;': '⩍',\n\t'ccaron;': 'č',\n\tccedil: 'ç',\n\t'ccedil;': 'ç',\n\t'ccirc;': 'ĉ',\n\t'ccups;': '⩌',\n\t'ccupssm;': '⩐',\n\t'cdot;': 'ċ',\n\tcedil: '¸',\n\t'cedil;': '¸',\n\t'cemptyv;': '⦲',\n\tcent: '¢',\n\t'cent;': '¢',\n\t'centerdot;': '·',\n\t'cfr;': '𝔠',\n\t'chcy;': 'ч',\n\t'check;': '✓',\n\t'checkmark;': '✓',\n\t'chi;': 'χ',\n\t'cir;': '○',\n\t'cirE;': '⧃',\n\t'circ;': 'ˆ',\n\t'circeq;': '≗',\n\t'circlearrowleft;': '↺',\n\t'circlearrowright;': '↻',\n\t'circledR;': '®',\n\t'circledS;': 'Ⓢ',\n\t'circledast;': '⊛',\n\t'circledcirc;': '⊚',\n\t'circleddash;': '⊝',\n\t'cire;': '≗',\n\t'cirfnint;': '⨐',\n\t'cirmid;': '⫯',\n\t'cirscir;': '⧂',\n\t'clubs;': '♣',\n\t'clubsuit;': '♣',\n\t'colon;': ':',\n\t'colone;': '≔',\n\t'coloneq;': '≔',\n\t'comma;': ',',\n\t'commat;': '@',\n\t'comp;': '∁',\n\t'compfn;': '∘',\n\t'complement;': '∁',\n\t'complexes;': 'ℂ',\n\t'cong;': '≅',\n\t'congdot;': '⩭',\n\t'conint;': '∮',\n\t'copf;': '𝕔',\n\t'coprod;': '∐',\n\tcopy: '©',\n\t'copy;': '©',\n\t'copysr;': '℗',\n\t'crarr;': '↵',\n\t'cross;': '✗',\n\t'cscr;': '𝒸',\n\t'csub;': '⫏',\n\t'csube;': '⫑',\n\t'csup;': '⫐',\n\t'csupe;': '⫒',\n\t'ctdot;': '⋯',\n\t'cudarrl;': '⤸',\n\t'cudarrr;': '⤵',\n\t'cuepr;': '⋞',\n\t'cuesc;': '⋟',\n\t'cularr;': '↶',\n\t'cularrp;': '⤽',\n\t'cup;': '∪',\n\t'cupbrcap;': '⩈',\n\t'cupcap;': '⩆',\n\t'cupcup;': '⩊',\n\t'cupdot;': '⊍',\n\t'cupor;': '⩅',\n\t'cups;': '∪︀',\n\t'curarr;': '↷',\n\t'curarrm;': '⤼',\n\t'curlyeqprec;': '⋞',\n\t'curlyeqsucc;': '⋟',\n\t'curlyvee;': '⋎',\n\t'curlywedge;': '⋏',\n\tcurren: '¤',\n\t'curren;': '¤',\n\t'curvearrowleft;': '↶',\n\t'curvearrowright;': '↷',\n\t'cuvee;': '⋎',\n\t'cuwed;': '⋏',\n\t'cwconint;': '∲',\n\t'cwint;': '∱',\n\t'cylcty;': '⌭',\n\t'dArr;': '⇓',\n\t'dHar;': '⥥',\n\t'dagger;': '†',\n\t'daleth;': 'ℸ',\n\t'darr;': '↓',\n\t'dash;': '‐',\n\t'dashv;': '⊣',\n\t'dbkarow;': '⤏',\n\t'dblac;': '˝',\n\t'dcaron;': 'ď',\n\t'dcy;': 'д',\n\t'dd;': 'ⅆ',\n\t'ddagger;': '‡',\n\t'ddarr;': '⇊',\n\t'ddotseq;': '⩷',\n\tdeg: '°',\n\t'deg;': '°',\n\t'delta;': 'δ',\n\t'demptyv;': '⦱',\n\t'dfisht;': '⥿',\n\t'dfr;': '𝔡',\n\t'dharl;': '⇃',\n\t'dharr;': '⇂',\n\t'diam;': '⋄',\n\t'diamond;': '⋄',\n\t'diamondsuit;': '♦',\n\t'diams;': '♦',\n\t'die;': '¨',\n\t'digamma;': 'ϝ',\n\t'disin;': '⋲',\n\t'div;': '÷',\n\tdivide: '÷',\n\t'divide;': '÷',\n\t'divideontimes;': '⋇',\n\t'divonx;': '⋇',\n\t'djcy;': 'ђ',\n\t'dlcorn;': '⌞',\n\t'dlcrop;': '⌍',\n\t'dollar;': '$',\n\t'dopf;': '𝕕',\n\t'dot;': '˙',\n\t'doteq;': '≐',\n\t'doteqdot;': '≑',\n\t'dotminus;': '∸',\n\t'dotplus;': '∔',\n\t'dotsquare;': '⊡',\n\t'doublebarwedge;': '⌆',\n\t'downarrow;': '↓',\n\t'downdownarrows;': '⇊',\n\t'downharpoonleft;': '⇃',\n\t'downharpoonright;': '⇂',\n\t'drbkarow;': '⤐',\n\t'drcorn;': '⌟',\n\t'drcrop;': '⌌',\n\t'dscr;': '𝒹',\n\t'dscy;': 'ѕ',\n\t'dsol;': '⧶',\n\t'dstrok;': 'đ',\n\t'dtdot;': '⋱',\n\t'dtri;': '▿',\n\t'dtrif;': '▾',\n\t'duarr;': '⇵',\n\t'duhar;': '⥯',\n\t'dwangle;': '⦦',\n\t'dzcy;': 'џ',\n\t'dzigrarr;': '⟿',\n\t'eDDot;': '⩷',\n\t'eDot;': '≑',\n\teacute: 'é',\n\t'eacute;': 'é',\n\t'easter;': '⩮',\n\t'ecaron;': 'ě',\n\t'ecir;': '≖',\n\tecirc: 'ê',\n\t'ecirc;': 'ê',\n\t'ecolon;': '≕',\n\t'ecy;': 'э',\n\t'edot;': 'ė',\n\t'ee;': 'ⅇ',\n\t'efDot;': '≒',\n\t'efr;': '𝔢',\n\t'eg;': '⪚',\n\tegrave: 'è',\n\t'egrave;': 'è',\n\t'egs;': '⪖',\n\t'egsdot;': '⪘',\n\t'el;': '⪙',\n\t'elinters;': '⏧',\n\t'ell;': 'ℓ',\n\t'els;': '⪕',\n\t'elsdot;': '⪗',\n\t'emacr;': 'ē',\n\t'empty;': '∅',\n\t'emptyset;': '∅',\n\t'emptyv;': '∅',\n\t'emsp13;': ' ',\n\t'emsp14;': ' ',\n\t'emsp;': ' ',\n\t'eng;': 'ŋ',\n\t'ensp;': ' ',\n\t'eogon;': 'ę',\n\t'eopf;': '𝕖',\n\t'epar;': '⋕',\n\t'eparsl;': '⧣',\n\t'eplus;': '⩱',\n\t'epsi;': 'ε',\n\t'epsilon;': 'ε',\n\t'epsiv;': 'ϵ',\n\t'eqcirc;': '≖',\n\t'eqcolon;': '≕',\n\t'eqsim;': '≂',\n\t'eqslantgtr;': '⪖',\n\t'eqslantless;': '⪕',\n\t'equals;': '=',\n\t'equest;': '≟',\n\t'equiv;': '≡',\n\t'equivDD;': '⩸',\n\t'eqvparsl;': '⧥',\n\t'erDot;': '≓',\n\t'erarr;': '⥱',\n\t'escr;': 'ℯ',\n\t'esdot;': '≐',\n\t'esim;': '≂',\n\t'eta;': 'η',\n\teth: 'ð',\n\t'eth;': 'ð',\n\teuml: 'ë',\n\t'euml;': 'ë',\n\t'euro;': '€',\n\t'excl;': '!',\n\t'exist;': '∃',\n\t'expectation;': 'ℰ',\n\t'exponentiale;': 'ⅇ',\n\t'fallingdotseq;': '≒',\n\t'fcy;': 'ф',\n\t'female;': '♀',\n\t'ffilig;': 'ﬃ',\n\t'fflig;': 'ﬀ',\n\t'ffllig;': 'ﬄ',\n\t'ffr;': '𝔣',\n\t'filig;': 'ﬁ',\n\t'fjlig;': 'fj',\n\t'flat;': '♭',\n\t'fllig;': 'ﬂ',\n\t'fltns;': '▱',\n\t'fnof;': 'ƒ',\n\t'fopf;': '𝕗',\n\t'forall;': '∀',\n\t'fork;': '⋔',\n\t'forkv;': '⫙',\n\t'fpartint;': '⨍',\n\tfrac12: '½',\n\t'frac12;': '½',\n\t'frac13;': '⅓',\n\tfrac14: '¼',\n\t'frac14;': '¼',\n\t'frac15;': '⅕',\n\t'frac16;': '⅙',\n\t'frac18;': '⅛',\n\t'frac23;': '⅔',\n\t'frac25;': '⅖',\n\tfrac34: '¾',\n\t'frac34;': '¾',\n\t'frac35;': '⅗',\n\t'frac38;': '⅜',\n\t'frac45;': '⅘',\n\t'frac56;': '⅚',\n\t'frac58;': '⅝',\n\t'frac78;': '⅞',\n\t'frasl;': '⁄',\n\t'frown;': '⌢',\n\t'fscr;': '𝒻',\n\t'gE;': '≧',\n\t'gEl;': '⪌',\n\t'gacute;': 'ǵ',\n\t'gamma;': 'γ',\n\t'gammad;': 'ϝ',\n\t'gap;': '⪆',\n\t'gbreve;': 'ğ',\n\t'gcirc;': 'ĝ',\n\t'gcy;': 'г',\n\t'gdot;': 'ġ',\n\t'ge;': '≥',\n\t'gel;': '⋛',\n\t'geq;': '≥',\n\t'geqq;': '≧',\n\t'geqslant;': '⩾',\n\t'ges;': '⩾',\n\t'gescc;': '⪩',\n\t'gesdot;': '⪀',\n\t'gesdoto;': '⪂',\n\t'gesdotol;': '⪄',\n\t'gesl;': '⋛︀',\n\t'gesles;': '⪔',\n\t'gfr;': '𝔤',\n\t'gg;': '≫',\n\t'ggg;': '⋙',\n\t'gimel;': 'ℷ',\n\t'gjcy;': 'ѓ',\n\t'gl;': '≷',\n\t'glE;': '⪒',\n\t'gla;': '⪥',\n\t'glj;': '⪤',\n\t'gnE;': '≩',\n\t'gnap;': '⪊',\n\t'gnapprox;': '⪊',\n\t'gne;': '⪈',\n\t'gneq;': '⪈',\n\t'gneqq;': '≩',\n\t'gnsim;': '⋧',\n\t'gopf;': '𝕘',\n\t'grave;': '`',\n\t'gscr;': 'ℊ',\n\t'gsim;': '≳',\n\t'gsime;': '⪎',\n\t'gsiml;': '⪐',\n\tgt: '>',\n\t'gt;': '>',\n\t'gtcc;': '⪧',\n\t'gtcir;': '⩺',\n\t'gtdot;': '⋗',\n\t'gtlPar;': '⦕',\n\t'gtquest;': '⩼',\n\t'gtrapprox;': '⪆',\n\t'gtrarr;': '⥸',\n\t'gtrdot;': '⋗',\n\t'gtreqless;': '⋛',\n\t'gtreqqless;': '⪌',\n\t'gtrless;': '≷',\n\t'gtrsim;': '≳',\n\t'gvertneqq;': '≩︀',\n\t'gvnE;': '≩︀',\n\t'hArr;': '⇔',\n\t'hairsp;': ' ',\n\t'half;': '½',\n\t'hamilt;': 'ℋ',\n\t'hardcy;': 'ъ',\n\t'harr;': '↔',\n\t'harrcir;': '⥈',\n\t'harrw;': '↭',\n\t'hbar;': 'ℏ',\n\t'hcirc;': 'ĥ',\n\t'hearts;': '♥',\n\t'heartsuit;': '♥',\n\t'hellip;': '…',\n\t'hercon;': '⊹',\n\t'hfr;': '𝔥',\n\t'hksearow;': '⤥',\n\t'hkswarow;': '⤦',\n\t'hoarr;': '⇿',\n\t'homtht;': '∻',\n\t'hookleftarrow;': '↩',\n\t'hookrightarrow;': '↪',\n\t'hopf;': '𝕙',\n\t'horbar;': '―',\n\t'hscr;': '𝒽',\n\t'hslash;': 'ℏ',\n\t'hstrok;': 'ħ',\n\t'hybull;': '⁃',\n\t'hyphen;': '‐',\n\tiacute: 'í',\n\t'iacute;': 'í',\n\t'ic;': '⁣',\n\ticirc: 'î',\n\t'icirc;': 'î',\n\t'icy;': 'и',\n\t'iecy;': 'е',\n\tiexcl: '¡',\n\t'iexcl;': '¡',\n\t'iff;': '⇔',\n\t'ifr;': '𝔦',\n\tigrave: 'ì',\n\t'igrave;': 'ì',\n\t'ii;': 'ⅈ',\n\t'iiiint;': '⨌',\n\t'iiint;': '∭',\n\t'iinfin;': '⧜',\n\t'iiota;': '℩',\n\t'ijlig;': 'ĳ',\n\t'imacr;': 'ī',\n\t'image;': 'ℑ',\n\t'imagline;': 'ℐ',\n\t'imagpart;': 'ℑ',\n\t'imath;': 'ı',\n\t'imof;': '⊷',\n\t'imped;': 'Ƶ',\n\t'in;': '∈',\n\t'incare;': '℅',\n\t'infin;': '∞',\n\t'infintie;': '⧝',\n\t'inodot;': 'ı',\n\t'int;': '∫',\n\t'intcal;': '⊺',\n\t'integers;': 'ℤ',\n\t'intercal;': '⊺',\n\t'intlarhk;': '⨗',\n\t'intprod;': '⨼',\n\t'iocy;': 'ё',\n\t'iogon;': 'į',\n\t'iopf;': '𝕚',\n\t'iota;': 'ι',\n\t'iprod;': '⨼',\n\tiquest: '¿',\n\t'iquest;': '¿',\n\t'iscr;': '𝒾',\n\t'isin;': '∈',\n\t'isinE;': '⋹',\n\t'isindot;': '⋵',\n\t'isins;': '⋴',\n\t'isinsv;': '⋳',\n\t'isinv;': '∈',\n\t'it;': '⁢',\n\t'itilde;': 'ĩ',\n\t'iukcy;': 'і',\n\tiuml: 'ï',\n\t'iuml;': 'ï',\n\t'jcirc;': 'ĵ',\n\t'jcy;': 'й',\n\t'jfr;': '𝔧',\n\t'jmath;': 'ȷ',\n\t'jopf;': '𝕛',\n\t'jscr;': '𝒿',\n\t'jsercy;': 'ј',\n\t'jukcy;': 'є',\n\t'kappa;': 'κ',\n\t'kappav;': 'ϰ',\n\t'kcedil;': 'ķ',\n\t'kcy;': 'к',\n\t'kfr;': '𝔨',\n\t'kgreen;': 'ĸ',\n\t'khcy;': 'х',\n\t'kjcy;': 'ќ',\n\t'kopf;': '𝕜',\n\t'kscr;': '𝓀',\n\t'lAarr;': '⇚',\n\t'lArr;': '⇐',\n\t'lAtail;': '⤛',\n\t'lBarr;': '⤎',\n\t'lE;': '≦',\n\t'lEg;': '⪋',\n\t'lHar;': '⥢',\n\t'lacute;': 'ĺ',\n\t'laemptyv;': '⦴',\n\t'lagran;': 'ℒ',\n\t'lambda;': 'λ',\n\t'lang;': '⟨',\n\t'langd;': '⦑',\n\t'langle;': '⟨',\n\t'lap;': '⪅',\n\tlaquo: '«',\n\t'laquo;': '«',\n\t'larr;': '←',\n\t'larrb;': '⇤',\n\t'larrbfs;': '⤟',\n\t'larrfs;': '⤝',\n\t'larrhk;': '↩',\n\t'larrlp;': '↫',\n\t'larrpl;': '⤹',\n\t'larrsim;': '⥳',\n\t'larrtl;': '↢',\n\t'lat;': '⪫',\n\t'latail;': '⤙',\n\t'late;': '⪭',\n\t'lates;': '⪭︀',\n\t'lbarr;': '⤌',\n\t'lbbrk;': '❲',\n\t'lbrace;': '{',\n\t'lbrack;': '[',\n\t'lbrke;': '⦋',\n\t'lbrksld;': '⦏',\n\t'lbrkslu;': '⦍',\n\t'lcaron;': 'ľ',\n\t'lcedil;': 'ļ',\n\t'lceil;': '⌈',\n\t'lcub;': '{',\n\t'lcy;': 'л',\n\t'ldca;': '⤶',\n\t'ldquo;': '“',\n\t'ldquor;': '„',\n\t'ldrdhar;': '⥧',\n\t'ldrushar;': '⥋',\n\t'ldsh;': '↲',\n\t'le;': '≤',\n\t'leftarrow;': '←',\n\t'leftarrowtail;': '↢',\n\t'leftharpoondown;': '↽',\n\t'leftharpoonup;': '↼',\n\t'leftleftarrows;': '⇇',\n\t'leftrightarrow;': '↔',\n\t'leftrightarrows;': '⇆',\n\t'leftrightharpoons;': '⇋',\n\t'leftrightsquigarrow;': '↭',\n\t'leftthreetimes;': '⋋',\n\t'leg;': '⋚',\n\t'leq;': '≤',\n\t'leqq;': '≦',\n\t'leqslant;': '⩽',\n\t'les;': '⩽',\n\t'lescc;': '⪨',\n\t'lesdot;': '⩿',\n\t'lesdoto;': '⪁',\n\t'lesdotor;': '⪃',\n\t'lesg;': '⋚︀',\n\t'lesges;': '⪓',\n\t'lessapprox;': '⪅',\n\t'lessdot;': '⋖',\n\t'lesseqgtr;': '⋚',\n\t'lesseqqgtr;': '⪋',\n\t'lessgtr;': '≶',\n\t'lesssim;': '≲',\n\t'lfisht;': '⥼',\n\t'lfloor;': '⌊',\n\t'lfr;': '𝔩',\n\t'lg;': '≶',\n\t'lgE;': '⪑',\n\t'lhard;': '↽',\n\t'lharu;': '↼',\n\t'lharul;': '⥪',\n\t'lhblk;': '▄',\n\t'ljcy;': 'љ',\n\t'll;': '≪',\n\t'llarr;': '⇇',\n\t'llcorner;': '⌞',\n\t'llhard;': '⥫',\n\t'lltri;': '◺',\n\t'lmidot;': 'ŀ',\n\t'lmoust;': '⎰',\n\t'lmoustache;': '⎰',\n\t'lnE;': '≨',\n\t'lnap;': '⪉',\n\t'lnapprox;': '⪉',\n\t'lne;': '⪇',\n\t'lneq;': '⪇',\n\t'lneqq;': '≨',\n\t'lnsim;': '⋦',\n\t'loang;': '⟬',\n\t'loarr;': '⇽',\n\t'lobrk;': '⟦',\n\t'longleftarrow;': '⟵',\n\t'longleftrightarrow;': '⟷',\n\t'longmapsto;': '⟼',\n\t'longrightarrow;': '⟶',\n\t'looparrowleft;': '↫',\n\t'looparrowright;': '↬',\n\t'lopar;': '⦅',\n\t'lopf;': '𝕝',\n\t'loplus;': '⨭',\n\t'lotimes;': '⨴',\n\t'lowast;': '∗',\n\t'lowbar;': '_',\n\t'loz;': '◊',\n\t'lozenge;': '◊',\n\t'lozf;': '⧫',\n\t'lpar;': '(',\n\t'lparlt;': '⦓',\n\t'lrarr;': '⇆',\n\t'lrcorner;': '⌟',\n\t'lrhar;': '⇋',\n\t'lrhard;': '⥭',\n\t'lrm;': '‎',\n\t'lrtri;': '⊿',\n\t'lsaquo;': '‹',\n\t'lscr;': '𝓁',\n\t'lsh;': '↰',\n\t'lsim;': '≲',\n\t'lsime;': '⪍',\n\t'lsimg;': '⪏',\n\t'lsqb;': '[',\n\t'lsquo;': '‘',\n\t'lsquor;': '‚',\n\t'lstrok;': 'ł',\n\tlt: '<',\n\t'lt;': '<',\n\t'ltcc;': '⪦',\n\t'ltcir;': '⩹',\n\t'ltdot;': '⋖',\n\t'lthree;': '⋋',\n\t'ltimes;': '⋉',\n\t'ltlarr;': '⥶',\n\t'ltquest;': '⩻',\n\t'ltrPar;': '⦖',\n\t'ltri;': '◃',\n\t'ltrie;': '⊴',\n\t'ltrif;': '◂',\n\t'lurdshar;': '⥊',\n\t'luruhar;': '⥦',\n\t'lvertneqq;': '≨︀',\n\t'lvnE;': '≨︀',\n\t'mDDot;': '∺',\n\tmacr: '¯',\n\t'macr;': '¯',\n\t'male;': '♂',\n\t'malt;': '✠',\n\t'maltese;': '✠',\n\t'map;': '↦',\n\t'mapsto;': '↦',\n\t'mapstodown;': '↧',\n\t'mapstoleft;': '↤',\n\t'mapstoup;': '↥',\n\t'marker;': '▮',\n\t'mcomma;': '⨩',\n\t'mcy;': 'м',\n\t'mdash;': '—',\n\t'measuredangle;': '∡',\n\t'mfr;': '𝔪',\n\t'mho;': '℧',\n\tmicro: 'µ',\n\t'micro;': 'µ',\n\t'mid;': '∣',\n\t'midast;': '*',\n\t'midcir;': '⫰',\n\tmiddot: '·',\n\t'middot;': '·',\n\t'minus;': '−',\n\t'minusb;': '⊟',\n\t'minusd;': '∸',\n\t'minusdu;': '⨪',\n\t'mlcp;': '⫛',\n\t'mldr;': '…',\n\t'mnplus;': '∓',\n\t'models;': '⊧',\n\t'mopf;': '𝕞',\n\t'mp;': '∓',\n\t'mscr;': '𝓂',\n\t'mstpos;': '∾',\n\t'mu;': 'μ',\n\t'multimap;': '⊸',\n\t'mumap;': '⊸',\n\t'nGg;': '⋙̸',\n\t'nGt;': '≫⃒',\n\t'nGtv;': '≫̸',\n\t'nLeftarrow;': '⇍',\n\t'nLeftrightarrow;': '⇎',\n\t'nLl;': '⋘̸',\n\t'nLt;': '≪⃒',\n\t'nLtv;': '≪̸',\n\t'nRightarrow;': '⇏',\n\t'nVDash;': '⊯',\n\t'nVdash;': '⊮',\n\t'nabla;': '∇',\n\t'nacute;': 'ń',\n\t'nang;': '∠⃒',\n\t'nap;': '≉',\n\t'napE;': '⩰̸',\n\t'napid;': '≋̸',\n\t'napos;': 'ŉ',\n\t'napprox;': '≉',\n\t'natur;': '♮',\n\t'natural;': '♮',\n\t'naturals;': 'ℕ',\n\tnbsp: ' ',\n\t'nbsp;': ' ',\n\t'nbump;': '≎̸',\n\t'nbumpe;': '≏̸',\n\t'ncap;': '⩃',\n\t'ncaron;': 'ň',\n\t'ncedil;': 'ņ',\n\t'ncong;': '≇',\n\t'ncongdot;': '⩭̸',\n\t'ncup;': '⩂',\n\t'ncy;': 'н',\n\t'ndash;': '–',\n\t'ne;': '≠',\n\t'neArr;': '⇗',\n\t'nearhk;': '⤤',\n\t'nearr;': '↗',\n\t'nearrow;': '↗',\n\t'nedot;': '≐̸',\n\t'nequiv;': '≢',\n\t'nesear;': '⤨',\n\t'nesim;': '≂̸',\n\t'nexist;': '∄',\n\t'nexists;': '∄',\n\t'nfr;': '𝔫',\n\t'ngE;': '≧̸',\n\t'nge;': '≱',\n\t'ngeq;': '≱',\n\t'ngeqq;': '≧̸',\n\t'ngeqslant;': '⩾̸',\n\t'nges;': '⩾̸',\n\t'ngsim;': '≵',\n\t'ngt;': '≯',\n\t'ngtr;': '≯',\n\t'nhArr;': '⇎',\n\t'nharr;': '↮',\n\t'nhpar;': '⫲',\n\t'ni;': '∋',\n\t'nis;': '⋼',\n\t'nisd;': '⋺',\n\t'niv;': '∋',\n\t'njcy;': 'њ',\n\t'nlArr;': '⇍',\n\t'nlE;': '≦̸',\n\t'nlarr;': '↚',\n\t'nldr;': '‥',\n\t'nle;': '≰',\n\t'nleftarrow;': '↚',\n\t'nleftrightarrow;': '↮',\n\t'nleq;': '≰',\n\t'nleqq;': '≦̸',\n\t'nleqslant;': '⩽̸',\n\t'nles;': '⩽̸',\n\t'nless;': '≮',\n\t'nlsim;': '≴',\n\t'nlt;': '≮',\n\t'nltri;': '⋪',\n\t'nltrie;': '⋬',\n\t'nmid;': '∤',\n\t'nopf;': '𝕟',\n\tnot: '¬',\n\t'not;': '¬',\n\t'notin;': '∉',\n\t'notinE;': '⋹̸',\n\t'notindot;': '⋵̸',\n\t'notinva;': '∉',\n\t'notinvb;': '⋷',\n\t'notinvc;': '⋶',\n\t'notni;': '∌',\n\t'notniva;': '∌',\n\t'notnivb;': '⋾',\n\t'notnivc;': '⋽',\n\t'npar;': '∦',\n\t'nparallel;': '∦',\n\t'nparsl;': '⫽⃥',\n\t'npart;': '∂̸',\n\t'npolint;': '⨔',\n\t'npr;': '⊀',\n\t'nprcue;': '⋠',\n\t'npre;': '⪯̸',\n\t'nprec;': '⊀',\n\t'npreceq;': '⪯̸',\n\t'nrArr;': '⇏',\n\t'nrarr;': '↛',\n\t'nrarrc;': '⤳̸',\n\t'nrarrw;': '↝̸',\n\t'nrightarrow;': '↛',\n\t'nrtri;': '⋫',\n\t'nrtrie;': '⋭',\n\t'nsc;': '⊁',\n\t'nsccue;': '⋡',\n\t'nsce;': '⪰̸',\n\t'nscr;': '𝓃',\n\t'nshortmid;': '∤',\n\t'nshortparallel;': '∦',\n\t'nsim;': '≁',\n\t'nsime;': '≄',\n\t'nsimeq;': '≄',\n\t'nsmid;': '∤',\n\t'nspar;': '∦',\n\t'nsqsube;': '⋢',\n\t'nsqsupe;': '⋣',\n\t'nsub;': '⊄',\n\t'nsubE;': '⫅̸',\n\t'nsube;': '⊈',\n\t'nsubset;': '⊂⃒',\n\t'nsubseteq;': '⊈',\n\t'nsubseteqq;': '⫅̸',\n\t'nsucc;': '⊁',\n\t'nsucceq;': '⪰̸',\n\t'nsup;': '⊅',\n\t'nsupE;': '⫆̸',\n\t'nsupe;': '⊉',\n\t'nsupset;': '⊃⃒',\n\t'nsupseteq;': '⊉',\n\t'nsupseteqq;': '⫆̸',\n\t'ntgl;': '≹',\n\tntilde: 'ñ',\n\t'ntilde;': 'ñ',\n\t'ntlg;': '≸',\n\t'ntriangleleft;': '⋪',\n\t'ntrianglelefteq;': '⋬',\n\t'ntriangleright;': '⋫',\n\t'ntrianglerighteq;': '⋭',\n\t'nu;': 'ν',\n\t'num;': '#',\n\t'numero;': '№',\n\t'numsp;': ' ',\n\t'nvDash;': '⊭',\n\t'nvHarr;': '⤄',\n\t'nvap;': '≍⃒',\n\t'nvdash;': '⊬',\n\t'nvge;': '≥⃒',\n\t'nvgt;': '>⃒',\n\t'nvinfin;': '⧞',\n\t'nvlArr;': '⤂',\n\t'nvle;': '≤⃒',\n\t'nvlt;': '<⃒',\n\t'nvltrie;': '⊴⃒',\n\t'nvrArr;': '⤃',\n\t'nvrtrie;': '⊵⃒',\n\t'nvsim;': '∼⃒',\n\t'nwArr;': '⇖',\n\t'nwarhk;': '⤣',\n\t'nwarr;': '↖',\n\t'nwarrow;': '↖',\n\t'nwnear;': '⤧',\n\t'oS;': 'Ⓢ',\n\toacute: 'ó',\n\t'oacute;': 'ó',\n\t'oast;': '⊛',\n\t'ocir;': '⊚',\n\tocirc: 'ô',\n\t'ocirc;': 'ô',\n\t'ocy;': 'о',\n\t'odash;': '⊝',\n\t'odblac;': 'ő',\n\t'odiv;': '⨸',\n\t'odot;': '⊙',\n\t'odsold;': '⦼',\n\t'oelig;': 'œ',\n\t'ofcir;': '⦿',\n\t'ofr;': '𝔬',\n\t'ogon;': '˛',\n\tograve: 'ò',\n\t'ograve;': 'ò',\n\t'ogt;': '⧁',\n\t'ohbar;': '⦵',\n\t'ohm;': 'Ω',\n\t'oint;': '∮',\n\t'olarr;': '↺',\n\t'olcir;': '⦾',\n\t'olcross;': '⦻',\n\t'oline;': '‾',\n\t'olt;': '⧀',\n\t'omacr;': 'ō',\n\t'omega;': 'ω',\n\t'omicron;': 'ο',\n\t'omid;': '⦶',\n\t'ominus;': '⊖',\n\t'oopf;': '𝕠',\n\t'opar;': '⦷',\n\t'operp;': '⦹',\n\t'oplus;': '⊕',\n\t'or;': '∨',\n\t'orarr;': '↻',\n\t'ord;': '⩝',\n\t'order;': 'ℴ',\n\t'orderof;': 'ℴ',\n\tordf: 'ª',\n\t'ordf;': 'ª',\n\tordm: 'º',\n\t'ordm;': 'º',\n\t'origof;': '⊶',\n\t'oror;': '⩖',\n\t'orslope;': '⩗',\n\t'orv;': '⩛',\n\t'oscr;': 'ℴ',\n\toslash: 'ø',\n\t'oslash;': 'ø',\n\t'osol;': '⊘',\n\totilde: 'õ',\n\t'otilde;': 'õ',\n\t'otimes;': '⊗',\n\t'otimesas;': '⨶',\n\touml: 'ö',\n\t'ouml;': 'ö',\n\t'ovbar;': '⌽',\n\t'par;': '∥',\n\tpara: '¶',\n\t'para;': '¶',\n\t'parallel;': '∥',\n\t'parsim;': '⫳',\n\t'parsl;': '⫽',\n\t'part;': '∂',\n\t'pcy;': 'п',\n\t'percnt;': '%',\n\t'period;': '.',\n\t'permil;': '‰',\n\t'perp;': '⊥',\n\t'pertenk;': '‱',\n\t'pfr;': '𝔭',\n\t'phi;': 'φ',\n\t'phiv;': 'ϕ',\n\t'phmmat;': 'ℳ',\n\t'phone;': '☎',\n\t'pi;': 'π',\n\t'pitchfork;': '⋔',\n\t'piv;': 'ϖ',\n\t'planck;': 'ℏ',\n\t'planckh;': 'ℎ',\n\t'plankv;': 'ℏ',\n\t'plus;': '+',\n\t'plusacir;': '⨣',\n\t'plusb;': '⊞',\n\t'pluscir;': '⨢',\n\t'plusdo;': '∔',\n\t'plusdu;': '⨥',\n\t'pluse;': '⩲',\n\tplusmn: '±',\n\t'plusmn;': '±',\n\t'plussim;': '⨦',\n\t'plustwo;': '⨧',\n\t'pm;': '±',\n\t'pointint;': '⨕',\n\t'popf;': '𝕡',\n\tpound: '£',\n\t'pound;': '£',\n\t'pr;': '≺',\n\t'prE;': '⪳',\n\t'prap;': '⪷',\n\t'prcue;': '≼',\n\t'pre;': '⪯',\n\t'prec;': '≺',\n\t'precapprox;': '⪷',\n\t'preccurlyeq;': '≼',\n\t'preceq;': '⪯',\n\t'precnapprox;': '⪹',\n\t'precneqq;': '⪵',\n\t'precnsim;': '⋨',\n\t'precsim;': '≾',\n\t'prime;': '′',\n\t'primes;': 'ℙ',\n\t'prnE;': '⪵',\n\t'prnap;': '⪹',\n\t'prnsim;': '⋨',\n\t'prod;': '∏',\n\t'profalar;': '⌮',\n\t'profline;': '⌒',\n\t'profsurf;': '⌓',\n\t'prop;': '∝',\n\t'propto;': '∝',\n\t'prsim;': '≾',\n\t'prurel;': '⊰',\n\t'pscr;': '𝓅',\n\t'psi;': 'ψ',\n\t'puncsp;': ' ',\n\t'qfr;': '𝔮',\n\t'qint;': '⨌',\n\t'qopf;': '𝕢',\n\t'qprime;': '⁗',\n\t'qscr;': '𝓆',\n\t'quaternions;': 'ℍ',\n\t'quatint;': '⨖',\n\t'quest;': '?',\n\t'questeq;': '≟',\n\tquot: '\"',\n\t'quot;': '\"',\n\t'rAarr;': '⇛',\n\t'rArr;': '⇒',\n\t'rAtail;': '⤜',\n\t'rBarr;': '⤏',\n\t'rHar;': '⥤',\n\t'race;': '∽̱',\n\t'racute;': 'ŕ',\n\t'radic;': '√',\n\t'raemptyv;': '⦳',\n\t'rang;': '⟩',\n\t'rangd;': '⦒',\n\t'range;': '⦥',\n\t'rangle;': '⟩',\n\traquo: '»',\n\t'raquo;': '»',\n\t'rarr;': '→',\n\t'rarrap;': '⥵',\n\t'rarrb;': '⇥',\n\t'rarrbfs;': '⤠',\n\t'rarrc;': '⤳',\n\t'rarrfs;': '⤞',\n\t'rarrhk;': '↪',\n\t'rarrlp;': '↬',\n\t'rarrpl;': '⥅',\n\t'rarrsim;': '⥴',\n\t'rarrtl;': '↣',\n\t'rarrw;': '↝',\n\t'ratail;': '⤚',\n\t'ratio;': '∶',\n\t'rationals;': 'ℚ',\n\t'rbarr;': '⤍',\n\t'rbbrk;': '❳',\n\t'rbrace;': '}',\n\t'rbrack;': ']',\n\t'rbrke;': '⦌',\n\t'rbrksld;': '⦎',\n\t'rbrkslu;': '⦐',\n\t'rcaron;': 'ř',\n\t'rcedil;': 'ŗ',\n\t'rceil;': '⌉',\n\t'rcub;': '}',\n\t'rcy;': 'р',\n\t'rdca;': '⤷',\n\t'rdldhar;': '⥩',\n\t'rdquo;': '”',\n\t'rdquor;': '”',\n\t'rdsh;': '↳',\n\t'real;': 'ℜ',\n\t'realine;': 'ℛ',\n\t'realpart;': 'ℜ',\n\t'reals;': 'ℝ',\n\t'rect;': '▭',\n\treg: '®',\n\t'reg;': '®',\n\t'rfisht;': '⥽',\n\t'rfloor;': '⌋',\n\t'rfr;': '𝔯',\n\t'rhard;': '⇁',\n\t'rharu;': '⇀',\n\t'rharul;': '⥬',\n\t'rho;': 'ρ',\n\t'rhov;': 'ϱ',\n\t'rightarrow;': '→',\n\t'rightarrowtail;': '↣',\n\t'rightharpoondown;': '⇁',\n\t'rightharpoonup;': '⇀',\n\t'rightleftarrows;': '⇄',\n\t'rightleftharpoons;': '⇌',\n\t'rightrightarrows;': '⇉',\n\t'rightsquigarrow;': '↝',\n\t'rightthreetimes;': '⋌',\n\t'ring;': '˚',\n\t'risingdotseq;': '≓',\n\t'rlarr;': '⇄',\n\t'rlhar;': '⇌',\n\t'rlm;': '‏',\n\t'rmoust;': '⎱',\n\t'rmoustache;': '⎱',\n\t'rnmid;': '⫮',\n\t'roang;': '⟭',\n\t'roarr;': '⇾',\n\t'robrk;': '⟧',\n\t'ropar;': '⦆',\n\t'ropf;': '𝕣',\n\t'roplus;': '⨮',\n\t'rotimes;': '⨵',\n\t'rpar;': ')',\n\t'rpargt;': '⦔',\n\t'rppolint;': '⨒',\n\t'rrarr;': '⇉',\n\t'rsaquo;': '›',\n\t'rscr;': '𝓇',\n\t'rsh;': '↱',\n\t'rsqb;': ']',\n\t'rsquo;': '’',\n\t'rsquor;': '’',\n\t'rthree;': '⋌',\n\t'rtimes;': '⋊',\n\t'rtri;': '▹',\n\t'rtrie;': '⊵',\n\t'rtrif;': '▸',\n\t'rtriltri;': '⧎',\n\t'ruluhar;': '⥨',\n\t'rx;': '℞',\n\t'sacute;': 'ś',\n\t'sbquo;': '‚',\n\t'sc;': '≻',\n\t'scE;': '⪴',\n\t'scap;': '⪸',\n\t'scaron;': 'š',\n\t'sccue;': '≽',\n\t'sce;': '⪰',\n\t'scedil;': 'ş',\n\t'scirc;': 'ŝ',\n\t'scnE;': '⪶',\n\t'scnap;': '⪺',\n\t'scnsim;': '⋩',\n\t'scpolint;': '⨓',\n\t'scsim;': '≿',\n\t'scy;': 'с',\n\t'sdot;': '⋅',\n\t'sdotb;': '⊡',\n\t'sdote;': '⩦',\n\t'seArr;': '⇘',\n\t'searhk;': '⤥',\n\t'searr;': '↘',\n\t'searrow;': '↘',\n\tsect: '§',\n\t'sect;': '§',\n\t'semi;': ';',\n\t'seswar;': '⤩',\n\t'setminus;': '∖',\n\t'setmn;': '∖',\n\t'sext;': '✶',\n\t'sfr;': '𝔰',\n\t'sfrown;': '⌢',\n\t'sharp;': '♯',\n\t'shchcy;': 'щ',\n\t'shcy;': 'ш',\n\t'shortmid;': '∣',\n\t'shortparallel;': '∥',\n\tshy: '­',\n\t'shy;': '­',\n\t'sigma;': 'σ',\n\t'sigmaf;': 'ς',\n\t'sigmav;': 'ς',\n\t'sim;': '∼',\n\t'simdot;': '⩪',\n\t'sime;': '≃',\n\t'simeq;': '≃',\n\t'simg;': '⪞',\n\t'simgE;': '⪠',\n\t'siml;': '⪝',\n\t'simlE;': '⪟',\n\t'simne;': '≆',\n\t'simplus;': '⨤',\n\t'simrarr;': '⥲',\n\t'slarr;': '←',\n\t'smallsetminus;': '∖',\n\t'smashp;': '⨳',\n\t'smeparsl;': '⧤',\n\t'smid;': '∣',\n\t'smile;': '⌣',\n\t'smt;': '⪪',\n\t'smte;': '⪬',\n\t'smtes;': '⪬︀',\n\t'softcy;': 'ь',\n\t'sol;': '/',\n\t'solb;': '⧄',\n\t'solbar;': '⌿',\n\t'sopf;': '𝕤',\n\t'spades;': '♠',\n\t'spadesuit;': '♠',\n\t'spar;': '∥',\n\t'sqcap;': '⊓',\n\t'sqcaps;': '⊓︀',\n\t'sqcup;': '⊔',\n\t'sqcups;': '⊔︀',\n\t'sqsub;': '⊏',\n\t'sqsube;': '⊑',\n\t'sqsubset;': '⊏',\n\t'sqsubseteq;': '⊑',\n\t'sqsup;': '⊐',\n\t'sqsupe;': '⊒',\n\t'sqsupset;': '⊐',\n\t'sqsupseteq;': '⊒',\n\t'squ;': '□',\n\t'square;': '□',\n\t'squarf;': '▪',\n\t'squf;': '▪',\n\t'srarr;': '→',\n\t'sscr;': '𝓈',\n\t'ssetmn;': '∖',\n\t'ssmile;': '⌣',\n\t'sstarf;': '⋆',\n\t'star;': '☆',\n\t'starf;': '★',\n\t'straightepsilon;': 'ϵ',\n\t'straightphi;': 'ϕ',\n\t'strns;': '¯',\n\t'sub;': '⊂',\n\t'subE;': '⫅',\n\t'subdot;': '⪽',\n\t'sube;': '⊆',\n\t'subedot;': '⫃',\n\t'submult;': '⫁',\n\t'subnE;': '⫋',\n\t'subne;': '⊊',\n\t'subplus;': '⪿',\n\t'subrarr;': '⥹',\n\t'subset;': '⊂',\n\t'subseteq;': '⊆',\n\t'subseteqq;': '⫅',\n\t'subsetneq;': '⊊',\n\t'subsetneqq;': '⫋',\n\t'subsim;': '⫇',\n\t'subsub;': '⫕',\n\t'subsup;': '⫓',\n\t'succ;': '≻',\n\t'succapprox;': '⪸',\n\t'succcurlyeq;': '≽',\n\t'succeq;': '⪰',\n\t'succnapprox;': '⪺',\n\t'succneqq;': '⪶',\n\t'succnsim;': '⋩',\n\t'succsim;': '≿',\n\t'sum;': '∑',\n\t'sung;': '♪',\n\tsup1: '¹',\n\t'sup1;': '¹',\n\tsup2: '²',\n\t'sup2;': '²',\n\tsup3: '³',\n\t'sup3;': '³',\n\t'sup;': '⊃',\n\t'supE;': '⫆',\n\t'supdot;': '⪾',\n\t'supdsub;': '⫘',\n\t'supe;': '⊇',\n\t'supedot;': '⫄',\n\t'suphsol;': '⟉',\n\t'suphsub;': '⫗',\n\t'suplarr;': '⥻',\n\t'supmult;': '⫂',\n\t'supnE;': '⫌',\n\t'supne;': '⊋',\n\t'supplus;': '⫀',\n\t'supset;': '⊃',\n\t'supseteq;': '⊇',\n\t'supseteqq;': '⫆',\n\t'supsetneq;': '⊋',\n\t'supsetneqq;': '⫌',\n\t'supsim;': '⫈',\n\t'supsub;': '⫔',\n\t'supsup;': '⫖',\n\t'swArr;': '⇙',\n\t'swarhk;': '⤦',\n\t'swarr;': '↙',\n\t'swarrow;': '↙',\n\t'swnwar;': '⤪',\n\tszlig: 'ß',\n\t'szlig;': 'ß',\n\t'target;': '⌖',\n\t'tau;': 'τ',\n\t'tbrk;': '⎴',\n\t'tcaron;': 'ť',\n\t'tcedil;': 'ţ',\n\t'tcy;': 'т',\n\t'tdot;': '⃛',\n\t'telrec;': '⌕',\n\t'tfr;': '𝔱',\n\t'there4;': '∴',\n\t'therefore;': '∴',\n\t'theta;': 'θ',\n\t'thetasym;': 'ϑ',\n\t'thetav;': 'ϑ',\n\t'thickapprox;': '≈',\n\t'thicksim;': '∼',\n\t'thinsp;': ' ',\n\t'thkap;': '≈',\n\t'thksim;': '∼',\n\tthorn: 'þ',\n\t'thorn;': 'þ',\n\t'tilde;': '˜',\n\ttimes: '×',\n\t'times;': '×',\n\t'timesb;': '⊠',\n\t'timesbar;': '⨱',\n\t'timesd;': '⨰',\n\t'tint;': '∭',\n\t'toea;': '⤨',\n\t'top;': '⊤',\n\t'topbot;': '⌶',\n\t'topcir;': '⫱',\n\t'topf;': '𝕥',\n\t'topfork;': '⫚',\n\t'tosa;': '⤩',\n\t'tprime;': '‴',\n\t'trade;': '™',\n\t'triangle;': '▵',\n\t'triangledown;': '▿',\n\t'triangleleft;': '◃',\n\t'trianglelefteq;': '⊴',\n\t'triangleq;': '≜',\n\t'triangleright;': '▹',\n\t'trianglerighteq;': '⊵',\n\t'tridot;': '◬',\n\t'trie;': '≜',\n\t'triminus;': '⨺',\n\t'triplus;': '⨹',\n\t'trisb;': '⧍',\n\t'tritime;': '⨻',\n\t'trpezium;': '⏢',\n\t'tscr;': '𝓉',\n\t'tscy;': 'ц',\n\t'tshcy;': 'ћ',\n\t'tstrok;': 'ŧ',\n\t'twixt;': '≬',\n\t'twoheadleftarrow;': '↞',\n\t'twoheadrightarrow;': '↠',\n\t'uArr;': '⇑',\n\t'uHar;': '⥣',\n\tuacute: 'ú',\n\t'uacute;': 'ú',\n\t'uarr;': '↑',\n\t'ubrcy;': 'ў',\n\t'ubreve;': 'ŭ',\n\tucirc: 'û',\n\t'ucirc;': 'û',\n\t'ucy;': 'у',\n\t'udarr;': '⇅',\n\t'udblac;': 'ű',\n\t'udhar;': '⥮',\n\t'ufisht;': '⥾',\n\t'ufr;': '𝔲',\n\tugrave: 'ù',\n\t'ugrave;': 'ù',\n\t'uharl;': '↿',\n\t'uharr;': '↾',\n\t'uhblk;': '▀',\n\t'ulcorn;': '⌜',\n\t'ulcorner;': '⌜',\n\t'ulcrop;': '⌏',\n\t'ultri;': '◸',\n\t'umacr;': 'ū',\n\tuml: '¨',\n\t'uml;': '¨',\n\t'uogon;': 'ų',\n\t'uopf;': '𝕦',\n\t'uparrow;': '↑',\n\t'updownarrow;': '↕',\n\t'upharpoonleft;': '↿',\n\t'upharpoonright;': '↾',\n\t'uplus;': '⊎',\n\t'upsi;': 'υ',\n\t'upsih;': 'ϒ',\n\t'upsilon;': 'υ',\n\t'upuparrows;': '⇈',\n\t'urcorn;': '⌝',\n\t'urcorner;': '⌝',\n\t'urcrop;': '⌎',\n\t'uring;': 'ů',\n\t'urtri;': '◹',\n\t'uscr;': '𝓊',\n\t'utdot;': '⋰',\n\t'utilde;': 'ũ',\n\t'utri;': '▵',\n\t'utrif;': '▴',\n\t'uuarr;': '⇈',\n\tuuml: 'ü',\n\t'uuml;': 'ü',\n\t'uwangle;': '⦧',\n\t'vArr;': '⇕',\n\t'vBar;': '⫨',\n\t'vBarv;': '⫩',\n\t'vDash;': '⊨',\n\t'vangrt;': '⦜',\n\t'varepsilon;': 'ϵ',\n\t'varkappa;': 'ϰ',\n\t'varnothing;': '∅',\n\t'varphi;': 'ϕ',\n\t'varpi;': 'ϖ',\n\t'varpropto;': '∝',\n\t'varr;': '↕',\n\t'varrho;': 'ϱ',\n\t'varsigma;': 'ς',\n\t'varsubsetneq;': '⊊︀',\n\t'varsubsetneqq;': '⫋︀',\n\t'varsupsetneq;': '⊋︀',\n\t'varsupsetneqq;': '⫌︀',\n\t'vartheta;': 'ϑ',\n\t'vartriangleleft;': '⊲',\n\t'vartriangleright;': '⊳',\n\t'vcy;': 'в',\n\t'vdash;': '⊢',\n\t'vee;': '∨',\n\t'veebar;': '⊻',\n\t'veeeq;': '≚',\n\t'vellip;': '⋮',\n\t'verbar;': '|',\n\t'vert;': '|',\n\t'vfr;': '𝔳',\n\t'vltri;': '⊲',\n\t'vnsub;': '⊂⃒',\n\t'vnsup;': '⊃⃒',\n\t'vopf;': '𝕧',\n\t'vprop;': '∝',\n\t'vrtri;': '⊳',\n\t'vscr;': '𝓋',\n\t'vsubnE;': '⫋︀',\n\t'vsubne;': '⊊︀',\n\t'vsupnE;': '⫌︀',\n\t'vsupne;': '⊋︀',\n\t'vzigzag;': '⦚',\n\t'wcirc;': 'ŵ',\n\t'wedbar;': '⩟',\n\t'wedge;': '∧',\n\t'wedgeq;': '≙',\n\t'weierp;': '℘',\n\t'wfr;': '𝔴',\n\t'wopf;': '𝕨',\n\t'wp;': '℘',\n\t'wr;': '≀',\n\t'wreath;': '≀',\n\t'wscr;': '𝓌',\n\t'xcap;': '⋂',\n\t'xcirc;': '◯',\n\t'xcup;': '⋃',\n\t'xdtri;': '▽',\n\t'xfr;': '𝔵',\n\t'xhArr;': '⟺',\n\t'xharr;': '⟷',\n\t'xi;': 'ξ',\n\t'xlArr;': '⟸',\n\t'xlarr;': '⟵',\n\t'xmap;': '⟼',\n\t'xnis;': '⋻',\n\t'xodot;': '⨀',\n\t'xopf;': '𝕩',\n\t'xoplus;': '⨁',\n\t'xotime;': '⨂',\n\t'xrArr;': '⟹',\n\t'xrarr;': '⟶',\n\t'xscr;': '𝓍',\n\t'xsqcup;': '⨆',\n\t'xuplus;': '⨄',\n\t'xutri;': '△',\n\t'xvee;': '⋁',\n\t'xwedge;': '⋀',\n\tyacute: 'ý',\n\t'yacute;': 'ý',\n\t'yacy;': 'я',\n\t'ycirc;': 'ŷ',\n\t'ycy;': 'ы',\n\tyen: '¥',\n\t'yen;': '¥',\n\t'yfr;': '𝔶',\n\t'yicy;': 'ї',\n\t'yopf;': '𝕪',\n\t'yscr;': '𝓎',\n\t'yucy;': 'ю',\n\tyuml: 'ÿ',\n\t'yuml;': 'ÿ',\n\t'zacute;': 'ź',\n\t'zcaron;': 'ž',\n\t'zcy;': 'з',\n\t'zdot;': 'ż',\n\t'zeetrf;': 'ℨ',\n\t'zeta;': 'ζ',\n\t'zfr;': '𝔷',\n\t'zhcy;': 'ж',\n\t'zigrarr;': '⇝',\n\t'zopf;': '𝕫',\n\t'zscr;': '𝓏',\n\t'zwj;': '‍',\n\t'zwnj;': '‌'\n};\n\nconst numeric = /&#(x)?([0-9a-f]+);/i;\nconst named = new RegExp(\n\t`&(${Object.keys(entities)\n\t\t.sort((a, b) => b.length - a.length)\n\t\t.join('|')})`,\n\t'g'\n);\n\n/** @param {string} str */\nexport function decode(str) {\n\treturn str\n\t\t.replace(numeric, (_match, hex, code) => String.fromCharCode(hex ? parseInt(code, 16) : +code))\n\t\t.replace(named, (_match, entity) => entities[entity]);\n}\n"}},"fallback.js":{"file":{"contents":"import { readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { installPolyfills } from '../../exports/node/polyfills.js';\nimport { load_config } from '../config/index.js';\nimport { forked } from '../../utils/fork.js';\n\nexport default forked(import.meta.url, generate_fallback);\n\n/**\n * @param {{\n *   manifest_path: string;\n *   env: Record<string, string>\n * }} opts\n */\nasync function generate_fallback({ manifest_path, env }) {\n\t/** @type {import('types').ValidatedKitConfig} */\n\tconst config = (await load_config()).kit;\n\n\tinstallPolyfills();\n\n\tconst server_root = join(config.outDir, 'output');\n\n\t/** @type {import('types').ServerInternalModule} */\n\tconst { set_building } = await import(pathToFileURL(`${server_root}/server/internal.js`).href);\n\n\t/** @type {import('types').ServerModule} */\n\tconst { Server } = await import(pathToFileURL(`${server_root}/server/index.js`).href);\n\n\t/** @type {import('types').SSRManifest} */\n\tconst manifest = (await import(pathToFileURL(manifest_path).href)).manifest;\n\n\tset_building(true);\n\n\tconst server = new Server(manifest);\n\tawait server.init({ env });\n\n\tconst response = await server.respond(new Request(config.prerender.origin + '/[fallback]'), {\n\t\tgetClientAddress: () => {\n\t\t\tthrow new Error('Cannot read clientAddress during prerendering');\n\t\t},\n\t\tprerendering: {\n\t\t\tfallback: true,\n\t\t\tdependencies: new Map()\n\t\t},\n\t\tread: (file) => readFileSync(join(config.files.assets, file))\n\t});\n\n\tif (response.ok) {\n\t\treturn await response.text();\n\t}\n\n\tthrow new Error(`Could not create a fallback page — failed with status ${response.status}`);\n}\n"}},"prerender.js":{"file":{"contents":"import { readFileSync, writeFileSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { installPolyfills } from '../../exports/node/polyfills.js';\nimport { mkdirp, posixify, walk } from '../../utils/filesystem.js';\nimport { should_polyfill } from '../../utils/platform.js';\nimport { decode_uri, is_root_relative, resolve } from '../../utils/url.js';\nimport { escape_html_attr } from '../../utils/escape.js';\nimport { logger } from '../utils.js';\nimport { load_config } from '../config/index.js';\nimport { get_route_segments } from '../../utils/routing.js';\nimport { queue } from './queue.js';\nimport { crawl } from './crawl.js';\nimport { forked } from '../../utils/fork.js';\n\nexport default forked(import.meta.url, prerender);\n\n/**\n * @param {{\n *   out: string;\n *   manifest_path: string;\n *   metadata: import('types').ServerMetadata;\n *   verbose: boolean;\n *   env: Record<string, string>\n * }} opts\n */\nasync function prerender({ out, manifest_path, metadata, verbose, env }) {\n\t/** @type {import('types').SSRManifest} */\n\tconst manifest = (await import(pathToFileURL(manifest_path).href)).manifest;\n\n\t/** @type {import('types').ServerInternalModule} */\n\tconst internal = await import(pathToFileURL(`${out}/server/internal.js`).href);\n\n\t/** @type {import('types').ServerModule} */\n\tconst { Server } = await import(pathToFileURL(`${out}/server/index.js`).href);\n\n\t// configure `import { building } from '$app/environment'` —\n\t// essential we do this before analysing the code\n\tinternal.set_building(true);\n\n\t/**\n\t * @template {{message: string}} T\n\t * @template {Omit<T, 'message'>} K\n\t * @param {import('types').Logger} log\n\t * @param {'fail' | 'warn' | 'ignore' | ((details: T) => void)} input\n\t * @param {(details: K) => string} format\n\t * @returns {(details: K) => void}\n\t */\n\tfunction normalise_error_handler(log, input, format) {\n\t\tswitch (input) {\n\t\t\tcase 'fail':\n\t\t\t\treturn (details) => {\n\t\t\t\t\tthrow new Error(format(details));\n\t\t\t\t};\n\t\t\tcase 'warn':\n\t\t\t\treturn (details) => {\n\t\t\t\t\tlog.error(format(details));\n\t\t\t\t};\n\t\t\tcase 'ignore':\n\t\t\t\treturn () => {};\n\t\t\tdefault:\n\t\t\t\t// @ts-expect-error TS thinks T might be of a different kind, but it's not\n\t\t\t\treturn (details) => input({ ...details, message: format(details) });\n\t\t}\n\t}\n\n\tconst OK = 2;\n\tconst REDIRECT = 3;\n\n\t/** @type {import('types').Prerendered} */\n\tconst prerendered = {\n\t\tpages: new Map(),\n\t\tassets: new Map(),\n\t\tredirects: new Map(),\n\t\tpaths: []\n\t};\n\n\t/** @type {import('types').PrerenderMap} */\n\tconst prerender_map = new Map();\n\n\tfor (const [id, { prerender }] of metadata.routes) {\n\t\tif (prerender !== undefined) {\n\t\t\tprerender_map.set(id, prerender);\n\t\t}\n\t}\n\n\t/** @type {Set<string>} */\n\tconst prerendered_routes = new Set();\n\n\t/** @type {import('types').ValidatedKitConfig} */\n\tconst config = (await load_config()).kit;\n\n\t/** @type {import('types').Logger} */\n\tconst log = logger({ verbose });\n\n\tif (should_polyfill) {\n\t\tinstallPolyfills();\n\t}\n\n\t/** @type {Map<string, string>} */\n\tconst saved = new Map();\n\n\tconst server = new Server(manifest);\n\tawait server.init({ env });\n\n\tconst handle_http_error = normalise_error_handler(\n\t\tlog,\n\t\tconfig.prerender.handleHttpError,\n\t\t({ status, path, referrer, referenceType }) => {\n\t\t\tconst message =\n\t\t\t\tstatus === 404 && !path.startsWith(config.paths.base)\n\t\t\t\t\t? `${path} does not begin with \\`base\\`, which is configured in \\`paths.base\\` and can be imported from \\`$app/paths\\` - see https://kit.svelte.dev/docs/configuration#paths for more info`\n\t\t\t\t\t: path;\n\n\t\t\treturn `${status} ${message}${referrer ? ` (${referenceType} from ${referrer})` : ''}`;\n\t\t}\n\t);\n\n\tconst handle_missing_id = normalise_error_handler(\n\t\tlog,\n\t\tconfig.prerender.handleMissingId,\n\t\t({ path, id, referrers }) => {\n\t\t\treturn (\n\t\t\t\t`The following pages contain links to ${path}#${id}, but no element with id=\"${id}\" exists on ${path} - see the \\`handleMissingId\\` option in https://kit.svelte.dev/docs/configuration#prerender for more info:` +\n\t\t\t\treferrers.map((l) => `\\n  - ${l}`).join('')\n\t\t\t);\n\t\t}\n\t);\n\n\tconst q = queue(config.prerender.concurrency);\n\n\t/**\n\t * @param {string} path\n\t * @param {boolean} is_html\n\t */\n\tfunction output_filename(path, is_html) {\n\t\tconst file = path.slice(config.paths.base.length + 1) || 'index.html';\n\n\t\tif (is_html && !file.endsWith('.html')) {\n\t\t\treturn file + (file.endsWith('/') ? 'index.html' : '.html');\n\t\t}\n\n\t\treturn file;\n\t}\n\n\tconst files = new Set(walk(`${out}/client`).map(posixify));\n\tconst seen = new Set();\n\tconst written = new Set();\n\n\t/** @type {Map<string, Set<string>>} */\n\tconst expected_hashlinks = new Map();\n\n\t/** @type {Map<string, string[]>} */\n\tconst actual_hashlinks = new Map();\n\n\t/**\n\t * @param {string | null} referrer\n\t * @param {string} decoded\n\t * @param {string} [encoded]\n\t */\n\tfunction enqueue(referrer, decoded, encoded) {\n\t\tif (seen.has(decoded)) return;\n\t\tseen.add(decoded);\n\n\t\tconst file = decoded.slice(config.paths.base.length + 1);\n\t\tif (files.has(file)) return;\n\n\t\treturn q.add(() => visit(decoded, encoded || encodeURI(decoded), referrer));\n\t}\n\n\t/**\n\t * @param {string} decoded\n\t * @param {string} encoded\n\t * @param {string?} referrer\n\t */\n\tasync function visit(decoded, encoded, referrer) {\n\t\tif (!decoded.startsWith(config.paths.base)) {\n\t\t\thandle_http_error({ status: 404, path: decoded, referrer, referenceType: 'linked' });\n\t\t\treturn;\n\t\t}\n\n\t\t/** @type {Map<string, import('types').PrerenderDependency>} */\n\t\tconst dependencies = new Map();\n\n\t\tconst response = await server.respond(new Request(config.prerender.origin + encoded), {\n\t\t\tgetClientAddress() {\n\t\t\t\tthrow new Error('Cannot read clientAddress during prerendering');\n\t\t\t},\n\t\t\tprerendering: {\n\t\t\t\tdependencies\n\t\t\t},\n\t\t\tread: (file) => {\n\t\t\t\t// stuff we just wrote\n\t\t\t\tconst filepath = saved.get(file);\n\t\t\t\tif (filepath) return readFileSync(filepath);\n\n\t\t\t\t// stuff in `static`\n\t\t\t\treturn readFileSync(join(config.files.assets, file));\n\t\t\t}\n\t\t});\n\n\t\tconst body = Buffer.from(await response.arrayBuffer());\n\n\t\tsave('pages', response, body, decoded, encoded, referrer, 'linked');\n\n\t\tfor (const [dependency_path, result] of dependencies) {\n\t\t\t// this seems circuitous, but using new URL allows us to not care\n\t\t\t// whether dependency_path is encoded or not\n\t\t\tconst encoded_dependency_path = new URL(dependency_path, 'http://localhost').pathname;\n\t\t\tconst decoded_dependency_path = decode_uri(encoded_dependency_path);\n\n\t\t\tconst headers = Object.fromEntries(result.response.headers);\n\n\t\t\tconst prerender = headers['x-sveltekit-prerender'];\n\t\t\tif (prerender) {\n\t\t\t\tconst encoded_route_id = headers['x-sveltekit-routeid'];\n\t\t\t\tif (encoded_route_id != null) {\n\t\t\t\t\tconst route_id = decode_uri(encoded_route_id);\n\t\t\t\t\tconst existing_value = prerender_map.get(route_id);\n\t\t\t\t\tif (existing_value !== 'auto') {\n\t\t\t\t\t\tprerender_map.set(route_id, prerender === 'true' ? true : 'auto');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst body = result.body ?? new Uint8Array(await result.response.arrayBuffer());\n\n\t\t\tsave(\n\t\t\t\t'dependencies',\n\t\t\t\tresult.response,\n\t\t\t\tbody,\n\t\t\t\tdecoded_dependency_path,\n\t\t\t\tencoded_dependency_path,\n\t\t\t\tdecoded,\n\t\t\t\t'fetched'\n\t\t\t);\n\t\t}\n\n\t\t// avoid triggering `filterSerializeResponseHeaders` guard\n\t\tconst headers = Object.fromEntries(response.headers);\n\n\t\tif (config.prerender.crawl && headers['content-type'] === 'text/html') {\n\t\t\tconst { ids, hrefs } = crawl(body.toString());\n\n\t\t\tactual_hashlinks.set(decoded, ids);\n\n\t\t\tfor (const href of hrefs) {\n\t\t\t\tif (href.startsWith('data:')) continue;\n\n\t\t\t\tconst resolved = resolve(encoded, href);\n\t\t\t\tif (!is_root_relative(resolved)) continue;\n\n\t\t\t\tconst { pathname, search, hash } = new URL(resolved, 'http://localhost');\n\n\t\t\t\tif (search) {\n\t\t\t\t\t// TODO warn that query strings have no effect on statically-exported pages\n\t\t\t\t}\n\n\t\t\t\tif (hash) {\n\t\t\t\t\tconst key = decode_uri(pathname + hash);\n\n\t\t\t\t\tif (!expected_hashlinks.has(key)) {\n\t\t\t\t\t\texpected_hashlinks.set(key, new Set());\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Set<string>} */ (expected_hashlinks.get(key)).add(decoded);\n\t\t\t\t}\n\n\t\t\t\tenqueue(decoded, decode_uri(pathname), pathname);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {'pages' | 'dependencies'} category\n\t * @param {Response} response\n\t * @param {string | Uint8Array} body\n\t * @param {string} decoded\n\t * @param {string} encoded\n\t * @param {string | null} referrer\n\t * @param {'linked' | 'fetched'} referenceType\n\t */\n\tfunction save(category, response, body, decoded, encoded, referrer, referenceType) {\n\t\tconst response_type = Math.floor(response.status / 100);\n\t\tconst headers = Object.fromEntries(response.headers);\n\n\t\tconst type = headers['content-type'];\n\t\tconst is_html = response_type === REDIRECT || type === 'text/html';\n\n\t\tconst file = output_filename(decoded, is_html);\n\t\tconst dest = `${config.outDir}/output/prerendered/${category}/${file}`;\n\n\t\tif (written.has(file)) return;\n\n\t\tconst encoded_route_id = response.headers.get('x-sveltekit-routeid');\n\t\tconst route_id = encoded_route_id != null ? decode_uri(encoded_route_id) : null;\n\t\tif (route_id !== null) prerendered_routes.add(route_id);\n\n\t\tif (response_type === REDIRECT) {\n\t\t\tconst location = headers['location'];\n\n\t\t\tif (location) {\n\t\t\t\tconst resolved = resolve(encoded, location);\n\t\t\t\tif (is_root_relative(resolved)) {\n\t\t\t\t\tenqueue(decoded, decode_uri(resolved), resolved);\n\t\t\t\t}\n\n\t\t\t\tif (!headers['x-sveltekit-normalize']) {\n\t\t\t\t\tmkdirp(dirname(dest));\n\n\t\t\t\t\tlog.warn(`${response.status} ${decoded} -> ${location}`);\n\n\t\t\t\t\twriteFileSync(\n\t\t\t\t\t\tdest,\n\t\t\t\t\t\t`<meta http-equiv=\"refresh\" content=${escape_html_attr(`0;url=${location}`)}>`\n\t\t\t\t\t);\n\n\t\t\t\t\twritten.add(file);\n\n\t\t\t\t\tif (!prerendered.redirects.has(decoded)) {\n\t\t\t\t\t\tprerendered.redirects.set(decoded, {\n\t\t\t\t\t\t\tstatus: response.status,\n\t\t\t\t\t\t\tlocation: resolved\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tprerendered.paths.push(decoded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.warn(`location header missing on redirect received from ${decoded}`);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (response.status === 200) {\n\t\t\tmkdirp(dirname(dest));\n\n\t\t\tlog.info(`${response.status} ${decoded}`);\n\t\t\twriteFileSync(dest, body);\n\t\t\twritten.add(file);\n\n\t\t\tif (is_html) {\n\t\t\t\tprerendered.pages.set(decoded, {\n\t\t\t\t\tfile\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tprerendered.assets.set(decoded, {\n\t\t\t\t\ttype\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tprerendered.paths.push(decoded);\n\t\t} else if (response_type !== OK) {\n\t\t\thandle_http_error({ status: response.status, path: decoded, referrer, referenceType });\n\t\t}\n\n\t\tmanifest.assets.add(file);\n\t\tsaved.set(file, dest);\n\t}\n\n\tif (\n\t\tconfig.prerender.entries.length > 1 ||\n\t\tconfig.prerender.entries[0] !== '*' ||\n\t\tprerender_map.size > 0\n\t) {\n\t\t// Only log if we're actually going to do something to not confuse users\n\t\tlog.info('Prerendering');\n\t}\n\n\tfor (const entry of config.prerender.entries) {\n\t\tif (entry === '*') {\n\t\t\tfor (const [id, prerender] of prerender_map) {\n\t\t\t\tif (prerender) {\n\t\t\t\t\tif (id.includes('[')) continue;\n\t\t\t\t\tconst path = `/${get_route_segments(id).join('/')}`;\n\t\t\t\t\tenqueue(null, config.paths.base + path);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tenqueue(null, config.paths.base + entry);\n\t\t}\n\t}\n\n\tawait q.done();\n\n\t// handle invalid fragment links\n\tfor (const [key, referrers] of expected_hashlinks) {\n\t\tconst index = key.indexOf('#');\n\t\tconst path = key.slice(0, index);\n\t\tconst id = key.slice(index + 1);\n\n\t\tconst hashlinks = actual_hashlinks.get(path);\n\t\t// ignore fragment links to pages that were not prerendered\n\t\tif (!hashlinks) continue;\n\n\t\tif (!hashlinks.includes(id)) {\n\t\t\thandle_missing_id({ id, path, referrers: Array.from(referrers) });\n\t\t}\n\t}\n\n\t/** @type {string[]} */\n\tconst not_prerendered = [];\n\n\tfor (const [route_id, prerender] of prerender_map) {\n\t\tif (prerender === true && !prerendered_routes.has(route_id)) {\n\t\t\tnot_prerendered.push(route_id);\n\t\t}\n\t}\n\n\tif (not_prerendered.length > 0) {\n\t\tthrow new Error(\n\t\t\t`The following routes were marked as prerenderable, but were not prerendered because they were not found while crawling your app:\\n${not_prerendered.map(\n\t\t\t\t(id) => `  - ${id}`\n\t\t\t)}\\n\\nSee https://kit.svelte.dev/docs/page-options#prerender-troubleshooting for info on how to solve this`\n\t\t);\n\t}\n\n\treturn { prerendered, prerender_map };\n}\n"}},"queue.js":{"file":{"contents":"/**\n * @typedef {{\n *   fn: () => Promise<any>,\n *   fulfil: (value: any) => void,\n *   reject: (error: Error) => void\n * }} Task\n */\n\n/** @param {number} concurrency */\nexport function queue(concurrency) {\n\t/** @type {Task[]} */\n\tconst tasks = [];\n\n\tlet current = 0;\n\n\t/** @type {(value?: any) => void} */\n\tlet fulfil;\n\n\t/** @type {(error: Error) => void} */\n\tlet reject;\n\n\tlet closed = false;\n\n\tconst done = new Promise((f, r) => {\n\t\tfulfil = f;\n\t\treject = r;\n\t});\n\n\tdone.catch(() => {\n\t\t// this is necessary in case a catch handler is never added\n\t\t// to the done promise by the user\n\t});\n\n\tfunction dequeue() {\n\t\tif (current < concurrency) {\n\t\t\tconst task = tasks.shift();\n\n\t\t\tif (task) {\n\t\t\t\tcurrent += 1;\n\t\t\t\tconst promise = Promise.resolve(task.fn());\n\n\t\t\t\tpromise\n\t\t\t\t\t.then(task.fulfil, (err) => {\n\t\t\t\t\t\ttask.reject(err);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tcurrent -= 1;\n\t\t\t\t\t\tdequeue();\n\t\t\t\t\t});\n\t\t\t} else if (current === 0) {\n\t\t\t\tclosed = true;\n\t\t\t\tfulfil();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\t/** @param {() => any} fn */\n\t\tadd: (fn) => {\n\t\t\tif (closed) throw new Error('Cannot add tasks to a queue that has ended');\n\n\t\t\tconst promise = new Promise((fulfil, reject) => {\n\t\t\t\ttasks.push({ fn, fulfil, reject });\n\t\t\t});\n\n\t\t\tdequeue();\n\t\t\treturn promise;\n\t\t},\n\n\t\tdone: () => {\n\t\t\tif (current === 0) {\n\t\t\t\tclosed = true;\n\t\t\t\tfulfil();\n\t\t\t}\n\n\t\t\treturn done;\n\t\t}\n\t};\n}\n"}}}},"sync":{"directory":{"create_manifest_data":{"directory":{"conflict.js":{"file":{"contents":""}},"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport mime from 'mime';\nimport { runtime_directory } from '../../utils.js';\nimport { posixify } from '../../../utils/filesystem.js';\nimport { parse_route_id } from '../../../utils/routing.js';\nimport { sort_routes } from './sort.js';\n\n/**\n * Generates the manifest data used for the client-side manifest and types generation.\n * @param {{\n *   config: import('types').ValidatedConfig;\n *   fallback?: string;\n *   cwd?: string;\n * }} opts\n * @returns {import('types').ManifestData}\n */\nexport default function create_manifest_data({\n\tconfig,\n\tfallback = `${runtime_directory}/components`,\n\tcwd = process.cwd()\n}) {\n\tconst assets = create_assets(config);\n\tconst matchers = create_matchers(config, cwd);\n\tconst { nodes, routes } = create_routes_and_nodes(cwd, config, fallback);\n\n\tfor (const route of routes) {\n\t\tfor (const param of route.params) {\n\t\t\tif (param.matcher && !matchers[param.matcher]) {\n\t\t\t\tthrow new Error(`No matcher found for parameter '${param.matcher}' in route ${route.id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tassets,\n\t\tmatchers,\n\t\tnodes,\n\t\troutes\n\t};\n}\n\n/**\n * @param {import('types').ValidatedConfig} config\n */\nexport function create_assets(config) {\n\treturn list_files(config.kit.files.assets).map((file) => ({\n\t\tfile,\n\t\tsize: fs.statSync(path.resolve(config.kit.files.assets, file)).size,\n\t\ttype: mime.getType(file)\n\t}));\n}\n\n/**\n * @param {import('types').ValidatedConfig} config\n * @param {string} cwd\n */\nfunction create_matchers(config, cwd) {\n\tconst params_base = path.relative(cwd, config.kit.files.params);\n\n\t/** @type {Record<string, string>} */\n\tconst matchers = {};\n\tif (fs.existsSync(config.kit.files.params)) {\n\t\tfor (const file of fs.readdirSync(config.kit.files.params)) {\n\t\t\tconst ext = path.extname(file);\n\t\t\tif (!config.kit.moduleExtensions.includes(ext)) continue;\n\t\t\tconst type = file.slice(0, -ext.length);\n\n\t\t\tif (/^\\w+$/.test(type)) {\n\t\t\t\tconst matcher_file = path.join(params_base, file);\n\n\t\t\t\t// Disallow same matcher with different extensions\n\t\t\t\tif (matchers[type]) {\n\t\t\t\t\tthrow new Error(`Duplicate matchers: ${matcher_file} and ${matchers[type]}`);\n\t\t\t\t} else {\n\t\t\t\t\tmatchers[type] = matcher_file;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Allow for matcher test collocation\n\t\t\t\tif (type.endsWith('.test') || type.endsWith('.spec')) continue;\n\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Matcher names can only have underscores and alphanumeric characters — \"${file}\" is invalid`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn matchers;\n}\n\n/**\n * @param {import('types').ValidatedConfig} config\n * @param {string} cwd\n * @param {string} fallback\n */\nfunction create_routes_and_nodes(cwd, config, fallback) {\n\t/** @type {import('types').RouteData[]} */\n\tconst routes = [];\n\n\tconst routes_base = posixify(path.relative(cwd, config.kit.files.routes));\n\n\tconst valid_extensions = [...config.extensions, ...config.kit.moduleExtensions];\n\n\t/** @type {import('types').PageNode[]} */\n\tconst nodes = [];\n\n\tif (fs.existsSync(config.kit.files.routes)) {\n\t\t/**\n\t\t * @param {number} depth\n\t\t * @param {string} id\n\t\t * @param {string} segment\n\t\t * @param {import('types').RouteData | null} parent\n\t\t */\n\t\tconst walk = (depth, id, segment, parent) => {\n\t\t\tconst unescaped = id.replace(/\\[([ux])\\+([^\\]]+)\\]/gi, (match, type, code) => {\n\t\t\t\tif (match !== match.toLowerCase()) {\n\t\t\t\t\tthrow new Error(`Character escape sequence in ${id} must be lowercase`);\n\t\t\t\t}\n\n\t\t\t\tif (!/[0-9a-f]+/.test(code)) {\n\t\t\t\t\tthrow new Error(`Invalid character escape sequence in ${id}`);\n\t\t\t\t}\n\n\t\t\t\tif (type === 'x') {\n\t\t\t\t\tif (code.length !== 2) {\n\t\t\t\t\t\tthrow new Error(`Hexadecimal escape sequence in ${id} must be two characters`);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn String.fromCharCode(parseInt(code, 16));\n\t\t\t\t} else {\n\t\t\t\t\tif (code.length < 4 || code.length > 6) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unicode escape sequence in ${id} must be between four and six characters`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn String.fromCharCode(parseInt(code, 16));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (/\\]\\[/.test(unescaped)) {\n\t\t\t\tthrow new Error(`Invalid route ${id} — parameters must be separated`);\n\t\t\t}\n\n\t\t\tif (count_occurrences('[', id) !== count_occurrences(']', id)) {\n\t\t\t\tthrow new Error(`Invalid route ${id} — brackets are unbalanced`);\n\t\t\t}\n\n\t\t\tif (/#/.test(segment)) {\n\t\t\t\t// Vite will barf on files with # in them\n\t\t\t\tthrow new Error(`Route ${id} should be renamed to ${id.replace(/#/g, '[x+23]')}`);\n\t\t\t}\n\n\t\t\tif (/\\[\\.\\.\\.\\w+\\]\\/\\[\\[/.test(id)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid route ${id} — an [[optional]] route segment cannot follow a [...rest] route segment`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (/\\[\\[\\.\\.\\./.test(id)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid route ${id} — a rest route segment is always optional, remove the outer square brackets`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst { pattern, params } = parse_route_id(id);\n\n\t\t\t/** @type {import('types').RouteData} */\n\t\t\tconst route = {\n\t\t\t\tid,\n\t\t\t\tparent,\n\n\t\t\t\tsegment,\n\t\t\t\tpattern,\n\t\t\t\tparams,\n\n\t\t\t\tlayout: null,\n\t\t\t\terror: null,\n\t\t\t\tleaf: null,\n\t\t\t\tpage: null,\n\t\t\t\tendpoint: null\n\t\t\t};\n\n\t\t\t// important to do this before walking children, so that child\n\t\t\t// routes appear later\n\t\t\troutes.push(route);\n\n\t\t\t// if we don't do this, the route map becomes unwieldy to console.log\n\t\t\tObject.defineProperty(route, 'parent', { enumerable: false });\n\n\t\t\tconst dir = path.join(cwd, routes_base, id);\n\n\t\t\t// We can't use withFileTypes because of a NodeJs bug which returns wrong results\n\t\t\t// with isDirectory() in case of symlinks: https://github.com/nodejs/node/issues/30646\n\t\t\tconst files = fs.readdirSync(dir).map((name) => ({\n\t\t\t\tis_dir: fs.statSync(path.join(dir, name)).isDirectory(),\n\t\t\t\tname\n\t\t\t}));\n\n\t\t\t// process files first\n\t\t\tfor (const file of files) {\n\t\t\t\tif (file.is_dir) continue;\n\t\t\t\tif (!file.name.startsWith('+')) continue;\n\t\t\t\tif (!valid_extensions.find((ext) => file.name.endsWith(ext))) continue;\n\n\t\t\t\tif (file.name.endsWith('.d.ts')) {\n\t\t\t\t\tlet name = file.name.slice(0, -5);\n\t\t\t\t\tconst ext = valid_extensions.find((ext) => name.endsWith(ext));\n\t\t\t\t\tif (ext) name = name.slice(0, -ext.length);\n\n\t\t\t\t\tconst valid =\n\t\t\t\t\t\t/^\\+(?:(page(?:@(.*))?)|(layout(?:@(.*))?)|(error))$/.test(name) ||\n\t\t\t\t\t\t/^\\+(?:(server)|(page(?:(@[a-zA-Z0-9_-]*))?(\\.server)?)|(layout(?:(@[a-zA-Z0-9_-]*))?(\\.server)?))$/.test(\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\tif (valid) continue;\n\t\t\t\t}\n\n\t\t\t\tconst project_relative = posixify(path.relative(cwd, path.join(dir, file.name)));\n\n\t\t\t\tconst item = analyze(\n\t\t\t\t\tproject_relative,\n\t\t\t\t\tfile.name,\n\t\t\t\t\tconfig.extensions,\n\t\t\t\t\tconfig.kit.moduleExtensions\n\t\t\t\t);\n\n\t\t\t\tif (item.kind === 'component') {\n\t\t\t\t\tif (item.is_error) {\n\t\t\t\t\t\troute.error = {\n\t\t\t\t\t\t\tdepth,\n\t\t\t\t\t\t\tcomponent: project_relative\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (item.is_layout) {\n\t\t\t\t\t\tif (!route.layout) route.layout = { depth, child_pages: [] };\n\t\t\t\t\t\troute.layout.component = project_relative;\n\t\t\t\t\t\tif (item.uses_layout !== undefined) route.layout.parent_id = item.uses_layout;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!route.leaf) route.leaf = { depth };\n\t\t\t\t\t\troute.leaf.component = project_relative;\n\t\t\t\t\t\tif (item.uses_layout !== undefined) route.leaf.parent_id = item.uses_layout;\n\t\t\t\t\t}\n\t\t\t\t} else if (item.is_layout) {\n\t\t\t\t\tif (!route.layout) route.layout = { depth, child_pages: [] };\n\t\t\t\t\troute.layout[item.kind] = project_relative;\n\t\t\t\t} else if (item.is_page) {\n\t\t\t\t\tif (!route.leaf) route.leaf = { depth };\n\t\t\t\t\troute.leaf[item.kind] = project_relative;\n\t\t\t\t} else {\n\t\t\t\t\troute.endpoint = {\n\t\t\t\t\t\tfile: project_relative\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// then handle children\n\t\t\tfor (const file of files) {\n\t\t\t\tif (file.is_dir) {\n\t\t\t\t\twalk(depth + 1, path.posix.join(id, file.name), file.name, route);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\twalk(0, '/', '', null);\n\n\t\tif (routes.length === 1) {\n\t\t\tconst root = routes[0];\n\t\t\tif (!root.leaf && !root.error && !root.layout && !root.endpoint) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'No routes found. If you are using a custom src/routes directory, make sure it is specified in svelte.config.js'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If there's no routes directory, we'll just create a single empty route. This ensures the root layout and\n\t\t// error components are included in the manifest, which is needed for subsequent build/dev commands to work\n\t\troutes.push({\n\t\t\tid: '/',\n\t\t\tsegment: '',\n\t\t\tpattern: /^$/,\n\t\t\tparams: [],\n\t\t\tparent: null,\n\t\t\tlayout: null,\n\t\t\terror: null,\n\t\t\tleaf: null,\n\t\t\tpage: null,\n\t\t\tendpoint: null\n\t\t});\n\t}\n\n\tprevent_conflicts(routes);\n\n\tconst root = routes[0];\n\n\tif (!root.layout?.component) {\n\t\tif (!root.layout) root.layout = { depth: 0, child_pages: [] };\n\t\troot.layout.component = posixify(path.relative(cwd, `${fallback}/layout.svelte`));\n\t}\n\n\tif (!root.error?.component) {\n\t\tif (!root.error) root.error = { depth: 0 };\n\t\troot.error.component = posixify(path.relative(cwd, `${fallback}/error.svelte`));\n\t}\n\n\t// we do layouts/errors first as they are more likely to be reused,\n\t// and smaller indexes take fewer bytes. also, this guarantees that\n\t// the default error/layout are 0/1\n\tfor (const route of routes) {\n\t\tif (route.layout) {\n\t\t\tif (!route.layout?.component) {\n\t\t\t\troute.layout.component = posixify(path.relative(cwd, `${fallback}/layout.svelte`));\n\t\t\t}\n\t\t\tnodes.push(route.layout);\n\t\t}\n\t\tif (route.error) nodes.push(route.error);\n\t}\n\n\tfor (const route of routes) {\n\t\tif (route.leaf) nodes.push(route.leaf);\n\t}\n\n\tconst indexes = new Map(nodes.map((node, i) => [node, i]));\n\n\tfor (const route of routes) {\n\t\tif (!route.leaf) continue;\n\n\t\troute.page = {\n\t\t\tlayouts: [],\n\t\t\terrors: [],\n\t\t\tleaf: /** @type {number} */ (indexes.get(route.leaf))\n\t\t};\n\n\t\t/** @type {import('types').RouteData | null} */\n\t\tlet current_route = route;\n\t\tlet current_node = route.leaf;\n\t\tlet parent_id = route.leaf.parent_id;\n\n\t\twhile (current_route) {\n\t\t\tif (parent_id === undefined || current_route.segment === parent_id) {\n\t\t\t\tif (current_route.layout || current_route.error) {\n\t\t\t\t\troute.page.layouts.unshift(\n\t\t\t\t\t\tcurrent_route.layout ? indexes.get(current_route.layout) : undefined\n\t\t\t\t\t);\n\t\t\t\t\troute.page.errors.unshift(\n\t\t\t\t\t\tcurrent_route.error ? indexes.get(current_route.error) : undefined\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (current_route.layout) {\n\t\t\t\t\t/** @type {import('types').PageNode[]} */ (current_route.layout.child_pages).push(\n\t\t\t\t\t\troute.leaf\n\t\t\t\t\t);\n\t\t\t\t\tcurrent_node.parent = current_node = current_route.layout;\n\t\t\t\t\tparent_id = current_node.parent_id;\n\t\t\t\t} else {\n\t\t\t\t\tparent_id = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent_route = current_route.parent;\n\t\t}\n\n\t\tif (parent_id !== undefined) {\n\t\t\tthrow new Error(`${current_node.component} references missing segment \"${parent_id}\"`);\n\t\t}\n\t}\n\n\treturn {\n\t\tnodes,\n\t\troutes: sort_routes(routes)\n\t};\n}\n\n/**\n * @param {string} project_relative\n * @param {string} file\n * @param {string[]} component_extensions\n * @param {string[]} module_extensions\n * @returns {import('./types').RouteFile}\n */\nfunction analyze(project_relative, file, component_extensions, module_extensions) {\n\tconst component_extension = component_extensions.find((ext) => file.endsWith(ext));\n\tif (component_extension) {\n\t\tconst name = file.slice(0, -component_extension.length);\n\t\tconst pattern = /^\\+(?:(page(?:@(.*))?)|(layout(?:@(.*))?)|(error))$/;\n\t\tconst match = pattern.exec(name);\n\t\tif (!match) {\n\t\t\tthrow new Error(`Files prefixed with + are reserved (saw ${project_relative})`);\n\t\t}\n\n\t\treturn {\n\t\t\tkind: 'component',\n\t\t\tis_page: !!match[1],\n\t\t\tis_layout: !!match[3],\n\t\t\tis_error: !!match[5],\n\t\t\tuses_layout: match[2] ?? match[4]\n\t\t};\n\t}\n\n\tconst module_extension = module_extensions.find((ext) => file.endsWith(ext));\n\tif (module_extension) {\n\t\tconst name = file.slice(0, -module_extension.length);\n\t\tconst pattern =\n\t\t\t/^\\+(?:(server)|(page(?:(@[a-zA-Z0-9_-]*))?(\\.server)?)|(layout(?:(@[a-zA-Z0-9_-]*))?(\\.server)?))$/;\n\t\tconst match = pattern.exec(name);\n\t\tif (!match) {\n\t\t\tthrow new Error(`Files prefixed with + are reserved (saw ${project_relative})`);\n\t\t} else if (match[3] || match[6]) {\n\t\t\tthrow new Error(\n\t\t\t\t// prettier-ignore\n\t\t\t\t`Only Svelte files can reference named layouts. Remove '${match[3] || match[6]}' from ${file} (at ${project_relative})`\n\t\t\t);\n\t\t}\n\n\t\tconst kind = !!(match[1] || match[4] || match[7]) ? 'server' : 'universal';\n\n\t\treturn {\n\t\t\tkind,\n\t\t\tis_page: !!match[2],\n\t\t\tis_layout: !!match[5]\n\t\t};\n\t}\n\n\tthrow new Error(`Files and directories prefixed with + are reserved (saw ${project_relative})`);\n}\n\n/** @param {string} dir */\nfunction list_files(dir) {\n\t/** @type {string[]} */\n\tconst files = [];\n\n\t/** @param {string} current */\n\tfunction walk(current) {\n\t\tfor (const file of fs.readdirSync(path.resolve(dir, current))) {\n\t\t\tconst child = path.posix.join(current, file);\n\t\t\tif (fs.statSync(path.resolve(dir, child)).isDirectory()) {\n\t\t\t\twalk(child);\n\t\t\t} else {\n\t\t\t\tfiles.push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fs.existsSync(dir)) walk('');\n\n\treturn files;\n}\n\n/**\n * @param {string} needle\n * @param {string} haystack\n */\nfunction count_occurrences(needle, haystack) {\n\tlet count = 0;\n\tfor (let i = 0; i < haystack.length; i += 1) {\n\t\tif (haystack[i] === needle) count += 1;\n\t}\n\treturn count;\n}\n\n/** @param {import('types').RouteData[]} routes */\nfunction prevent_conflicts(routes) {\n\t/** @type {Map<string, string>} */\n\tconst lookup = new Map();\n\n\tfor (const route of routes) {\n\t\tif (!route.leaf && !route.endpoint) continue;\n\n\t\tconst normalized = normalize_route_id(route.id);\n\n\t\t// find all permutations created by optional parameters\n\t\tconst split = normalized.split(/<\\?(.+?)\\>/g);\n\n\t\tlet permutations = [/** @type {string} */ (split[0])];\n\n\t\t// turn `x/[[optional]]/y` into `x/y` and `x/[required]/y`\n\t\tfor (let i = 1; i < split.length; i += 2) {\n\t\t\tconst matcher = split[i];\n\t\t\tconst next = split[i + 1];\n\n\t\t\tpermutations = permutations.reduce((a, b) => {\n\t\t\t\ta.push(b + next);\n\t\t\t\tif (!(matcher === '*' && b.endsWith('//'))) a.push(b + `<${matcher}>${next}`);\n\t\t\t\treturn a;\n\t\t\t}, /** @type {string[]} */ ([]));\n\t\t}\n\n\t\tfor (const permutation of permutations) {\n\t\t\t// remove leading/trailing/duplicated slashes caused by prior\n\t\t\t// manipulation of optional parameters and (groups)\n\t\t\tconst key = permutation\n\t\t\t\t.replace(/\\/{2,}/, '/')\n\t\t\t\t.replace(/^\\//, '')\n\t\t\t\t.replace(/\\/$/, '');\n\n\t\t\tif (lookup.has(key)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`The \"${lookup.get(key)}\" and \"${route.id}\" routes conflict with each other`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlookup.set(key, route.id);\n\t\t}\n\t}\n}\n\n/** @param {string} id */\nfunction normalize_route_id(id) {\n\treturn (\n\t\tid\n\t\t\t// remove groups\n\t\t\t.replace(/(?<=^|\\/)\\(.+?\\)(?=$|\\/)/g, '')\n\n\t\t\t.replace(/\\[[ux]\\+([0-9a-f]+)\\]/g, (_, x) =>\n\t\t\t\tString.fromCharCode(parseInt(x, 16)).replace(/\\//g, '%2f')\n\t\t\t)\n\n\t\t\t// replace `[param]` with `<*>`, `[param=x]` with `<x>`, and `[[param]]` with `<?*>`\n\t\t\t.replace(\n\t\t\t\t/\\[(?:(\\[)|(\\.\\.\\.))?.+?(=.+?)?\\]\\]?/g,\n\t\t\t\t(_, optional, rest, matcher) => `<${optional ? '?' : ''}${rest ?? ''}${matcher ?? '*'}>`\n\t\t\t)\n\t);\n}\n"}},"sort.js":{"file":{"contents":"import { get_route_segments } from '../../../utils/routing.js';\n\n/**\n * @typedef {{\n *   type: 'static' | 'required' | 'optional' | 'rest';\n *   content: string;\n *   matched: boolean;\n * }} Part\n */\n\n/**\n * @typedef {Part[]} Segment\n */\n\nconst EMPTY = { type: 'static', content: '', matched: false };\n\n/** @param {import('types').RouteData[]} routes */\nexport function sort_routes(routes) {\n\t/** @type {Map<string, Part[]>} */\n\tconst segment_cache = new Map();\n\n\t/** @param {string} segment */\n\tfunction get_parts(segment) {\n\t\tif (!segment_cache.has(segment)) {\n\t\t\tsegment_cache.set(segment, split(segment));\n\t\t}\n\n\t\treturn segment_cache.get(segment);\n\t}\n\n\t/** @param {string} id */\n\tfunction split(id) {\n\t\t/** @type {Part[]} */\n\t\tconst parts = [];\n\n\t\tlet i = 0;\n\t\twhile (i <= id.length) {\n\t\t\tconst start = id.indexOf('[', i);\n\t\t\tif (start === -1) {\n\t\t\t\tparts.push({ type: 'static', content: id.slice(i), matched: false });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparts.push({ type: 'static', content: id.slice(i, start), matched: false });\n\n\t\t\tconst type = id[start + 1] === '[' ? 'optional' : id[start + 1] === '.' ? 'rest' : 'required';\n\t\t\tconst delimiter = type === 'optional' ? ']]' : ']';\n\t\t\tconst end = id.indexOf(delimiter, start);\n\n\t\t\tif (end === -1) {\n\t\t\t\tthrow new Error(`Invalid route ID ${id}`);\n\t\t\t}\n\n\t\t\tconst content = id.slice(start, (i = end + delimiter.length));\n\n\t\t\tparts.push({\n\t\t\t\ttype,\n\t\t\t\tcontent,\n\t\t\t\tmatched: content.includes('=')\n\t\t\t});\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\treturn routes.sort((route_a, route_b) => {\n\t\tconst segments_a = split_route_id(route_a.id).map(get_parts);\n\t\tconst segments_b = split_route_id(route_b.id).map(get_parts);\n\n\t\tfor (let i = 0; i < Math.max(segments_a.length, segments_b.length); i += 1) {\n\t\t\tconst segment_a = segments_a[i] ?? [EMPTY];\n\t\t\tconst segment_b = segments_b[i] ?? [EMPTY];\n\n\t\t\tfor (let j = 0; j < Math.max(segment_a.length, segment_b.length); j += 1) {\n\t\t\t\tconst a = segment_a[j];\n\t\t\t\tconst b = segment_b[j];\n\n\t\t\t\t// first part of each segment is always static\n\t\t\t\t// (though it may be the empty string), then\n\t\t\t\t// it alternates between dynamic and static\n\t\t\t\t// (i.e. [foo][bar] is disallowed)\n\t\t\t\tconst dynamic = j % 2 === 1;\n\n\t\t\t\tif (dynamic) {\n\t\t\t\t\tif (!a) return -1;\n\t\t\t\t\tif (!b) return +1;\n\n\t\t\t\t\t// get the next static chunk, so we can handle [...rest] edge cases\n\t\t\t\t\tconst next_a = segment_a[j + 1].content || segments_a[i + 1]?.[0].content;\n\t\t\t\t\tconst next_b = segment_b[j + 1].content || segments_b[i + 1]?.[0].content;\n\n\t\t\t\t\t// `[...rest]/x` outranks `[...rest]`\n\t\t\t\t\tif (a.type === 'rest' && b.type === 'rest') {\n\t\t\t\t\t\tif (next_a && next_b) continue;\n\t\t\t\t\t\tif (next_a) return -1;\n\t\t\t\t\t\tif (next_b) return +1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// `[...rest]/x` outranks `[required]` or `[required]/[required]`\n\t\t\t\t\t// but not `[required]/x`\n\t\t\t\t\tif (a.type === 'rest') {\n\t\t\t\t\t\treturn next_a && !next_b ? -1 : +1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (b.type === 'rest') {\n\t\t\t\t\t\treturn next_b && !next_a ? +1 : -1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// part with matcher outranks one without\n\t\t\t\t\tif (a.matched !== b.matched) {\n\t\t\t\t\t\treturn a.matched ? -1 : +1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (a.type !== b.type) {\n\t\t\t\t\t\t// `[...rest]` has already been accounted for, so here\n\t\t\t\t\t\t// we're comparing between `[required]` and `[[optional]]`\n\t\t\t\t\t\tif (a.type === 'required') return -1;\n\t\t\t\t\t\tif (b.type === 'required') return +1;\n\t\t\t\t\t}\n\t\t\t\t} else if (a.content !== b.content) {\n\t\t\t\t\t// shallower path outranks deeper path\n\t\t\t\t\tif (a === EMPTY) return -1;\n\t\t\t\t\tif (b === EMPTY) return +1;\n\n\t\t\t\t\treturn sort_static(a.content, b.content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn route_a.id < route_b.id ? +1 : -1;\n\t});\n}\n\n/** @param {string} id */\nfunction split_route_id(id) {\n\treturn get_route_segments(\n\t\tid\n\t\t\t// remove all [[optional]] parts unless they're at the very end\n\t\t\t.replace(/\\[\\[[^\\]]+\\]\\](?!$)/g, '')\n\t).filter(Boolean);\n}\n\n/**\n * Sort two strings lexicographically, except `foobar` outranks `foo`\n * @param {string} a\n * @param {string} b\n */\nfunction sort_static(a, b) {\n\tif (a === b) return 0;\n\n\tfor (let i = 0; true; i += 1) {\n\t\tconst char_a = a[i];\n\t\tconst char_b = b[i];\n\n\t\tif (char_a !== char_b) {\n\t\t\tif (char_a === undefined) return +1;\n\t\t\tif (char_b === undefined) return -1;\n\t\t\treturn char_a < char_b ? -1 : +1;\n\t\t}\n\t}\n}\n"}},"types.d.ts":{"file":{"contents":"import { PageNode } from 'types';\n\ninterface Part {\n\tdynamic: boolean;\n\toptional: boolean;\n\trest: boolean;\n\ttype: string | null;\n}\n\ninterface RouteTreeNode {\n\terror: PageNode | undefined;\n\tlayout: PageNode | undefined;\n}\n\nexport type RouteTree = Map<string, RouteTreeNode>;\n\ninterface RouteComponent {\n\tkind: 'component';\n\tis_page: boolean;\n\tis_layout: boolean;\n\tis_error: boolean;\n\tuses_layout: string | undefined;\n}\n\ninterface RouteSharedModule {\n\tkind: 'universal';\n\tis_page: boolean;\n\tis_layout: boolean;\n}\n\ninterface RouteServerModule {\n\tkind: 'server';\n\tis_page: boolean;\n\tis_layout: boolean;\n}\n\nexport type RouteFile = RouteComponent | RouteSharedModule | RouteServerModule;\n"}}}},"sync.js":{"file":{"contents":"import path from 'node:path';\nimport create_manifest_data from './create_manifest_data/index.js';\nimport { write_client_manifest } from './write_client_manifest.js';\nimport { write_root } from './write_root.js';\nimport { write_tsconfig } from './write_tsconfig.js';\nimport { write_types, write_all_types } from './write_types/index.js';\nimport { write_ambient } from './write_ambient.js';\nimport { write_server } from './write_server.js';\n\n/**\n * Initialize SvelteKit's generated files.\n * @param {import('types').ValidatedConfig} config\n * @param {string} mode\n */\nexport function init(config, mode) {\n\twrite_tsconfig(config.kit);\n\twrite_ambient(config.kit, mode);\n}\n\n/**\n * Update SvelteKit's generated files\n * @param {import('types').ValidatedConfig} config\n */\nexport async function create(config) {\n\tconst manifest_data = create_manifest_data({ config });\n\n\tconst output = path.join(config.kit.outDir, 'generated');\n\n\twrite_client_manifest(config.kit, manifest_data, `${output}/client`);\n\twrite_server(config, output);\n\twrite_root(manifest_data, output);\n\tawait write_all_types(config, manifest_data);\n\n\treturn { manifest_data };\n}\n\n/**\n * Update SvelteKit's generated files in response to a single file content update.\n * Do not call this when the file in question was created/deleted.\n *\n * @param {import('types').ValidatedConfig} config\n * @param {import('types').ManifestData} manifest_data\n * @param {string} file\n */\nexport async function update(config, manifest_data, file) {\n\tawait write_types(config, manifest_data, file);\n\n\treturn { manifest_data };\n}\n\n/**\n * Run sync.init and sync.create in series, returning the result from sync.create.\n * @param {import('types').ValidatedConfig} config\n * @param {string} mode The Vite mode\n */\nexport async function all(config, mode) {\n\tinit(config, mode);\n\treturn await create(config);\n}\n\n/**\n * Run sync.init and then generate all type files.\n * @param {import('types').ValidatedConfig} config\n * @param {string} mode The Vite mode\n */\nexport async function all_types(config, mode) {\n\tinit(config, mode);\n\tconst manifest_data = create_manifest_data({ config });\n\tawait write_all_types(config, manifest_data);\n}\n\n/**\n * Regenerate __SERVER__/internal.js in response to src/{app.html,error.html,service-worker.js} changing\n * @param {import('types').ValidatedConfig} config\n */\nexport function server(config) {\n\twrite_server(config, path.join(config.kit.outDir, 'generated'));\n}\n"}},"ts.js":{"file":{"contents":"/** @type {import('typescript')} */\n// @ts-ignore\nexport let ts = undefined;\ntry {\n\tts = (await import('typescript')).default;\n} catch {}\n"}},"utils.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport { mkdirp } from '../../utils/filesystem.js';\n\n/** @type {Map<string, string>} */\nconst previous_contents = new Map();\n\n/**\n * @param {string} file\n * @param {string} code\n */\nexport function write_if_changed(file, code) {\n\tif (code !== previous_contents.get(file)) {\n\t\twrite(file, code);\n\t}\n}\n\n/**\n * @param {string} file\n * @param {string} code\n */\nexport function write(file, code) {\n\tprevious_contents.set(file, code);\n\tmkdirp(path.dirname(file));\n\tfs.writeFileSync(file, code);\n}\n\n/** @type {WeakMap<TemplateStringsArray, { strings: string[], indents: string[] }>} */\nconst dedent_map = new WeakMap();\n\n/**\n * Allows indenting template strings without the extra indentation ending up in the result.\n * Still allows indentation of lines relative to one another in the template string.\n * @param {TemplateStringsArray} strings\n * @param {any[]} values\n */\nexport function dedent(strings, ...values) {\n\tlet dedented = dedent_map.get(strings);\n\n\tif (!dedented) {\n\t\tconst indentation = /** @type {RegExpExecArray} */ (/\\n?([ \\t]*)/.exec(strings[0]))[1];\n\t\tconst pattern = new RegExp(`^${indentation}`, 'gm');\n\n\t\tdedented = {\n\t\t\tstrings: strings.map((str) => str.replace(pattern, '')),\n\t\t\tindents: []\n\t\t};\n\n\t\tlet current = '\\n';\n\n\t\tfor (let i = 0; i < values.length; i += 1) {\n\t\t\tconst string = dedented.strings[i];\n\t\t\tconst match = /\\n([ \\t]*)$/.exec(string);\n\n\t\t\tif (match) current = match[0];\n\t\t\tdedented.indents[i] = current;\n\t\t}\n\n\t\tdedent_map.set(strings, dedented);\n\t}\n\n\tlet str = dedented.strings[0];\n\tfor (let i = 0; i < values.length; i += 1) {\n\t\tstr += String(values[i]).replace(/\\n/g, dedented.indents[i]) + dedented.strings[i + 1];\n\t}\n\n\tstr = str.trim();\n\n\treturn str;\n}\n"}},"write_ambient.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { get_env } from '../../exports/vite/utils.js';\nimport { GENERATED_COMMENT } from '../../constants.js';\nimport { create_dynamic_types, create_static_types } from '../env.js';\nimport { write_if_changed } from './utils.js';\n\n// TODO these types should be described in a neutral place, rather than\n// inside either `packages/kit` or `kit.svelte.dev`\nconst descriptions_dir = fileURLToPath(new URL('../../../types/synthetic', import.meta.url));\n\n/** @param {string} filename */\nfunction read_description(filename) {\n\tconst content = fs.readFileSync(`${descriptions_dir}/${filename}`, 'utf8');\n\treturn `/**\\n${content\n\t\t.trim()\n\t\t.split('\\n')\n\t\t.map((line) => ` * ${line}`)\n\t\t.join('\\n')}\\n */`;\n}\n\n/**\n * @param {import('types').Env} env\n * @param {string} prefix\n */\nconst template = (env, prefix) => `\n${GENERATED_COMMENT}\n\n/// <reference types=\"@sveltejs/kit\" />\n\n${read_description('$env+static+private.md')}\n${create_static_types('private', env)}\n\n${read_description('$env+static+public.md')}\n${create_static_types('public', env)}\n\n${read_description('$env+dynamic+private.md')}\n${create_dynamic_types('private', env, prefix)}\n\n${read_description('$env+dynamic+public.md')}\n${create_dynamic_types('public', env, prefix)}\n`;\n\n/**\n * Writes ambient declarations including types reference to @sveltejs/kit,\n * and the existing environment variables in process.env to\n * $env/static/private and $env/static/public\n * @param {import('types').ValidatedKitConfig} config\n * @param {string} mode The Vite mode\n */\nexport function write_ambient(config, mode) {\n\tconst env = get_env(config.env, mode);\n\n\twrite_if_changed(\n\t\tpath.join(config.outDir, 'ambient.d.ts'),\n\t\ttemplate(env, config.env.publicPrefix)\n\t);\n}\n"}},"write_client_manifest.js":{"file":{"contents":"import { relative_path, resolve_entry } from '../../utils/filesystem.js';\nimport { s } from '../../utils/misc.js';\nimport { dedent, write_if_changed } from './utils.js';\n\n/**\n * Writes the client manifest to disk. The manifest is used to power the router. It contains the\n * list of routes and corresponding Svelte components (i.e. pages and layouts).\n * @param {import('types').ValidatedKitConfig} kit\n * @param {import('types').ManifestData} manifest_data\n * @param {string} output\n * @param {Array<{ has_server_load: boolean }>} [metadata]\n */\nexport function write_client_manifest(kit, manifest_data, output, metadata) {\n\t/**\n\t * Creates a module that exports a `CSRPageNode`\n\t * @param {import('types').PageNode} node\n\t */\n\tfunction generate_node(node) {\n\t\tconst declarations = [];\n\n\t\tif (node.universal) {\n\t\t\tdeclarations.push(\n\t\t\t\t`import * as universal from ${s(relative_path(`${output}/nodes`, node.universal))};`,\n\t\t\t\t`export { universal };`\n\t\t\t);\n\t\t}\n\n\t\tif (node.component) {\n\t\t\tdeclarations.push(\n\t\t\t\t`export { default as component } from ${s(\n\t\t\t\t\trelative_path(`${output}/nodes`, node.component)\n\t\t\t\t)};`\n\t\t\t);\n\t\t}\n\n\t\treturn declarations.join('\\n');\n\t}\n\n\t/** @type {Map<import('types').PageNode, number>} */\n\tconst indices = new Map();\n\tconst nodes = manifest_data.nodes\n\t\t.map((node, i) => {\n\t\t\tindices.set(node, i);\n\n\t\t\twrite_if_changed(`${output}/nodes/${i}.js`, generate_node(node));\n\t\t\treturn `() => import('./nodes/${i}')`;\n\t\t})\n\t\t.join(',\\n');\n\n\tconst layouts_with_server_load = new Set();\n\n\tconst dictionary = dedent`\n\t\t{\n\t\t\t${manifest_data.routes\n\t\t\t\t.map((route) => {\n\t\t\t\t\tif (route.page) {\n\t\t\t\t\t\tconst errors = route.page.errors.slice(1).map((n) => n ?? '');\n\t\t\t\t\t\tconst layouts = route.page.layouts.slice(1).map((n) => n ?? '');\n\n\t\t\t\t\t\twhile (layouts.at(-1) === '') layouts.pop();\n\t\t\t\t\t\twhile (errors.at(-1) === '') errors.pop();\n\n\t\t\t\t\t\tlet leaf_has_server_load = false;\n\t\t\t\t\t\tif (route.leaf) {\n\t\t\t\t\t\t\tif (metadata) {\n\t\t\t\t\t\t\t\tconst i = /** @type {number} */ (indices.get(route.leaf));\n\n\t\t\t\t\t\t\t\tleaf_has_server_load = metadata[i].has_server_load;\n\t\t\t\t\t\t\t} else if (route.leaf.server) {\n\t\t\t\t\t\t\t\tleaf_has_server_load = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Encode whether or not the route uses server data\n\t\t\t\t\t\t// using the ones' complement, to save space\n\t\t\t\t\t\tconst array = [`${leaf_has_server_load ? '~' : ''}${route.page.leaf}`];\n\n\t\t\t\t\t\t// Encode whether or not the layout uses server data.\n\t\t\t\t\t\t// It's a different method compared to pages because layouts\n\t\t\t\t\t\t// are reused across pages, so we save space by doing it this way.\n\t\t\t\t\t\troute.page.layouts.forEach((layout) => {\n\t\t\t\t\t\t\tif (layout == undefined) return;\n\n\t\t\t\t\t\t\tlet layout_has_server_load = false;\n\n\t\t\t\t\t\t\tif (metadata) {\n\t\t\t\t\t\t\t\tlayout_has_server_load = metadata[layout].has_server_load;\n\t\t\t\t\t\t\t} else if (manifest_data.nodes[layout].server) {\n\t\t\t\t\t\t\t\tlayout_has_server_load = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (layout_has_server_load) {\n\t\t\t\t\t\t\t\tlayouts_with_server_load.add(layout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// only include non-root layout/error nodes if they exist\n\t\t\t\t\t\tif (layouts.length > 0 || errors.length > 0) array.push(`[${layouts.join(',')}]`);\n\t\t\t\t\t\tif (errors.length > 0) array.push(`[${errors.join(',')}]`);\n\n\t\t\t\t\t\treturn `${s(route.id)}: [${array.join(',')}]`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(',\\n')}\n\t\t}\n\t`;\n\n\tconst hooks_file = resolve_entry(kit.files.hooks.client);\n\n\twrite_if_changed(\n\t\t`${output}/app.js`,\n\t\tdedent`\n\t\t\t${hooks_file ? `import * as client_hooks from '${relative_path(output, hooks_file)}';` : ''}\n\n\t\t\texport { matchers } from './matchers.js';\n\n\t\t\texport const nodes = [\n\t\t\t\t${nodes}\n\t\t\t];\n\n\t\t\texport const server_loads = [${[...layouts_with_server_load].join(',')}];\n\n\t\t\texport const dictionary = ${dictionary};\n\n\t\t\texport const hooks = {\n\t\t\t\thandleError: ${\n\t\t\t\t\thooks_file ? 'client_hooks.handleError || ' : ''\n\t\t\t\t}(({ error }) => { console.error(error) }),\n\t\t\t};\n\n\t\t\texport { default as root } from '../root.svelte';\n\t\t`\n\t);\n\n\t// write matchers to a separate module so that we don't\n\t// need to worry about name conflicts\n\tconst imports = [];\n\tconst matchers = [];\n\n\tfor (const key in manifest_data.matchers) {\n\t\tconst src = manifest_data.matchers[key];\n\n\t\timports.push(`import { match as ${key} } from ${s(relative_path(output, src))};`);\n\t\tmatchers.push(key);\n\t}\n\n\tconst module = imports.length\n\t\t? `${imports.join('\\n')}\\n\\nexport const matchers = { ${matchers.join(', ')} };`\n\t\t: 'export const matchers = {};';\n\n\twrite_if_changed(`${output}/matchers.js`, module);\n}\n"}},"write_root.js":{"file":{"contents":"import { dedent, write_if_changed } from './utils.js';\n\n/**\n * @param {import('types').ManifestData} manifest_data\n * @param {string} output\n */\nexport function write_root(manifest_data, output) {\n\t// TODO remove default layout altogether\n\n\tconst max_depth = Math.max(\n\t\t...manifest_data.routes.map((route) =>\n\t\t\troute.page ? route.page.layouts.filter(Boolean).length + 1 : 0\n\t\t),\n\t\t1\n\t);\n\n\tconst levels = [];\n\tfor (let i = 0; i <= max_depth; i += 1) {\n\t\tlevels.push(i);\n\t}\n\n\tlet l = max_depth;\n\n\tlet pyramid = `<svelte:component this={constructors[${l}]} bind:this={components[${l}]} data={data_${l}} {form} />`;\n\n\twhile (l--) {\n\t\tpyramid = dedent`\n\t\t\t{#if constructors[${l + 1}]}\n\t\t\t\t<svelte:component this={constructors[${l}]} bind:this={components[${l}]} data={data_${l}}>\n\t\t\t\t\t${pyramid}\n\t\t\t\t</svelte:component>\n\t\t\t{:else}\n\t\t\t\t<svelte:component this={constructors[${l}]} bind:this={components[${l}]} data={data_${l}} {form} />\n\t\t\t{/if}\n\t\t`;\n\t}\n\n\twrite_if_changed(\n\t\t`${output}/root.svelte`,\n\t\tdedent`\n\t\t\t<!-- This file is generated by @sveltejs/kit — do not edit it! -->\n\t\t\t<script>\n\t\t\t\timport { setContext, afterUpdate, onMount } from 'svelte';\n\t\t\t\timport { browser } from '$app/environment';\n\n\t\t\t\t// stores\n\t\t\t\texport let stores;\n\t\t\t\texport let page;\n\n\t\t\t\texport let constructors;\n\t\t\t\texport let components = [];\n\t\t\t\texport let form;\n\t\t\t\t${levels.map((l) => `export let data_${l} = null;`).join('\\n')}\n\n\t\t\t\tif (!browser) {\n\t\t\t\t\tsetContext('__svelte__', stores);\n\t\t\t\t}\n\n\t\t\t\t$: stores.page.set(page);\n\t\t\t\tafterUpdate(stores.page.notify);\n\n\t\t\t\tlet mounted = false;\n\t\t\t\tlet navigated = false;\n\t\t\t\tlet title = null;\n\n\t\t\t\tonMount(() => {\n\t\t\t\t\tconst unsubscribe = stores.page.subscribe(() => {\n\t\t\t\t\t\tif (mounted) {\n\t\t\t\t\t\t\tnavigated = true;\n\t\t\t\t\t\t\ttitle = document.title || 'untitled page';\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tmounted = true;\n\t\t\t\t\treturn unsubscribe;\n\t\t\t\t});\n\t\t\t</script>\n\n\t\t\t${pyramid}\n\n\t\t\t{#if mounted}\n\t\t\t\t<div id=\"svelte-announcer\" aria-live=\"assertive\" aria-atomic=\"true\" style=\"position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px\">\n\t\t\t\t\t{#if navigated}\n\t\t\t\t\t\t{title}\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t`\n\t);\n}\n"}},"write_server.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport { hash } from '../../runtime/hash.js';\nimport { posixify, resolve_entry } from '../../utils/filesystem.js';\nimport { s } from '../../utils/misc.js';\nimport { load_error_page, load_template } from '../config/index.js';\nimport { runtime_directory } from '../utils.js';\nimport { write_if_changed } from './utils.js';\n\n/**\n * @param {{\n *   hooks: string | null;\n *   config: import('types').ValidatedConfig;\n *   has_service_worker: boolean;\n *   runtime_directory: string;\n *   template: string;\n *   error_page: string;\n * }} opts\n */\nconst server_template = ({\n\tconfig,\n\thooks,\n\thas_service_worker,\n\truntime_directory,\n\ttemplate,\n\terror_page\n}) => `\nimport root from '../root.svelte';\nimport { set_building } from '__sveltekit/environment';\nimport { set_assets } from '__sveltekit/paths';\nimport { set_private_env, set_public_env } from '${runtime_directory}/shared-server.js';\n\nexport const options = {\n\tapp_template_contains_nonce: ${template.includes('%sveltekit.nonce%')},\n\tcsp: ${s(config.kit.csp)},\n\tcsrf_check_origin: ${s(config.kit.csrf.checkOrigin)},\n\tembedded: ${config.kit.embedded},\n\tenv_public_prefix: '${config.kit.env.publicPrefix}',\n\thooks: null, // added lazily, via \\`get_hooks\\`\n\tpreload_strategy: ${s(config.kit.output.preloadStrategy)},\n\troot,\n\tservice_worker: ${has_service_worker},\n\ttemplates: {\n\t\tapp: ({ head, body, assets, nonce, env }) => ${s(template)\n\t\t\t.replace('%sveltekit.head%', '\" + head + \"')\n\t\t\t.replace('%sveltekit.body%', '\" + body + \"')\n\t\t\t.replace(/%sveltekit\\.assets%/g, '\" + assets + \"')\n\t\t\t.replace(/%sveltekit\\.nonce%/g, '\" + nonce + \"')\n\t\t\t.replace(\n\t\t\t\t/%sveltekit\\.env\\.([^%]+)%/g,\n\t\t\t\t(_match, capture) => `\" + (env[${s(capture)}] ?? \"\") + \"`\n\t\t\t)},\n\t\terror: ({ status, message }) => ${s(error_page)\n\t\t\t.replace(/%sveltekit\\.status%/g, '\" + status + \"')\n\t\t\t.replace(/%sveltekit\\.error\\.message%/g, '\" + message + \"')}\n\t},\n\tversion_hash: ${s(hash(config.kit.version.name))}\n};\n\nexport function get_hooks() {\n\treturn ${hooks ? `import(${s(hooks)})` : '{}'};\n}\n\nexport { set_assets, set_building, set_private_env, set_public_env };\n`;\n\n// TODO need to re-run this whenever src/app.html or src/error.html are\n// created or changed, or src/service-worker.js is created or deleted.\n// Also, need to check that updating hooks.server.js works\n\n/**\n * Write server configuration to disk\n * @param {import('types').ValidatedConfig} config\n * @param {string} output\n */\nexport function write_server(config, output) {\n\t// TODO the casting shouldn't be necessary — investigate\n\tconst hooks_file = /** @type {string} */ (resolve_entry(config.kit.files.hooks.server));\n\n\t/** @param {string} file */\n\tfunction relative(file) {\n\t\treturn posixify(path.relative(`${output}/server`, file));\n\t}\n\n\twrite_if_changed(\n\t\t`${output}/server/internal.js`,\n\t\tserver_template({\n\t\t\tconfig,\n\t\t\thooks: fs.existsSync(hooks_file) ? relative(hooks_file) : null,\n\t\t\thas_service_worker:\n\t\t\t\tconfig.kit.serviceWorker.register && !!resolve_entry(config.kit.files.serviceWorker),\n\t\t\truntime_directory: relative(runtime_directory),\n\t\t\ttemplate: load_template(process.cwd(), config),\n\t\t\terror_page: load_error_page(config)\n\t\t})\n\t);\n}\n"}},"write_tsconfig.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport colors from 'kleur';\nimport { posixify } from '../../utils/filesystem.js';\nimport { write_if_changed } from './utils.js';\nimport { ts } from './ts.js';\n\n/**\n * @param {string} cwd\n * @param {string} file\n */\nfunction maybe_file(cwd, file) {\n\tconst resolved = path.resolve(cwd, file);\n\tif (fs.existsSync(resolved)) {\n\t\treturn resolved;\n\t}\n}\n\n/**\n * @param {string} file\n */\nfunction project_relative(file) {\n\treturn posixify(path.relative('.', file));\n}\n\n/**\n * @param {string} file\n */\nfunction remove_trailing_slashstar(file) {\n\tif (file.endsWith('/*')) {\n\t\treturn file.slice(0, -2);\n\t} else {\n\t\treturn file;\n\t}\n}\n\n/**\n * Generates the tsconfig that the user's tsconfig inherits from.\n * @param {import('types').ValidatedKitConfig} kit\n */\nexport function write_tsconfig(kit, cwd = process.cwd()) {\n\tconst out = path.join(kit.outDir, 'tsconfig.json');\n\n\tconst user_config = load_user_tsconfig(cwd);\n\tif (user_config) validate_user_config(kit, cwd, out, user_config);\n\n\t// only specify baseUrl if a) the user doesn't specify their own baseUrl\n\t// and b) they have non-relative paths. this causes problems with auto-imports,\n\t// so we print a suggestion that they use relative paths instead\n\t// TODO(v2): never include base URL, and skip the check below\n\tlet include_base_url = false;\n\n\tif (user_config && !user_config.options.compilerOptions?.baseUrl) {\n\t\tconst non_relative_paths = new Set();\n\t\tfor (const paths of Object.values(user_config?.options.compilerOptions?.paths || {})) {\n\t\t\tfor (const path of paths) {\n\t\t\t\tif (!path.startsWith('.')) non_relative_paths.add(path);\n\t\t\t}\n\t\t}\n\n\t\tif (non_relative_paths.size) {\n\t\t\tinclude_base_url = true;\n\n\t\t\tconsole.log(colors.bold().yellow('Please replace non-relative compilerOptions.paths:\\n'));\n\n\t\t\tfor (const path of non_relative_paths) {\n\t\t\t\tconsole.log(`  - \"${path}\" -> \"./${path}\"`);\n\t\t\t}\n\n\t\t\tconsole.log(\n\t\t\t\t'\\nDoing so allows us to omit \"baseUrl\" — which causes problems with imports — from the generated tsconfig.json. See https://github.com/sveltejs/kit/pull/8437 for more information.'\n\t\t\t);\n\t\t}\n\t}\n\n\twrite_if_changed(out, JSON.stringify(get_tsconfig(kit, include_base_url), null, '\\t'));\n}\n\n/**\n * Generates the tsconfig that the user's tsconfig inherits from.\n * @param {import('types').ValidatedKitConfig} kit\n * @param {boolean} include_base_url\n */\nexport function get_tsconfig(kit, include_base_url) {\n\t/** @param {string} file */\n\tconst config_relative = (file) => posixify(path.relative(kit.outDir, file));\n\n\tconst include = new Set([\n\t\t'ambient.d.ts',\n\t\t'./types/**/$types.d.ts',\n\t\tconfig_relative('vite.config.ts')\n\t]);\n\t// TODO(v2): find a better way to include all src files. We can't just use routes/lib only because\n\t// people might have other folders/files in src that they want included.\n\tconst src_includes = [kit.files.routes, kit.files.lib, path.resolve('src')].filter((dir) => {\n\t\tconst relative = path.relative(path.resolve('src'), dir);\n\t\treturn !relative || relative.startsWith('..');\n\t});\n\tfor (const dir of src_includes) {\n\t\tinclude.add(config_relative(`${dir}/**/*.js`));\n\t\tinclude.add(config_relative(`${dir}/**/*.ts`));\n\t\tinclude.add(config_relative(`${dir}/**/*.svelte`));\n\t}\n\n\t// Test folder is a special case - we advocate putting tests in a top-level test folder\n\t// and it's not configurable (should we make it?)\n\tconst test_folder = project_relative('tests');\n\tinclude.add(config_relative(`${test_folder}/**/*.js`));\n\tinclude.add(config_relative(`${test_folder}/**/*.ts`));\n\tinclude.add(config_relative(`${test_folder}/**/*.svelte`));\n\n\tconst exclude = [config_relative('node_modules/**'), './[!ambient.d.ts]**'];\n\tif (path.extname(kit.files.serviceWorker)) {\n\t\texclude.push(config_relative(kit.files.serviceWorker));\n\t} else {\n\t\texclude.push(config_relative(`${kit.files.serviceWorker}.js`));\n\t\texclude.push(config_relative(`${kit.files.serviceWorker}.ts`));\n\t\texclude.push(config_relative(`${kit.files.serviceWorker}.d.ts`));\n\t}\n\n\tconst config = {\n\t\tcompilerOptions: {\n\t\t\t// generated options\n\t\t\tbaseUrl: include_base_url ? config_relative('.') : undefined,\n\t\t\tpaths: get_tsconfig_paths(kit, include_base_url),\n\t\t\trootDirs: [config_relative('.'), './types'],\n\n\t\t\t// essential options\n\t\t\t// svelte-preprocess cannot figure out whether you have a value or a type, so tell TypeScript\n\t\t\t// to enforce using \\`import type\\` instead of \\`import\\` for Types.\n\t\t\timportsNotUsedAsValues: 'error',\n\t\t\t// Vite compiles modules one at a time\n\t\t\tisolatedModules: true,\n\t\t\t// TypeScript doesn't know about import usages in the template because it only sees the\n\t\t\t// script of a Svelte file. Therefore preserve all value imports. Requires TS 4.5 or higher.\n\t\t\tpreserveValueImports: true,\n\n\t\t\t// This is required for svelte-package to work as expected\n\t\t\t// Can be overwritten\n\t\t\tlib: ['esnext', 'DOM', 'DOM.Iterable'],\n\t\t\tmoduleResolution: 'node',\n\t\t\tmodule: 'esnext',\n\t\t\ttarget: 'esnext',\n\n\t\t\t// TODO(v2): use the new flag verbatimModuleSyntax instead (requires support by Vite/Esbuild)\n\t\t\tignoreDeprecations: ts && Number(ts.version.split('.')[0]) >= 5 ? '5.0' : undefined\n\t\t},\n\t\tinclude: [...include],\n\t\texclude\n\t};\n\n\treturn kit.typescript.config(config) ?? config;\n}\n\n/** @param {string} cwd */\nfunction load_user_tsconfig(cwd) {\n\tconst file = maybe_file(cwd, 'tsconfig.json') || maybe_file(cwd, 'jsconfig.json');\n\n\tif (!file) return;\n\n\t// we have to eval the file, since it's not parseable as JSON (contains comments)\n\tconst json = fs.readFileSync(file, 'utf-8');\n\n\treturn {\n\t\tkind: path.basename(file),\n\t\toptions: (0, eval)(`(${json})`)\n\t};\n}\n\n/**\n * @param {import('types').ValidatedKitConfig} kit\n * @param {string} cwd\n * @param {string} out\n * @param {{ kind: string, options: any }} config\n */\nfunction validate_user_config(kit, cwd, out, config) {\n\t// we need to check that the user's tsconfig extends the framework config\n\tconst extend = config.options.extends;\n\tconst extends_framework_config = extend && path.resolve(cwd, extend) === out;\n\n\tconst options = config.options.compilerOptions || {};\n\n\tif (extends_framework_config) {\n\t\tconst { paths: user_paths } = options;\n\n\t\tif (user_paths && fs.existsSync(kit.files.lib)) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lib = user_paths['$lib'] || [];\n\t\t\t/** @type {string[]} */\n\t\t\tconst lib_ = user_paths['$lib/*'] || [];\n\n\t\t\t// TODO(v2): check needs to be adjusted when we remove the base path\n\t\t\tconst missing_lib_paths =\n\t\t\t\t!lib.some((relative) => path.resolve(cwd, relative) === kit.files.lib) ||\n\t\t\t\t!lib_.some((relative) => path.resolve(cwd, relative) === path.join(kit.files.lib, '/*'));\n\n\t\t\tif (missing_lib_paths) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\tcolors\n\t\t\t\t\t\t.bold()\n\t\t\t\t\t\t.yellow(`Your compilerOptions.paths in ${config.kind} should include the following:`)\n\t\t\t\t);\n\t\t\t\tlet relative = posixify(path.relative('.', kit.files.lib));\n\t\t\t\tif (!relative.startsWith('.')) relative = `./${relative}`;\n\t\t\t\tconsole.warn(`{\\n  \"$lib\":[\"${relative}\"],\\n  \"$lib/*\":[\"${relative}/*\"]\\n}`);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet relative = posixify(path.relative('.', out));\n\t\tif (!relative.startsWith('./')) relative = './' + relative;\n\n\t\tconsole.warn(\n\t\t\tcolors\n\t\t\t\t.bold()\n\t\t\t\t.yellow(`Your ${config.kind} should extend the configuration generated by SvelteKit:`)\n\t\t);\n\t\tconsole.warn(`{\\n  \"extends\": \"${relative}\"\\n}`);\n\t}\n}\n\n// <something><optional /*>\nconst alias_regex = /^(.+?)(\\/\\*)?$/;\n// <path><optional /* or .fileending>\nconst value_regex = /^(.*?)((\\/\\*)|(\\.\\w+))?$/;\n\n/**\n * Generates tsconfig path aliases from kit's aliases.\n * Related to vite alias creation.\n *\n * @param {import('types').ValidatedKitConfig} config\n * @param {boolean} include_base_url\n */\nfunction get_tsconfig_paths(config, include_base_url) {\n\t/** @param {string} file */\n\tconst config_relative = (file) => posixify(path.relative(config.outDir, file));\n\n\tconst alias = { ...config.alias };\n\tif (fs.existsSync(project_relative(config.files.lib))) {\n\t\talias['$lib'] = project_relative(config.files.lib);\n\t}\n\n\t/** @type {Record<string, string[]>} */\n\tconst paths = {};\n\n\tfor (const [key, value] of Object.entries(alias)) {\n\t\tconst key_match = alias_regex.exec(key);\n\t\tif (!key_match) throw new Error(`Invalid alias key: ${key}`);\n\n\t\tconst value_match = value_regex.exec(value);\n\t\tif (!value_match) throw new Error(`Invalid alias value: ${value}`);\n\n\t\tconst rel_path = (include_base_url ? project_relative : config_relative)(\n\t\t\tremove_trailing_slashstar(value)\n\t\t);\n\t\tconst slashstar = key_match[2];\n\n\t\tif (slashstar) {\n\t\t\tpaths[key] = [rel_path + '/*'];\n\t\t} else {\n\t\t\tpaths[key] = [rel_path];\n\t\t\tconst fileending = value_match[4];\n\n\t\t\tif (!fileending && !(key + '/*' in alias)) {\n\t\t\t\tpaths[key + '/*'] = [rel_path + '/*'];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn paths;\n}\n"}},"write_types":{"directory":{"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport MagicString from 'magic-string';\nimport { posixify, rimraf, walk } from '../../../utils/filesystem.js';\nimport { compact } from '../../../utils/array.js';\nimport { ts } from '../ts.js';\n\n/**\n *  @typedef {{\n *   file_name: string;\n *   modified: boolean;\n *   code: string;\n *   exports: any[];\n *  } | null} Proxy\n *\n *  @typedef {{\n *   server: Proxy,\n *   universal: Proxy\n *  }} Proxies\n *\n *  @typedef {Map<import('types').PageNode, {route: import('types').RouteData, proxies: Proxies}>} RoutesMap\n */\n\nconst cwd = process.cwd();\n\n/**\n * Creates types for the whole manifest\n * @param {import('types').ValidatedConfig} config\n * @param {import('types').ManifestData} manifest_data\n */\nexport async function write_all_types(config, manifest_data) {\n\tif (!ts) return;\n\n\tconst types_dir = `${config.kit.outDir}/types`;\n\n\t// empty out files that no longer need to exist\n\tconst routes_dir = posixify(path.relative('.', config.kit.files.routes)).replace(/\\.\\.\\//g, '');\n\tconst expected_directories = new Set(\n\t\tmanifest_data.routes.map((route) => path.join(routes_dir, route.id))\n\t);\n\n\tif (fs.existsSync(types_dir)) {\n\t\tfor (const file of walk(types_dir)) {\n\t\t\tconst dir = path.dirname(file);\n\t\t\tif (!expected_directories.has(dir)) {\n\t\t\t\trimraf(path.join(types_dir, file));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Read/write meta data on each invocation, not once per node process,\n\t// it could be invoked by another process in the meantime.\n\tconst meta_data_file = `${types_dir}/route_meta_data.json`;\n\tconst has_meta_data = fs.existsSync(meta_data_file);\n\tlet meta_data = has_meta_data\n\t\t? /** @type {Record<string, string[]>} */ (JSON.parse(fs.readFileSync(meta_data_file, 'utf-8')))\n\t\t: {};\n\tconst routes_map = create_routes_map(manifest_data);\n\t// For each directory, write $types.d.ts\n\tfor (const route of manifest_data.routes) {\n\t\tif (!route.leaf && !route.layout && !route.endpoint) continue; // nothing to do\n\n\t\tconst outdir = path.join(config.kit.outDir, 'types', routes_dir, route.id);\n\n\t\t// check if the types are out of date\n\t\t/** @type {string[]} */\n\t\tconst input_files = [];\n\n\t\t/** @type {import('types').PageNode | null} */\n\t\tlet node = route.leaf;\n\t\twhile (node) {\n\t\t\tif (node.universal) input_files.push(node.universal);\n\t\t\tif (node.server) input_files.push(node.server);\n\t\t\tnode = node.parent ?? null;\n\t\t}\n\n\t\t/** @type {import('types').PageNode | null} */\n\t\tnode = route.layout;\n\t\twhile (node) {\n\t\t\tif (node.universal) input_files.push(node.universal);\n\t\t\tif (node.server) input_files.push(node.server);\n\t\t\tnode = node.parent ?? null;\n\t\t}\n\n\t\tif (route.endpoint) {\n\t\t\tinput_files.push(route.endpoint.file);\n\t\t}\n\n\t\ttry {\n\t\t\tfs.mkdirSync(outdir, { recursive: true });\n\t\t} catch {}\n\n\t\tconst output_files = compact(\n\t\t\tfs.readdirSync(outdir).map((name) => {\n\t\t\t\tconst stats = fs.statSync(path.join(outdir, name));\n\t\t\t\tif (stats.isDirectory()) return;\n\t\t\t\treturn {\n\t\t\t\t\tname,\n\t\t\t\t\tupdated: stats.mtimeMs\n\t\t\t\t};\n\t\t\t})\n\t\t);\n\n\t\tconst source_last_updated = Math.max(\n\t\t\t// ctimeMs includes move operations whereas mtimeMs does not\n\t\t\t...input_files.map((file) => fs.statSync(file).ctimeMs)\n\t\t);\n\t\tconst types_last_updated = Math.max(...output_files.map((file) => file.updated));\n\n\t\tconst should_generate =\n\t\t\t// source files were generated more recently than the types\n\t\t\tsource_last_updated > types_last_updated ||\n\t\t\t// no meta data file exists yet\n\t\t\t!has_meta_data ||\n\t\t\t// some file was deleted\n\t\t\t!meta_data[route.id]?.every((file) => input_files.includes(file));\n\n\t\tif (should_generate) {\n\t\t\t// track which old files end up being surplus to requirements\n\t\t\tconst to_delete = new Set(output_files.map((file) => file.name));\n\t\t\tupdate_types(config, routes_map, route, to_delete);\n\t\t\tmeta_data[route.id] = input_files;\n\t\t}\n\t}\n\n\tfs.writeFileSync(meta_data_file, JSON.stringify(meta_data, null, '\\t'));\n}\n\n/**\n * Creates types related to the given file. This should only be called\n * if the file in question was edited, not if it was created/deleted/moved.\n * @param {import('types').ValidatedConfig} config\n * @param {import('types').ManifestData} manifest_data\n * @param {string} file\n */\nexport async function write_types(config, manifest_data, file) {\n\tif (!ts) return;\n\n\tif (!path.basename(file).startsWith('+')) {\n\t\t// Not a route file\n\t\treturn;\n\t}\n\n\tconst id = '/' + posixify(path.relative(config.kit.files.routes, path.dirname(file)));\n\n\tconst route = manifest_data.routes.find((route) => route.id === id);\n\tif (!route) return;\n\tif (!route.leaf && !route.layout && !route.endpoint) return; // nothing to do\n\n\tupdate_types(config, create_routes_map(manifest_data), route);\n}\n\n/**\n * Collect all leafs into a leaf -> route map\n * @param {import('types').ManifestData} manifest_data\n */\nfunction create_routes_map(manifest_data) {\n\t/** @type {RoutesMap} */\n\tconst map = new Map();\n\tfor (const route of manifest_data.routes) {\n\t\tif (route.leaf) {\n\t\t\tmap.set(route.leaf, { route, proxies: { server: null, universal: null } });\n\t\t}\n\t}\n\treturn map;\n}\n\n/**\n * Update types for a specific route\n * @param {import('types').ValidatedConfig} config\n * @param {RoutesMap} routes\n * @param {import('types').RouteData} route\n * @param {Set<string>} [to_delete]\n */\nfunction update_types(config, routes, route, to_delete = new Set()) {\n\tconst routes_dir = posixify(path.relative('.', config.kit.files.routes)).replace(/\\.\\.\\//g, '');\n\tconst outdir = path.join(config.kit.outDir, 'types', routes_dir, route.id);\n\n\t// now generate new types\n\tconst imports = [`import type * as Kit from '@sveltejs/kit';`];\n\n\t/** @type {string[]} */\n\tconst declarations = [];\n\n\t/** @type {string[]} */\n\tconst exports = [];\n\n\t// add 'Expand' helper\n\t// Makes sure a type is \"repackaged\" and therefore more readable\n\tdeclarations.push('type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;');\n\tdeclarations.push(\n\t\t`type RouteParams = { ${route.params\n\t\t\t.map((param) => `${param.name}${param.optional ? '?' : ''}: string`)\n\t\t\t.join('; ')} }`\n\t);\n\n\tdeclarations.push(`type RouteId = '${route.id}';`);\n\n\t// These could also be placed in our public types, but it would bloat them unnecessarily and we may want to change these in the future\n\tif (route.layout || route.leaf) {\n\t\tdeclarations.push(\n\t\t\t// If T extends the empty object, void is also allowed as a return type\n\t\t\t`type MaybeWithVoid<T> = {} extends T ? T | void : T;`,\n\n\t\t\t// Returns the key of the object whose values are required.\n\t\t\t`export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];`,\n\n\t\t\t// Helper type to get the correct output type for load functions. It should be passed the parent type to check what types from App.PageData are still required.\n\t\t\t// If none, void is also allowed as a return type.\n\t\t\t`type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>`,\n\n\t\t\t// null & {} == null, we need to prevent that in some situations\n\t\t\t`type EnsureDefined<T> = T extends null | undefined ? {} : T;`,\n\n\t\t\t// Takes a union type and returns a union type where each type also has all properties\n\t\t\t// of all possible types (typed as undefined), making accessing them more ergonomic\n\t\t\t`type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;`,\n\n\t\t\t// Re-export `Snapshot` from @sveltejs/kit — in future we could use this to infer <T> from the return type of `snapshot.capture`\n\t\t\t`export type Snapshot<T = any> = Kit.Snapshot<T>;`\n\t\t);\n\t}\n\n\tif (route.leaf) {\n\t\tlet route_info = routes.get(route.leaf);\n\t\tif (!route_info) {\n\t\t\t// This should be defined, but belts and braces\n\t\t\troute_info = { route, proxies: { server: null, universal: null } };\n\t\t\troutes.set(route.leaf, route_info);\n\t\t}\n\n\t\tconst {\n\t\t\tdeclarations: d,\n\t\t\texports: e,\n\t\t\tproxies\n\t\t} = process_node(route.leaf, outdir, true, route_info.proxies);\n\n\t\texports.push(...e);\n\t\tdeclarations.push(...d);\n\n\t\tif (proxies.server) {\n\t\t\troute_info.proxies.server = proxies.server;\n\t\t\tif (proxies.server?.modified) to_delete.delete(proxies.server.file_name);\n\t\t}\n\t\tif (proxies.universal) {\n\t\t\troute_info.proxies.universal = proxies.universal;\n\t\t\tif (proxies.universal?.modified) to_delete.delete(proxies.universal.file_name);\n\t\t}\n\n\t\tif (route.leaf.server) {\n\t\t\texports.push(\n\t\t\t\t`export type Action<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Action<RouteParams, OutputData, RouteId>`\n\t\t\t);\n\t\t\texports.push(\n\t\t\t\t`export type Actions<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Actions<RouteParams, OutputData, RouteId>`\n\t\t\t);\n\t\t}\n\t}\n\n\tif (route.layout) {\n\t\tlet all_pages_have_load = true;\n\t\tconst layout_params = new Set();\n\t\tconst ids = ['RouteId'];\n\n\t\troute.layout.child_pages?.forEach((page) => {\n\t\t\tconst leaf = routes.get(page);\n\t\t\tif (leaf) {\n\t\t\t\tif (leaf.route.page) ids.push(`\"${leaf.route.id}\"`);\n\n\t\t\t\tfor (const param of leaf.route.params) {\n\t\t\t\t\tlayout_params.add(param.name);\n\t\t\t\t}\n\n\t\t\t\tensureProxies(page, leaf.proxies);\n\n\t\t\t\tif (\n\t\t\t\t\t// Be defensive - if a proxy doesn't exist (because it couldn't be created), assume a load function exists.\n\t\t\t\t\t// If we didn't and it's a false negative, the user could wrongfully get a type error on layouts.\n\t\t\t\t\t(leaf.proxies.server && !leaf.proxies.server.exports.includes('load')) ||\n\t\t\t\t\t(leaf.proxies.universal && !leaf.proxies.universal.exports.includes('load'))\n\t\t\t\t) {\n\t\t\t\t\tall_pages_have_load = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!page.server && !page.universal) {\n\t\t\t\tall_pages_have_load = false;\n\t\t\t}\n\t\t});\n\n\t\tif (route.id === '/') {\n\t\t\t// root layout is used for fallback error page, where ID can be null\n\t\t\tids.push('null');\n\t\t}\n\n\t\tdeclarations.push(`type LayoutRouteId = ${ids.join(' | ')}`);\n\n\t\tdeclarations.push(\n\t\t\t`type LayoutParams = RouteParams & { ${Array.from(layout_params).map(\n\t\t\t\t(param) => `${param}?: string`\n\t\t\t)} }`\n\t\t);\n\n\t\tconst {\n\t\t\texports: e,\n\t\t\tdeclarations: d,\n\t\t\tproxies\n\t\t} = process_node(\n\t\t\troute.layout,\n\t\t\toutdir,\n\t\t\tfalse,\n\t\t\t{ server: null, universal: null },\n\t\t\tall_pages_have_load\n\t\t);\n\n\t\texports.push(...e);\n\t\tdeclarations.push(...d);\n\n\t\tif (proxies.server?.modified) to_delete.delete(proxies.server.file_name);\n\t\tif (proxies.universal?.modified) to_delete.delete(proxies.universal.file_name);\n\t}\n\n\tif (route.endpoint) {\n\t\texports.push(`export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;`);\n\t}\n\n\tif (route.leaf?.server || route.layout?.server || route.endpoint) {\n\t\texports.push(`export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;`);\n\t}\n\n\tconst output = [imports.join('\\n'), declarations.join('\\n'), exports.join('\\n')]\n\t\t.filter(Boolean)\n\t\t.join('\\n\\n');\n\n\tfs.writeFileSync(`${outdir}/$types.d.ts`, output);\n\tto_delete.delete('$types.d.ts');\n\n\tfor (const file of to_delete) {\n\t\tfs.unlinkSync(path.join(outdir, file));\n\t}\n}\n\n/**\n * @param {import('types').PageNode} node\n * @param {string} outdir\n * @param {boolean} is_page\n * @param {Proxies} proxies\n * @param {boolean} [all_pages_have_load]\n */\nfunction process_node(node, outdir, is_page, proxies, all_pages_have_load = true) {\n\tconst params = `${is_page ? 'Route' : 'Layout'}Params`;\n\tconst prefix = is_page ? 'Page' : 'Layout';\n\n\tconst route_id = is_page ? 'RouteId' : 'LayoutRouteId';\n\n\t/** @type {string[]} */\n\tconst declarations = [];\n\t/** @type {string[]} */\n\tconst exports = [];\n\n\t/** @type {string} */\n\tlet server_data;\n\t/** @type {string} */\n\tlet data;\n\n\tensureProxies(node, proxies);\n\n\tif (node.server) {\n\t\tconst basename = path.basename(node.server);\n\t\tconst proxy = proxies.server;\n\t\tif (proxy?.modified) {\n\t\t\tfs.writeFileSync(`${outdir}/proxy${basename}`, proxy.code);\n\t\t}\n\n\t\tserver_data = get_data_type(node.server, 'null', proxy, true);\n\n\t\tconst parent_type = `${prefix}ServerParentData`;\n\n\t\tdeclarations.push(`type ${parent_type} = ${get_parent_type(node, 'LayoutServerData')};`);\n\n\t\t// +page.js load present -> server can return all-optional data\n\t\tconst output_data_shape =\n\t\t\tnode.universal || (!is_page && all_pages_have_load)\n\t\t\t\t? `Partial<App.PageData> & Record<string, any> | void`\n\t\t\t\t: `OutputDataShape<${parent_type}>`;\n\t\texports.push(\n\t\t\t`export type ${prefix}ServerLoad<OutputData extends ${output_data_shape} = ${output_data_shape}> = Kit.ServerLoad<${params}, ${parent_type}, OutputData, ${route_id}>;`\n\t\t);\n\n\t\texports.push(`export type ${prefix}ServerLoadEvent = Parameters<${prefix}ServerLoad>[0];`);\n\n\t\tif (is_page) {\n\t\t\tlet type = 'unknown';\n\t\t\tif (proxy) {\n\t\t\t\tif (proxy.exports.includes('actions')) {\n\t\t\t\t\t// If the file wasn't tweaked, we can use the return type of the original file.\n\t\t\t\t\t// The advantage is that type updates are reflected without saving.\n\t\t\t\t\tconst from = proxy.modified\n\t\t\t\t\t\t? `./proxy${replace_ext_with_js(basename)}`\n\t\t\t\t\t\t: path_to_original(outdir, node.server);\n\n\t\t\t\t\ttype = `Expand<Kit.AwaitedActions<typeof import('${from}').actions>> | null`;\n\t\t\t\t}\n\t\t\t}\n\t\t\texports.push(`export type ActionData = ${type};`);\n\t\t}\n\t} else {\n\t\tserver_data = 'null';\n\t}\n\texports.push(`export type ${prefix}ServerData = ${server_data};`);\n\n\tconst parent_type = `${prefix}ParentData`;\n\tdeclarations.push(`type ${parent_type} = ${get_parent_type(node, 'LayoutData')};`);\n\n\tif (node.universal) {\n\t\tconst proxy = proxies.universal;\n\t\tif (proxy?.modified) {\n\t\t\tfs.writeFileSync(`${outdir}/proxy${path.basename(node.universal)}`, proxy.code);\n\t\t}\n\n\t\tconst type = get_data_type(\n\t\t\tnode.universal,\n\t\t\t`${parent_type} & EnsureDefined<${prefix}ServerData>`,\n\t\t\tproxy\n\t\t);\n\n\t\tdata = `Expand<Omit<${parent_type}, keyof ${type}> & OptionalUnion<EnsureDefined<${type}>>>`;\n\n\t\tconst output_data_shape =\n\t\t\t!is_page && all_pages_have_load\n\t\t\t\t? `Partial<App.PageData> & Record<string, any> | void`\n\t\t\t\t: `OutputDataShape<${parent_type}>`;\n\t\texports.push(\n\t\t\t`export type ${prefix}Load<OutputData extends ${output_data_shape} = ${output_data_shape}> = Kit.Load<${params}, ${prefix}ServerData, ${parent_type}, OutputData, ${route_id}>;`\n\t\t);\n\n\t\texports.push(`export type ${prefix}LoadEvent = Parameters<${prefix}Load>[0];`);\n\t} else if (server_data === 'null') {\n\t\tdata = `Expand<${parent_type}>`;\n\t} else {\n\t\tdata = `Expand<Omit<${parent_type}, keyof ${prefix}ServerData> & EnsureDefined<${prefix}ServerData>>`;\n\t}\n\n\texports.push(`export type ${prefix}Data = ${data};`);\n\n\treturn { declarations, exports, proxies };\n\n\t/**\n\t * @param {string} file_path\n\t * @param {string} fallback\n\t * @param {Proxy} proxy\n\t * @param {boolean} expand\n\t */\n\tfunction get_data_type(file_path, fallback, proxy, expand = false) {\n\t\tif (proxy) {\n\t\t\tif (proxy.exports.includes('load')) {\n\t\t\t\t// If the file wasn't tweaked, we can use the return type of the original file.\n\t\t\t\t// The advantage is that type updates are reflected without saving.\n\t\t\t\tconst from = proxy.modified\n\t\t\t\t\t? `./proxy${replace_ext_with_js(path.basename(file_path))}`\n\t\t\t\t\t: path_to_original(outdir, file_path);\n\t\t\t\tconst type = `Kit.AwaitedProperties<Awaited<ReturnType<typeof import('${from}').load>>>`;\n\t\t\t\treturn expand ? `Expand<OptionalUnion<EnsureDefined<${type}>>>` : type;\n\t\t\t} else {\n\t\t\t\treturn fallback;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n\n/**\n * This function populates the proxies object, if necessary and not already done.\n * Proxies are used to tweak the code of a file before it's typechecked.\n * They are needed in two places - when generating the types for a page or layout.\n * To not do the same work twice, we generate the proxies once and pass them around.\n *\n * @param {import('types').PageNode} node\n * @param {Proxies} proxies\n */\nfunction ensureProxies(node, proxies) {\n\tif (node.server && !proxies.server) {\n\t\tproxies.server = createProxy(node.server, true);\n\t}\n\n\tif (node.universal && !proxies.universal) {\n\t\tproxies.universal = createProxy(node.universal, false);\n\t}\n}\n\n/**\n * @param {string} file_path\n * @param {boolean} is_server\n * @returns {Proxy}\n */\nfunction createProxy(file_path, is_server) {\n\tconst proxy = tweak_types(fs.readFileSync(file_path, 'utf8'), is_server);\n\tif (proxy) {\n\t\treturn {\n\t\t\t...proxy,\n\t\t\tfile_name: `proxy${path.basename(file_path)}`\n\t\t};\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Get the parent type string by recursively looking up the parent layout and accumulate them to one type.\n * @param {import('types').PageNode} node\n * @param {string} type\n */\nfunction get_parent_type(node, type) {\n\tconst parent_imports = [];\n\n\tlet parent = node.parent;\n\n\twhile (parent) {\n\t\tconst d = node.depth - parent.depth;\n\t\t// unshift because we need it the other way round for the import string\n\t\tparent_imports.unshift(\n\t\t\t`${d === 0 ? '' : `import('${'../'.repeat(d)}${'$types.js'}').`}${type}`\n\t\t);\n\t\tparent = parent.parent;\n\t}\n\n\tlet parent_str = `EnsureDefined<${parent_imports[0] || '{}'}>`;\n\tfor (let i = 1; i < parent_imports.length; i++) {\n\t\t// Omit is necessary because a parent could have a property with the same key which would\n\t\t// cause a type conflict. At runtime the child overwrites the parent property in this case,\n\t\t// so reflect that in the type definition.\n\t\t// EnsureDefined is necessary because {something: string} & null becomes null.\n\t\t// Output types of server loads can be null but when passed in through the `parent` parameter they are the empty object instead.\n\t\tparent_str = `Omit<${parent_str}, keyof ${parent_imports[i]}> & EnsureDefined<${parent_imports[i]}>`;\n\t}\n\treturn parent_str;\n}\n\n/**\n * @param {string} outdir\n * @param {string} file_path\n */\nfunction path_to_original(outdir, file_path) {\n\treturn posixify(path.relative(outdir, path.join(cwd, replace_ext_with_js(file_path))));\n}\n\n/**\n * @param {string} file_path\n */\nfunction replace_ext_with_js(file_path) {\n\t// Another extension than `.js` (or nothing, but that fails with node16 moduleResolution)\n\t// will result in TS failing to lookup the file\n\tconst ext = path.extname(file_path);\n\treturn file_path.slice(0, -ext.length) + '.js';\n}\n\n/**\n * @param {string} content\n * @param {boolean} is_server\n * @returns {Omit<NonNullable<Proxy>, 'file_name'> | null}\n */\nexport function tweak_types(content, is_server) {\n\tconst names = new Set(is_server ? ['load', 'actions'] : ['load']);\n\n\ttry {\n\t\tlet modified = false;\n\n\t\tconst ast = ts.createSourceFile(\n\t\t\t'filename.ts',\n\t\t\tcontent,\n\t\t\tts.ScriptTarget.Latest,\n\t\t\tfalse,\n\t\t\tts.ScriptKind.TS\n\t\t);\n\n\t\tconst code = new MagicString(content);\n\n\t\tconst exports = new Map();\n\n\t\tast.forEachChild((node) => {\n\t\t\tif (\n\t\t\t\tts.isExportDeclaration(node) &&\n\t\t\t\tnode.exportClause &&\n\t\t\t\tts.isNamedExports(node.exportClause)\n\t\t\t) {\n\t\t\t\tnode.exportClause.elements.forEach((element) => {\n\t\t\t\t\tconst exported = element.name;\n\t\t\t\t\tif (names.has(element.name.text)) {\n\t\t\t\t\t\tconst local = element.propertyName || element.name;\n\t\t\t\t\t\texports.set(exported.text, local.text);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (node.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword)) {\n\t\t\t\tif (ts.isFunctionDeclaration(node) && node.name?.text && names.has(node.name?.text)) {\n\t\t\t\t\texports.set(node.name.text, node.name.text);\n\t\t\t\t}\n\n\t\t\t\tif (ts.isVariableStatement(node)) {\n\t\t\t\t\tnode.declarationList.declarations.forEach((declaration) => {\n\t\t\t\t\t\tif (ts.isIdentifier(declaration.name) && names.has(declaration.name.text)) {\n\t\t\t\t\t\t\texports.set(declaration.name.text, declaration.name.text);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * @param {import('typescript').Node} node\n\t\t * @param {import('typescript').Node} value\n\t\t */\n\t\tfunction replace_jsdoc_type_tags(node, value) {\n\t\t\tlet _modified = false;\n\t\t\t// @ts-ignore\n\t\t\tif (node.jsDoc) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfor (const comment of node.jsDoc) {\n\t\t\t\t\tfor (const tag of comment.tags ?? []) {\n\t\t\t\t\t\tif (ts.isJSDocTypeTag(tag)) {\n\t\t\t\t\t\t\tconst is_fn =\n\t\t\t\t\t\t\t\tts.isFunctionDeclaration(value) ||\n\t\t\t\t\t\t\t\tts.isFunctionExpression(value) ||\n\t\t\t\t\t\t\t\tts.isArrowFunction(value);\n\n\t\t\t\t\t\t\tif (is_fn && value.parameters?.length > 0) {\n\t\t\t\t\t\t\t\tconst name = ts.isIdentifier(value.parameters[0].name)\n\t\t\t\t\t\t\t\t\t? value.parameters[0].name.text\n\t\t\t\t\t\t\t\t\t: 'event';\n\t\t\t\t\t\t\t\tcode.overwrite(tag.tagName.pos, tag.tagName.end, 'param');\n\t\t\t\t\t\t\t\tcode.prependRight(tag.typeExpression.pos + 1, 'Parameters<');\n\t\t\t\t\t\t\t\tcode.appendLeft(tag.typeExpression.end - 1, '>[0]');\n\t\t\t\t\t\t\t\tcode.appendLeft(tag.typeExpression.end, ` ${name}`);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcode.overwrite(tag.pos, tag.end, '');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_modified = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmodified = modified || _modified;\n\t\t\treturn _modified;\n\t\t}\n\n\t\tast.forEachChild((node) => {\n\t\t\tif (ts.isFunctionDeclaration(node) && node.name?.text && node.name?.text === 'load') {\n\t\t\t\t// remove JSDoc comment above `export function load ...`\n\t\t\t\treplace_jsdoc_type_tags(node, node);\n\t\t\t}\n\n\t\t\tif (ts.isVariableStatement(node)) {\n\t\t\t\t// remove JSDoc comment above `export const load = ...`\n\t\t\t\tif (\n\t\t\t\t\tts.isIdentifier(node.declarationList.declarations[0].name) &&\n\t\t\t\t\tnames.has(node.declarationList.declarations[0].name.text) &&\n\t\t\t\t\tnode.declarationList.declarations[0].initializer\n\t\t\t\t) {\n\t\t\t\t\treplace_jsdoc_type_tags(node, node.declarationList.declarations[0].initializer);\n\t\t\t\t}\n\n\t\t\t\tfor (const declaration of node.declarationList.declarations) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tts.isIdentifier(declaration.name) &&\n\t\t\t\t\t\tdeclaration.name.text === 'load' &&\n\t\t\t\t\t\tdeclaration.initializer\n\t\t\t\t\t) {\n\t\t\t\t\t\t// edge case — remove JSDoc comment above individual export\n\t\t\t\t\t\treplace_jsdoc_type_tags(declaration, declaration.initializer);\n\n\t\t\t\t\t\t// remove type from `export const load: Load ...`\n\t\t\t\t\t\tif (declaration.type) {\n\t\t\t\t\t\t\tlet a = declaration.type.pos;\n\t\t\t\t\t\t\tlet b = declaration.type.end;\n\t\t\t\t\t\t\twhile (/\\s/.test(content[a])) a += 1;\n\n\t\t\t\t\t\t\tconst type = content.slice(a, b);\n\t\t\t\t\t\t\tcode.remove(declaration.name.end, declaration.type.end);\n\n\t\t\t\t\t\t\tconst rhs = declaration.initializer;\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\trhs &&\n\t\t\t\t\t\t\t\t(ts.isArrowFunction(rhs) || ts.isFunctionExpression(rhs)) &&\n\t\t\t\t\t\t\t\trhs.parameters.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst arg = rhs.parameters[0];\n\t\t\t\t\t\t\t\tconst add_parens = content[arg.pos - 1] !== '(';\n\n\t\t\t\t\t\t\t\tif (add_parens) code.prependRight(arg.pos, '(');\n\n\t\t\t\t\t\t\t\tif (arg && !arg.type) {\n\t\t\t\t\t\t\t\t\tcode.appendLeft(\n\t\t\t\t\t\t\t\t\t\targ.name.end,\n\t\t\t\t\t\t\t\t\t\t`: Parameters<${type}>[0]` + (add_parens ? ')' : '')\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// prevent \"type X is imported but not used\" (isn't silenced by @ts-nocheck) when svelte-check runs\n\t\t\t\t\t\t\t\t\tcode.append(`;null as any as ${type};`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// prevent \"type X is imported but not used\" (isn't silenced by @ts-nocheck) when svelte-check runs\n\t\t\t\t\t\t\t\tcode.append(`;null as any as ${type};`);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tis_server &&\n\t\t\t\t\t\tts.isIdentifier(declaration.name) &&\n\t\t\t\t\t\tdeclaration.name?.text === 'actions' &&\n\t\t\t\t\t\tdeclaration.initializer\n\t\t\t\t\t) {\n\t\t\t\t\t\t// remove JSDoc comment from `export const actions = ..`\n\t\t\t\t\t\tconst removed = replace_jsdoc_type_tags(node, declaration.initializer);\n\t\t\t\t\t\t// ... and move type to each individual action\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tconst rhs = declaration.initializer;\n\t\t\t\t\t\t\tif (ts.isObjectLiteralExpression(rhs)) {\n\t\t\t\t\t\t\t\tfor (const prop of rhs.properties) {\n\t\t\t\t\t\t\t\t\tif (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {\n\t\t\t\t\t\t\t\t\t\tconst rhs = prop.initializer;\n\t\t\t\t\t\t\t\t\t\tconst replaced = replace_jsdoc_type_tags(prop, rhs);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!replaced &&\n\t\t\t\t\t\t\t\t\t\t\trhs &&\n\t\t\t\t\t\t\t\t\t\t\t(ts.isArrowFunction(rhs) || ts.isFunctionExpression(rhs)) &&\n\t\t\t\t\t\t\t\t\t\t\trhs.parameters?.[0]\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst name = ts.isIdentifier(rhs.parameters[0].name)\n\t\t\t\t\t\t\t\t\t\t\t\t? rhs.parameters[0].name.text\n\t\t\t\t\t\t\t\t\t\t\t\t: 'event';\n\t\t\t\t\t\t\t\t\t\t\tcode.prependRight(\n\t\t\t\t\t\t\t\t\t\t\t\trhs.pos,\n\t\t\t\t\t\t\t\t\t\t\t\t`/** @param {import('./$types').RequestEvent} ${name} */ `\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove type from `export const actions: Actions ...`\n\t\t\t\t\t\tif (declaration.type) {\n\t\t\t\t\t\t\tlet a = declaration.type.pos;\n\t\t\t\t\t\t\tlet b = declaration.type.end;\n\t\t\t\t\t\t\twhile (/\\s/.test(content[a])) a += 1;\n\n\t\t\t\t\t\t\tconst type = content.slice(a, b);\n\t\t\t\t\t\t\tcode.remove(declaration.name.end, declaration.type.end);\n\t\t\t\t\t\t\tcode.append(`;null as any as ${type};`);\n\t\t\t\t\t\t\tmodified = true;\n\n\t\t\t\t\t\t\t// ... and move type to each individual action\n\t\t\t\t\t\t\tconst rhs = declaration.initializer;\n\t\t\t\t\t\t\tif (ts.isObjectLiteralExpression(rhs)) {\n\t\t\t\t\t\t\t\tfor (const prop of rhs.properties) {\n\t\t\t\t\t\t\t\t\tif (ts.isPropertyAssignment(prop) && ts.isIdentifier(prop.name)) {\n\t\t\t\t\t\t\t\t\t\tconst rhs = prop.initializer;\n\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\trhs &&\n\t\t\t\t\t\t\t\t\t\t\t(ts.isArrowFunction(rhs) || ts.isFunctionExpression(rhs)) &&\n\t\t\t\t\t\t\t\t\t\t\trhs.parameters.length\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst arg = rhs.parameters[0];\n\t\t\t\t\t\t\t\t\t\t\tconst add_parens = content[arg.pos - 1] !== '(';\n\n\t\t\t\t\t\t\t\t\t\t\tif (add_parens) code.prependRight(arg.pos, '(');\n\n\t\t\t\t\t\t\t\t\t\t\tif (arg && !arg.type) {\n\t\t\t\t\t\t\t\t\t\t\t\tcode.appendLeft(\n\t\t\t\t\t\t\t\t\t\t\t\t\targ.name.end,\n\t\t\t\t\t\t\t\t\t\t\t\t\t`: import('./$types').RequestEvent` + (add_parens ? ')' : '')\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (modified) {\n\t\t\t// Ignore all type errors so they don't show up twice when svelte-check runs\n\t\t\t// Account for possible @ts-check which would overwrite @ts-nocheck\n\t\t\tif (code.original.startsWith('// @ts-check')) {\n\t\t\t\tcode.prependLeft('// @ts-check'.length, '\\n// @ts-nocheck\\n');\n\t\t\t} else {\n\t\t\t\tcode.prepend('// @ts-nocheck\\n');\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmodified,\n\t\t\tcode: code.toString(),\n\t\t\texports: Array.from(exports.keys())\n\t\t};\n\t} catch {\n\t\treturn null;\n\t}\n}\n"}}}}}},"utils.js":{"file":{"contents":"import path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport colors from 'kleur';\nimport { posixify, to_fs } from '../utils/filesystem.js';\n\n/**\n * Resolved path of the `runtime` directory\n *\n * TODO Windows issue:\n * Vite or sth else somehow sets the driver letter inconsistently to lower or upper case depending on the run environment.\n * In playwright debug mode run through VS Code this a root-to-lowercase conversion is needed in order for the tests to run.\n * If we do this conversion in other cases it has the opposite effect though and fails.\n */\nexport const runtime_directory = posixify(fileURLToPath(new URL('../runtime', import.meta.url)));\n\n/**\n * This allows us to import SvelteKit internals that aren't exposed via `pkg.exports` in a\n * way that works whether `@sveltejs/kit` is installed inside the project's `node_modules`\n * or in a workspace root\n */\nexport const runtime_base = runtime_directory.startsWith(process.cwd())\n\t? `/${path.relative('.', runtime_directory)}`\n\t: to_fs(runtime_directory);\n\nfunction noop() {}\n\n/** @param {{ verbose: boolean }} opts */\nexport function logger({ verbose }) {\n\t/** @type {import('types').Logger} */\n\tconst log = (msg) => console.log(msg.replace(/^/gm, '  '));\n\n\t/** @param {string} msg */\n\tconst err = (msg) => console.error(msg.replace(/^/gm, '  '));\n\n\tlog.success = (msg) => log(colors.green(`✔ ${msg}`));\n\tlog.error = (msg) => err(colors.bold().red(msg));\n\tlog.warn = (msg) => log(colors.bold().yellow(msg));\n\n\tlog.minor = verbose ? (msg) => log(colors.grey(msg)) : noop;\n\tlog.info = verbose ? log : noop;\n\n\treturn log;\n}\n\n/** @param {import('types').ManifestData} manifest_data */\nexport function get_mime_lookup(manifest_data) {\n\t/** @type {Record<string, string>} */\n\tconst mime = {};\n\n\tmanifest_data.assets.forEach((asset) => {\n\t\tif (asset.type) {\n\t\t\tconst ext = path.extname(asset.file);\n\t\t\tmime[ext] = asset.type;\n\t\t}\n\t});\n\n\treturn mime;\n}\n"}}}},"exports":{"directory":{"hooks":{"directory":{"index.js":{"file":{"contents":"export { sequence } from './sequence.js';\n"}},"sequence.js":{"file":{"contents":"/**\n * @param {...import('types').Handle} handlers\n * @returns {import('types').Handle}\n */\nexport function sequence(...handlers) {\n\tconst length = handlers.length;\n\tif (!length) return ({ event, resolve }) => resolve(event);\n\n\treturn ({ event, resolve }) => {\n\t\treturn apply_handle(0, event, {});\n\n\t\t/**\n\t\t * @param {number} i\n\t\t * @param {import('types').RequestEvent} event\n\t\t * @param {import('types').ResolveOptions | undefined} parent_options\n\t\t * @returns {import('types').MaybePromise<Response>}\n\t\t */\n\t\tfunction apply_handle(i, event, parent_options) {\n\t\t\tconst handle = handlers[i];\n\n\t\t\treturn handle({\n\t\t\t\tevent,\n\t\t\t\tresolve: (event, options) => {\n\t\t\t\t\t/** @param {{ html: string, done: boolean }} opts */\n\t\t\t\t\tconst transformPageChunk = async ({ html, done }) => {\n\t\t\t\t\t\tif (options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parent_options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await parent_options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn html;\n\t\t\t\t\t};\n\n\t\t\t\t\treturn i < length - 1\n\t\t\t\t\t\t? apply_handle(i + 1, event, { transformPageChunk })\n\t\t\t\t\t\t: resolve(event, { transformPageChunk });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n"}}}},"index.js":{"file":{"contents":"import { HttpError, Redirect, ActionFailure } from '../runtime/control.js';\nimport { BROWSER, DEV } from 'esm-env';\n\n// For some reason we need to type the params as well here,\n// JSdoc doesn't seem to like @type with function overloads\n/**\n * @type {import('@sveltejs/kit').error}\n * @param {number} status\n * @param {any} message\n */\nexport function error(status, message) {\n\tif ((!BROWSER || DEV) && (isNaN(status) || status < 400 || status > 599)) {\n\t\tthrow new Error(`HTTP error status codes must be between 400 and 599 — ${status} is invalid`);\n\t}\n\n\treturn new HttpError(status, message);\n}\n\n/** @type {import('@sveltejs/kit').redirect} */\nexport function redirect(status, location) {\n\tif ((!BROWSER || DEV) && (isNaN(status) || status < 300 || status > 308)) {\n\t\tthrow new Error('Invalid status code');\n\t}\n\n\treturn new Redirect(status, location);\n}\n\n/** @type {import('@sveltejs/kit').json} */\nexport function json(data, init) {\n\t// TODO deprecate this in favour of `Response.json` when it's\n\t// more widely supported\n\tconst body = JSON.stringify(data);\n\n\t// we can't just do `text(JSON.stringify(data), init)` because\n\t// it will set a default `content-type` header. duplicated code\n\t// means less duplicated work\n\tconst headers = new Headers(init?.headers);\n\tif (!headers.has('content-length')) {\n\t\theaders.set('content-length', encoder.encode(body).byteLength.toString());\n\t}\n\n\tif (!headers.has('content-type')) {\n\t\theaders.set('content-type', 'application/json');\n\t}\n\n\treturn new Response(body, {\n\t\t...init,\n\t\theaders\n\t});\n}\n\nconst encoder = new TextEncoder();\n\n/** @type {import('@sveltejs/kit').text} */\nexport function text(body, init) {\n\tconst headers = new Headers(init?.headers);\n\tif (!headers.has('content-length')) {\n\t\theaders.set('content-length', encoder.encode(body).byteLength.toString());\n\t}\n\n\treturn new Response(body, {\n\t\t...init,\n\t\theaders\n\t});\n}\n\n/**\n * Generates an `ActionFailure` object.\n * @param {number} status\n * @param {Record<string, any> | undefined} [data]\n */\nexport function fail(status, data) {\n\treturn new ActionFailure(status, data);\n}\n"}},"node":{"directory":{"index.js":{"file":{"contents":"import * as set_cookie_parser from 'set-cookie-parser';\nimport { error } from '../index.js';\n\n/**\n * @param {import('http').IncomingMessage} req\n * @param {number} [body_size_limit]\n */\nfunction get_raw_body(req, body_size_limit) {\n\tconst h = req.headers;\n\n\tif (!h['content-type']) {\n\t\treturn null;\n\t}\n\n\tconst content_length = Number(h['content-length']);\n\n\t// check if no request body\n\tif (\n\t\t(req.httpVersionMajor === 1 && isNaN(content_length) && h['transfer-encoding'] == null) ||\n\t\tcontent_length === 0\n\t) {\n\t\treturn null;\n\t}\n\n\tlet length = content_length;\n\n\tif (body_size_limit) {\n\t\tif (!length) {\n\t\t\tlength = body_size_limit;\n\t\t} else if (length > body_size_limit) {\n\t\t\tthrow error(\n\t\t\t\t413,\n\t\t\t\t`Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n\t\t\t);\n\t\t}\n\t}\n\n\tif (req.destroyed) {\n\t\tconst readable = new ReadableStream();\n\t\treadable.cancel();\n\t\treturn readable;\n\t}\n\n\tlet size = 0;\n\tlet cancelled = false;\n\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\treq.on('error', (error) => {\n\t\t\t\tcancelled = true;\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\n\t\t\treq.on('end', () => {\n\t\t\t\tif (cancelled) return;\n\t\t\t\tcontroller.close();\n\t\t\t});\n\n\t\t\treq.on('data', (chunk) => {\n\t\t\t\tif (cancelled) return;\n\n\t\t\t\tsize += chunk.length;\n\t\t\t\tif (size > length) {\n\t\t\t\t\tcancelled = true;\n\t\t\t\t\tcontroller.error(\n\t\t\t\t\t\terror(\n\t\t\t\t\t\t\t413,\n\t\t\t\t\t\t\t`request body size exceeded ${\n\t\t\t\t\t\t\t\tcontent_length ? \"'content-length'\" : 'BODY_SIZE_LIMIT'\n\t\t\t\t\t\t\t} of ${length}`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontroller.enqueue(chunk);\n\n\t\t\t\tif (controller.desiredSize === null || controller.desiredSize <= 0) {\n\t\t\t\t\treq.pause();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tpull() {\n\t\t\treq.resume();\n\t\t},\n\n\t\tcancel(reason) {\n\t\t\tcancelled = true;\n\t\t\treq.destroy(reason);\n\t\t}\n\t});\n}\n\n/** @type {import('@sveltejs/kit/node').getRequest} */\nexport async function getRequest({ request, base, bodySizeLimit }) {\n\treturn new Request(base + request.url, {\n\t\t// @ts-expect-error\n\t\tduplex: 'half',\n\t\tmethod: request.method,\n\t\theaders: /** @type {Record<string, string>} */ (request.headers),\n\t\tbody: get_raw_body(request, bodySizeLimit)\n\t});\n}\n\n/** @type {import('@sveltejs/kit/node').setResponse} */\nexport async function setResponse(res, response) {\n\tconst headers = Object.fromEntries(response.headers);\n\n\tif (response.headers.has('set-cookie')) {\n\t\tconst header = /** @type {string} */ (response.headers.get('set-cookie'));\n\t\tconst split = set_cookie_parser.splitCookiesString(header);\n\n\t\t// @ts-expect-error\n\t\theaders['set-cookie'] = split;\n\t}\n\n\tres.writeHead(response.status, headers);\n\n\tif (!response.body) {\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (response.body.locked) {\n\t\tres.write(\n\t\t\t'Fatal error: Response body is locked. ' +\n\t\t\t\t`This can happen when the response was already read (for example through 'response.json()' or 'response.text()').`\n\t\t);\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tconst reader = response.body.getReader();\n\n\tif (res.destroyed) {\n\t\treader.cancel();\n\t\treturn;\n\t}\n\n\tconst cancel = (/** @type {Error|undefined} */ error) => {\n\t\tres.off('close', cancel);\n\t\tres.off('error', cancel);\n\n\t\t// If the reader has already been interrupted with an error earlier,\n\t\t// then it will appear here, it is useless, but it needs to be catch.\n\t\treader.cancel(error).catch(() => {});\n\t\tif (error) res.destroy(error);\n\t};\n\n\tres.on('close', cancel);\n\tres.on('error', cancel);\n\n\tnext();\n\tasync function next() {\n\t\ttry {\n\t\t\tfor (;;) {\n\t\t\t\tconst { done, value } = await reader.read();\n\n\t\t\t\tif (done) break;\n\n\t\t\t\tif (!res.write(value)) {\n\t\t\t\t\tres.once('drain', next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.end();\n\t\t} catch (error) {\n\t\t\tcancel(error instanceof Error ? error : new Error(String(error)));\n\t\t}\n\t}\n}\n"}},"polyfills.js":{"file":{"contents":"import { ReadableStream, TransformStream, WritableStream } from 'node:stream/web';\nimport buffer from 'node:buffer';\nimport { webcrypto as crypto } from 'node:crypto';\nimport { fetch, Response, Request, Headers, FormData, File as UndiciFile } from 'undici';\n\n// @ts-expect-error\nconst File = buffer.File ?? UndiciFile;\n\n/** @type {Record<string, any>} */\nconst globals = {\n\tcrypto,\n\tfetch,\n\tResponse,\n\tRequest,\n\tHeaders,\n\tReadableStream,\n\tTransformStream,\n\tWritableStream,\n\tFormData,\n\tFile\n};\n\n// exported for dev/preview and node environments\n// TODO: remove this once we only support Node 18.11+ (the version multipart/form-data was added)\nexport function installPolyfills() {\n\tfor (const name in globals) {\n\t\tObject.defineProperty(globalThis, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tvalue: globals[name]\n\t\t});\n\t}\n}\n"}}}},"vite":{"directory":{"build":{"directory":{"build_server.js":{"file":{"contents":"import fs from 'node:fs';\nimport { mkdirp } from '../../../utils/filesystem.js';\nimport { find_deps, resolve_symlinks } from './utils.js';\nimport { s } from '../../../utils/misc.js';\n\n/**\n * @param {string} out\n * @param {import('types').ValidatedKitConfig} kit\n * @param {import('types').ManifestData} manifest_data\n * @param {import('vite').Manifest} server_manifest\n * @param {import('vite').Manifest | null} client_manifest\n * @param {import('rollup').OutputAsset[] | null} css\n */\nexport function build_server_nodes(out, kit, manifest_data, server_manifest, client_manifest, css) {\n\tmkdirp(`${out}/server/nodes`);\n\tmkdirp(`${out}/server/stylesheets`);\n\n\tconst stylesheet_lookup = new Map();\n\n\tif (css) {\n\t\tcss.forEach((asset) => {\n\t\t\tif (asset.source.length < kit.inlineStyleThreshold) {\n\t\t\t\tconst index = stylesheet_lookup.size;\n\t\t\t\tconst file = `${out}/server/stylesheets/${index}.js`;\n\n\t\t\t\tfs.writeFileSync(file, `// ${asset.fileName}\\nexport default ${s(asset.source)};`);\n\t\t\t\tstylesheet_lookup.set(asset.fileName, index);\n\t\t\t}\n\t\t});\n\t}\n\n\tmanifest_data.nodes.forEach((node, i) => {\n\t\t/** @type {string[]} */\n\t\tconst imports = [];\n\n\t\t// String representation of\n\t\t/** @type {import('types').SSRNode} */\n\t\t/** @type {string[]} */\n\t\tconst exports = [`export const index = ${i};`];\n\n\t\t/** @type {string[]} */\n\t\tconst imported = [];\n\n\t\t/** @type {string[]} */\n\t\tconst stylesheets = [];\n\n\t\t/** @type {string[]} */\n\t\tconst fonts = [];\n\n\t\tif (node.component && client_manifest) {\n\t\t\tconst entry = find_deps(client_manifest, node.component, true);\n\n\t\t\timported.push(...entry.imports);\n\t\t\tstylesheets.push(...entry.stylesheets);\n\t\t\tfonts.push(...entry.fonts);\n\n\t\t\texports.push(\n\t\t\t\t`export const component = async () => (await import('../${\n\t\t\t\t\tresolve_symlinks(server_manifest, node.component).chunk.file\n\t\t\t\t}')).default;`,\n\t\t\t\t`export const file = '${entry.file}';` // TODO what is this?\n\t\t\t);\n\t\t}\n\n\t\tif (node.universal) {\n\t\t\tif (client_manifest) {\n\t\t\t\tconst entry = find_deps(client_manifest, node.universal, true);\n\n\t\t\t\timported.push(...entry.imports);\n\t\t\t\tstylesheets.push(...entry.stylesheets);\n\t\t\t\tfonts.push(...entry.fonts);\n\t\t\t}\n\n\t\t\timports.push(`import * as universal from '../${server_manifest[node.universal].file}';`);\n\t\t\texports.push(`export { universal };`);\n\t\t\texports.push(`export const universal_id = ${s(node.universal)};`);\n\t\t}\n\n\t\tif (node.server) {\n\t\t\timports.push(`import * as server from '../${server_manifest[node.server].file}';`);\n\t\t\texports.push(`export { server };`);\n\t\t\texports.push(`export const server_id = ${s(node.server)};`);\n\t\t}\n\n\t\texports.push(\n\t\t\t`export const imports = ${s(imported)};`,\n\t\t\t`export const stylesheets = ${s(stylesheets)};`,\n\t\t\t`export const fonts = ${s(fonts)};`\n\t\t);\n\n\t\t/** @type {string[]} */\n\t\tconst styles = [];\n\n\t\tstylesheets.forEach((file) => {\n\t\t\tif (stylesheet_lookup.has(file)) {\n\t\t\t\tconst index = stylesheet_lookup.get(file);\n\t\t\t\tconst name = `stylesheet_${index}`;\n\t\t\t\timports.push(`import ${name} from '../stylesheets/${index}.js';`);\n\t\t\t\tstyles.push(`\\t${s(file)}: ${name}`);\n\t\t\t}\n\t\t});\n\n\t\tif (styles.length > 0) {\n\t\t\texports.push(`export const inline_styles = () => ({\\n${styles.join(',\\n')}\\n});`);\n\t\t}\n\n\t\tfs.writeFileSync(\n\t\t\t`${out}/server/nodes/${i}.js`,\n\t\t\t`${imports.join('\\n')}\\n\\n${exports.join('\\n')}\\n`\n\t\t);\n\t});\n}\n"}},"build_service_worker.js":{"file":{"contents":"import fs from 'node:fs';\nimport * as vite from 'vite';\nimport { dedent } from '../../../core/sync/utils.js';\nimport { s } from '../../../utils/misc.js';\nimport { get_config_aliases } from '../utils.js';\nimport { assets_base } from './utils.js';\n\n/**\n * @param {string} out\n * @param {import('types').ValidatedKitConfig} kit\n * @param {import('vite').ResolvedConfig} vite_config\n * @param {import('types').ManifestData} manifest_data\n * @param {string} service_worker_entry_file\n * @param {import('types').Prerendered} prerendered\n * @param {import('vite').Manifest} client_manifest\n */\nexport async function build_service_worker(\n\tout,\n\tkit,\n\tvite_config,\n\tmanifest_data,\n\tservice_worker_entry_file,\n\tprerendered,\n\tclient_manifest\n) {\n\tconst build = new Set();\n\tfor (const key in client_manifest) {\n\t\tconst { file, css = [], assets = [] } = client_manifest[key];\n\t\tbuild.add(file);\n\t\tcss.forEach((file) => build.add(file));\n\t\tassets.forEach((file) => build.add(file));\n\t}\n\n\tconst service_worker = `${kit.outDir}/generated/service-worker.js`;\n\n\tfs.writeFileSync(\n\t\tservice_worker,\n\t\tdedent`\n\t\t\texport const build = [\n\t\t\t\t${Array.from(build)\n\t\t\t\t\t.map((file) => `${s(`${kit.paths.base}/${file}`)}`)\n\t\t\t\t\t.join(',\\n')}\n\t\t\t];\n\n\t\t\texport const files = [\n\t\t\t\t${manifest_data.assets\n\t\t\t\t\t.filter((asset) => kit.serviceWorker.files(asset.file))\n\t\t\t\t\t.map((asset) => `${s(`${kit.paths.base}/${asset.file}`)}`)\n\t\t\t\t\t.join(',\\n')}\n\t\t\t];\n\n\t\t\texport const prerendered = [\n\t\t\t\t${prerendered.paths.map((path) => s(path)).join(',\\n')}\n\t\t\t];\n\n\t\t\texport const version = ${s(kit.version.name)};\n\t\t`\n\t);\n\n\tawait vite.build({\n\t\tbase: assets_base(kit),\n\t\tbuild: {\n\t\t\tlib: {\n\t\t\t\tentry: /** @type {string} */ (service_worker_entry_file),\n\t\t\t\tname: 'app',\n\t\t\t\tformats: ['es']\n\t\t\t},\n\t\t\trollupOptions: {\n\t\t\t\toutput: {\n\t\t\t\t\tentryFileNames: 'service-worker.js'\n\t\t\t\t}\n\t\t\t},\n\t\t\toutDir: `${out}/client`,\n\t\t\temptyOutDir: false\n\t\t},\n\t\tdefine: vite_config.define,\n\t\tconfigFile: false,\n\t\tresolve: {\n\t\t\talias: [...get_config_aliases(kit), { find: '$service-worker', replacement: service_worker }]\n\t\t}\n\t});\n}\n"}},"utils.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Adds transitive JS and CSS dependencies to the js and css inputs.\n * @param {import('vite').Manifest} manifest\n * @param {string} entry\n * @param {boolean} add_dynamic_css\n * @returns {import('types').AssetDependencies}\n */\nexport function find_deps(manifest, entry, add_dynamic_css) {\n\t/** @type {Set<string>} */\n\tconst seen = new Set();\n\n\t/** @type {Set<string>} */\n\tconst imports = new Set();\n\n\t/** @type {Set<string>} */\n\tconst stylesheets = new Set();\n\n\t/** @type {Set<string>} */\n\tconst fonts = new Set();\n\n\t/**\n\t * @param {string} current\n\t * @param {boolean} add_js\n\t */\n\tfunction traverse(current, add_js) {\n\t\tif (seen.has(current)) return;\n\t\tseen.add(current);\n\n\t\tconst { chunk } = resolve_symlinks(manifest, current);\n\n\t\tif (add_js) imports.add(chunk.file);\n\n\t\tif (chunk.assets) {\n\t\t\tfor (const asset of chunk.assets) {\n\t\t\t\tif (/\\.(woff2?|ttf|otf)$/.test(asset)) {\n\t\t\t\t\tfonts.add(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chunk.css) {\n\t\t\tchunk.css.forEach((file) => stylesheets.add(file));\n\t\t}\n\n\t\tif (chunk.imports) {\n\t\t\tchunk.imports.forEach((file) => traverse(file, add_js));\n\t\t}\n\n\t\tif (add_dynamic_css && chunk.dynamicImports) {\n\t\t\tchunk.dynamicImports.forEach((file) => traverse(file, false));\n\t\t}\n\t}\n\n\tconst { chunk, file } = resolve_symlinks(manifest, entry);\n\n\ttraverse(file, true);\n\n\treturn {\n\t\tfile: chunk.file,\n\t\timports: Array.from(imports),\n\t\tstylesheets: Array.from(stylesheets),\n\t\tfonts: Array.from(fonts)\n\t};\n}\n\n/**\n * @param {import('vite').Manifest} manifest\n * @param {string} file\n */\nexport function resolve_symlinks(manifest, file) {\n\twhile (!manifest[file]) {\n\t\tfile = path.relative('.', fs.realpathSync(file));\n\t}\n\n\tconst chunk = manifest[file];\n\n\treturn { chunk, file };\n}\n\n/**\n * @param {import('types').ValidatedKitConfig} config\n * @returns {string}\n */\nexport function assets_base(config) {\n\treturn (config.paths.assets || config.paths.base || '.') + '/';\n}\n\nconst method_names = new Set(['GET', 'HEAD', 'PUT', 'POST', 'DELETE', 'PATCH', 'OPTIONS']);\n\n// If we'd written this in TypeScript, it could be easy...\n/**\n * @param {string} str\n * @returns {str is import('types').HttpMethod}\n */\nexport function is_http_method(str) {\n\treturn method_names.has(str);\n}\n"}}}},"dev":{"directory":{"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\nimport { URL } from 'node:url';\nimport colors from 'kleur';\nimport sirv from 'sirv';\nimport { isCSSRequest, loadEnv, buildErrorMessage } from 'vite';\nimport { getRequest, setResponse } from '../../../exports/node/index.js';\nimport { installPolyfills } from '../../../exports/node/polyfills.js';\nimport { coalesce_to_error } from '../../../utils/error.js';\nimport { posixify, resolve_entry, to_fs } from '../../../utils/filesystem.js';\nimport { should_polyfill } from '../../../utils/platform.js';\nimport { load_error_page } from '../../../core/config/index.js';\nimport { SVELTE_KIT_ASSETS } from '../../../constants.js';\nimport * as sync from '../../../core/sync/sync.js';\nimport { get_mime_lookup, runtime_base } from '../../../core/utils.js';\nimport { compact } from '../../../utils/array.js';\nimport { not_found } from '../utils.js';\n\nconst cwd = process.cwd();\n\n/**\n * @param {import('vite').ViteDevServer} vite\n * @param {import('vite').ResolvedConfig} vite_config\n * @param {import('types').ValidatedConfig} svelte_config\n * @return {Promise<Promise<() => void>>}\n */\nexport async function dev(vite, vite_config, svelte_config) {\n\tif (should_polyfill) {\n\t\tinstallPolyfills();\n\t}\n\n\tconst fetch = globalThis.fetch;\n\tglobalThis.fetch = (info, init) => {\n\t\tif (typeof info === 'string' && !/^\\w+:\\/\\//.test(info)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot use relative URL (${info}) with global fetch — use \\`event.fetch\\` instead: https://kit.svelte.dev/docs/web-standards#fetch-apis`\n\t\t\t);\n\t\t}\n\n\t\treturn fetch(info, init);\n\t};\n\n\tsync.init(svelte_config, vite_config.mode);\n\n\t/** @type {import('types').ManifestData} */\n\tlet manifest_data;\n\t/** @type {import('types').SSRManifest} */\n\tlet manifest;\n\n\t/** @type {Error | null} */\n\tlet manifest_error = null;\n\n\t/** @param {string} url */\n\tasync function loud_ssr_load_module(url) {\n\t\ttry {\n\t\t\treturn await vite.ssrLoadModule(url);\n\t\t} catch (/** @type {any} */ err) {\n\t\t\tconst msg = buildErrorMessage(err, [colors.red(`Internal server error: ${err.message}`)]);\n\n\t\t\tvite.config.logger.error(msg, { error: err });\n\t\t\tvite.ws.send({ type: 'error', err: err });\n\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/** @param {string} id */\n\tasync function resolve(id) {\n\t\tconst url = id.startsWith('..') ? `/@fs${path.posix.resolve(id)}` : `/${id}`;\n\n\t\tconst module = await loud_ssr_load_module(url);\n\n\t\tconst module_node = await vite.moduleGraph.getModuleByUrl(url);\n\t\tif (!module_node) throw new Error(`Could not find node for ${url}`);\n\n\t\treturn { module, module_node, url };\n\t}\n\n\tasync function update_manifest() {\n\t\ttry {\n\t\t\t({ manifest_data } = await sync.create(svelte_config));\n\n\t\t\tif (manifest_error) {\n\t\t\t\tmanifest_error = null;\n\t\t\t\tvite.ws.send({ type: 'full-reload' });\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tmanifest_error = /** @type {Error} */ (error);\n\n\t\t\tconsole.error(colors.bold().red(manifest_error.message));\n\t\t\tvite.ws.send({\n\t\t\t\ttype: 'error',\n\t\t\t\terr: {\n\t\t\t\t\tmessage: manifest_error.message ?? 'Invalid routes',\n\t\t\t\t\tstack: ''\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tmanifest = {\n\t\t\tappDir: svelte_config.kit.appDir,\n\t\t\tappPath: svelte_config.kit.appDir,\n\t\t\tassets: new Set(manifest_data.assets.map((asset) => asset.file)),\n\t\t\tmimeTypes: get_mime_lookup(manifest_data),\n\t\t\t_: {\n\t\t\t\tclient: {\n\t\t\t\t\tstart: {\n\t\t\t\t\t\tfile: `${runtime_base}/client/start.js`,\n\t\t\t\t\t\timports: [],\n\t\t\t\t\t\tstylesheets: [],\n\t\t\t\t\t\tfonts: []\n\t\t\t\t\t},\n\t\t\t\t\tapp: {\n\t\t\t\t\t\tfile: `${svelte_config.kit.outDir}/generated/client/app.js`,\n\t\t\t\t\t\timports: [],\n\t\t\t\t\t\tstylesheets: [],\n\t\t\t\t\t\tfonts: []\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnodes: manifest_data.nodes.map((node, index) => {\n\t\t\t\t\treturn async () => {\n\t\t\t\t\t\t/** @type {import('types').SSRNode} */\n\t\t\t\t\t\tconst result = {};\n\n\t\t\t\t\t\t/** @type {import('vite').ModuleNode[]} */\n\t\t\t\t\t\tconst module_nodes = [];\n\n\t\t\t\t\t\tresult.index = index;\n\n\t\t\t\t\t\t// these are unused in dev, it's easier to include them\n\t\t\t\t\t\tresult.imports = [];\n\t\t\t\t\t\tresult.stylesheets = [];\n\t\t\t\t\t\tresult.fonts = [];\n\n\t\t\t\t\t\tif (node.component) {\n\t\t\t\t\t\t\tresult.component = async () => {\n\t\t\t\t\t\t\t\tconst { module_node, module, url } = await resolve(\n\t\t\t\t\t\t\t\t\t/** @type {string} */ (node.component)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tmodule_nodes.push(module_node);\n\t\t\t\t\t\t\t\tresult.file = url.endsWith('.svelte') ? url : url + '?import'; // TODO what is this for?\n\n\t\t\t\t\t\t\t\treturn module.default;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.universal) {\n\t\t\t\t\t\t\tconst { module, module_node } = await resolve(node.universal);\n\n\t\t\t\t\t\t\tmodule_nodes.push(module_node);\n\n\t\t\t\t\t\t\tresult.universal = module;\n\t\t\t\t\t\t\tresult.universal_id = node.universal;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.server) {\n\t\t\t\t\t\t\tconst { module } = await resolve(node.server);\n\t\t\t\t\t\t\tresult.server = module;\n\t\t\t\t\t\t\tresult.server_id = node.server;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// in dev we inline all styles to avoid FOUC. this gets populated lazily so that\n\t\t\t\t\t\t// components/stylesheets loaded via import() during `load` are included\n\t\t\t\t\t\tresult.inline_styles = async () => {\n\t\t\t\t\t\t\tconst deps = new Set();\n\n\t\t\t\t\t\t\tfor (const module_node of module_nodes) {\n\t\t\t\t\t\t\t\tawait find_deps(vite, module_node, deps);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/** @type {Record<string, string>} */\n\t\t\t\t\t\t\tconst styles = {};\n\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tconst parsed = new URL(dep.url, 'http://localhost/');\n\t\t\t\t\t\t\t\tconst query = parsed.searchParams;\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisCSSRequest(dep.file) ||\n\t\t\t\t\t\t\t\t\t(query.has('svelte') && query.get('type') === 'style')\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst mod = await loud_ssr_load_module(dep.url);\n\t\t\t\t\t\t\t\t\t\tstyles[dep.url] = mod.default;\n\t\t\t\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t\t\t\t// this can happen with dynamically imported modules, I think\n\t\t\t\t\t\t\t\t\t\t// because the Vite module graph doesn't distinguish between\n\t\t\t\t\t\t\t\t\t\t// static and dynamic imports? TODO investigate, submit fix\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn styles;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\troutes: compact(\n\t\t\t\t\tmanifest_data.routes.map((route) => {\n\t\t\t\t\t\tif (!route.page && !route.endpoint) return null;\n\n\t\t\t\t\t\tconst endpoint = route.endpoint;\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tid: route.id,\n\t\t\t\t\t\t\tpattern: route.pattern,\n\t\t\t\t\t\t\tparams: route.params,\n\t\t\t\t\t\t\tpage: route.page,\n\t\t\t\t\t\t\tendpoint: endpoint\n\t\t\t\t\t\t\t\t? async () => {\n\t\t\t\t\t\t\t\t\t\tconst url = path.resolve(cwd, endpoint.file);\n\t\t\t\t\t\t\t\t\t\treturn await loud_ssr_load_module(url);\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\tendpoint_id: endpoint?.file\n\t\t\t\t\t\t};\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tmatchers: async () => {\n\t\t\t\t\t/** @type {Record<string, import('types').ParamMatcher>} */\n\t\t\t\t\tconst matchers = {};\n\n\t\t\t\t\tfor (const key in manifest_data.matchers) {\n\t\t\t\t\t\tconst file = manifest_data.matchers[key];\n\t\t\t\t\t\tconst url = path.resolve(cwd, file);\n\t\t\t\t\t\tconst module = await vite.ssrLoadModule(url);\n\n\t\t\t\t\t\tif (module.match) {\n\t\t\t\t\t\t\tmatchers[key] = module.match;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(`${file} does not export a \\`match\\` function`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn matchers;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/** @param {string} stack */\n\tfunction fix_stack_trace(stack) {\n\t\treturn stack ? vite.ssrRewriteStacktrace(stack) : stack;\n\t}\n\n\tawait update_manifest();\n\n\t/**\n\t * @param {string} event\n\t * @param {(file: string) => void} cb\n\t */\n\tconst watch = (event, cb) => {\n\t\tvite.watcher.on(event, (file) => {\n\t\t\tif (\n\t\t\t\tfile.startsWith(svelte_config.kit.files.routes + path.sep) ||\n\t\t\t\tfile.startsWith(svelte_config.kit.files.params + path.sep) ||\n\t\t\t\t// in contrast to server hooks, client hooks are written to the client manifest\n\t\t\t\t// and therefore need rebuilding when they are added/removed\n\t\t\t\tfile.startsWith(svelte_config.kit.files.hooks.client)\n\t\t\t) {\n\t\t\t\tcb(file);\n\t\t\t}\n\t\t});\n\t};\n\t/** @type {NodeJS.Timeout | null } */\n\tlet timeout = null;\n\t/** @param {() => void} to_run */\n\tconst debounce = (to_run) => {\n\t\ttimeout && clearTimeout(timeout);\n\t\ttimeout = setTimeout(() => {\n\t\t\ttimeout = null;\n\t\t\tto_run();\n\t\t}, 100);\n\t};\n\n\t// flag to skip watchers if server is already restarting\n\tlet restarting = false;\n\n\t// Debounce add/unlink events because in case of folder deletion or moves\n\t// they fire in rapid succession, causing needless invocations.\n\twatch('add', () => debounce(update_manifest));\n\twatch('unlink', () => debounce(update_manifest));\n\twatch('change', (file) => {\n\t\t// Don't run for a single file if the whole manifest is about to get updated\n\t\tif (timeout || restarting) return;\n\n\t\tsync.update(svelte_config, manifest_data, file);\n\t});\n\n\tconst { appTemplate, errorTemplate, serviceWorker, hooks } = svelte_config.kit.files;\n\n\t// vite client only executes a full reload if the triggering html file path is index.html\n\t// kit defaults to src/app.html, so unless user changed that to index.html\n\t// send the vite client a full-reload event without path being set\n\tif (appTemplate !== 'index.html') {\n\t\tvite.watcher.on('change', (file) => {\n\t\t\tif (file === appTemplate && !restarting) {\n\t\t\t\tvite.ws.send({ type: 'full-reload' });\n\t\t\t}\n\t\t});\n\t}\n\n\tvite.watcher.on('all', (_, file) => {\n\t\tif (\n\t\t\tfile === appTemplate ||\n\t\t\tfile === errorTemplate ||\n\t\t\tfile.startsWith(serviceWorker) ||\n\t\t\tfile.startsWith(hooks.server)\n\t\t) {\n\t\t\tsync.server(svelte_config);\n\t\t}\n\t});\n\n\t// changing the svelte config requires restarting the dev server\n\t// the config is only read on start and passed on to vite-plugin-svelte\n\t// which needs up-to-date values to operate correctly\n\tvite.watcher.on('change', (file) => {\n\t\tif (path.basename(file) === 'svelte.config.js') {\n\t\t\tconsole.log(`svelte config changed, restarting vite dev-server. changed file: ${file}`);\n\t\t\trestarting = true;\n\t\t\tvite.restart();\n\t\t}\n\t});\n\n\tconst assets = svelte_config.kit.paths.assets ? SVELTE_KIT_ASSETS : svelte_config.kit.paths.base;\n\tconst asset_server = sirv(svelte_config.kit.files.assets, {\n\t\tdev: true,\n\t\tetag: true,\n\t\tmaxAge: 0,\n\t\textensions: [],\n\t\tsetHeaders: (res) => {\n\t\t\tres.setHeader('access-control-allow-origin', '*');\n\t\t}\n\t});\n\n\tasync function align_exports() {\n\t\t// This shameful hack allows us to load runtime server code via Vite\n\t\t// while apps load `HttpError` and `Redirect` in Node, without\n\t\t// causing `instanceof` checks to fail\n\t\tconst control_module_node = await import(`../../../runtime/control.js`);\n\t\tconst control_module_vite = await vite.ssrLoadModule(`${runtime_base}/control.js`);\n\n\t\tcontrol_module_node.replace_implementations({\n\t\t\tActionFailure: control_module_vite.ActionFailure,\n\t\t\tHttpError: control_module_vite.HttpError,\n\t\t\tRedirect: control_module_vite.Redirect\n\t\t});\n\t}\n\talign_exports();\n\tconst ws_send = vite.ws.send;\n\t/** @param {any} args */\n\tvite.ws.send = function (...args) {\n\t\t// We need to reapply the patch after Vite did dependency optimizations\n\t\t// because that clears the module resolutions\n\t\tif (args[0]?.type === 'full-reload' && args[0].path === '*') {\n\t\t\talign_exports();\n\t\t}\n\t\treturn ws_send.apply(vite.ws, args);\n\t};\n\n\tvite.middlewares.use(async (req, res, next) => {\n\t\ttry {\n\t\t\tconst base = `${vite.config.server.https ? 'https' : 'http'}://${\n\t\t\t\treq.headers[':authority'] || req.headers.host\n\t\t\t}`;\n\n\t\t\tconst decoded = decodeURI(new URL(base + req.url).pathname);\n\n\t\t\tif (decoded.startsWith(assets)) {\n\t\t\t\tconst pathname = decoded.slice(assets.length);\n\t\t\t\tconst file = svelte_config.kit.files.assets + pathname;\n\n\t\t\t\tif (fs.existsSync(file) && !fs.statSync(file).isDirectory()) {\n\t\t\t\t\tif (has_correct_case(file, svelte_config.kit.files.assets)) {\n\t\t\t\t\t\treq.url = encodeURI(pathname); // don't need query/hash\n\t\t\t\t\t\tasset_server(req, res);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext();\n\t\t} catch (e) {\n\t\t\tconst error = coalesce_to_error(e);\n\t\t\tres.statusCode = 500;\n\t\t\tres.end(fix_stack_trace(/** @type {string} */ (error.stack)));\n\t\t}\n\t});\n\n\tconst env = loadEnv(vite_config.mode, svelte_config.kit.env.dir, '');\n\n\treturn () => {\n\t\tconst serve_static_middleware = vite.middlewares.stack.find(\n\t\t\t(middleware) =>\n\t\t\t\t/** @type {function} */ (middleware.handle).name === 'viteServeStaticMiddleware'\n\t\t);\n\n\t\t// Vite will give a 403 on URLs like /test, /static, and /package.json preventing us from\n\t\t// serving routes with those names. See https://github.com/vitejs/vite/issues/7363\n\t\tremove_static_middlewares(vite.middlewares);\n\n\t\tvite.middlewares.use(async (req, res) => {\n\t\t\t// Vite's base middleware strips out the base path. Restore it\n\t\t\tconst original_url = req.url;\n\t\t\treq.url = req.originalUrl;\n\t\t\ttry {\n\t\t\t\tconst base = `${vite.config.server.https ? 'https' : 'http'}://${\n\t\t\t\t\treq.headers[':authority'] || req.headers.host\n\t\t\t\t}`;\n\n\t\t\t\tconst decoded = decodeURI(new URL(base + req.url).pathname);\n\t\t\t\tconst file = posixify(path.resolve(decoded.slice(svelte_config.kit.paths.base.length + 1)));\n\t\t\t\tconst is_file = fs.existsSync(file) && !fs.statSync(file).isDirectory();\n\t\t\t\tconst allowed =\n\t\t\t\t\t!vite_config.server.fs.strict ||\n\t\t\t\t\tvite_config.server.fs.allow.some((dir) => file.startsWith(dir));\n\n\t\t\t\tif (is_file && allowed) {\n\t\t\t\t\treq.url = original_url;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tserve_static_middleware.handle(req, res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!decoded.startsWith(svelte_config.kit.paths.base)) {\n\t\t\t\t\treturn not_found(req, res, svelte_config.kit.paths.base);\n\t\t\t\t}\n\n\t\t\t\tif (decoded === svelte_config.kit.paths.base + '/service-worker.js') {\n\t\t\t\t\tconst resolved = resolve_entry(svelte_config.kit.files.serviceWorker);\n\n\t\t\t\t\tif (resolved) {\n\t\t\t\t\t\tres.writeHead(200, {\n\t\t\t\t\t\t\t'content-type': 'application/javascript'\n\t\t\t\t\t\t});\n\t\t\t\t\t\tres.end(`import '${to_fs(resolved)}';`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.writeHead(404);\n\t\t\t\t\t\tres.end('not found');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// we have to import `Server` before calling `set_assets`\n\t\t\t\tconst { Server } = /** @type {import('types').ServerModule} */ (\n\t\t\t\t\tawait vite.ssrLoadModule(`${runtime_base}/server/index.js`)\n\t\t\t\t);\n\n\t\t\t\tconst { set_fix_stack_trace } = await vite.ssrLoadModule(\n\t\t\t\t\t`${runtime_base}/shared-server.js`\n\t\t\t\t);\n\t\t\t\tset_fix_stack_trace(fix_stack_trace);\n\n\t\t\t\tconst { set_assets } = await vite.ssrLoadModule('__sveltekit/paths');\n\t\t\t\tset_assets(assets);\n\n\t\t\t\tconst server = new Server(manifest);\n\n\t\t\t\tawait server.init({ env });\n\n\t\t\t\tlet request;\n\n\t\t\t\ttry {\n\t\t\t\t\trequest = await getRequest({\n\t\t\t\t\t\tbase,\n\t\t\t\t\t\trequest: req\n\t\t\t\t\t});\n\t\t\t\t} catch (/** @type {any} */ err) {\n\t\t\t\t\tres.statusCode = err.status || 400;\n\t\t\t\t\treturn res.end('Invalid request body');\n\t\t\t\t}\n\n\t\t\t\tif (manifest_error) {\n\t\t\t\t\tconsole.error(colors.bold().red(manifest_error.message));\n\n\t\t\t\t\tconst error_page = load_error_page(svelte_config);\n\n\t\t\t\t\t/** @param {{ status: number; message: string }} opts */\n\t\t\t\t\tconst error_template = ({ status, message }) => {\n\t\t\t\t\t\treturn error_page\n\t\t\t\t\t\t\t.replace(/%sveltekit\\.status%/g, String(status))\n\t\t\t\t\t\t\t.replace(/%sveltekit\\.error\\.message%/g, message);\n\t\t\t\t\t};\n\n\t\t\t\t\tres.writeHead(500, {\n\t\t\t\t\t\t'Content-Type': 'text/html; charset=utf-8'\n\t\t\t\t\t});\n\t\t\t\t\tres.end(\n\t\t\t\t\t\terror_template({ status: 500, message: manifest_error.message ?? 'Invalid routes' })\n\t\t\t\t\t);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst rendered = await server.respond(request, {\n\t\t\t\t\tgetClientAddress: () => {\n\t\t\t\t\t\tconst { remoteAddress } = req.socket;\n\t\t\t\t\t\tif (remoteAddress) return remoteAddress;\n\t\t\t\t\t\tthrow new Error('Could not determine clientAddress');\n\t\t\t\t\t},\n\t\t\t\t\tread: (file) => fs.readFileSync(path.join(svelte_config.kit.files.assets, file))\n\t\t\t\t});\n\n\t\t\t\tif (rendered.status === 404) {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tserve_static_middleware.handle(req, res, () => {\n\t\t\t\t\t\tsetResponse(res, rendered);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tsetResponse(res, rendered);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconst error = coalesce_to_error(e);\n\t\t\t\tres.statusCode = 500;\n\t\t\t\tres.end(fix_stack_trace(/** @type {string} */ (error.stack)));\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * @param {import('connect').Server} server\n */\nfunction remove_static_middlewares(server) {\n\tconst static_middlewares = ['viteServeStaticMiddleware'];\n\tfor (let i = server.stack.length - 1; i > 0; i--) {\n\t\t// @ts-expect-error using internals\n\t\tif (static_middlewares.includes(server.stack[i].handle.name)) {\n\t\t\tserver.stack.splice(i, 1);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('vite').ViteDevServer} vite\n * @param {import('vite').ModuleNode} node\n * @param {Set<import('vite').ModuleNode>} deps\n */\nasync function find_deps(vite, node, deps) {\n\t// since `ssrTransformResult.deps` contains URLs instead of `ModuleNode`s, this process is asynchronous.\n\t// instead of using `await`, we resolve all branches in parallel.\n\t/** @type {Promise<void>[]} */\n\tconst branches = [];\n\n\t/** @param {import('vite').ModuleNode} node */\n\tasync function add(node) {\n\t\tif (!deps.has(node)) {\n\t\t\tdeps.add(node);\n\t\t\tawait find_deps(vite, node, deps);\n\t\t}\n\t}\n\n\t/** @param {string} url */\n\tasync function add_by_url(url) {\n\t\tconst node = await vite.moduleGraph.getModuleByUrl(url);\n\n\t\tif (node) {\n\t\t\tawait add(node);\n\t\t}\n\t}\n\n\tif (node.ssrTransformResult) {\n\t\tif (node.ssrTransformResult.deps) {\n\t\t\tnode.ssrTransformResult.deps.forEach((url) => branches.push(add_by_url(url)));\n\t\t}\n\n\t\tif (node.ssrTransformResult.dynamicDeps) {\n\t\t\tnode.ssrTransformResult.dynamicDeps.forEach((url) => branches.push(add_by_url(url)));\n\t\t}\n\t} else {\n\t\tnode.importedModules.forEach((node) => branches.push(add(node)));\n\t}\n\n\tawait Promise.all(branches);\n}\n\n/**\n * Determine if a file is being requested with the correct case,\n * to ensure consistent behaviour between dev and prod and across\n * operating systems. Note that we can't use realpath here,\n * because we don't want to follow symlinks\n * @param {string} file\n * @param {string} assets\n * @returns {boolean}\n */\nfunction has_correct_case(file, assets) {\n\tif (file === assets) return true;\n\n\tconst parent = path.dirname(file);\n\n\tif (fs.readdirSync(parent).includes(path.basename(file))) {\n\t\treturn has_correct_case(parent, assets);\n\t}\n\n\treturn false;\n}\n"}}}},"graph_analysis":{"directory":{"index.js":{"file":{"contents":"import path from 'node:path';\nimport { posixify } from '../../../utils/filesystem.js';\n\nconst ILLEGAL_IMPORTS = new Set(['\\0$env/dynamic/private', '\\0$env/static/private']);\nconst ILLEGAL_MODULE_NAME_PATTERN = /.*\\.server\\..+/;\n\n/**\n * Checks if given id imports a module that is not allowed to be imported into client-side code.\n * @param {string} id\n * @param {{\n *   cwd: string;\n *   node_modules: string;\n *   server: string;\n * }} dirs\n */\nexport function is_illegal(id, dirs) {\n\tif (ILLEGAL_IMPORTS.has(id)) return true;\n\tif (!id.startsWith(dirs.cwd) || id.startsWith(dirs.node_modules)) return false;\n\treturn ILLEGAL_MODULE_NAME_PATTERN.test(path.basename(id)) || id.startsWith(dirs.server);\n}\n\n/**\n * Creates a guard that checks that no id imports a module that is not allowed to be imported into client-side code.\n * @param {import('rollup').PluginContext} context\n * @param {{ cwd: string; lib: string }} paths\n */\nexport function module_guard(context, { cwd, lib }) {\n\t/** @type {Set<string>} */\n\tconst seen = new Set();\n\n\tconst dirs = {\n\t\t// ids will be posixified, so we need to posixify these, too\n\t\tcwd: posixify(cwd),\n\t\tnode_modules: posixify(path.join(cwd, 'node_modules')),\n\t\tserver: posixify(path.join(lib, 'server'))\n\t};\n\n\t/**\n\t * @param {string} id\n\t * @param {Array<{ id: string; dynamic: boolean }>} chain\n\t */\n\tfunction follow(id, chain) {\n\t\tif (seen.has(id)) return;\n\t\tseen.add(id);\n\n\t\tif (is_illegal(id, dirs)) {\n\t\t\tchain.shift(); // discard the entry point\n\t\t\tid = normalize_id(id, lib, cwd);\n\n\t\t\tconst pyramid =\n\t\t\t\tchain.map(({ id, dynamic }, i) => {\n\t\t\t\t\tid = normalize_id(id, lib, cwd);\n\n\t\t\t\t\treturn `${' '.repeat(i * 2)}- ${id} ${dynamic ? 'dynamically imports' : 'imports'}\\n`;\n\t\t\t\t}) + `${' '.repeat(chain.length)}- ${id}`;\n\n\t\t\tconst message = `Cannot import ${id} into client-side code:\\n${pyramid}`;\n\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\tconst module = context.getModuleInfo(id);\n\n\t\tif (module) {\n\t\t\tfor (const child of module.importedIds) {\n\t\t\t\tfollow(child, [...chain, { id, dynamic: false }]);\n\t\t\t}\n\n\t\t\tfor (const child of module.dynamicallyImportedIds) {\n\t\t\t\tfollow(child, [...chain, { id, dynamic: true }]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\t/** @param {string} id should be posixified */\n\t\tcheck: (id) => {\n\t\t\tfollow(id, []);\n\t\t}\n\t};\n}\n\n/**\n * Removes cwd/lib path from the start of the id\n * @param {string} id\n * @param {string} lib\n * @param {string} cwd\n */\nexport function normalize_id(id, lib, cwd) {\n\tif (id.startsWith(lib)) {\n\t\tid = id.replace(lib, '$lib');\n\t}\n\n\tif (id.startsWith(cwd)) {\n\t\tid = path.relative(cwd, id);\n\t}\n\n\treturn posixify(id);\n}\n"}},"types.d.ts":{"file":{"contents":"export interface ImportGraph {\n\treadonly id: string;\n\treadonly dynamic: boolean;\n\treadonly children: Generator<ImportGraph>;\n}\n"}},"utils.js":{"file":{"contents":"const query_pattern = /\\?.*$/s;\n\n/** @param {string} path */\nexport function remove_query_from_id(path) {\n\treturn path.replace(query_pattern, '');\n}\n"}}}},"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\n\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\nimport colors from 'kleur';\nimport * as vite from 'vite';\n\nimport { mkdirp, posixify, read, resolve_entry, rimraf } from '../../utils/filesystem.js';\nimport { create_static_module, create_dynamic_module } from '../../core/env.js';\nimport * as sync from '../../core/sync/sync.js';\nimport { create_assets } from '../../core/sync/create_manifest_data/index.js';\nimport { runtime_directory, logger } from '../../core/utils.js';\nimport { load_config } from '../../core/config/index.js';\nimport { generate_manifest } from '../../core/generate_manifest/index.js';\nimport { build_server_nodes } from './build/build_server.js';\nimport { build_service_worker } from './build/build_service_worker.js';\nimport { assets_base, find_deps } from './build/utils.js';\nimport { dev } from './dev/index.js';\nimport { is_illegal, module_guard, normalize_id } from './graph_analysis/index.js';\nimport { preview } from './preview/index.js';\nimport { get_config_aliases, get_env } from './utils.js';\nimport { write_client_manifest } from '../../core/sync/write_client_manifest.js';\nimport prerender from '../../core/postbuild/prerender.js';\nimport analyse from '../../core/postbuild/analyse.js';\nimport { s } from '../../utils/misc.js';\nimport { hash } from '../../runtime/hash.js';\nimport { dedent } from '../../core/sync/utils.js';\n\nexport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\nconst cwd = process.cwd();\n\n/** @type {import('./types').EnforcedConfig} */\nconst enforced_config = {\n\tappType: true,\n\tbase: true,\n\tbuild: {\n\t\tcssCodeSplit: true,\n\t\temptyOutDir: true,\n\t\tlib: {\n\t\t\tentry: true,\n\t\t\tname: true,\n\t\t\tformats: true\n\t\t},\n\t\tmanifest: true,\n\t\toutDir: true,\n\t\trollupOptions: {\n\t\t\tinput: true,\n\t\t\toutput: {\n\t\t\t\tformat: true,\n\t\t\t\tentryFileNames: true,\n\t\t\t\tchunkFileNames: true,\n\t\t\t\tassetFileNames: true\n\t\t\t},\n\t\t\tpreserveEntrySignatures: true\n\t\t},\n\t\tssr: true\n\t},\n\tpublicDir: true,\n\tresolve: {\n\t\talias: {\n\t\t\t$app: true,\n\t\t\t$lib: true,\n\t\t\t'$service-worker': true\n\t\t}\n\t},\n\troot: true\n};\n\nconst options_regex = /(export\\s+const\\s+(prerender|csr|ssr|trailingSlash))\\s*=/s;\n\n/** @type {Set<string>} */\nconst warned = new Set();\n\n/** @type {import('@sveltejs/vite-plugin-svelte').PreprocessorGroup} */\nconst warning_preprocessor = {\n\tscript: ({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tmarkup: ({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+layout.') && !content.includes('<slot')) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t`\\`<slot />\\` missing — inner content will not be rendered`;\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/** @return {Promise<import('vite').Plugin[]>} */\nexport async function sveltekit() {\n\tconst svelte_config = await load_config();\n\n\t/** @type {import('@sveltejs/vite-plugin-svelte').Options['preprocess']} */\n\tlet preprocess = svelte_config.preprocess;\n\tif (Array.isArray(preprocess)) {\n\t\tpreprocess = [...preprocess, warning_preprocessor];\n\t} else if (preprocess) {\n\t\tpreprocess = [preprocess, warning_preprocessor];\n\t} else {\n\t\tpreprocess = warning_preprocessor;\n\t}\n\n\t/** @type {import('@sveltejs/vite-plugin-svelte').Options} */\n\tconst vite_plugin_svelte_options = {\n\t\tconfigFile: false,\n\t\textensions: svelte_config.extensions,\n\t\tpreprocess,\n\t\tonwarn: svelte_config.onwarn,\n\t\tcompilerOptions: {\n\t\t\t// @ts-expect-error SvelteKit requires hydratable true by default\n\t\t\thydratable: true,\n\t\t\t...svelte_config.compilerOptions\n\t\t},\n\t\t...svelte_config.vitePlugin\n\t};\n\n\treturn [...svelte(vite_plugin_svelte_options), ...kit({ svelte_config })];\n}\n\n// These variables live outside the `kit()` function because it is re-invoked by each Vite build\n\nlet secondary_build_started = false;\n\n/** @type {import('types').ManifestData} */\nlet manifest_data;\n\n/**\n * Returns the SvelteKit Vite plugin. Vite executes Rollup hooks as well as some of its own.\n * Background reading is available at:\n * - https://vitejs.dev/guide/api-plugin.html\n * - https://rollupjs.org/guide/en/#plugin-development\n *\n * You can get an idea of the lifecycle by looking at the flow charts here:\n * - https://rollupjs.org/guide/en/#build-hooks\n * - https://rollupjs.org/guide/en/#output-generation-hooks\n *\n * @param {{ svelte_config: import('types').ValidatedConfig }} options\n * @return {import('vite').Plugin[]}\n */\nfunction kit({ svelte_config }) {\n\tconst { kit } = svelte_config;\n\tconst out = `${kit.outDir}/output`;\n\n\tconst version_hash = hash(kit.version.name);\n\n\t/** @type {import('vite').ResolvedConfig} */\n\tlet vite_config;\n\n\t/** @type {import('vite').ConfigEnv} */\n\tlet vite_config_env;\n\n\t/** @type {boolean} */\n\tlet is_build;\n\n\t/** @type {{ public: Record<string, string>; private: Record<string, string> }} */\n\tlet env;\n\n\t/** @type {() => Promise<void>} */\n\tlet finalise;\n\n\t/** @type {import('vite').UserConfig} */\n\tlet initial_config;\n\n\tconst service_worker_entry_file = resolve_entry(kit.files.serviceWorker);\n\n\t/** @type {import('vite').Plugin} */\n\tconst plugin_setup = {\n\t\tname: 'vite-plugin-sveltekit-setup',\n\n\t\t/**\n\t\t * Build the SvelteKit-provided Vite config to be merged with the user's vite.config.js file.\n\t\t * @see https://vitejs.dev/guide/api-plugin.html#config\n\t\t */\n\t\tasync config(config, config_env) {\n\t\t\tinitial_config = config;\n\t\t\tvite_config_env = config_env;\n\t\t\tis_build = config_env.command === 'build';\n\n\t\t\tenv = get_env(kit.env, vite_config_env.mode);\n\n\t\t\tconst allow = new Set([\n\t\t\t\tkit.files.lib,\n\t\t\t\tkit.files.routes,\n\t\t\t\tkit.outDir,\n\t\t\t\tpath.resolve('src'), // TODO this isn't correct if user changed all his files to sth else than src (like in test/options)\n\t\t\t\tpath.resolve('node_modules'),\n\t\t\t\tpath.resolve(vite.searchForWorkspaceRoot(cwd), 'node_modules')\n\t\t\t]);\n\n\t\t\t// We can only add directories to the allow list, so we find out\n\t\t\t// if there's a client hooks file and pass its directory\n\t\t\tconst client_hooks = resolve_entry(kit.files.hooks.client);\n\t\t\tif (client_hooks) allow.add(path.dirname(client_hooks));\n\n\t\t\tconst generated = path.posix.join(kit.outDir, 'generated');\n\n\t\t\t// dev and preview config can be shared\n\t\t\t/** @type {import('vite').UserConfig} */\n\t\t\tconst new_config = {\n\t\t\t\tresolve: {\n\t\t\t\t\talias: [\n\t\t\t\t\t\t{ find: '__SERVER__', replacement: `${generated}/server` },\n\t\t\t\t\t\t{ find: '$app', replacement: `${runtime_directory}/app` },\n\t\t\t\t\t\t...get_config_aliases(kit)\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\troot: cwd,\n\t\t\t\tserver: {\n\t\t\t\t\tfs: {\n\t\t\t\t\t\tallow: [...allow]\n\t\t\t\t\t},\n\t\t\t\t\twatch: {\n\t\t\t\t\t\tignored: [\n\t\t\t\t\t\t\t// Ignore all siblings of config.kit.outDir/generated\n\t\t\t\t\t\t\t`${posixify(kit.outDir)}/!(generated)`\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tcors: { preflightContinue: true }\n\t\t\t\t},\n\t\t\t\tpreview: {\n\t\t\t\t\tcors: { preflightContinue: true }\n\t\t\t\t},\n\t\t\t\toptimizeDeps: {\n\t\t\t\t\texclude: [\n\t\t\t\t\t\t'@sveltejs/kit',\n\t\t\t\t\t\t// exclude kit features so that libraries using them work even when they are prebundled\n\t\t\t\t\t\t// this does not affect app code, just handling of imported libraries that use $app or $env\n\t\t\t\t\t\t'$app',\n\t\t\t\t\t\t'$env'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tssr: {\n\t\t\t\t\tnoExternal: [\n\t\t\t\t\t\t// This ensures that esm-env is inlined into the server output with the\n\t\t\t\t\t\t// export conditions resolved correctly through Vite. This prevents adapters\n\t\t\t\t\t\t// that bundle later on from resolving the export conditions incorrectly\n\t\t\t\t\t\t// and for example include browser-only code in the server output\n\t\t\t\t\t\t// because they for example use esbuild.build with `platform: 'browser'`\n\t\t\t\t\t\t'esm-env',\n\t\t\t\t\t\t// We need this for two reasons:\n\t\t\t\t\t\t// 1. Without this, `@sveltejs/kit` imports are kept as-is in the server output,\n\t\t\t\t\t\t//    and that causes modules and therefore classes like `Redirect` to be imported twice\n\t\t\t\t\t\t//    under different IDs, which breaks a bunch of stuff because of failing instanceof checks.\n\t\t\t\t\t\t// 2. Vitest bypasses Vite when loading external modules, so we bundle\n\t\t\t\t\t\t//    when it is detected to keep our virtual modules working.\n\t\t\t\t\t\t//    See https://github.com/sveltejs/kit/pull/9172\n\t\t\t\t\t\t//    and https://vitest.dev/config/#deps-registernodeloader\n\t\t\t\t\t\t'@sveltejs/kit'\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (is_build) {\n\t\t\t\tif (!new_config.build) new_config.build = {};\n\t\t\t\tnew_config.build.ssr = !secondary_build_started;\n\n\t\t\t\tnew_config.define = {\n\t\t\t\t\t__SVELTEKIT_ADAPTER_NAME__: s(kit.adapter?.name),\n\t\t\t\t\t__SVELTEKIT_APP_VERSION_FILE__: s(`${kit.appDir}/version.json`),\n\t\t\t\t\t__SVELTEKIT_APP_VERSION_POLL_INTERVAL__: s(kit.version.pollInterval),\n\t\t\t\t\t__SVELTEKIT_DEV__: 'false',\n\t\t\t\t\t__SVELTEKIT_EMBEDDED__: kit.embedded ? 'true' : 'false'\n\t\t\t\t};\n\n\t\t\t\tif (!secondary_build_started) {\n\t\t\t\t\tmanifest_data = (await sync.all(svelte_config, config_env.mode)).manifest_data;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnew_config.define = {\n\t\t\t\t\t__SVELTEKIT_APP_VERSION_POLL_INTERVAL__: '0',\n\t\t\t\t\t__SVELTEKIT_DEV__: 'true',\n\t\t\t\t\t__SVELTEKIT_EMBEDDED__: kit.embedded ? 'true' : 'false'\n\t\t\t\t};\n\n\t\t\t\t// These Kit dependencies are packaged as CommonJS, which means they must always be externalized.\n\t\t\t\t// Without this, the tests will still pass but `pnpm dev` will fail in projects that link `@sveltejs/kit`.\n\t\t\t\t/** @type {NonNullable<import('vite').UserConfig['ssr']>} */ (new_config.ssr).external = [\n\t\t\t\t\t'cookie',\n\t\t\t\t\t'set-cookie-parser'\n\t\t\t\t];\n\t\t\t}\n\n\t\t\twarn_overridden_config(config, new_config);\n\n\t\t\treturn new_config;\n\t\t},\n\n\t\t/**\n\t\t * Stores the final config.\n\t\t */\n\t\tconfigResolved(config) {\n\t\t\tvite_config = config;\n\n\t\t\t// This is a hack to prevent Vite from nuking useful logs,\n\t\t\t// pending https://github.com/vitejs/vite/issues/9378\n\t\t\tconfig.logger.warn('');\n\t\t}\n\t};\n\n\t/** @type {import('vite').Plugin} */\n\tconst plugin_virtual_modules = {\n\t\tname: 'vite-plugin-sveltekit-virtual-modules',\n\n\t\tasync resolveId(id) {\n\t\t\t// treat $env/static/[public|private] as virtual\n\t\t\tif (id.startsWith('$env/') || id.startsWith('__sveltekit/') || id === '$service-worker') {\n\t\t\t\treturn `\\0${id}`;\n\t\t\t}\n\t\t},\n\n\t\tasync load(id, options) {\n\t\t\tconst browser = !options?.ssr;\n\t\t\tconst global = `globalThis.__sveltekit_${version_hash}`;\n\n\t\t\tif (options?.ssr === false && process.env.TEST !== 'true') {\n\t\t\t\tconst normalized_cwd = vite.normalizePath(cwd);\n\t\t\t\tconst normalized_lib = vite.normalizePath(kit.files.lib);\n\t\t\t\tif (\n\t\t\t\t\tis_illegal(id, {\n\t\t\t\t\t\tcwd: normalized_cwd,\n\t\t\t\t\t\tnode_modules: vite.normalizePath(path.resolve('node_modules')),\n\t\t\t\t\t\tserver: vite.normalizePath(path.join(normalized_lib, 'server'))\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\tconst relative = normalize_id(id, normalized_lib, normalized_cwd);\n\t\t\t\t\tthrow new Error(`Cannot import ${relative} into client-side code`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (id) {\n\t\t\t\tcase '\\0$env/static/private':\n\t\t\t\t\treturn create_static_module('$env/static/private', env.private);\n\n\t\t\t\tcase '\\0$env/static/public':\n\t\t\t\t\treturn create_static_module('$env/static/public', env.public);\n\n\t\t\t\tcase '\\0$env/dynamic/private':\n\t\t\t\t\treturn create_dynamic_module(\n\t\t\t\t\t\t'private',\n\t\t\t\t\t\tvite_config_env.command === 'serve' ? env.private : undefined\n\t\t\t\t\t);\n\n\t\t\t\tcase '\\0$env/dynamic/public':\n\t\t\t\t\t// populate `$env/dynamic/public` from `window`\n\t\t\t\t\tif (browser) {\n\t\t\t\t\t\treturn `export const env = ${global}.env;`;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn create_dynamic_module(\n\t\t\t\t\t\t'public',\n\t\t\t\t\t\tvite_config_env.command === 'serve' ? env.public : undefined\n\t\t\t\t\t);\n\n\t\t\t\tcase '\\0$service-worker':\n\t\t\t\t\treturn create_service_worker_module(svelte_config);\n\n\t\t\t\t// for internal use only. it's published as $app/paths externally\n\t\t\t\t// we use this alias so that we won't collide with user aliases\n\t\t\t\tcase '\\0__sveltekit/paths':\n\t\t\t\t\tconst { assets, base } = svelte_config.kit.paths;\n\n\t\t\t\t\t// use the values defined in `global`, but fall back to hard-coded values\n\t\t\t\t\t// for the sake of things like Vitest which may import this module\n\t\t\t\t\t// outside the context of a page\n\t\t\t\t\tif (browser) {\n\t\t\t\t\t\treturn dedent`\n\t\t\t\t\t\t\texport const base = ${global}?.base ?? ${s(base)};\n\t\t\t\t\t\t\texport const assets = ${global}?.assets ?? ${assets ? s(assets) : 'base'};\n\t\t\t\t\t\t`;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn dedent`\n\t\t\t\t\t\texport let base = ${s(base)};\n\t\t\t\t\t\texport let assets = ${assets ? s(assets) : 'base'};\n\n\t\t\t\t\t\texport const relative = ${svelte_config.kit.paths.relative};\n\n\t\t\t\t\t\tconst initial = { base, assets };\n\n\t\t\t\t\t\texport function override(paths) {\n\t\t\t\t\t\t\tbase = paths.base;\n\t\t\t\t\t\t\tassets = paths.assets;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texport function reset() {\n\t\t\t\t\t\t\tbase = initial.base;\n\t\t\t\t\t\t\tassets = initial.assets;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @param {string} path */\n\t\t\t\t\t\texport function set_assets(path) {\n\t\t\t\t\t\t\tassets = initial.assets = path;\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\n\t\t\t\tcase '\\0__sveltekit/environment':\n\t\t\t\t\tconst { version } = svelte_config.kit;\n\n\t\t\t\t\treturn dedent`\n\t\t\t\t\t\texport const version = ${s(version.name)};\n\t\t\t\t\t\texport let building = false;\n\n\t\t\t\t\t\texport function set_building() {\n\t\t\t\t\t\t\tbuilding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t`;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Ensures that client-side code can't accidentally import server-side code,\n\t * whether in `*.server.js` files, `$lib/server`, or `$env/[static|dynamic]/private`\n\t * @type {import('vite').Plugin}\n\t */\n\tconst plugin_guard = {\n\t\tname: 'vite-plugin-sveltekit-guard',\n\n\t\twriteBundle: {\n\t\t\tsequential: true,\n\t\t\tasync handler(_options) {\n\t\t\t\tif (vite_config.build.ssr) return;\n\n\t\t\t\tconst guard = module_guard(this, {\n\t\t\t\t\tcwd: vite.normalizePath(process.cwd()),\n\t\t\t\t\tlib: vite.normalizePath(kit.files.lib)\n\t\t\t\t});\n\n\t\t\t\tmanifest_data.nodes.forEach((_node, i) => {\n\t\t\t\t\tconst id = vite.normalizePath(\n\t\t\t\t\t\tpath.resolve(kit.outDir, `generated/client-optimized/nodes/${i}.js`)\n\t\t\t\t\t);\n\n\t\t\t\t\tguard.check(id);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/** @type {import('vite').Plugin} */\n\tconst plugin_compile = {\n\t\tname: 'vite-plugin-sveltekit-compile',\n\n\t\t/**\n\t\t * Build the SvelteKit-provided Vite config to be merged with the user's vite.config.js file.\n\t\t * @see https://vitejs.dev/guide/api-plugin.html#config\n\t\t */\n\t\tasync config(config) {\n\t\t\t/** @type {import('vite').UserConfig} */\n\t\t\tlet new_config;\n\n\t\t\tif (is_build) {\n\t\t\t\tconst ssr = /** @type {boolean} */ (config.build?.ssr);\n\t\t\t\tconst prefix = `${kit.appDir}/immutable`;\n\n\t\t\t\t/** @type {Record<string, string>} */\n\t\t\t\tconst input = {};\n\n\t\t\t\tif (ssr) {\n\t\t\t\t\tinput.index = `${runtime_directory}/server/index.js`;\n\t\t\t\t\tinput.internal = `${kit.outDir}/generated/server/internal.js`;\n\n\t\t\t\t\t// add entry points for every endpoint...\n\t\t\t\t\tmanifest_data.routes.forEach((route) => {\n\t\t\t\t\t\tif (route.endpoint) {\n\t\t\t\t\t\t\tconst resolved = path.resolve(route.endpoint.file);\n\t\t\t\t\t\t\tconst relative = decodeURIComponent(path.relative(kit.files.routes, resolved));\n\t\t\t\t\t\t\tconst name = posixify(path.join('entries/endpoints', relative.replace(/\\.js$/, '')));\n\t\t\t\t\t\t\tinput[name] = resolved;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// ...and every component used by pages...\n\t\t\t\t\tmanifest_data.nodes.forEach((node) => {\n\t\t\t\t\t\tfor (const file of [node.component, node.universal, node.server]) {\n\t\t\t\t\t\t\tif (file) {\n\t\t\t\t\t\t\t\tconst resolved = path.resolve(file);\n\t\t\t\t\t\t\t\tconst relative = decodeURIComponent(path.relative(kit.files.routes, resolved));\n\n\t\t\t\t\t\t\t\tconst name = relative.startsWith('..')\n\t\t\t\t\t\t\t\t\t? posixify(path.join('entries/fallbacks', path.basename(file)))\n\t\t\t\t\t\t\t\t\t: posixify(path.join('entries/pages', relative.replace(/\\.js$/, '')));\n\t\t\t\t\t\t\t\tinput[name] = resolved;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// ...and every matcher\n\t\t\t\t\tObject.entries(manifest_data.matchers).forEach(([key, file]) => {\n\t\t\t\t\t\tconst name = posixify(path.join('entries/matchers', key));\n\t\t\t\t\t\tinput[name] = path.resolve(file);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tinput['entry/start'] = `${runtime_directory}/client/start.js`;\n\t\t\t\t\tinput['entry/app'] = `${kit.outDir}/generated/client-optimized/app.js`;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string | undefined} file\n\t\t\t\t\t */\n\t\t\t\t\tfunction add_input(file) {\n\t\t\t\t\t\tif (!file) return;\n\n\t\t\t\t\t\tconst resolved = path.resolve(file);\n\t\t\t\t\t\tconst relative = decodeURIComponent(path.relative(kit.files.routes, resolved));\n\n\t\t\t\t\t\tconst name = relative.startsWith('..')\n\t\t\t\t\t\t\t? path.basename(file).replace(/^\\+/, '')\n\t\t\t\t\t\t\t: relative.replace(/(\\\\|\\/)\\+/g, '-').replace(/[\\\\/]/g, '-');\n\n\t\t\t\t\t\tinput[`entry/${name}`] = resolved;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const node of manifest_data.nodes) {\n\t\t\t\t\t\tadd_input(node.component);\n\t\t\t\t\t\tadd_input(node.universal);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// see the kit.output.preloadStrategy option for details on why we have multiple options here\n\t\t\t\tconst ext = kit.output.preloadStrategy === 'preload-mjs' ? 'mjs' : 'js';\n\n\t\t\t\tnew_config = {\n\t\t\t\t\tbase: ssr ? assets_base(kit) : './',\n\t\t\t\t\tbuild: {\n\t\t\t\t\t\tcssCodeSplit: true,\n\t\t\t\t\t\toutDir: `${out}/${ssr ? 'server' : 'client'}`,\n\t\t\t\t\t\trollupOptions: {\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\toutput: {\n\t\t\t\t\t\t\t\tformat: 'esm',\n\t\t\t\t\t\t\t\tentryFileNames: ssr ? '[name].js' : `${prefix}/[name].[hash].${ext}`,\n\t\t\t\t\t\t\t\tchunkFileNames: ssr ? 'chunks/[name].js' : `${prefix}/chunks/[name].[hash].${ext}`,\n\t\t\t\t\t\t\t\tassetFileNames: `${prefix}/assets/[name].[hash][extname]`,\n\t\t\t\t\t\t\t\thoistTransitiveImports: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpreserveEntrySignatures: 'strict'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tssrEmitAssets: true,\n\t\t\t\t\t\ttarget: ssr ? 'node16.14' : undefined,\n\t\t\t\t\t\t// don't use the default name to avoid collisions with 'static/manifest.json'\n\t\t\t\t\t\tmanifest: 'vite-manifest.json'\n\t\t\t\t\t},\n\t\t\t\t\tpublicDir: ssr ? false : kit.files.assets,\n\t\t\t\t\tworker: {\n\t\t\t\t\t\trollupOptions: {\n\t\t\t\t\t\t\toutput: {\n\t\t\t\t\t\t\t\tentryFileNames: `${prefix}/workers/[name]-[hash].js`,\n\t\t\t\t\t\t\t\tchunkFileNames: `${prefix}/workers/chunks/[name]-[hash].js`,\n\t\t\t\t\t\t\t\tassetFileNames: `${prefix}/workers/assets/[name]-[hash][extname]`,\n\t\t\t\t\t\t\t\thoistTransitiveImports: false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tnew_config = {\n\t\t\t\t\tappType: 'custom',\n\t\t\t\t\tbase: kit.paths.base,\n\t\t\t\t\tbuild: {\n\t\t\t\t\t\trollupOptions: {\n\t\t\t\t\t\t\t// Vite dependency crawler needs an explicit JS entry point\n\t\t\t\t\t\t\t// eventhough server otherwise works without it\n\t\t\t\t\t\t\tinput: `${runtime_directory}/client/start.js`\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tpublicDir: kit.files.assets\n\t\t\t\t};\n\t\t\t}\n\n\t\t\twarn_overridden_config(config, new_config);\n\n\t\t\treturn new_config;\n\t\t},\n\n\t\t/**\n\t\t * Adds the SvelteKit middleware to do SSR in dev mode.\n\t\t * @see https://vitejs.dev/guide/api-plugin.html#configureserver\n\t\t */\n\t\tasync configureServer(vite) {\n\t\t\treturn await dev(vite, vite_config, svelte_config);\n\t\t},\n\n\t\t/**\n\t\t * Adds the SvelteKit middleware to do SSR in preview mode.\n\t\t * @see https://vitejs.dev/guide/api-plugin.html#configurepreviewserver\n\t\t */\n\t\tconfigurePreviewServer(vite) {\n\t\t\treturn preview(vite, vite_config, svelte_config);\n\t\t},\n\n\t\t/**\n\t\t * Clears the output directories.\n\t\t */\n\t\tbuildStart() {\n\t\t\tif (secondary_build_started) return;\n\n\t\t\tif (is_build) {\n\t\t\t\tif (!vite_config.build.watch) {\n\t\t\t\t\trimraf(out);\n\t\t\t\t}\n\t\t\t\tmkdirp(out);\n\t\t\t}\n\t\t},\n\n\t\tgenerateBundle() {\n\t\t\tif (vite_config.build.ssr) return;\n\n\t\t\tthis.emitFile({\n\t\t\t\ttype: 'asset',\n\t\t\t\tfileName: `${kit.appDir}/version.json`,\n\t\t\t\tsource: s({ version: kit.version.name })\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Vite builds a single bundle. We need three bundles: client, server, and service worker.\n\t\t * The user's package.json scripts will invoke the Vite CLI to execute the server build. We\n\t\t * then use this hook to kick off builds for the client and service worker.\n\t\t */\n\t\twriteBundle: {\n\t\t\tsequential: true,\n\t\t\tasync handler(_options) {\n\t\t\t\tif (secondary_build_started) return; // only run this once\n\n\t\t\t\tconst verbose = vite_config.logLevel === 'info';\n\t\t\t\tconst log = logger({ verbose });\n\n\t\t\t\t/** @type {import('vite').Manifest} */\n\t\t\t\tconst server_manifest = JSON.parse(read(`${out}/server/${vite_config.build.manifest}`));\n\n\t\t\t\t/** @type {import('types').BuildData} */\n\t\t\t\tconst build_data = {\n\t\t\t\t\tapp_dir: kit.appDir,\n\t\t\t\t\tapp_path: `${kit.paths.base.slice(1)}${kit.paths.base ? '/' : ''}${kit.appDir}`,\n\t\t\t\t\tmanifest_data,\n\t\t\t\t\tservice_worker: !!service_worker_entry_file ? 'service-worker.js' : null, // TODO make file configurable?\n\t\t\t\t\tclient: null,\n\t\t\t\t\tserver_manifest\n\t\t\t\t};\n\n\t\t\t\tconst manifest_path = `${out}/server/manifest-full.js`;\n\t\t\t\tfs.writeFileSync(\n\t\t\t\t\tmanifest_path,\n\t\t\t\t\t`export const manifest = ${generate_manifest({\n\t\t\t\t\t\tbuild_data,\n\t\t\t\t\t\trelative_path: '.',\n\t\t\t\t\t\troutes: manifest_data.routes\n\t\t\t\t\t})};\\n`\n\t\t\t\t);\n\n\t\t\t\t// first, build server nodes without the client manifest so we can analyse it\n\t\t\t\tlog.info('Analysing routes');\n\n\t\t\t\tbuild_server_nodes(out, kit, manifest_data, server_manifest, null, null);\n\n\t\t\t\tconst metadata = await analyse({\n\t\t\t\t\tmanifest_path,\n\t\t\t\t\tenv: { ...env.private, ...env.public }\n\t\t\t\t});\n\n\t\t\t\tlog.info('Building app');\n\n\t\t\t\t// create client build\n\t\t\t\twrite_client_manifest(\n\t\t\t\t\tkit,\n\t\t\t\t\tmanifest_data,\n\t\t\t\t\t`${kit.outDir}/generated/client-optimized`,\n\t\t\t\t\tmetadata.nodes\n\t\t\t\t);\n\n\t\t\t\tsecondary_build_started = true;\n\n\t\t\t\tconst { output } = /** @type {import('rollup').RollupOutput} */ (\n\t\t\t\t\tawait vite.build({\n\t\t\t\t\t\tconfigFile: vite_config.configFile,\n\t\t\t\t\t\t// CLI args\n\t\t\t\t\t\tmode: vite_config_env.mode,\n\t\t\t\t\t\tlogLevel: vite_config.logLevel,\n\t\t\t\t\t\tclearScreen: vite_config.clearScreen,\n\t\t\t\t\t\tbuild: {\n\t\t\t\t\t\t\tminify: initial_config.build?.minify,\n\t\t\t\t\t\t\tassetsInlineLimit: vite_config.build.assetsInlineLimit,\n\t\t\t\t\t\t\tsourcemap: vite_config.build.sourcemap\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptimizeDeps: {\n\t\t\t\t\t\t\tforce: vite_config.optimizeDeps.force\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\t/** @type {import('vite').Manifest} */\n\t\t\t\tconst client_manifest = JSON.parse(read(`${out}/client/${vite_config.build.manifest}`));\n\n\t\t\t\tbuild_data.client = {\n\t\t\t\t\tstart: find_deps(\n\t\t\t\t\t\tclient_manifest,\n\t\t\t\t\t\tposixify(path.relative('.', `${runtime_directory}/client/start.js`)),\n\t\t\t\t\t\tfalse\n\t\t\t\t\t),\n\t\t\t\t\tapp: find_deps(\n\t\t\t\t\t\tclient_manifest,\n\t\t\t\t\t\tposixify(path.relative('.', `${kit.outDir}/generated/client-optimized/app.js`)),\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\t\t\t\t};\n\n\t\t\t\tconst css = output.filter(\n\t\t\t\t\t/** @type {(value: any) => value is import('rollup').OutputAsset} */\n\t\t\t\t\t(value) => value.type === 'asset' && value.fileName.endsWith('.css')\n\t\t\t\t);\n\n\t\t\t\t// regenerate manifest now that we have client entry...\n\t\t\t\tfs.writeFileSync(\n\t\t\t\t\tmanifest_path,\n\t\t\t\t\t`export const manifest = ${generate_manifest({\n\t\t\t\t\t\tbuild_data,\n\t\t\t\t\t\trelative_path: '.',\n\t\t\t\t\t\troutes: manifest_data.routes\n\t\t\t\t\t})};\\n`\n\t\t\t\t);\n\n\t\t\t\t// regenerate nodes with the client manifest...\n\t\t\t\tbuild_server_nodes(out, kit, manifest_data, server_manifest, client_manifest, css);\n\n\t\t\t\t// ...and prerender\n\t\t\t\tconst { prerendered, prerender_map } = await prerender({\n\t\t\t\t\tout,\n\t\t\t\t\tmanifest_path,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tverbose,\n\t\t\t\t\tenv: { ...env.private, ...env.public }\n\t\t\t\t});\n\n\t\t\t\t// generate a new manifest that doesn't include prerendered pages\n\t\t\t\tfs.writeFileSync(\n\t\t\t\t\t`${out}/server/manifest.js`,\n\t\t\t\t\t`export const manifest = ${generate_manifest({\n\t\t\t\t\t\tbuild_data,\n\t\t\t\t\t\trelative_path: '.',\n\t\t\t\t\t\troutes: manifest_data.routes.filter((route) => prerender_map.get(route.id) !== true)\n\t\t\t\t\t})};\\n`\n\t\t\t\t);\n\n\t\t\t\tif (service_worker_entry_file) {\n\t\t\t\t\tif (kit.paths.assets) {\n\t\t\t\t\t\tthrow new Error('Cannot use service worker alongside config.kit.paths.assets');\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.info('Building service worker');\n\n\t\t\t\t\tawait build_service_worker(\n\t\t\t\t\t\tout,\n\t\t\t\t\t\tkit,\n\t\t\t\t\t\tvite_config,\n\t\t\t\t\t\tmanifest_data,\n\t\t\t\t\t\tservice_worker_entry_file,\n\t\t\t\t\t\tprerendered,\n\t\t\t\t\t\tclient_manifest\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// we need to defer this to closeBundle, so that adapters copy files\n\t\t\t\t// created by other Vite plugins\n\t\t\t\tfinalise = async () => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`\\nRun ${colors\n\t\t\t\t\t\t\t.bold()\n\t\t\t\t\t\t\t.cyan('npm run preview')} to preview your production build locally.`\n\t\t\t\t\t);\n\n\t\t\t\t\t// avoid making the manifest available to users\n\t\t\t\t\tfs.unlinkSync(`${out}/client/${vite_config.build.manifest}`);\n\t\t\t\t\tfs.unlinkSync(`${out}/server/${vite_config.build.manifest}`);\n\n\t\t\t\t\tif (kit.adapter) {\n\t\t\t\t\t\tconst { adapt } = await import('../../core/adapt/index.js');\n\t\t\t\t\t\tawait adapt(svelte_config, build_data, metadata, prerendered, prerender_map, log);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(colors.bold().yellow('\\nNo adapter specified'));\n\n\t\t\t\t\t\tconst link = colors.bold().cyan('https://kit.svelte.dev/docs/adapters');\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`See ${link} to learn how to configure your app to run on the platform of your choosing`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tsecondary_build_started = false;\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Runs the adapter.\n\t\t */\n\t\tcloseBundle: {\n\t\t\tsequential: true,\n\t\t\tasync handler() {\n\t\t\t\tif (!vite_config.build.ssr) return;\n\t\t\t\tawait finalise?.();\n\t\t\t}\n\t\t}\n\t};\n\n\treturn [plugin_setup, plugin_virtual_modules, plugin_guard, plugin_compile];\n}\n\n/**\n * @param {Record<string, any>} config\n * @param {Record<string, any>} resolved_config\n */\nfunction warn_overridden_config(config, resolved_config) {\n\tconst overridden = find_overridden_config(config, resolved_config, enforced_config, '', []);\n\n\tif (overridden.length > 0) {\n\t\tconsole.error(\n\t\t\tcolors.bold().red('The following Vite config options will be overridden by SvelteKit:') +\n\t\t\t\toverridden.map((key) => `\\n  - ${key}`).join('')\n\t\t);\n\t}\n}\n\n/**\n * @param {Record<string, any>} config\n * @param {Record<string, any>} resolved_config\n * @param {import('./types').EnforcedConfig} enforced_config\n * @param {string} path\n * @param {string[]} out used locally to compute the return value\n */\nfunction find_overridden_config(config, resolved_config, enforced_config, path, out) {\n\tif (config == null || resolved_config == null) {\n\t\treturn out;\n\t}\n\n\tfor (const key in enforced_config) {\n\t\tif (typeof config === 'object' && key in config && key in resolved_config) {\n\t\t\tconst enforced = enforced_config[key];\n\n\t\t\tif (enforced === true) {\n\t\t\t\tif (config[key] !== resolved_config[key]) {\n\t\t\t\t\tout.push(path + key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfind_overridden_config(config[key], resolved_config[key], enforced, path + key + '.', out);\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n\n/**\n * @param {import('types').ValidatedConfig} config\n */\nconst create_service_worker_module = (config) => dedent`\n\tif (typeof self === 'undefined' || self instanceof ServiceWorkerGlobalScope === false) {\n\t\tthrow new Error('This module can only be imported inside a service worker');\n\t}\n\n\texport const build = [];\n\texport const files = [\n\t\t${create_assets(config)\n\t\t\t.filter((asset) => config.kit.serviceWorker.files(asset.file))\n\t\t\t.map((asset) => `${s(`${config.kit.paths.base}/${asset.file}`)}`)\n\t\t\t.join(',\\n')}\n\t];\n\texport const prerendered = [];\n\texport const version = ${s(config.kit.version.name)};\n`;\n"}},"preview":{"directory":{"index.js":{"file":{"contents":"import fs from 'node:fs';\nimport { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport sirv from 'sirv';\nimport { loadEnv, normalizePath } from 'vite';\nimport { getRequest, setResponse } from '../../../exports/node/index.js';\nimport { installPolyfills } from '../../../exports/node/polyfills.js';\nimport { SVELTE_KIT_ASSETS } from '../../../constants.js';\nimport { should_polyfill } from '../../../utils/platform.js';\nimport { not_found } from '../utils.js';\n\n/** @typedef {import('http').IncomingMessage} Req */\n/** @typedef {import('http').ServerResponse} Res */\n/** @typedef {(req: Req, res: Res, next: () => void) => void} Handler */\n\n/**\n * @param {{\n *   middlewares: import('connect').Server;\n *   httpServer: import('http').Server;\n * }} vite\n * @param {import('vite').ResolvedConfig} vite_config\n * @param {import('types').ValidatedConfig} svelte_config\n */\nexport async function preview(vite, vite_config, svelte_config) {\n\tif (should_polyfill) {\n\t\tinstallPolyfills();\n\t}\n\n\tconst { paths } = svelte_config.kit;\n\tconst base = paths.base;\n\tconst assets = paths.assets ? SVELTE_KIT_ASSETS : paths.base;\n\n\tconst protocol = vite_config.preview.https ? 'https' : 'http';\n\n\tconst etag = `\"${Date.now()}\"`;\n\n\tconst dir = join(svelte_config.kit.outDir, 'output/server');\n\n\t/** @type {import('types').ServerInternalModule} */\n\tconst { set_assets } = await import(pathToFileURL(join(dir, 'internal.js')).href);\n\n\t/** @type {import('types').ServerModule} */\n\tconst { Server } = await import(pathToFileURL(join(dir, 'index.js')).href);\n\n\tconst { manifest } = await import(pathToFileURL(join(dir, 'manifest.js')).href);\n\n\tset_assets(assets);\n\n\tconst server = new Server(manifest);\n\tawait server.init({\n\t\tenv: loadEnv(vite_config.mode, svelte_config.kit.env.dir, '')\n\t});\n\n\treturn () => {\n\t\t// generated client assets and the contents of `static`\n\t\tvite.middlewares.use(\n\t\t\tscoped(\n\t\t\t\tassets,\n\t\t\t\tsirv(join(svelte_config.kit.outDir, 'output/client'), {\n\t\t\t\t\tsetHeaders: (res, pathname) => {\n\t\t\t\t\t\t// only apply to immutable directory, not e.g. version.json\n\t\t\t\t\t\tif (pathname.startsWith(`/${svelte_config.kit.appDir}/immutable`)) {\n\t\t\t\t\t\t\tres.setHeader('cache-control', 'public,max-age=31536000,immutable');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\n\t\tvite.middlewares.use((req, res, next) => {\n\t\t\tconst original_url = /** @type {string} */ (req.url);\n\t\t\tconst { pathname } = new URL(original_url, 'http://dummy');\n\n\t\t\tif (pathname.startsWith(base)) {\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\tres.statusCode = 404;\n\t\t\t\tnot_found(req, res, base);\n\t\t\t}\n\t\t});\n\n\t\t// prerendered dependencies\n\t\tvite.middlewares.use(\n\t\t\tscoped(base, mutable(join(svelte_config.kit.outDir, 'output/prerendered/dependencies')))\n\t\t);\n\n\t\t// prerendered pages (we can't just use sirv because we need to\n\t\t// preserve the correct trailingSlash behaviour)\n\t\tvite.middlewares.use(\n\t\t\tscoped(base, (req, res, next) => {\n\t\t\t\tlet if_none_match_value = req.headers['if-none-match'];\n\n\t\t\t\tif (if_none_match_value?.startsWith('W/\"')) {\n\t\t\t\t\tif_none_match_value = if_none_match_value.substring(2);\n\t\t\t\t}\n\n\t\t\t\tif (if_none_match_value === etag) {\n\t\t\t\t\tres.statusCode = 304;\n\t\t\t\t\tres.end();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { pathname } = new URL(/** @type {string} */ (req.url), 'http://dummy');\n\n\t\t\t\tlet filename = normalizePath(\n\t\t\t\t\tjoin(svelte_config.kit.outDir, 'output/prerendered/pages' + pathname)\n\t\t\t\t);\n\t\t\t\tlet prerendered = is_file(filename);\n\n\t\t\t\tif (!prerendered) {\n\t\t\t\t\tfilename += filename.endsWith('/') ? 'index.html' : '.html';\n\t\t\t\t\tprerendered = is_file(filename);\n\t\t\t\t}\n\n\t\t\t\tif (prerendered) {\n\t\t\t\t\tres.writeHead(200, {\n\t\t\t\t\t\t'content-type': 'text/html',\n\t\t\t\t\t\tetag\n\t\t\t\t\t});\n\n\t\t\t\t\tfs.createReadStream(filename).pipe(res);\n\t\t\t\t} else {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\t// SSR\n\t\tvite.middlewares.use(async (req, res) => {\n\t\t\tconst host = req.headers['host'];\n\n\t\t\tlet request;\n\n\t\t\ttry {\n\t\t\t\trequest = await getRequest({\n\t\t\t\t\tbase: `${protocol}://${host}`,\n\t\t\t\t\trequest: req\n\t\t\t\t});\n\t\t\t} catch (/** @type {any} */ err) {\n\t\t\t\tres.statusCode = err.status || 400;\n\t\t\t\treturn res.end('Invalid request body');\n\t\t\t}\n\n\t\t\tsetResponse(\n\t\t\t\tres,\n\t\t\t\tawait server.respond(request, {\n\t\t\t\t\tgetClientAddress: () => {\n\t\t\t\t\t\tconst { remoteAddress } = req.socket;\n\t\t\t\t\t\tif (remoteAddress) return remoteAddress;\n\t\t\t\t\t\tthrow new Error('Could not determine clientAddress');\n\t\t\t\t\t},\n\t\t\t\t\tread: (file) => fs.readFileSync(join(svelte_config.kit.files.assets, file))\n\t\t\t\t})\n\t\t\t);\n\t\t});\n\t};\n}\n\n/**\n * @param {string} dir\n * @returns {Handler}\n */\nconst mutable = (dir) =>\n\tfs.existsSync(dir)\n\t\t? sirv(dir, {\n\t\t\t\tetag: true,\n\t\t\t\tmaxAge: 0\n\t\t  })\n\t\t: (_req, _res, next) => next();\n\n/**\n * @param {string} scope\n * @param {Handler} handler\n * @returns {Handler}\n */\nfunction scoped(scope, handler) {\n\tif (scope === '') return handler;\n\n\treturn (req, res, next) => {\n\t\tif (req.url?.startsWith(scope)) {\n\t\t\tconst original_url = req.url;\n\t\t\treq.url = req.url.slice(scope.length);\n\t\t\thandler(req, res, () => {\n\t\t\t\treq.url = original_url;\n\t\t\t\tnext();\n\t\t\t});\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t};\n}\n\n/** @param {string} path */\nfunction is_file(path) {\n\treturn fs.existsSync(path) && !fs.statSync(path).isDirectory();\n}\n"}}}},"types.d.ts":{"file":{"contents":"export interface EnforcedConfig {\n\t[key: string]: EnforcedConfig | true;\n}\n"}},"utils.js":{"file":{"contents":"import path from 'node:path';\nimport { loadEnv } from 'vite';\nimport { posixify } from '../../utils/filesystem.js';\nimport { negotiate } from '../../utils/http.js';\n\n/**\n * Transforms kit.alias to a valid vite.resolve.alias array.\n *\n * Related to tsconfig path alias creation.\n *\n * @param {import('types').ValidatedKitConfig} config\n * */\nexport function get_config_aliases(config) {\n\t/** @type {import('vite').Alias[]} */\n\tconst alias = [\n\t\t// For now, we handle `$lib` specially here rather than make it a default value for\n\t\t// `config.kit.alias` since it has special meaning for packaging, etc.\n\t\t{ find: '$lib', replacement: config.files.lib }\n\t];\n\n\tfor (let [key, value] of Object.entries(config.alias)) {\n\t\tvalue = posixify(value);\n\t\tif (value.endsWith('/*')) {\n\t\t\tvalue = value.slice(0, -2);\n\t\t}\n\t\tif (key.endsWith('/*')) {\n\t\t\t// Doing just `{ find: key.slice(0, -2) ,..}` would mean `import .. from \"key\"` would also be matched, which we don't want\n\t\t\talias.push({\n\t\t\t\tfind: new RegExp(`^${escape_for_regexp(key.slice(0, -2))}\\\\/(.+)$`),\n\t\t\t\treplacement: `${path.resolve(value)}/$1`\n\t\t\t});\n\t\t} else if (key + '/*' in config.alias) {\n\t\t\t// key and key/* both exist -> the replacement for key needs to happen _only_ on import .. from \"key\"\n\t\t\talias.push({\n\t\t\t\tfind: new RegExp(`^${escape_for_regexp(key)}$`),\n\t\t\t\treplacement: path.resolve(value)\n\t\t\t});\n\t\t} else {\n\t\t\talias.push({ find: key, replacement: path.resolve(value) });\n\t\t}\n\t}\n\n\treturn alias;\n}\n\n/**\n * @param {string} str\n */\nfunction escape_for_regexp(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, (match) => '\\\\' + match);\n}\n\n/**\n * Load environment variables from process.env and .env files\n * @param {import('types').ValidatedKitConfig['env']} env_config\n * @param {string} mode\n */\nexport function get_env(env_config, mode) {\n\tconst entries = Object.entries(loadEnv(mode, env_config.dir, ''));\n\n\treturn {\n\t\tpublic: Object.fromEntries(entries.filter(([k]) => k.startsWith(env_config.publicPrefix))),\n\t\tprivate: Object.fromEntries(entries.filter(([k]) => !k.startsWith(env_config.publicPrefix)))\n\t};\n}\n\n/**\n * @param {import('http').IncomingMessage} req\n * @param {import('http').ServerResponse} res\n * @param {string} base\n */\nexport function not_found(req, res, base) {\n\tconst type = negotiate(req.headers.accept ?? '*', ['text/plain', 'text/html']);\n\n\t// special case — handle `/` request automatically\n\tif (req.url === '/' && type === 'text/html') {\n\t\tres.statusCode = 307;\n\t\tres.setHeader('location', base);\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tres.statusCode = 404;\n\n\tconst prefixed = base + req.url;\n\n\tif (type === 'text/html') {\n\t\tres.setHeader('Content-Type', 'text/html');\n\t\tres.end(\n\t\t\t`The server is configured with a public base URL of ${base} - did you mean to visit <a href=\"${prefixed}\">${prefixed}</a> instead?`\n\t\t);\n\t} else {\n\t\tres.end(\n\t\t\t`The server is configured with a public base URL of ${base} - did you mean to visit ${prefixed} instead?`\n\t\t);\n\t}\n}\n"}}}}}},"internal.d.ts":{"file":{"contents":"/** Internal version of $app/environment */\ndeclare module '__sveltekit/environment' {\n\texport const building: boolean;\n\texport const version: string;\n\texport function set_building(): void;\n}\n\n/** Internal version of $app/paths */\ndeclare module '__sveltekit/paths' {\n\texport let base: '' | `/${string}`;\n\texport let assets: '' | `https://${string}` | `http://${string}` | '/_svelte_kit_assets';\n\texport let relative: boolean | undefined; // TODO in 2.0, make this a `boolean` that defaults to `true`\n\texport function reset(): void;\n\texport function override(paths: { base: string; assets: string }): void;\n\texport function set_assets(path: string): void;\n}\n"}},"runtime":{"directory":{"app":{"directory":{"env.js":{"file":{"contents":"throw new Error('$app/env has been renamed to $app/environment');\n"}},"environment.js":{"file":{"contents":"import { BROWSER, DEV } from 'esm-env';\n\n/**\n * @type {import('$app/environment').browser}\n */\nexport const browser = BROWSER;\n\n/**\n * @type {import('$app/environment').dev}\n */\nexport const dev = DEV;\n\nexport { building, version } from '__sveltekit/environment';\n"}},"forms.js":{"file":{"contents":"import * as devalue from 'devalue';\nimport { client } from '../client/singletons.js';\nimport { invalidateAll } from './navigation.js';\nimport { BROWSER, DEV } from 'esm-env';\n\n/**\n * @param {string} name\n */\nfunction guard(name) {\n\treturn () => {\n\t\tthrow new Error(`Cannot call ${name}(...) on the server`);\n\t};\n}\n\n/** @type {import('$app/forms').applyAction} */\nexport const applyAction = BROWSER ? client.apply_action : guard('applyAction');\n\n/** @type {import('$app/forms').deserialize} */\nexport function deserialize(result) {\n\tconst parsed = JSON.parse(result);\n\tif (parsed.data) {\n\t\tparsed.data = devalue.parse(parsed.data);\n\t}\n\treturn parsed;\n}\n\n/** @type {import('$app/forms').enhance} */\nexport function enhance(form, submit = () => {}) {\n\tif (\n\t\tDEV &&\n\t\t/** @type {HTMLFormElement} */ (HTMLFormElement.prototype.cloneNode.call(form)).method !==\n\t\t\t'post'\n\t) {\n\t\tthrow new Error('use:enhance can only be used on <form> fields with method=\"POST\"');\n\t}\n\n\t/**\n\t * @param {{\n\t *   action: URL;\n\t *   result: import('types').ActionResult;\n\t *   reset?: boolean\n\t * }} opts\n\t */\n\tconst fallback_callback = async ({ action, result, reset }) => {\n\t\tif (result.type === 'success') {\n\t\t\tif (reset !== false) {\n\t\t\t\t// We call reset from the prototype to avoid DOM clobbering\n\t\t\t\tHTMLFormElement.prototype.reset.call(form);\n\t\t\t}\n\t\t\tawait invalidateAll();\n\t\t}\n\n\t\t// For success/failure results, only apply action if it belongs to the\n\t\t// current page, otherwise `form` will be updated erroneously\n\t\tif (\n\t\t\tlocation.origin + location.pathname === action.origin + action.pathname ||\n\t\t\tresult.type === 'redirect' ||\n\t\t\tresult.type === 'error'\n\t\t) {\n\t\t\tapplyAction(result);\n\t\t}\n\t};\n\n\t/** @param {SubmitEvent} event */\n\tasync function handle_submit(event) {\n\t\tevent.preventDefault();\n\n\t\tconst action = new URL(\n\t\t\t// We can't do submitter.formAction directly because that property is always set\n\t\t\t// We do cloneNode for avoid DOM clobbering - https://github.com/sveltejs/kit/issues/7593\n\t\t\tevent.submitter?.hasAttribute('formaction')\n\t\t\t\t? /** @type {HTMLButtonElement | HTMLInputElement} */ (event.submitter).formAction\n\t\t\t\t: /** @type {HTMLFormElement} */ (HTMLFormElement.prototype.cloneNode.call(form)).action\n\t\t);\n\n\t\tconst data = new FormData(form);\n\n\t\tconst submitter_name = event.submitter?.getAttribute('name');\n\t\tif (submitter_name) {\n\t\t\tdata.append(submitter_name, event.submitter?.getAttribute('value') ?? '');\n\t\t}\n\n\t\tconst controller = new AbortController();\n\n\t\tlet cancelled = false;\n\t\tconst cancel = () => (cancelled = true);\n\n\t\tconst callback =\n\t\t\t(await submit({\n\t\t\t\taction,\n\t\t\t\tcancel,\n\t\t\t\tcontroller,\n\t\t\t\tdata,\n\t\t\t\tform\n\t\t\t})) ?? fallback_callback;\n\t\tif (cancelled) return;\n\n\t\t/** @type {import('types').ActionResult} */\n\t\tlet result;\n\n\t\ttry {\n\t\t\tconst response = await fetch(action, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: {\n\t\t\t\t\taccept: 'application/json',\n\t\t\t\t\t'x-sveltekit-action': 'true'\n\t\t\t\t},\n\t\t\t\tcache: 'no-store',\n\t\t\t\tbody: data,\n\t\t\t\tsignal: controller.signal\n\t\t\t});\n\n\t\t\tresult = deserialize(await response.text());\n\t\t\tif (result.type === 'error') result.status = response.status;\n\t\t} catch (error) {\n\t\t\tif (/** @type {any} */ (error)?.name === 'AbortError') return;\n\t\t\tresult = { type: 'error', error };\n\t\t}\n\n\t\tcallback({\n\t\t\taction,\n\t\t\tdata,\n\t\t\tform,\n\t\t\tupdate: (opts) => fallback_callback({ action, result, reset: opts?.reset }),\n\t\t\t// @ts-expect-error generic constraints stuff we don't care about\n\t\t\tresult\n\t\t});\n\t}\n\n\t// @ts-expect-error\n\tHTMLFormElement.prototype.addEventListener.call(form, 'submit', handle_submit);\n\n\treturn {\n\t\tdestroy() {\n\t\t\t// @ts-expect-error\n\t\t\tHTMLFormElement.prototype.removeEventListener.call(form, 'submit', handle_submit);\n\t\t}\n\t};\n}\n"}},"navigation.js":{"file":{"contents":"import { BROWSER } from 'esm-env';\nimport { client } from '../client/singletons.js';\n\n/**\n * @param {string} name\n */\nfunction guard(name) {\n\treturn () => {\n\t\tthrow new Error(`Cannot call ${name}(...) on the server`);\n\t};\n}\n\nexport const disableScrollHandling = BROWSER\n\t? client.disable_scroll_handling\n\t: guard('disableScrollHandling');\nexport const goto = BROWSER ? client.goto : guard('goto');\nexport const invalidate = BROWSER ? client.invalidate : guard('invalidate');\nexport const invalidateAll = BROWSER ? client.invalidateAll : guard('invalidateAll');\nexport const preloadData = BROWSER ? client.preload_data : guard('preloadData');\nexport const preloadCode = BROWSER ? client.preload_code : guard('preloadCode');\nexport const beforeNavigate = BROWSER ? client.before_navigate : () => {};\nexport const afterNavigate = BROWSER ? client.after_navigate : () => {};\n"}},"paths.js":{"file":{"contents":"export { base, assets } from '__sveltekit/paths';\n"}},"stores.js":{"file":{"contents":"import { getContext } from 'svelte';\nimport { browser } from './environment.js';\nimport { stores as browser_stores } from '../client/singletons.js';\n\n/**\n * @type {import('$app/stores').getStores}\n */\nexport const getStores = () => {\n\tconst stores = browser ? browser_stores : getContext('__svelte__');\n\n\treturn {\n\t\tpage: {\n\t\t\tsubscribe: stores.page.subscribe\n\t\t},\n\t\tnavigating: {\n\t\t\tsubscribe: stores.navigating.subscribe\n\t\t},\n\t\tupdated: stores.updated\n\t};\n};\n\n/** @type {typeof import('$app/stores').page} */\nexport const page = {\n\t/** @param {(value: any) => void} fn */\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('page') : getStores().page;\n\t\treturn store.subscribe(fn);\n\t}\n};\n\n/** @type {typeof import('$app/stores').navigating} */\nexport const navigating = {\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('navigating') : getStores().navigating;\n\t\treturn store.subscribe(fn);\n\t}\n};\n\n/** @type {typeof import('$app/stores').updated} */\nexport const updated = {\n\tsubscribe(fn) {\n\t\tconst store = __SVELTEKIT_DEV__ ? get_store('updated') : getStores().updated;\n\n\t\tif (browser) {\n\t\t\tupdated.check = store.check;\n\t\t}\n\n\t\treturn store.subscribe(fn);\n\t},\n\tcheck: () => {\n\t\tthrow new Error(\n\t\t\tbrowser\n\t\t\t\t? `Cannot check updated store before subscribing`\n\t\t\t\t: `Can only check updated store in browser`\n\t\t);\n\t}\n};\n\n/**\n * @template {keyof ReturnType<typeof getStores>} Name\n * @param {Name} name\n * @returns {ReturnType<typeof getStores>[Name]}\n */\nfunction get_store(name) {\n\ttry {\n\t\treturn getStores()[name];\n\t} catch (e) {\n\t\tthrow new Error(\n\t\t\t`Cannot subscribe to '${name}' store on the server outside of a Svelte component, as it is bound to the current request via component context. This prevents state from leaking between users.` +\n\t\t\t\t'For more information, see https://kit.svelte.dev/docs/state-management#avoid-shared-state-on-the-server'\n\t\t);\n\t}\n}\n"}}}},"client":{"directory":{"client.js":{"file":{"contents":"import { DEV } from 'esm-env';\nimport { onMount, tick } from 'svelte';\nimport {\n\tmake_trackable,\n\tdecode_pathname,\n\tdecode_params,\n\tnormalize_path,\n\tadd_data_suffix\n} from '../../utils/url.js';\nimport {\n\tfind_anchor,\n\tget_base_uri,\n\tget_link_info,\n\tget_router_options,\n\tis_external_url,\n\tscroll_state\n} from './utils.js';\nimport * as storage from './session-storage.js';\nimport {\n\tlock_fetch,\n\tunlock_fetch,\n\tinitial_fetch,\n\tsubsequent_fetch,\n\tnative_fetch\n} from './fetcher.js';\nimport { parse } from './parse.js';\n\nimport { base } from '__sveltekit/paths';\nimport { HttpError, Redirect } from '../control.js';\nimport { stores } from './singletons.js';\nimport { unwrap_promises } from '../../utils/promises.js';\nimport * as devalue from 'devalue';\nimport { INDEX_KEY, PRELOAD_PRIORITIES, SCROLL_KEY, SNAPSHOT_KEY } from './constants.js';\nimport { validate_common_exports } from '../../utils/exports.js';\nimport { compact } from '../../utils/array.js';\nimport { validate_depends } from '../shared.js';\n\n// We track the scroll position associated with each history entry in sessionStorage,\n// rather than on history.state itself, because when navigation is driven by\n// popstate it's too late to update the scroll position associated with the\n// state we're navigating from\n\n/** @typedef {{ x: number, y: number }} ScrollPosition */\n/** @type {Record<number, ScrollPosition>} */\nconst scroll_positions = storage.get(SCROLL_KEY) ?? {};\n\n/** @type {Record<string, any[]>} */\nconst snapshots = storage.get(SNAPSHOT_KEY) ?? {};\n\n/** @param {number} index */\nfunction update_scroll_positions(index) {\n\tscroll_positions[index] = scroll_state();\n}\n\n/**\n * @param {import('./types').SvelteKitApp} app\n * @param {HTMLElement} target\n * @returns {import('./types').Client}\n */\nexport function create_client(app, target) {\n\tconst routes = parse(app);\n\n\tconst default_layout_loader = app.nodes[0];\n\tconst default_error_loader = app.nodes[1];\n\n\t// we import the root layout/error nodes eagerly, so that\n\t// connectivity errors after initialisation don't nuke the app\n\tdefault_layout_loader();\n\tdefault_error_loader();\n\n\tconst container = __SVELTEKIT_EMBEDDED__ ? target : document.documentElement;\n\t/** @type {Array<((url: URL) => boolean)>} */\n\tconst invalidated = [];\n\n\t/**\n\t * An array of the `+layout.svelte` and `+page.svelte` component instances\n\t * that currently live on the page — used for capturing and restoring snapshots.\n\t * It's updated/manipulated through `bind:this` in `Root.svelte`.\n\t * @type {import('svelte').SvelteComponent[]}\n\t */\n\tconst components = [];\n\n\t/** @type {{id: string, promise: Promise<import('./types').NavigationResult>} | null} */\n\tlet load_cache = null;\n\n\tconst callbacks = {\n\t\t/** @type {Array<(navigation: import('types').BeforeNavigate) => void>} */\n\t\tbefore_navigate: [],\n\n\t\t/** @type {Array<(navigation: import('types').AfterNavigate) => void>} */\n\t\tafter_navigate: []\n\t};\n\n\t/** @type {import('./types').NavigationState} */\n\tlet current = {\n\t\tbranch: [],\n\t\terror: null,\n\t\t// @ts-ignore - we need the initial value to be null\n\t\turl: null\n\t};\n\n\t/** this being true means we SSR'd */\n\tlet hydrated = false;\n\tlet started = false;\n\tlet autoscroll = true;\n\tlet updating = false;\n\tlet navigating = false;\n\tlet hash_navigating = false;\n\n\tlet force_invalidation = false;\n\n\t/** @type {import('svelte').SvelteComponent} */\n\tlet root;\n\n\t// keeping track of the history index in order to prevent popstate navigation events if needed\n\tlet current_history_index = history.state?.[INDEX_KEY];\n\n\tif (!current_history_index) {\n\t\t// we use Date.now() as an offset so that cross-document navigations\n\t\t// within the app don't result in data loss\n\t\tcurrent_history_index = Date.now();\n\n\t\t// create initial history entry, so we can return here\n\t\thistory.replaceState(\n\t\t\t{ ...history.state, [INDEX_KEY]: current_history_index },\n\t\t\t'',\n\t\t\tlocation.href\n\t\t);\n\t}\n\n\t// if we reload the page, or Cmd-Shift-T back to it,\n\t// recover scroll position\n\tconst scroll = scroll_positions[current_history_index];\n\tif (scroll) {\n\t\thistory.scrollRestoration = 'manual';\n\t\tscrollTo(scroll.x, scroll.y);\n\t}\n\n\t/** @type {import('types').Page} */\n\tlet page;\n\n\t/** @type {{}} */\n\tlet token;\n\n\t/** @type {Promise<void> | null} */\n\tlet pending_invalidate;\n\n\tasync function invalidate() {\n\t\t// Accept all invalidations as they come, don't swallow any while another invalidation\n\t\t// is running because subsequent invalidations may make earlier ones outdated,\n\t\t// but batch multiple synchronous invalidations.\n\t\tpending_invalidate = pending_invalidate || Promise.resolve();\n\t\tawait pending_invalidate;\n\t\tpending_invalidate = null;\n\n\t\tconst url = new URL(location.href);\n\t\tconst intent = get_navigation_intent(url, true);\n\t\t// Clear preload, it might be affected by the invalidation.\n\t\t// Also solves an edge case where a preload is triggered, the navigation for it\n\t\t// was then triggered and is still running while the invalidation kicks in,\n\t\t// at which point the invalidation should take over and \"win\".\n\t\tload_cache = null;\n\t\tawait update(intent, url, []);\n\t}\n\n\t/** @param {number} index */\n\tfunction capture_snapshot(index) {\n\t\tif (components.some((c) => c?.snapshot)) {\n\t\t\tsnapshots[index] = components.map((c) => c?.snapshot?.capture());\n\t\t}\n\t}\n\n\t/** @param {number} index */\n\tfunction restore_snapshot(index) {\n\t\tsnapshots[index]?.forEach((value, i) => {\n\t\t\tcomponents[i]?.snapshot?.restore(value);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string | URL} url\n\t * @param {{ noScroll?: boolean; replaceState?: boolean; keepFocus?: boolean; state?: any; invalidateAll?: boolean }} opts\n\t * @param {string[]} redirect_chain\n\t * @param {{}} [nav_token]\n\t */\n\tasync function goto(\n\t\turl,\n\t\t{\n\t\t\tnoScroll = false,\n\t\t\treplaceState = false,\n\t\t\tkeepFocus = false,\n\t\t\tstate = {},\n\t\t\tinvalidateAll = false\n\t\t},\n\t\tredirect_chain,\n\t\tnav_token\n\t) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url, get_base_uri(document));\n\t\t}\n\n\t\treturn navigate({\n\t\t\turl,\n\t\t\tscroll: noScroll ? scroll_state() : null,\n\t\t\tkeepfocus: keepFocus,\n\t\t\tredirect_chain,\n\t\t\tdetails: {\n\t\t\t\tstate,\n\t\t\t\treplaceState\n\t\t\t},\n\t\t\tnav_token,\n\t\t\taccepted: () => {\n\t\t\t\tif (invalidateAll) {\n\t\t\t\t\tforce_invalidation = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tblocked: () => {},\n\t\t\ttype: 'goto'\n\t\t});\n\t}\n\n\t/** @param {import('./types').NavigationIntent} intent */\n\tasync function preload_data(intent) {\n\t\tload_cache = {\n\t\t\tid: intent.id,\n\t\t\tpromise: load_route(intent).then((result) => {\n\t\t\t\tif (result.type === 'loaded' && result.state.error) {\n\t\t\t\t\t// Don't cache errors, because they might be transient\n\t\t\t\t\tload_cache = null;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t})\n\t\t};\n\n\t\treturn load_cache.promise;\n\t}\n\n\t/** @param {...string} pathnames */\n\tasync function preload_code(...pathnames) {\n\t\tconst matching = routes.filter((route) => pathnames.some((pathname) => route.exec(pathname)));\n\n\t\tconst promises = matching.map((r) => {\n\t\t\treturn Promise.all([...r.layouts, r.leaf].map((load) => load?.[1]()));\n\t\t});\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * Returns `true` if update completes, `false` if it is aborted\n\t * @param {import('./types').NavigationIntent | undefined} intent\n\t * @param {URL} url\n\t * @param {string[]} redirect_chain\n\t * @param {number} [previous_history_index]\n\t * @param {{hash?: string, scroll: { x: number, y: number } | null, keepfocus: boolean, details: { replaceState: boolean, state: any } | null}} [opts]\n\t * @param {{}} [nav_token] To distinguish between different navigation events and determine the latest. Needed for example for redirects to keep the original token\n\t * @param {() => void} [callback]\n\t */\n\tasync function update(\n\t\tintent,\n\t\turl,\n\t\tredirect_chain,\n\t\tprevious_history_index,\n\t\topts,\n\t\tnav_token = {},\n\t\tcallback\n\t) {\n\t\ttoken = nav_token;\n\t\tlet navigation_result = intent && (await load_route(intent));\n\n\t\tif (!navigation_result) {\n\t\t\tnavigation_result = await server_fallback(\n\t\t\t\turl,\n\t\t\t\t{ id: null },\n\t\t\t\tawait handle_error(new Error(`Not found: ${url.pathname}`), {\n\t\t\t\t\turl,\n\t\t\t\t\tparams: {},\n\t\t\t\t\troute: { id: null }\n\t\t\t\t}),\n\t\t\t\t404\n\t\t\t);\n\t\t}\n\n\t\t// if this is an internal navigation intent, use the normalized\n\t\t// URL for the rest of the function\n\t\turl = intent?.url || url;\n\n\t\t// abort if user navigated during update\n\t\tif (token !== nav_token) return false;\n\n\t\tif (navigation_result.type === 'redirect') {\n\t\t\tif (redirect_chain.length > 10 || redirect_chain.includes(url.pathname)) {\n\t\t\t\tnavigation_result = await load_root_error_page({\n\t\t\t\t\tstatus: 500,\n\t\t\t\t\terror: await handle_error(new Error('Redirect loop'), {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\tparams: {},\n\t\t\t\t\t\troute: { id: null }\n\t\t\t\t\t}),\n\t\t\t\t\turl,\n\t\t\t\t\troute: { id: null }\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgoto(\n\t\t\t\t\tnew URL(navigation_result.location, url).href,\n\t\t\t\t\t{},\n\t\t\t\t\t[...redirect_chain, url.pathname],\n\t\t\t\t\tnav_token\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (/** @type {number} */ (navigation_result.props.page?.status) >= 400) {\n\t\t\tconst updated = await stores.updated.check();\n\t\t\tif (updated) {\n\t\t\t\tawait native_navigation(url);\n\t\t\t}\n\t\t}\n\n\t\t// reset invalidation only after a finished navigation. If there are redirects or\n\t\t// additional invalidations, they should get the same invalidation treatment\n\t\tinvalidated.length = 0;\n\t\tforce_invalidation = false;\n\n\t\tupdating = true;\n\n\t\t// `previous_history_index` will be undefined for invalidation\n\t\tif (previous_history_index) {\n\t\t\tupdate_scroll_positions(previous_history_index);\n\t\t\tcapture_snapshot(previous_history_index);\n\t\t}\n\n\t\t// ensure the url pathname matches the page's trailing slash option\n\t\tif (\n\t\t\tnavigation_result.props.page?.url &&\n\t\t\tnavigation_result.props.page.url.pathname !== url.pathname\n\t\t) {\n\t\t\turl.pathname = navigation_result.props.page?.url.pathname;\n\t\t}\n\n\t\tif (opts && opts.details) {\n\t\t\tconst { details } = opts;\n\t\t\tconst change = details.replaceState ? 0 : 1;\n\t\t\tdetails.state[INDEX_KEY] = current_history_index += change;\n\t\t\thistory[details.replaceState ? 'replaceState' : 'pushState'](details.state, '', url);\n\n\t\t\tif (!details.replaceState) {\n\t\t\t\t// if we navigated back, then pushed a new state, we can\n\t\t\t\t// release memory by pruning the scroll/snapshot lookup\n\t\t\t\tlet i = current_history_index + 1;\n\t\t\t\twhile (snapshots[i] || scroll_positions[i]) {\n\t\t\t\t\tdelete snapshots[i];\n\t\t\t\t\tdelete scroll_positions[i];\n\t\t\t\t\ti += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// reset preload synchronously after the history state has been set to avoid race conditions\n\t\tload_cache = null;\n\n\t\tif (started) {\n\t\t\tcurrent = navigation_result.state;\n\n\t\t\t// reset url before updating page store\n\t\t\tif (navigation_result.props.page) {\n\t\t\t\tnavigation_result.props.page.url = url;\n\t\t\t}\n\n\t\t\troot.$set(navigation_result.props);\n\t\t} else {\n\t\t\tinitialize(navigation_result);\n\t\t}\n\n\t\t// opts must be passed if we're navigating\n\t\tif (opts) {\n\t\t\tconst { scroll, keepfocus } = opts;\n\t\t\tconst { activeElement } = document;\n\n\t\t\t// need to render the DOM before we can scroll to the rendered elements and do focus management\n\t\t\tawait tick();\n\n\t\t\tconst changed_focus =\n\t\t\t\t// reset focus only if any manual focus management didn't override it\n\t\t\t\tdocument.activeElement !== activeElement &&\n\t\t\t\t// also refocus when activeElement is body already because the\n\t\t\t\t// focus event might not have been fired on it yet\n\t\t\t\tdocument.activeElement !== document.body;\n\n\t\t\tif (!keepfocus && !changed_focus) {\n\t\t\t\tawait reset_focus();\n\t\t\t}\n\n\t\t\tif (autoscroll) {\n\t\t\t\tconst deep_linked =\n\t\t\t\t\turl.hash && document.getElementById(decodeURIComponent(url.hash.slice(1)));\n\t\t\t\tif (scroll) {\n\t\t\t\t\tscrollTo(scroll.x, scroll.y);\n\t\t\t\t} else if (deep_linked) {\n\t\t\t\t\t// Here we use `scrollIntoView` on the element instead of `scrollTo`\n\t\t\t\t\t// because it natively supports the `scroll-margin` and `scroll-behavior`\n\t\t\t\t\t// CSS properties.\n\t\t\t\t\tdeep_linked.scrollIntoView();\n\t\t\t\t} else {\n\t\t\t\t\tscrollTo(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tawait tick();\n\t\t}\n\n\t\tautoscroll = true;\n\n\t\tif (navigation_result.props.page) {\n\t\t\tpage = navigation_result.props.page;\n\t\t}\n\n\t\tif (callback) callback();\n\n\t\tupdating = false;\n\t}\n\n\t/** @param {import('./types').NavigationFinished} result */\n\tfunction initialize(result) {\n\t\tif (DEV && document.querySelector('vite-error-overlay')) return;\n\n\t\tcurrent = result.state;\n\n\t\tconst style = document.querySelector('style[data-sveltekit]');\n\t\tif (style) style.remove();\n\n\t\tpage = /** @type {import('types').Page} */ (result.props.page);\n\n\t\troot = new app.root({\n\t\t\ttarget,\n\t\t\tprops: { ...result.props, stores, components },\n\t\t\thydrate: true\n\t\t});\n\n\t\trestore_snapshot(current_history_index);\n\n\t\t/** @type {import('types').AfterNavigate} */\n\t\tconst navigation = {\n\t\t\tfrom: null,\n\t\t\tto: {\n\t\t\t\tparams: current.params,\n\t\t\t\troute: { id: current.route?.id ?? null },\n\t\t\t\turl: new URL(location.href)\n\t\t\t},\n\t\t\twillUnload: false,\n\t\t\ttype: 'enter'\n\t\t};\n\t\tcallbacks.after_navigate.forEach((fn) => fn(navigation));\n\n\t\tstarted = true;\n\t}\n\n\t/**\n\t *\n\t * @param {{\n\t *   url: URL;\n\t *   params: Record<string, string>;\n\t *   branch: Array<import('./types').BranchNode | undefined>;\n\t *   status: number;\n\t *   error: App.Error | null;\n\t *   route: import('types').CSRRoute | null;\n\t *   form?: Record<string, any> | null;\n\t * }} opts\n\t */\n\tasync function get_navigation_result_from_branch({\n\t\turl,\n\t\tparams,\n\t\tbranch,\n\t\tstatus,\n\t\terror,\n\t\troute,\n\t\tform\n\t}) {\n\t\t/** @type {import('types').TrailingSlash} */\n\t\tlet slash = 'never';\n\t\tfor (const node of branch) {\n\t\t\tif (node?.slash !== undefined) slash = node.slash;\n\t\t}\n\t\turl.pathname = normalize_path(url.pathname, slash);\n\t\turl.search = url.search; // turn `/?` into `/`\n\n\t\t/** @type {import('./types').NavigationFinished} */\n\t\tconst result = {\n\t\t\ttype: 'loaded',\n\t\t\tstate: {\n\t\t\t\turl,\n\t\t\t\tparams,\n\t\t\t\tbranch,\n\t\t\t\terror,\n\t\t\t\troute\n\t\t\t},\n\t\t\tprops: {\n\t\t\t\t// @ts-ignore Somehow it's getting SvelteComponent and SvelteComponentDev mixed up\n\t\t\t\tconstructors: compact(branch).map((branch_node) => branch_node.node.component)\n\t\t\t}\n\t\t};\n\n\t\tif (form !== undefined) {\n\t\t\tresult.props.form = form;\n\t\t}\n\n\t\tlet data = {};\n\t\tlet data_changed = !page;\n\n\t\tlet p = 0;\n\n\t\tfor (let i = 0; i < Math.max(branch.length, current.branch.length); i += 1) {\n\t\t\tconst node = branch[i];\n\t\t\tconst prev = current.branch[i];\n\n\t\t\tif (node?.data !== prev?.data) data_changed = true;\n\t\t\tif (!node) continue;\n\n\t\t\tdata = { ...data, ...node.data };\n\n\t\t\t// Only set props if the node actually updated. This prevents needless rerenders.\n\t\t\tif (data_changed) {\n\t\t\t\tresult.props[`data_${p}`] = data;\n\t\t\t}\n\n\t\t\tp += 1;\n\t\t}\n\n\t\tconst page_changed =\n\t\t\t!current.url ||\n\t\t\turl.href !== current.url.href ||\n\t\t\tcurrent.error !== error ||\n\t\t\t(form !== undefined && form !== page.form) ||\n\t\t\tdata_changed;\n\n\t\tif (page_changed) {\n\t\t\tresult.props.page = {\n\t\t\t\terror,\n\t\t\t\tparams,\n\t\t\t\troute: {\n\t\t\t\t\tid: route?.id ?? null\n\t\t\t\t},\n\t\t\t\tstatus,\n\t\t\t\turl: new URL(url),\n\t\t\t\tform: form ?? null,\n\t\t\t\t// The whole page store is updated, but this way the object reference stays the same\n\t\t\t\tdata: data_changed ? data : page.data\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Call the load function of the given node, if it exists.\n\t * If `server_data` is passed, this is treated as the initial run and the page endpoint is not requested.\n\t *\n\t * @param {{\n\t *   loader: import('types').CSRPageNodeLoader;\n\t * \t parent: () => Promise<Record<string, any>>;\n\t *   url: URL;\n\t *   params: Record<string, string>;\n\t *   route: { id: string | null };\n\t * \t server_data_node: import('./types').DataNode | null;\n\t * }} options\n\t * @returns {Promise<import('./types').BranchNode>}\n\t */\n\tasync function load_node({ loader, parent, url, params, route, server_data_node }) {\n\t\t/** @type {Record<string, any> | null} */\n\t\tlet data = null;\n\n\t\t/** @type {import('types').Uses} */\n\t\tconst uses = {\n\t\t\tdependencies: new Set(),\n\t\t\tparams: new Set(),\n\t\t\tparent: false,\n\t\t\troute: false,\n\t\t\turl: false\n\t\t};\n\n\t\tconst node = await loader();\n\n\t\tif (DEV) {\n\t\t\tvalidate_common_exports(node.universal);\n\t\t}\n\n\t\tif (node.universal?.load) {\n\t\t\t/** @param {string[]} deps */\n\t\t\tfunction depends(...deps) {\n\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\tif (DEV) validate_depends(/** @type {string} */ (route.id), dep);\n\n\t\t\t\t\tconst { href } = new URL(dep, url);\n\t\t\t\t\tuses.dependencies.add(href);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/** @type {import('types').LoadEvent} */\n\t\t\tconst load_input = {\n\t\t\t\troute: {\n\t\t\t\t\tget id() {\n\t\t\t\t\t\tuses.route = true;\n\t\t\t\t\t\treturn route.id;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tparams: new Proxy(params, {\n\t\t\t\t\tget: (target, key) => {\n\t\t\t\t\t\tuses.params.add(/** @type {string} */ (key));\n\t\t\t\t\t\treturn target[/** @type {string} */ (key)];\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tdata: server_data_node?.data ?? null,\n\t\t\t\turl: make_trackable(url, () => {\n\t\t\t\t\tuses.url = true;\n\t\t\t\t}),\n\t\t\t\tasync fetch(resource, init) {\n\t\t\t\t\t/** @type {URL | string} */\n\t\t\t\t\tlet requested;\n\n\t\t\t\t\tif (resource instanceof Request) {\n\t\t\t\t\t\trequested = resource.url;\n\n\t\t\t\t\t\t// we're not allowed to modify the received `Request` object, so in order\n\t\t\t\t\t\t// to fixup relative urls we create a new equivalent `init` object instead\n\t\t\t\t\t\tinit = {\n\t\t\t\t\t\t\t// the request body must be consumed in memory until browsers\n\t\t\t\t\t\t\t// implement streaming request bodies and/or the body getter\n\t\t\t\t\t\t\tbody:\n\t\t\t\t\t\t\t\tresource.method === 'GET' || resource.method === 'HEAD'\n\t\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t\t: await resource.blob(),\n\t\t\t\t\t\t\tcache: resource.cache,\n\t\t\t\t\t\t\tcredentials: resource.credentials,\n\t\t\t\t\t\t\theaders: resource.headers,\n\t\t\t\t\t\t\tintegrity: resource.integrity,\n\t\t\t\t\t\t\tkeepalive: resource.keepalive,\n\t\t\t\t\t\t\tmethod: resource.method,\n\t\t\t\t\t\t\tmode: resource.mode,\n\t\t\t\t\t\t\tredirect: resource.redirect,\n\t\t\t\t\t\t\treferrer: resource.referrer,\n\t\t\t\t\t\t\treferrerPolicy: resource.referrerPolicy,\n\t\t\t\t\t\t\tsignal: resource.signal,\n\t\t\t\t\t\t\t...init\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequested = resource;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we must fixup relative urls so they are resolved from the target page\n\t\t\t\t\tconst resolved = new URL(requested, url);\n\t\t\t\t\tdepends(resolved.href);\n\n\t\t\t\t\t// match ssr serialized data url, which is important to find cached responses\n\t\t\t\t\tif (resolved.origin === url.origin) {\n\t\t\t\t\t\trequested = resolved.href.slice(url.origin.length);\n\t\t\t\t\t}\n\n\t\t\t\t\t// prerendered pages may be served from any origin, so `initial_fetch` urls shouldn't be resolved\n\t\t\t\t\treturn started\n\t\t\t\t\t\t? subsequent_fetch(requested, resolved.href, init)\n\t\t\t\t\t\t: initial_fetch(requested, init);\n\t\t\t\t},\n\t\t\t\tsetHeaders: () => {}, // noop\n\t\t\t\tdepends,\n\t\t\t\tparent() {\n\t\t\t\t\tuses.parent = true;\n\t\t\t\t\treturn parent();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (DEV) {\n\t\t\t\ttry {\n\t\t\t\t\tlock_fetch();\n\t\t\t\t\tdata = (await node.universal.load.call(null, load_input)) ?? null;\n\t\t\t\t\tif (data != null && Object.getPrototypeOf(data) !== Object.prototype) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`a load function related to route '${route.id}' returned ${\n\t\t\t\t\t\t\t\ttypeof data !== 'object'\n\t\t\t\t\t\t\t\t\t? `a ${typeof data}`\n\t\t\t\t\t\t\t\t\t: data instanceof Response\n\t\t\t\t\t\t\t\t\t? 'a Response object'\n\t\t\t\t\t\t\t\t\t: Array.isArray(data)\n\t\t\t\t\t\t\t\t\t? 'an array'\n\t\t\t\t\t\t\t\t\t: 'a non-plain object'\n\t\t\t\t\t\t\t}, but must return a plain object at the top level (i.e. \\`return {...}\\`)`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tunlock_fetch();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata = (await node.universal.load.call(null, load_input)) ?? null;\n\t\t\t}\n\t\t\tdata = data ? await unwrap_promises(data) : null;\n\t\t}\n\n\t\treturn {\n\t\t\tnode,\n\t\t\tloader,\n\t\t\tserver: server_data_node,\n\t\t\tuniversal: node.universal?.load ? { type: 'data', data, uses } : null,\n\t\t\tdata: data ?? server_data_node?.data ?? null,\n\t\t\tslash: node.universal?.trailingSlash ?? server_data_node?.slash\n\t\t};\n\t}\n\n\t/**\n\t * @param {boolean} parent_changed\n\t * @param {boolean} route_changed\n\t * @param {boolean} url_changed\n\t * @param {import('types').Uses | undefined} uses\n\t * @param {Record<string, string>} params\n\t */\n\tfunction has_changed(parent_changed, route_changed, url_changed, uses, params) {\n\t\tif (force_invalidation) return true;\n\n\t\tif (!uses) return false;\n\n\t\tif (uses.parent && parent_changed) return true;\n\t\tif (uses.route && route_changed) return true;\n\t\tif (uses.url && url_changed) return true;\n\n\t\tfor (const param of uses.params) {\n\t\t\tif (params[param] !== current.params[param]) return true;\n\t\t}\n\n\t\tfor (const href of uses.dependencies) {\n\t\t\tif (invalidated.some((fn) => fn(new URL(href)))) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {import('types').ServerDataNode | import('types').ServerDataSkippedNode | null} node\n\t * @param {import('./types').DataNode | null} [previous]\n\t * @returns {import('./types').DataNode | null}\n\t */\n\tfunction create_data_node(node, previous) {\n\t\tif (node?.type === 'data') return node;\n\t\tif (node?.type === 'skip') return previous ?? null;\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param {import('./types').NavigationIntent} intent\n\t * @returns {Promise<import('./types').NavigationResult>}\n\t */\n\tasync function load_route({ id, invalidating, url, params, route }) {\n\t\tif (load_cache?.id === id) {\n\t\t\treturn load_cache.promise;\n\t\t}\n\n\t\tconst { errors, layouts, leaf } = route;\n\n\t\tconst loaders = [...layouts, leaf];\n\n\t\t// preload modules to avoid waterfall, but handle rejections\n\t\t// so they don't get reported to Sentry et al (we don't need\n\t\t// to act on the failures at this point)\n\t\terrors.forEach((loader) => loader?.().catch(() => {}));\n\t\tloaders.forEach((loader) => loader?.[1]().catch(() => {}));\n\n\t\t/** @type {import('types').ServerNodesResponse | import('types').ServerRedirectNode | null} */\n\t\tlet server_data = null;\n\n\t\tconst url_changed = current.url ? id !== current.url.pathname + current.url.search : false;\n\t\tconst route_changed = current.route ? route.id !== current.route.id : false;\n\n\t\tlet parent_invalid = false;\n\t\tconst invalid_server_nodes = loaders.map((loader, i) => {\n\t\t\tconst previous = current.branch[i];\n\n\t\t\tconst invalid =\n\t\t\t\t!!loader?.[0] &&\n\t\t\t\t(previous?.loader !== loader[1] ||\n\t\t\t\t\thas_changed(parent_invalid, route_changed, url_changed, previous.server?.uses, params));\n\n\t\t\tif (invalid) {\n\t\t\t\t// For the next one\n\t\t\t\tparent_invalid = true;\n\t\t\t}\n\n\t\t\treturn invalid;\n\t\t});\n\n\t\tif (invalid_server_nodes.some(Boolean)) {\n\t\t\ttry {\n\t\t\t\tserver_data = await load_data(url, invalid_server_nodes);\n\t\t\t} catch (error) {\n\t\t\t\treturn load_root_error_page({\n\t\t\t\t\tstatus: error instanceof HttpError ? error.status : 500,\n\t\t\t\t\terror: await handle_error(error, { url, params, route: { id: route.id } }),\n\t\t\t\t\turl,\n\t\t\t\t\troute\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (server_data.type === 'redirect') {\n\t\t\t\treturn server_data;\n\t\t\t}\n\t\t}\n\n\t\tconst server_data_nodes = server_data?.nodes;\n\n\t\tlet parent_changed = false;\n\n\t\tconst branch_promises = loaders.map(async (loader, i) => {\n\t\t\tif (!loader) return;\n\n\t\t\t/** @type {import('./types').BranchNode | undefined} */\n\t\t\tconst previous = current.branch[i];\n\n\t\t\tconst server_data_node = server_data_nodes?.[i];\n\n\t\t\t// re-use data from previous load if it's still valid\n\t\t\tconst valid =\n\t\t\t\t(!server_data_node || server_data_node.type === 'skip') &&\n\t\t\t\tloader[1] === previous?.loader &&\n\t\t\t\t!has_changed(parent_changed, route_changed, url_changed, previous.universal?.uses, params);\n\t\t\tif (valid) return previous;\n\n\t\t\tparent_changed = true;\n\n\t\t\tif (server_data_node?.type === 'error') {\n\t\t\t\t// rethrow and catch below\n\t\t\t\tthrow server_data_node;\n\t\t\t}\n\n\t\t\treturn load_node({\n\t\t\t\tloader: loader[1],\n\t\t\t\turl,\n\t\t\t\tparams,\n\t\t\t\troute,\n\t\t\t\tparent: async () => {\n\t\t\t\t\tconst data = {};\n\t\t\t\t\tfor (let j = 0; j < i; j += 1) {\n\t\t\t\t\t\tObject.assign(data, (await branch_promises[j])?.data);\n\t\t\t\t\t}\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tserver_data_node: create_data_node(\n\t\t\t\t\t// server_data_node is undefined if it wasn't reloaded from the server;\n\t\t\t\t\t// and if current loader uses server data, we want to reuse previous data.\n\t\t\t\t\tserver_data_node === undefined && loader[0] ? { type: 'skip' } : server_data_node ?? null,\n\t\t\t\t\tloader[0] ? previous?.server : undefined\n\t\t\t\t)\n\t\t\t});\n\t\t});\n\n\t\t// if we don't do this, rejections will be unhandled\n\t\tfor (const p of branch_promises) p.catch(() => {});\n\n\t\t/** @type {Array<import('./types').BranchNode | undefined>} */\n\t\tconst branch = [];\n\n\t\tfor (let i = 0; i < loaders.length; i += 1) {\n\t\t\tif (loaders[i]) {\n\t\t\t\ttry {\n\t\t\t\t\tbranch.push(await branch_promises[i]);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (err instanceof Redirect) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'redirect',\n\t\t\t\t\t\t\tlocation: err.location\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tlet status = 500;\n\t\t\t\t\t/** @type {App.Error} */\n\t\t\t\t\tlet error;\n\n\t\t\t\t\tif (server_data_nodes?.includes(/** @type {import('types').ServerErrorNode} */ (err))) {\n\t\t\t\t\t\t// this is the server error rethrown above, reconstruct but don't invoke\n\t\t\t\t\t\t// the client error handler; it should've already been handled on the server\n\t\t\t\t\t\tstatus = /** @type {import('types').ServerErrorNode} */ (err).status ?? status;\n\t\t\t\t\t\terror = /** @type {import('types').ServerErrorNode} */ (err).error;\n\t\t\t\t\t} else if (err instanceof HttpError) {\n\t\t\t\t\t\tstatus = err.status;\n\t\t\t\t\t\terror = err.body;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Referenced node could have been removed due to redeploy, check\n\t\t\t\t\t\tconst updated = await stores.updated.check();\n\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\treturn await native_navigation(url);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terror = await handle_error(err, { params, url, route: { id: route.id } });\n\t\t\t\t\t}\n\n\t\t\t\t\tconst error_load = await load_nearest_error_page(i, branch, errors);\n\t\t\t\t\tif (error_load) {\n\t\t\t\t\t\treturn await get_navigation_result_from_branch({\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\tbranch: branch.slice(0, error_load.idx).concat(error_load.node),\n\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\troute\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if we get here, it's because the root `load` function failed,\n\t\t\t\t\t\t// and we need to fall back to the server\n\t\t\t\t\t\treturn await server_fallback(url, { id: route.id }, error, status);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// push an empty slot so we can rewind past gaps to the\n\t\t\t\t// layout that corresponds with an +error.svelte page\n\t\t\t\tbranch.push(undefined);\n\t\t\t}\n\t\t}\n\n\t\treturn await get_navigation_result_from_branch({\n\t\t\turl,\n\t\t\tparams,\n\t\t\tbranch,\n\t\t\tstatus: 200,\n\t\t\terror: null,\n\t\t\troute,\n\t\t\t// Reset `form` on navigation, but not invalidation\n\t\t\tform: invalidating ? undefined : null\n\t\t});\n\t}\n\n\t/**\n\t * @param {number} i Start index to backtrack from\n\t * @param {Array<import('./types').BranchNode | undefined>} branch Branch to backtrack\n\t * @param {Array<import('types').CSRPageNodeLoader | undefined>} errors All error pages for this branch\n\t * @returns {Promise<{idx: number; node: import('./types').BranchNode} | undefined>}\n\t */\n\tasync function load_nearest_error_page(i, branch, errors) {\n\t\twhile (i--) {\n\t\t\tif (errors[i]) {\n\t\t\t\tlet j = i;\n\t\t\t\twhile (!branch[j]) j -= 1;\n\t\t\t\ttry {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tidx: j + 1,\n\t\t\t\t\t\tnode: {\n\t\t\t\t\t\t\tnode: await /** @type {import('types').CSRPageNodeLoader } */ (errors[i])(),\n\t\t\t\t\t\t\tloader: /** @type {import('types').CSRPageNodeLoader } */ (errors[i]),\n\t\t\t\t\t\t\tdata: {},\n\t\t\t\t\t\t\tserver: null,\n\t\t\t\t\t\t\tuniversal: null\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {{\n\t *   status: number;\n\t *   error: App.Error;\n\t *   url: URL;\n\t *   route: { id: string | null }\n\t * }} opts\n\t * @returns {Promise<import('./types').NavigationFinished>}\n\t */\n\tasync function load_root_error_page({ status, error, url, route }) {\n\t\t/** @type {Record<string, string>} */\n\t\tconst params = {}; // error page does not have params\n\n\t\t/** @type {import('types').ServerDataNode | null} */\n\t\tlet server_data_node = null;\n\n\t\tconst default_layout_has_server_load = app.server_loads[0] === 0;\n\n\t\tif (default_layout_has_server_load) {\n\t\t\t// TODO post-https://github.com/sveltejs/kit/discussions/6124 we can use\n\t\t\t// existing root layout data\n\t\t\ttry {\n\t\t\t\tconst server_data = await load_data(url, [true]);\n\n\t\t\t\tif (\n\t\t\t\t\tserver_data.type !== 'data' ||\n\t\t\t\t\t(server_data.nodes[0] && server_data.nodes[0].type !== 'data')\n\t\t\t\t) {\n\t\t\t\t\tthrow 0;\n\t\t\t\t}\n\n\t\t\t\tserver_data_node = server_data.nodes[0] ?? null;\n\t\t\t} catch {\n\t\t\t\t// at this point we have no choice but to fall back to the server, if it wouldn't\n\t\t\t\t// bring us right back here, turning this into an endless loop\n\t\t\t\tif (url.origin !== location.origin || url.pathname !== location.pathname || hydrated) {\n\t\t\t\t\tawait native_navigation(url);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst root_layout = await load_node({\n\t\t\tloader: default_layout_loader,\n\t\t\turl,\n\t\t\tparams,\n\t\t\troute,\n\t\t\tparent: () => Promise.resolve({}),\n\t\t\tserver_data_node: create_data_node(server_data_node)\n\t\t});\n\n\t\t/** @type {import('./types').BranchNode} */\n\t\tconst root_error = {\n\t\t\tnode: await default_error_loader(),\n\t\t\tloader: default_error_loader,\n\t\t\tuniversal: null,\n\t\t\tserver: null,\n\t\t\tdata: null\n\t\t};\n\n\t\treturn await get_navigation_result_from_branch({\n\t\t\turl,\n\t\t\tparams,\n\t\t\tbranch: [root_layout, root_error],\n\t\t\tstatus,\n\t\t\terror,\n\t\t\troute: null\n\t\t});\n\t}\n\n\t/**\n\t * @param {URL} url\n\t * @param {boolean} invalidating\n\t */\n\tfunction get_navigation_intent(url, invalidating) {\n\t\tif (is_external_url(url, base)) return;\n\n\t\tconst path = get_url_path(url);\n\n\t\tfor (const route of routes) {\n\t\t\tconst params = route.exec(path);\n\n\t\t\tif (params) {\n\t\t\t\tconst id = url.pathname + url.search;\n\t\t\t\t/** @type {import('./types').NavigationIntent} */\n\t\t\t\tconst intent = { id, invalidating, route, params: decode_params(params), url };\n\t\t\t\treturn intent;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @param {URL} url */\n\tfunction get_url_path(url) {\n\t\treturn decode_pathname(url.pathname.slice(base.length) || '/');\n\t}\n\n\t/**\n\t * @param {{\n\t *   url: URL;\n\t *   type: import('types').NavigationType;\n\t *   intent?: import('./types').NavigationIntent;\n\t *   delta?: number;\n\t * }} opts\n\t */\n\tfunction before_navigate({ url, type, intent, delta }) {\n\t\tlet should_block = false;\n\n\t\t/** @type {import('types').Navigation} */\n\t\tconst navigation = {\n\t\t\tfrom: {\n\t\t\t\tparams: current.params,\n\t\t\t\troute: { id: current.route?.id ?? null },\n\t\t\t\turl: current.url\n\t\t\t},\n\t\t\tto: {\n\t\t\t\tparams: intent?.params ?? null,\n\t\t\t\troute: { id: intent?.route?.id ?? null },\n\t\t\t\turl\n\t\t\t},\n\t\t\twillUnload: !intent,\n\t\t\ttype\n\t\t};\n\n\t\tif (delta !== undefined) {\n\t\t\tnavigation.delta = delta;\n\t\t}\n\n\t\tconst cancellable = {\n\t\t\t...navigation,\n\t\t\tcancel: () => {\n\t\t\t\tshould_block = true;\n\t\t\t}\n\t\t};\n\n\t\tif (!navigating) {\n\t\t\t// Don't run the event during redirects\n\t\t\tcallbacks.before_navigate.forEach((fn) => fn(cancellable));\n\t\t}\n\n\t\treturn should_block ? null : navigation;\n\t}\n\n\t/**\n\t * @param {{\n\t *   url: URL;\n\t *   scroll: { x: number, y: number } | null;\n\t *   keepfocus: boolean;\n\t *   redirect_chain: string[];\n\t *   details: {\n\t *     replaceState: boolean;\n\t *     state: any;\n\t *   } | null;\n\t *   type: import('types').NavigationType;\n\t *   delta?: number;\n\t *   nav_token?: {};\n\t *   accepted: () => void;\n\t *   blocked: () => void;\n\t * }} opts\n\t */\n\tasync function navigate({\n\t\turl,\n\t\tscroll,\n\t\tkeepfocus,\n\t\tredirect_chain,\n\t\tdetails,\n\t\ttype,\n\t\tdelta,\n\t\tnav_token,\n\t\taccepted,\n\t\tblocked\n\t}) {\n\t\tconst intent = get_navigation_intent(url, false);\n\t\tconst navigation = before_navigate({ url, type, delta, intent });\n\n\t\tif (!navigation) {\n\t\t\tblocked();\n\t\t\treturn;\n\t\t}\n\n\t\t// store this before calling `accepted()`, which may change the index\n\t\tconst previous_history_index = current_history_index;\n\n\t\taccepted();\n\n\t\tnavigating = true;\n\n\t\tif (started) {\n\t\t\tstores.navigating.set(navigation);\n\t\t}\n\n\t\tawait update(\n\t\t\tintent,\n\t\t\turl,\n\t\t\tredirect_chain,\n\t\t\tprevious_history_index,\n\t\t\t{\n\t\t\t\tscroll,\n\t\t\t\tkeepfocus,\n\t\t\t\tdetails\n\t\t\t},\n\t\t\tnav_token,\n\t\t\t() => {\n\t\t\t\tnavigating = false;\n\t\t\t\tcallbacks.after_navigate.forEach((fn) =>\n\t\t\t\t\tfn(/** @type {import('types').AfterNavigate} */ (navigation))\n\t\t\t\t);\n\t\t\t\tstores.navigating.set(null);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Does a full page reload if it wouldn't result in an endless loop in the SPA case\n\t * @param {URL} url\n\t * @param {{ id: string | null }} route\n\t * @param {App.Error} error\n\t * @param {number} status\n\t * @returns {Promise<import('./types').NavigationFinished>}\n\t */\n\tasync function server_fallback(url, route, error, status) {\n\t\tif (url.origin === location.origin && url.pathname === location.pathname && !hydrated) {\n\t\t\t// We would reload the same page we're currently on, which isn't hydrated,\n\t\t\t// which means no SSR, which means we would end up in an endless loop\n\t\t\treturn await load_root_error_page({\n\t\t\t\tstatus,\n\t\t\t\terror,\n\t\t\t\turl,\n\t\t\t\troute\n\t\t\t});\n\t\t}\n\t\treturn await native_navigation(url);\n\t}\n\n\t/**\n\t * Loads `href` the old-fashioned way, with a full page reload.\n\t * Returns a `Promise` that never resolves (to prevent any\n\t * subsequent work, e.g. history manipulation, from happening)\n\t * @param {URL} url\n\t */\n\tfunction native_navigation(url) {\n\t\tlocation.href = url.href;\n\t\treturn new Promise(() => {});\n\t}\n\n\tif (import.meta.hot) {\n\t\timport.meta.hot.on('vite:beforeUpdate', () => {\n\t\t\tif (current.error) location.reload();\n\t\t});\n\t}\n\n\tfunction setup_preload() {\n\t\t/** @type {NodeJS.Timeout} */\n\t\tlet mousemove_timeout;\n\n\t\tcontainer.addEventListener('mousemove', (event) => {\n\t\t\tconst target = /** @type {Element} */ (event.target);\n\n\t\t\tclearTimeout(mousemove_timeout);\n\t\t\tmousemove_timeout = setTimeout(() => {\n\t\t\t\tpreload(target, 2);\n\t\t\t}, 20);\n\t\t});\n\n\t\t/** @param {Event} event */\n\t\tfunction tap(event) {\n\t\t\tpreload(/** @type {Element} */ (event.composedPath()[0]), 1);\n\t\t}\n\n\t\tcontainer.addEventListener('mousedown', tap);\n\t\tcontainer.addEventListener('touchstart', tap, { passive: true });\n\n\t\tconst observer = new IntersectionObserver(\n\t\t\t(entries) => {\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tif (entry.isIntersecting) {\n\t\t\t\t\t\tpreload_code(\n\t\t\t\t\t\t\tget_url_path(new URL(/** @type {HTMLAnchorElement} */ (entry.target).href))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tobserver.unobserve(entry.target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ threshold: 0 }\n\t\t);\n\n\t\t/**\n\t\t * @param {Element} element\n\t\t * @param {number} priority\n\t\t */\n\t\tfunction preload(element, priority) {\n\t\t\tconst a = find_anchor(element, container);\n\t\t\tif (!a) return;\n\n\t\t\tconst { url, external } = get_link_info(a, base);\n\t\t\tif (external) return;\n\n\t\t\tconst options = get_router_options(a);\n\n\t\t\tif (!options.reload) {\n\t\t\t\tif (priority <= options.preload_data) {\n\t\t\t\t\tconst intent = get_navigation_intent(/** @type {URL} */ (url), false);\n\t\t\t\t\tif (intent) {\n\t\t\t\t\t\tif (__SVELTEKIT_DEV__) {\n\t\t\t\t\t\t\tpreload_data(intent).then((result) => {\n\t\t\t\t\t\t\t\tif (result.type === 'loaded' && result.state.error) {\n\t\t\t\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\t\t\t`Preloading data for ${intent.url.pathname} failed with the following error: ${result.state.error.message}\\n` +\n\t\t\t\t\t\t\t\t\t\t\t'If this error is transient, you can ignore it. Otherwise, consider disabling preloading for this route. ' +\n\t\t\t\t\t\t\t\t\t\t\t'This route was preloaded due to a data-sveltekit-preload-data attribute. ' +\n\t\t\t\t\t\t\t\t\t\t\t'See https://kit.svelte.dev/docs/link-options for more info'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpreload_data(intent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (priority <= options.preload_code) {\n\t\t\t\t\tpreload_code(get_url_path(/** @type {URL} */ (url)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction after_navigate() {\n\t\t\tobserver.disconnect();\n\n\t\t\tfor (const a of container.querySelectorAll('a')) {\n\t\t\t\tconst { url, external } = get_link_info(a, base);\n\t\t\t\tif (external) continue;\n\n\t\t\t\tconst options = get_router_options(a);\n\t\t\t\tif (options.reload) continue;\n\n\t\t\t\tif (options.preload_code === PRELOAD_PRIORITIES.viewport) {\n\t\t\t\t\tobserver.observe(a);\n\t\t\t\t}\n\n\t\t\t\tif (options.preload_code === PRELOAD_PRIORITIES.eager) {\n\t\t\t\t\tpreload_code(get_url_path(/** @type {URL} */ (url)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcallbacks.after_navigate.push(after_navigate);\n\t\tafter_navigate();\n\t}\n\n\t/**\n\t * @param {unknown} error\n\t * @param {import('types').NavigationEvent} event\n\t * @returns {import('types').MaybePromise<App.Error>}\n\t */\n\tfunction handle_error(error, event) {\n\t\tif (error instanceof HttpError) {\n\t\t\treturn error.body;\n\t\t}\n\t\treturn (\n\t\t\tapp.hooks.handleError({ error, event }) ??\n\t\t\t/** @type {any} */ ({ message: event.route.id != null ? 'Internal Error' : 'Not Found' })\n\t\t);\n\t}\n\n\treturn {\n\t\tafter_navigate: (fn) => {\n\t\t\tonMount(() => {\n\t\t\t\tcallbacks.after_navigate.push(fn);\n\n\t\t\t\treturn () => {\n\t\t\t\t\tconst i = callbacks.after_navigate.indexOf(fn);\n\t\t\t\t\tcallbacks.after_navigate.splice(i, 1);\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\n\t\tbefore_navigate: (fn) => {\n\t\t\tonMount(() => {\n\t\t\t\tcallbacks.before_navigate.push(fn);\n\n\t\t\t\treturn () => {\n\t\t\t\t\tconst i = callbacks.before_navigate.indexOf(fn);\n\t\t\t\t\tcallbacks.before_navigate.splice(i, 1);\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\n\t\tdisable_scroll_handling: () => {\n\t\t\tif (DEV && started && !updating) {\n\t\t\t\tthrow new Error('Can only disable scroll handling during navigation');\n\t\t\t}\n\n\t\t\tif (updating || !started) {\n\t\t\t\tautoscroll = false;\n\t\t\t}\n\t\t},\n\n\t\tgoto: (href, opts = {}) => {\n\t\t\treturn goto(href, opts, []);\n\t\t},\n\n\t\tinvalidate: (resource) => {\n\t\t\tif (typeof resource === 'function') {\n\t\t\t\tinvalidated.push(resource);\n\t\t\t} else {\n\t\t\t\tconst { href } = new URL(resource, location.href);\n\t\t\t\tinvalidated.push((url) => url.href === href);\n\t\t\t}\n\n\t\t\treturn invalidate();\n\t\t},\n\n\t\tinvalidateAll: () => {\n\t\t\tforce_invalidation = true;\n\t\t\treturn invalidate();\n\t\t},\n\n\t\tpreload_data: async (href) => {\n\t\t\tconst url = new URL(href, get_base_uri(document));\n\t\t\tconst intent = get_navigation_intent(url, false);\n\n\t\t\tif (!intent) {\n\t\t\t\tthrow new Error(`Attempted to preload a URL that does not belong to this app: ${url}`);\n\t\t\t}\n\n\t\t\tawait preload_data(intent);\n\t\t},\n\n\t\tpreload_code,\n\n\t\tapply_action: async (result) => {\n\t\t\tif (result.type === 'error') {\n\t\t\t\tconst url = new URL(location.href);\n\n\t\t\t\tconst { branch, route } = current;\n\t\t\t\tif (!route) return;\n\n\t\t\t\tconst error_load = await load_nearest_error_page(\n\t\t\t\t\tcurrent.branch.length,\n\t\t\t\t\tbranch,\n\t\t\t\t\troute.errors\n\t\t\t\t);\n\t\t\t\tif (error_load) {\n\t\t\t\t\tconst navigation_result = await get_navigation_result_from_branch({\n\t\t\t\t\t\turl,\n\t\t\t\t\t\tparams: current.params,\n\t\t\t\t\t\tbranch: branch.slice(0, error_load.idx).concat(error_load.node),\n\t\t\t\t\t\tstatus: result.status ?? 500,\n\t\t\t\t\t\terror: result.error,\n\t\t\t\t\t\troute\n\t\t\t\t\t});\n\n\t\t\t\t\tcurrent = navigation_result.state;\n\n\t\t\t\t\troot.$set(navigation_result.props);\n\n\t\t\t\t\ttick().then(reset_focus);\n\t\t\t\t}\n\t\t\t} else if (result.type === 'redirect') {\n\t\t\t\tgoto(result.location, { invalidateAll: true }, []);\n\t\t\t} else {\n\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\troot.$set({\n\t\t\t\t\t// this brings Svelte's view of the world in line with SvelteKit's\n\t\t\t\t\t// after use:enhance reset the form....\n\t\t\t\t\tform: null,\n\t\t\t\t\tpage: { ...page, form: result.data, status: result.status }\n\t\t\t\t});\n\n\t\t\t\t// ...so that setting the `form` prop takes effect and isn't ignored\n\t\t\t\tawait tick();\n\t\t\t\troot.$set({ form: result.data });\n\n\t\t\t\tif (result.type === 'success') {\n\t\t\t\t\treset_focus();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_start_router: () => {\n\t\t\thistory.scrollRestoration = 'manual';\n\n\t\t\t// Adopted from Nuxt.js\n\t\t\t// Reset scrollRestoration to auto when leaving page, allowing page reload\n\t\t\t// and back-navigation from other pages to use the browser to restore the\n\t\t\t// scrolling position.\n\t\t\taddEventListener('beforeunload', (e) => {\n\t\t\t\tlet should_block = false;\n\n\t\t\t\tif (!navigating) {\n\t\t\t\t\t// If we're navigating, beforeNavigate was already called. If we end up in here during navigation,\n\t\t\t\t\t// it's due to an external or full-page-reload link, for which we don't want to call the hook again.\n\t\t\t\t\t/** @type {import('types').BeforeNavigate} */\n\t\t\t\t\tconst navigation = {\n\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\tparams: current.params,\n\t\t\t\t\t\t\troute: { id: current.route?.id ?? null },\n\t\t\t\t\t\t\turl: current.url\n\t\t\t\t\t\t},\n\t\t\t\t\t\tto: null,\n\t\t\t\t\t\twillUnload: true,\n\t\t\t\t\t\ttype: 'leave',\n\t\t\t\t\t\tcancel: () => (should_block = true)\n\t\t\t\t\t};\n\n\t\t\t\t\tcallbacks.before_navigate.forEach((fn) => fn(navigation));\n\t\t\t\t}\n\n\t\t\t\tif (should_block) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\te.returnValue = '';\n\t\t\t\t} else {\n\t\t\t\t\thistory.scrollRestoration = 'auto';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\taddEventListener('visibilitychange', () => {\n\t\t\t\tif (document.visibilityState === 'hidden') {\n\t\t\t\t\tupdate_scroll_positions(current_history_index);\n\t\t\t\t\tstorage.set(SCROLL_KEY, scroll_positions);\n\n\t\t\t\t\tcapture_snapshot(current_history_index);\n\t\t\t\t\tstorage.set(SNAPSHOT_KEY, snapshots);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// @ts-expect-error this isn't supported everywhere yet\n\t\t\tif (!navigator.connection?.saveData) {\n\t\t\t\tsetup_preload();\n\t\t\t}\n\n\t\t\t/** @param {MouseEvent} event */\n\t\t\tcontainer.addEventListener('click', (event) => {\n\t\t\t\t// Adapted from https://github.com/visionmedia/page.js\n\t\t\t\t// MIT license https://github.com/visionmedia/page.js#license\n\t\t\t\tif (event.button || event.which !== 1) return;\n\t\t\t\tif (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;\n\t\t\t\tif (event.defaultPrevented) return;\n\n\t\t\t\tconst a = find_anchor(/** @type {Element} */ (event.composedPath()[0]), container);\n\t\t\t\tif (!a) return;\n\n\t\t\t\tconst { url, external, target } = get_link_info(a, base);\n\t\t\t\tif (!url) return;\n\n\t\t\t\t// bail out before `beforeNavigate` if link opens in a different tab\n\t\t\t\tif (target === '_parent' || target === '_top') {\n\t\t\t\t\tif (window.parent !== window) return;\n\t\t\t\t} else if (target && target !== '_self') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst options = get_router_options(a);\n\t\t\t\tconst is_svg_a_element = a instanceof SVGAElement;\n\n\t\t\t\t// Ignore URL protocols that differ to the current one and are not http(s) (e.g. `mailto:`, `tel:`, `myapp:`, etc.)\n\t\t\t\t// This may be wrong when the protocol is x: and the link goes to y:.. which should be treated as an external\n\t\t\t\t// navigation, but it's not clear how to handle that case and it's not likely to come up in practice.\n\t\t\t\t// MEMO: Without this condition, firefox will open mailer twice.\n\t\t\t\t// See:\n\t\t\t\t// - https://github.com/sveltejs/kit/issues/4045\n\t\t\t\t// - https://github.com/sveltejs/kit/issues/5725\n\t\t\t\t// - https://github.com/sveltejs/kit/issues/6496\n\t\t\t\tif (\n\t\t\t\t\t!is_svg_a_element &&\n\t\t\t\t\turl.protocol !== location.protocol &&\n\t\t\t\t\t!(url.protocol === 'https:' || url.protocol === 'http:')\n\t\t\t\t)\n\t\t\t\t\treturn;\n\n\t\t\t\t// Ignore the following but fire beforeNavigate\n\t\t\t\tif (external || options.reload) {\n\t\t\t\t\tconst navigation = before_navigate({ url, type: 'link' });\n\t\t\t\t\tif (!navigation) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\tnavigating = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check if new url only differs by hash and use the browser default behavior in that case\n\t\t\t\t// This will ensure the `hashchange` event is fired\n\t\t\t\t// Removing the hash does a full page navigation in the browser, so make sure a hash is present\n\t\t\t\tconst [nonhash, hash] = url.href.split('#');\n\t\t\t\tif (hash !== undefined && nonhash === location.href.split('#')[0]) {\n\t\t\t\t\t// set this flag to distinguish between navigations triggered by\n\t\t\t\t\t// clicking a hash link and those triggered by popstate\n\t\t\t\t\t// TODO why not update history here directly?\n\t\t\t\t\thash_navigating = true;\n\n\t\t\t\t\tupdate_scroll_positions(current_history_index);\n\n\t\t\t\t\tcurrent.url = url;\n\t\t\t\t\tstores.page.set({ ...page, url });\n\t\t\t\t\tstores.page.notify();\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tnavigate({\n\t\t\t\t\turl,\n\t\t\t\t\tscroll: options.noscroll ? scroll_state() : null,\n\t\t\t\t\tkeepfocus: false,\n\t\t\t\t\tredirect_chain: [],\n\t\t\t\t\tdetails: {\n\t\t\t\t\t\tstate: {},\n\t\t\t\t\t\treplaceState: url.href === location.href\n\t\t\t\t\t},\n\t\t\t\t\taccepted: () => event.preventDefault(),\n\t\t\t\t\tblocked: () => event.preventDefault(),\n\t\t\t\t\ttype: 'link'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tcontainer.addEventListener('submit', (event) => {\n\t\t\t\tif (event.defaultPrevented) return;\n\n\t\t\t\tconst form = /** @type {HTMLFormElement} */ (\n\t\t\t\t\tHTMLFormElement.prototype.cloneNode.call(event.target)\n\t\t\t\t);\n\n\t\t\t\tconst submitter = /** @type {HTMLButtonElement | HTMLInputElement | null} */ (\n\t\t\t\t\tevent.submitter\n\t\t\t\t);\n\n\t\t\t\tconst method = submitter?.formMethod || form.method;\n\n\t\t\t\tif (method !== 'get') return;\n\n\t\t\t\tconst url = new URL(\n\t\t\t\t\t(submitter?.hasAttribute('formaction') && submitter?.formAction) || form.action\n\t\t\t\t);\n\n\t\t\t\tif (is_external_url(url, base)) return;\n\n\t\t\t\tconst event_form = /** @type {HTMLFormElement} */ (event.target);\n\n\t\t\t\tconst { noscroll, reload } = get_router_options(event_form);\n\t\t\t\tif (reload) return;\n\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\tconst data = new FormData(event_form);\n\n\t\t\t\tconst submitter_name = submitter?.getAttribute('name');\n\t\t\t\tif (submitter_name) {\n\t\t\t\t\tdata.append(submitter_name, submitter?.getAttribute('value') ?? '');\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error `URLSearchParams(fd)` is kosher, but typescript doesn't know that\n\t\t\t\turl.search = new URLSearchParams(data).toString();\n\n\t\t\t\tnavigate({\n\t\t\t\t\turl,\n\t\t\t\t\tscroll: noscroll ? scroll_state() : null,\n\t\t\t\t\tkeepfocus: false,\n\t\t\t\t\tredirect_chain: [],\n\t\t\t\t\tdetails: {\n\t\t\t\t\t\tstate: {},\n\t\t\t\t\t\treplaceState: false\n\t\t\t\t\t},\n\t\t\t\t\tnav_token: {},\n\t\t\t\t\taccepted: () => {},\n\t\t\t\t\tblocked: () => {},\n\t\t\t\t\ttype: 'form'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\taddEventListener('popstate', async (event) => {\n\t\t\t\tif (event.state?.[INDEX_KEY]) {\n\t\t\t\t\t// if a popstate-driven navigation is cancelled, we need to counteract it\n\t\t\t\t\t// with history.go, which means we end up back here, hence this check\n\t\t\t\t\tif (event.state[INDEX_KEY] === current_history_index) return;\n\n\t\t\t\t\tconst scroll = scroll_positions[event.state[INDEX_KEY]];\n\n\t\t\t\t\t// if the only change is the hash, we don't need to do anything...\n\t\t\t\t\tif (current.url.href.split('#')[0] === location.href.split('#')[0]) {\n\t\t\t\t\t\t// ...except handle scroll\n\t\t\t\t\t\tscroll_positions[current_history_index] = scroll_state();\n\t\t\t\t\t\tcurrent_history_index = event.state[INDEX_KEY];\n\t\t\t\t\t\tscrollTo(scroll.x, scroll.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst delta = event.state[INDEX_KEY] - current_history_index;\n\t\t\t\t\tlet blocked = false;\n\n\t\t\t\t\tawait navigate({\n\t\t\t\t\t\turl: new URL(location.href),\n\t\t\t\t\t\tscroll,\n\t\t\t\t\t\tkeepfocus: false,\n\t\t\t\t\t\tredirect_chain: [],\n\t\t\t\t\t\tdetails: null,\n\t\t\t\t\t\taccepted: () => {\n\t\t\t\t\t\t\tcurrent_history_index = event.state[INDEX_KEY];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tblocked: () => {\n\t\t\t\t\t\t\thistory.go(-delta);\n\t\t\t\t\t\t\tblocked = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttype: 'popstate',\n\t\t\t\t\t\tdelta\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!blocked) {\n\t\t\t\t\t\trestore_snapshot(current_history_index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\taddEventListener('hashchange', () => {\n\t\t\t\t// if the hashchange happened as a result of clicking on a link,\n\t\t\t\t// we need to update history, otherwise we have to leave it alone\n\t\t\t\tif (hash_navigating) {\n\t\t\t\t\thash_navigating = false;\n\t\t\t\t\thistory.replaceState(\n\t\t\t\t\t\t{ ...history.state, [INDEX_KEY]: ++current_history_index },\n\t\t\t\t\t\t'',\n\t\t\t\t\t\tlocation.href\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// fix link[rel=icon], because browsers will occasionally try to load relative\n\t\t\t// URLs after a pushState/replaceState, resulting in a 404 — see\n\t\t\t// https://github.com/sveltejs/kit/issues/3748#issuecomment-1125980897\n\t\t\tfor (const link of document.querySelectorAll('link')) {\n\t\t\t\tif (link.rel === 'icon') link.href = link.href;\n\t\t\t}\n\n\t\t\taddEventListener('pageshow', (event) => {\n\t\t\t\t// If the user navigates to another site and then uses the back button and\n\t\t\t\t// bfcache hits, we need to set navigating to null, the site doesn't know\n\t\t\t\t// the navigation away from it was successful.\n\t\t\t\t// Info about bfcache here: https://web.dev/bfcache\n\t\t\t\tif (event.persisted) {\n\t\t\t\t\tstores.navigating.set(null);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_hydrate: async ({\n\t\t\tstatus = 200,\n\t\t\terror,\n\t\t\tnode_ids,\n\t\t\tparams,\n\t\t\troute,\n\t\t\tdata: server_data_nodes,\n\t\t\tform\n\t\t}) => {\n\t\t\thydrated = true;\n\n\t\t\tconst url = new URL(location.href);\n\n\t\t\tif (!__SVELTEKIT_EMBEDDED__) {\n\t\t\t\t// See https://github.com/sveltejs/kit/pull/4935#issuecomment-1328093358 for one motivation\n\t\t\t\t// of determining the params on the client side.\n\t\t\t\t({ params = {}, route = { id: null } } = get_navigation_intent(url, false) || {});\n\t\t\t}\n\n\t\t\t/** @type {import('./types').NavigationFinished | undefined} */\n\t\t\tlet result;\n\n\t\t\ttry {\n\t\t\t\tconst branch_promises = node_ids.map(async (n, i) => {\n\t\t\t\t\tconst server_data_node = server_data_nodes[i];\n\t\t\t\t\t// Type isn't completely accurate, we still need to deserialize uses\n\t\t\t\t\tif (server_data_node?.uses) {\n\t\t\t\t\t\tserver_data_node.uses = deserialize_uses(server_data_node.uses);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn load_node({\n\t\t\t\t\t\tloader: app.nodes[n],\n\t\t\t\t\t\turl,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\troute,\n\t\t\t\t\t\tparent: async () => {\n\t\t\t\t\t\t\tconst data = {};\n\t\t\t\t\t\t\tfor (let j = 0; j < i; j += 1) {\n\t\t\t\t\t\t\t\tObject.assign(data, (await branch_promises[j]).data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tserver_data_node: create_data_node(server_data_node)\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tresult = await get_navigation_result_from_branch({\n\t\t\t\t\turl,\n\t\t\t\t\tparams,\n\t\t\t\t\tbranch: await Promise.all(branch_promises),\n\t\t\t\t\tstatus,\n\t\t\t\t\terror,\n\t\t\t\t\tform,\n\t\t\t\t\troute: routes.find(({ id }) => id === route.id) ?? null\n\t\t\t\t});\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Redirect) {\n\t\t\t\t\t// this is a real edge case — `load` would need to return\n\t\t\t\t\t// a redirect but only in the browser\n\t\t\t\t\tawait native_navigation(new URL(error.location, location.href));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult = await load_root_error_page({\n\t\t\t\t\tstatus: error instanceof HttpError ? error.status : 500,\n\t\t\t\t\terror: await handle_error(error, { url, params, route }),\n\t\t\t\t\turl,\n\t\t\t\t\troute\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tinitialize(result);\n\t\t}\n\t};\n}\n\n/**\n * @param {URL} url\n * @param {boolean[]} invalid\n * @returns {Promise<import('types').ServerNodesResponse |import('types').ServerRedirectNode>}\n */\nasync function load_data(url, invalid) {\n\tconst data_url = new URL(url);\n\tdata_url.pathname = add_data_suffix(url.pathname);\n\tif (DEV && url.searchParams.has('x-sveltekit-invalidated')) {\n\t\tthrow new Error('Cannot used reserved query parameter \"x-sveltekit-invalidated\"');\n\t}\n\tdata_url.searchParams.append(\n\t\t'x-sveltekit-invalidated',\n\t\tinvalid.map((x) => (x ? '1' : '')).join('_')\n\t);\n\n\tconst res = await native_fetch(data_url.href);\n\n\tif (!res.ok) {\n\t\t// error message is a JSON-stringified string which devalue can't handle at the top level\n\t\t// turn it into a HttpError to not call handleError on the client again (was already handled on the server)\n\t\tthrow new HttpError(res.status, await res.json());\n\t}\n\n\treturn new Promise(async (resolve) => {\n\t\t/**\n\t\t * Map of deferred promises that will be resolved by a subsequent chunk of data\n\t\t * @type {Map<string, import('types').Deferred>}\n\t\t */\n\t\tconst deferreds = new Map();\n\t\tconst reader = /** @type {ReadableStream<Uint8Array>} */ (res.body).getReader();\n\t\tconst decoder = new TextDecoder();\n\n\t\t/**\n\t\t * @param {any} data\n\t\t */\n\t\tfunction deserialize(data) {\n\t\t\treturn devalue.unflatten(data, {\n\t\t\t\tPromise: (id) => {\n\t\t\t\t\treturn new Promise((fulfil, reject) => {\n\t\t\t\t\t\tdeferreds.set(id, { fulfil, reject });\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet text = '';\n\n\t\twhile (true) {\n\t\t\t// Format follows ndjson (each line is a JSON object) or regular JSON spec\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done && !text) break;\n\n\t\t\ttext += !value && text ? '\\n' : decoder.decode(value); // no value -> final chunk -> add a new line to trigger the last parse\n\n\t\t\twhile (true) {\n\t\t\t\tconst split = text.indexOf('\\n');\n\t\t\t\tif (split === -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tconst node = JSON.parse(text.slice(0, split));\n\t\t\t\ttext = text.slice(split + 1);\n\n\t\t\t\tif (node.type === 'redirect') {\n\t\t\t\t\treturn resolve(node);\n\t\t\t\t}\n\n\t\t\t\tif (node.type === 'data') {\n\t\t\t\t\t// This is the first (and possibly only, if no pending promises) chunk\n\t\t\t\t\tnode.nodes?.forEach((/** @type {any} */ node) => {\n\t\t\t\t\t\tif (node?.type === 'data') {\n\t\t\t\t\t\t\tnode.uses = deserialize_uses(node.uses);\n\t\t\t\t\t\t\tnode.data = deserialize(node.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tresolve(node);\n\t\t\t\t} else if (node.type === 'chunk') {\n\t\t\t\t\t// This is a subsequent chunk containing deferred data\n\t\t\t\t\tconst { id, data, error } = node;\n\t\t\t\t\tconst deferred = /** @type {import('types').Deferred} */ (deferreds.get(id));\n\t\t\t\t\tdeferreds.delete(id);\n\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tdeferred.reject(deserialize(error));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdeferred.fulfil(deserialize(data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// TODO edge case handling necessary? stream() read fails?\n}\n\n/**\n * @param {any} uses\n * @return {import('types').Uses}\n */\nfunction deserialize_uses(uses) {\n\treturn {\n\t\tdependencies: new Set(uses?.dependencies ?? []),\n\t\tparams: new Set(uses?.params ?? []),\n\t\tparent: !!uses?.parent,\n\t\troute: !!uses?.route,\n\t\turl: !!uses?.url\n\t};\n}\n\nfunction reset_focus() {\n\tconst autofocus = document.querySelector('[autofocus]');\n\tif (autofocus) {\n\t\t// @ts-ignore\n\t\tautofocus.focus();\n\t} else {\n\t\t// Reset page selection and focus\n\t\t// We try to mimic browsers' behaviour as closely as possible by targeting the\n\t\t// first scrollable region, but unfortunately it's not a perfect match — e.g.\n\t\t// shift-tabbing won't immediately cycle up from the end of the page on Chromium\n\t\t// See https://html.spec.whatwg.org/multipage/interaction.html#get-the-focusable-area\n\t\tconst root = document.body;\n\t\tconst tabindex = root.getAttribute('tabindex');\n\n\t\troot.tabIndex = -1;\n\t\troot.focus({ preventScroll: true });\n\n\t\t// restore `tabindex` as to prevent `root` from stealing input from elements\n\t\tif (tabindex !== null) {\n\t\t\troot.setAttribute('tabindex', tabindex);\n\t\t} else {\n\t\t\troot.removeAttribute('tabindex');\n\t\t}\n\n\t\treturn new Promise((resolve) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\t// fixes https://github.com/sveltejs/kit/issues/8439\n\t\t\t\tresolve(getSelection()?.removeAllRanges());\n\t\t\t});\n\t\t});\n\t}\n}\n\nif (DEV) {\n\t// Nasty hack to silence harmless warnings the user can do nothing about\n\tconst console_warn = console.warn;\n\tconsole.warn = function warn(...args) {\n\t\tif (\n\t\t\targs.length === 1 &&\n\t\t\t/<(Layout|Page|Error)(_[\\w$]+)?> was created (with unknown|without expected) prop '(data|form)'/.test(\n\t\t\t\targs[0]\n\t\t\t)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tconsole_warn(...args);\n\t};\n}\n"}},"constants.js":{"file":{"contents":"export const SNAPSHOT_KEY = 'sveltekit:snapshot';\nexport const SCROLL_KEY = 'sveltekit:scroll';\nexport const INDEX_KEY = 'sveltekit:index';\n\nexport const PRELOAD_PRIORITIES = /** @type {const} */ ({\n\ttap: 1,\n\thover: 2,\n\tviewport: 3,\n\teager: 4,\n\toff: -1\n});\n"}},"fetcher.js":{"file":{"contents":"import { DEV } from 'esm-env';\nimport { hash } from '../hash.js';\n\nlet loading = 0;\n\nexport const native_fetch = window.fetch;\n\nexport function lock_fetch() {\n\tloading += 1;\n}\n\nexport function unlock_fetch() {\n\tloading -= 1;\n}\n\nif (DEV) {\n\tlet can_inspect_stack_trace = false;\n\n\tconst check_stack_trace = async () => {\n\t\tconst stack = /** @type {string} */ (new Error().stack);\n\t\tcan_inspect_stack_trace = stack.includes('check_stack_trace');\n\t};\n\n\tcheck_stack_trace();\n\n\twindow.fetch = (input, init) => {\n\t\t// Check if fetch was called via load_node. the lock method only checks if it was called at the\n\t\t// same time, but not necessarily if it was called from `load`.\n\t\t// We use just the filename as the method name sometimes does not appear on the CI.\n\t\tconst url = input instanceof Request ? input.url : input.toString();\n\t\tconst stack_array = /** @type {string} */ (new Error().stack).split('\\n');\n\t\t// We need to do some Firefox-specific cutoff because it (impressively) maintains the stack\n\t\t// across events and for example traces a `fetch` call triggered from a button back\n\t\t// to the creation of the event listener and the element creation itself,\n\t\t// where at some point client.js will show up, leading to false positives.\n\t\tconst firefox_cutoff = stack_array.findIndex((a) => a.includes('*listen@'));\n\t\tconst stack = stack_array\n\t\t\t.slice(0, firefox_cutoff !== -1 ? firefox_cutoff : undefined)\n\t\t\t.join('\\n');\n\n\t\tconst heuristic = can_inspect_stack_trace\n\t\t\t? stack.includes('src/runtime/client/client.js')\n\t\t\t: loading;\n\t\tif (heuristic) {\n\t\t\tconsole.warn(\n\t\t\t\t`Loading ${url} using \\`window.fetch\\`. For best results, use the \\`fetch\\` that is passed to your \\`load\\` function: https://kit.svelte.dev/docs/load#making-fetch-requests`\n\t\t\t);\n\t\t}\n\n\t\tconst method = input instanceof Request ? input.method : init?.method || 'GET';\n\n\t\tif (method !== 'GET') {\n\t\t\tcache.delete(build_selector(input));\n\t\t}\n\n\t\treturn native_fetch(input, init);\n\t};\n} else {\n\twindow.fetch = (input, init) => {\n\t\tconst method = input instanceof Request ? input.method : init?.method || 'GET';\n\n\t\tif (method !== 'GET') {\n\t\t\tcache.delete(build_selector(input));\n\t\t}\n\n\t\treturn native_fetch(input, init);\n\t};\n}\n\nconst cache = new Map();\n\n/**\n * Should be called on the initial run of load functions that hydrate the page.\n * Saves any requests with cache-control max-age to the cache.\n * @param {URL | string} resource\n * @param {RequestInit} [opts]\n */\nexport function initial_fetch(resource, opts) {\n\tconst selector = build_selector(resource, opts);\n\n\tconst script = document.querySelector(selector);\n\tif (script?.textContent) {\n\t\tconst { body, ...init } = JSON.parse(script.textContent);\n\n\t\tconst ttl = script.getAttribute('data-ttl');\n\t\tif (ttl) cache.set(selector, { body, init, ttl: 1000 * Number(ttl) });\n\n\t\treturn Promise.resolve(new Response(body, init));\n\t}\n\n\treturn native_fetch(resource, opts);\n}\n\n/**\n * Tries to get the response from the cache, if max-age allows it, else does a fetch.\n * @param {URL | string} resource\n * @param {string} resolved\n * @param {RequestInit} [opts]\n */\nexport function subsequent_fetch(resource, resolved, opts) {\n\tif (cache.size > 0) {\n\t\tconst selector = build_selector(resource, opts);\n\t\tconst cached = cache.get(selector);\n\t\tif (cached) {\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache#value\n\t\t\tif (\n\t\t\t\tperformance.now() < cached.ttl &&\n\t\t\t\t['default', 'force-cache', 'only-if-cached', undefined].includes(opts?.cache)\n\t\t\t) {\n\t\t\t\treturn new Response(cached.body, cached.init);\n\t\t\t}\n\n\t\t\tcache.delete(selector);\n\t\t}\n\t}\n\n\treturn native_fetch(resolved, opts);\n}\n\n/**\n * Build the cache key for a given request\n * @param {URL | RequestInfo} resource\n * @param {RequestInit} [opts]\n */\nfunction build_selector(resource, opts) {\n\tconst url = JSON.stringify(resource instanceof Request ? resource.url : resource);\n\n\tlet selector = `script[data-sveltekit-fetched][data-url=${url}]`;\n\n\tif (opts?.headers || opts?.body) {\n\t\t/** @type {import('types').StrictBody[]} */\n\t\tconst values = [];\n\n\t\tif (opts.headers) {\n\t\t\tvalues.push([...new Headers(opts.headers)].join(','));\n\t\t}\n\n\t\tif (opts.body && (typeof opts.body === 'string' || ArrayBuffer.isView(opts.body))) {\n\t\t\tvalues.push(opts.body);\n\t\t}\n\n\t\tselector += `[data-hash=\"${hash(...values)}\"]`;\n\t}\n\n\treturn selector;\n}\n"}},"parse.js":{"file":{"contents":"import { exec, parse_route_id } from '../../utils/routing.js';\n\n/**\n * @param {import('./types').SvelteKitApp} app\n * @returns {import('types').CSRRoute[]}\n */\nexport function parse({ nodes, server_loads, dictionary, matchers }) {\n\tconst layouts_with_server_load = new Set(server_loads);\n\n\treturn Object.entries(dictionary).map(([id, [leaf, layouts, errors]]) => {\n\t\tconst { pattern, params } = parse_route_id(id);\n\n\t\tconst route = {\n\t\t\tid,\n\t\t\t/** @param {string} path */\n\t\t\texec: (path) => {\n\t\t\t\tconst match = pattern.exec(path);\n\t\t\t\tif (match) return exec(match, params, matchers);\n\t\t\t},\n\t\t\terrors: [1, ...(errors || [])].map((n) => nodes[n]),\n\t\t\tlayouts: [0, ...(layouts || [])].map(create_layout_loader),\n\t\t\tleaf: create_leaf_loader(leaf)\n\t\t};\n\n\t\t// bit of a hack, but ensures that layout/error node lists are the same\n\t\t// length, without which the wrong data will be applied if the route\n\t\t// manifest looks like `[[a, b], [c,], d]`\n\t\troute.errors.length = route.layouts.length = Math.max(\n\t\t\troute.errors.length,\n\t\t\troute.layouts.length\n\t\t);\n\n\t\treturn route;\n\t});\n\n\t/**\n\t * @param {number} id\n\t * @returns {[boolean, import('types').CSRPageNodeLoader]}\n\t */\n\tfunction create_leaf_loader(id) {\n\t\t// whether or not the route uses the server data is\n\t\t// encoded using the ones' complement, to save space\n\t\tconst uses_server_data = id < 0;\n\t\tif (uses_server_data) id = ~id;\n\t\treturn [uses_server_data, nodes[id]];\n\t}\n\n\t/**\n\t * @param {number | undefined} id\n\t * @returns {[boolean, import('types').CSRPageNodeLoader] | undefined}\n\t */\n\tfunction create_layout_loader(id) {\n\t\t// whether or not the layout uses the server data is\n\t\t// encoded in the layouts array, to save space\n\t\treturn id === undefined ? id : [layouts_with_server_load.has(id), nodes[id]];\n\t}\n}\n"}},"session-storage.js":{"file":{"contents":"/**\n * Read a value from `sessionStorage`\n * @param {string} key\n */\nexport function get(key) {\n\ttry {\n\t\treturn JSON.parse(sessionStorage[key]);\n\t} catch {\n\t\t// do nothing\n\t}\n}\n\n/**\n * Write a value to `sessionStorage`\n * @param {string} key\n * @param {any} value\n */\nexport function set(key, value) {\n\tconst json = JSON.stringify(value);\n\ttry {\n\t\tsessionStorage[key] = json;\n\t} catch {\n\t\t// do nothing\n\t}\n}\n"}},"singletons.js":{"file":{"contents":"import { writable } from 'svelte/store';\nimport { create_updated_store, notifiable_store } from './utils.js';\n\n/** @type {import('./types').Client} */\nexport let client;\n\n/**\n * @param {{\n *   client: import('./types').Client;\n * }} opts\n */\nexport function init(opts) {\n\tclient = opts.client;\n}\n\nexport const stores = {\n\turl: notifiable_store({}),\n\tpage: notifiable_store({}),\n\tnavigating: writable(/** @type {import('types').Navigation | null} */ (null)),\n\tupdated: create_updated_store()\n};\n"}},"start.js":{"file":{"contents":"import { DEV } from 'esm-env';\nimport { create_client } from './client.js';\nimport { init } from './singletons.js';\n\n/**\n * @param {import('./types').SvelteKitApp} app\n * @param {HTMLElement} target\n * @param {Parameters<import('./types').Client['_hydrate']>[0]} [hydrate]\n */\nexport async function start(app, target, hydrate) {\n\tif (DEV && target === document.body) {\n\t\tconsole.warn(\n\t\t\t`Placing %sveltekit.body% directly inside <body> is not recommended, as your app may break for users who have certain browser extensions installed.\\n\\nConsider wrapping it in an element:\\n\\n<div style=\"display: contents\">\\n  %sveltekit.body%\\n</div>`\n\t\t);\n\t}\n\n\tconst client = create_client(app, target);\n\n\tinit({ client });\n\n\tif (hydrate) {\n\t\tawait client._hydrate(hydrate);\n\t} else {\n\t\tclient.goto(location.href, { replaceState: true });\n\t}\n\n\tclient._start_router();\n}\n"}},"types.d.ts":{"file":{"contents":"import { applyAction } from '$app/forms';\nimport {\n\tafterNavigate,\n\tbeforeNavigate,\n\tgoto,\n\tinvalidate,\n\tinvalidateAll,\n\tpreloadCode,\n\tpreloadData\n} from '$app/navigation';\nimport { SvelteComponent } from 'svelte';\nimport {\n\tClientHooks,\n\tCSRPageNode,\n\tCSRPageNodeLoader,\n\tCSRRoute,\n\tPage,\n\tParamMatcher,\n\tTrailingSlash,\n\tUses\n} from 'types';\n\nexport interface SvelteKitApp {\n\t/**\n\t * A list of all the error/layout/page nodes used in the app\n\t */\n\tnodes: CSRPageNodeLoader[];\n\n\t/**\n\t * A list of all layout node ids that have a server load function.\n\t * Pages are not present because it's shorter to encode it on the leaf itself.\n\t */\n\tserver_loads: number[];\n\n\t/**\n\t * A map of `[routeId: string]: [leaf, layouts, errors]` tuples, which\n\t * is parsed into an array of routes on startup. The numbers refer to the indices in `nodes`.\n\t * If the leaf number is negative, it means it does use a server load function and the complement is the node index.\n\t * The route layout and error nodes are not referenced, they are always number 0 and 1 and always apply.\n\t */\n\tdictionary: Record<string, [leaf: number, layouts: number[], errors?: number[]]>;\n\n\tmatchers: Record<string, ParamMatcher>;\n\n\thooks: ClientHooks;\n\n\troot: typeof SvelteComponent;\n}\n\nexport interface Client {\n\t// public API, exposed via $app/navigation\n\tafter_navigate: typeof afterNavigate;\n\tbefore_navigate: typeof beforeNavigate;\n\tdisable_scroll_handling(): void;\n\tgoto: typeof goto;\n\tinvalidate: typeof invalidate;\n\tinvalidateAll: typeof invalidateAll;\n\tpreload_code: typeof preloadCode;\n\tpreload_data: typeof preloadData;\n\tapply_action: typeof applyAction;\n\n\t// private API\n\t_hydrate(opts: {\n\t\tstatus: number;\n\t\terror: App.Error | null;\n\t\tnode_ids: number[];\n\t\tparams: Record<string, string>;\n\t\troute: { id: string | null };\n\t\tdata: Array<import('types').ServerDataNode | null>;\n\t\tform: Record<string, any> | null;\n\t}): Promise<void>;\n\t_start_router(): void;\n}\n\nexport type NavigationIntent = {\n\t/** `url.pathname + url.search`  */\n\tid: string;\n\t/** Whether we are invalidating or navigating */\n\tinvalidating: boolean;\n\t/** The route parameters */\n\tparams: Record<string, string>;\n\t/** The route that matches `path` */\n\troute: CSRRoute;\n\t/** The destination URL */\n\turl: URL;\n};\n\nexport type NavigationResult = NavigationRedirect | NavigationFinished;\n\nexport type NavigationRedirect = {\n\ttype: 'redirect';\n\tlocation: string;\n};\n\nexport type NavigationFinished = {\n\ttype: 'loaded';\n\tstate: NavigationState;\n\tprops: {\n\t\tcomponents: Array<typeof SvelteComponent>;\n\t\tpage?: Page;\n\t\tform?: Record<string, any> | null;\n\t\t[key: `data_${number}`]: Record<string, any>;\n\t};\n};\n\nexport type BranchNode = {\n\tnode: CSRPageNode;\n\tloader: CSRPageNodeLoader;\n\tserver: DataNode | null;\n\tuniversal: DataNode | null;\n\tdata: Record<string, any> | null;\n\tslash?: TrailingSlash;\n};\n\nexport interface DataNode {\n\ttype: 'data';\n\tdata: Record<string, any> | null;\n\tuses: Uses;\n\tslash?: TrailingSlash;\n}\n\nexport interface NavigationState {\n\tbranch: Array<BranchNode | undefined>;\n\terror: App.Error | null;\n\tparams: Record<string, string>;\n\troute: CSRRoute | null;\n\turl: URL;\n}\n"}},"utils.js":{"file":{"contents":"import { BROWSER, DEV } from 'esm-env';\nimport { writable } from 'svelte/store';\nimport { assets } from '__sveltekit/paths';\nimport { version } from '__sveltekit/environment';\nimport { PRELOAD_PRIORITIES } from './constants.js';\n\n/* global __SVELTEKIT_APP_VERSION_FILE__, __SVELTEKIT_APP_VERSION_POLL_INTERVAL__ */\n\n/** @param {HTMLDocument} doc */\nexport function get_base_uri(doc) {\n\tlet baseURI = doc.baseURI;\n\n\tif (!baseURI) {\n\t\tconst baseTags = doc.getElementsByTagName('base');\n\t\tbaseURI = baseTags.length ? baseTags[0].href : doc.URL;\n\t}\n\n\treturn baseURI;\n}\n\nexport function scroll_state() {\n\treturn {\n\t\tx: pageXOffset,\n\t\ty: pageYOffset\n\t};\n}\n\nconst warned = new WeakSet();\n\n/** @typedef {keyof typeof valid_link_options} LinkOptionName */\n\nconst valid_link_options = /** @type {const} */ ({\n\t'preload-code': ['', 'off', 'tap', 'hover', 'viewport', 'eager'],\n\t'preload-data': ['', 'off', 'tap', 'hover'],\n\tnoscroll: ['', 'off'],\n\treload: ['', 'off']\n});\n\n/**\n * @template {LinkOptionName} T\n * @typedef {typeof valid_link_options[T][number]} ValidLinkOptions\n */\n\n/**\n * @template {LinkOptionName} T\n * @param {Element} element\n * @param {T} name\n */\nfunction link_option(element, name) {\n\tconst value = /** @type {ValidLinkOptions<T> | null} */ (\n\t\telement.getAttribute(`data-sveltekit-${name}`)\n\t);\n\n\tif (DEV) {\n\t\tvalidate_link_option(element, name, value);\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {LinkOptionName} T\n * @template {ValidLinkOptions<T> | null} U\n * @param {Element} element\n * @param {T} name\n * @param {U} value\n */\nfunction validate_link_option(element, name, value) {\n\tif (value === null) return;\n\n\t// @ts-expect-error - includes is dumb\n\tif (!warned.has(element) && !valid_link_options[name].includes(value)) {\n\t\tconsole.error(\n\t\t\t`Unexpected value for ${name} — should be one of ${valid_link_options[name]\n\t\t\t\t.map((option) => JSON.stringify(option))\n\t\t\t\t.join(', ')}`,\n\t\t\telement\n\t\t);\n\n\t\twarned.add(element);\n\t}\n}\n\nconst levels = {\n\t...PRELOAD_PRIORITIES,\n\t'': PRELOAD_PRIORITIES.hover\n};\n\n/**\n * @param {Element} element\n * @returns {Element | null}\n */\nfunction parent_element(element) {\n\tlet parent = element.assignedSlot ?? element.parentNode;\n\n\t// @ts-expect-error handle shadow roots\n\tif (parent?.nodeType === 11) parent = parent.host;\n\n\treturn /** @type {Element} */ (parent);\n}\n\n/**\n * @param {Element} element\n * @param {Element} target\n */\nexport function find_anchor(element, target) {\n\twhile (element && element !== target) {\n\t\tif (element.nodeName.toUpperCase() === 'A' && element.hasAttribute('href')) {\n\t\t\treturn /** @type {HTMLAnchorElement | SVGAElement} */ (element);\n\t\t}\n\n\t\telement = /** @type {Element} */ (parent_element(element));\n\t}\n}\n\n/**\n * @param {HTMLAnchorElement | SVGAElement} a\n * @param {string} base\n */\nexport function get_link_info(a, base) {\n\t/** @type {URL | undefined} */\n\tlet url;\n\n\ttry {\n\t\turl = new URL(a instanceof SVGAElement ? a.href.baseVal : a.href, document.baseURI);\n\t} catch {}\n\n\tconst target = a instanceof SVGAElement ? a.target.baseVal : a.target;\n\n\tconst external =\n\t\t!url ||\n\t\t!!target ||\n\t\tis_external_url(url, base) ||\n\t\t(a.getAttribute('rel') || '').split(/\\s+/).includes('external') ||\n\t\ta.hasAttribute('download');\n\n\treturn { url, external, target };\n}\n\n/**\n * @param {HTMLFormElement | HTMLAnchorElement | SVGAElement} element\n */\nexport function get_router_options(element) {\n\t/** @type {ValidLinkOptions<'noscroll'> | null} */\n\tlet noscroll = null;\n\n\t/** @type {ValidLinkOptions<'preload-code'> | null} */\n\tlet preload_code = null;\n\n\t/** @type {ValidLinkOptions<'preload-data'> | null} */\n\tlet preload_data = null;\n\n\t/** @type {ValidLinkOptions<'reload'> | null} */\n\tlet reload = null;\n\n\t/** @type {Element} */\n\tlet el = element;\n\n\twhile (el && el !== document.documentElement) {\n\t\tif (preload_code === null) preload_code = link_option(el, 'preload-code');\n\t\tif (preload_data === null) preload_data = link_option(el, 'preload-data');\n\t\tif (noscroll === null) noscroll = link_option(el, 'noscroll');\n\t\tif (reload === null) reload = link_option(el, 'reload');\n\n\t\tel = /** @type {Element} */ (parent_element(el));\n\t}\n\n\treturn {\n\t\tpreload_code: levels[preload_code ?? 'off'],\n\t\tpreload_data: levels[preload_data ?? 'off'],\n\t\tnoscroll: noscroll === 'off' ? false : noscroll === '' ? true : null,\n\t\treload: reload === 'off' ? false : reload === '' ? true : null\n\t};\n}\n\n/** @param {any} value */\nexport function notifiable_store(value) {\n\tconst store = writable(value);\n\tlet ready = true;\n\n\tfunction notify() {\n\t\tready = true;\n\t\tstore.update((val) => val);\n\t}\n\n\t/** @param {any} new_value */\n\tfunction set(new_value) {\n\t\tready = false;\n\t\tstore.set(new_value);\n\t}\n\n\t/** @param {(value: any) => void} run */\n\tfunction subscribe(run) {\n\t\t/** @type {any} */\n\t\tlet old_value;\n\t\treturn store.subscribe((new_value) => {\n\t\t\tif (old_value === undefined || (ready && new_value !== old_value)) {\n\t\t\t\trun((old_value = new_value));\n\t\t\t}\n\t\t});\n\t}\n\n\treturn { notify, set, subscribe };\n}\n\nexport function create_updated_store() {\n\tconst { set, subscribe } = writable(false);\n\n\tconst interval = __SVELTEKIT_APP_VERSION_POLL_INTERVAL__;\n\n\t/** @type {NodeJS.Timeout} */\n\tlet timeout;\n\n\t/** @type {() => Promise<boolean>} */\n\tasync function check() {\n\t\tif (DEV || !BROWSER) return false;\n\n\t\tclearTimeout(timeout);\n\n\t\tif (interval) timeout = setTimeout(check, interval);\n\n\t\tconst res = await fetch(`${assets}/${__SVELTEKIT_APP_VERSION_FILE__}`, {\n\t\t\theaders: {\n\t\t\t\tpragma: 'no-cache',\n\t\t\t\t'cache-control': 'no-cache'\n\t\t\t}\n\t\t});\n\n\t\tif (res.ok) {\n\t\t\tconst data = await res.json();\n\t\t\tconst updated = data.version !== version;\n\n\t\t\tif (updated) {\n\t\t\t\tset(true);\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t} else {\n\t\t\tthrow new Error(`Version check failed: ${res.status}`);\n\t\t}\n\t}\n\n\tif (interval) timeout = setTimeout(check, interval);\n\n\treturn {\n\t\tsubscribe,\n\t\tcheck\n\t};\n}\n\n/**\n * @param {URL} url\n * @param {string} base\n */\nexport function is_external_url(url, base) {\n\treturn url.origin !== location.origin || !url.pathname.startsWith(base);\n}\n"}}}},"components":{"directory":{"error.svelte":{"file":{"contents":"<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.status}</h1>\n<p>{$page.error?.message}</p>\n"}},"layout.svelte":{"file":{"contents":"<slot></slot>"}}}},"control.js":{"file":{"contents":"export let HttpError = class HttpError {\n\t/**\n\t * @param {number} status\n\t * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body\n\t */\n\tconstructor(status, body) {\n\t\tthis.status = status;\n\t\tif (typeof body === 'string') {\n\t\t\tthis.body = { message: body };\n\t\t} else if (body) {\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tthis.body = { message: `Error: ${status}` };\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this.body);\n\t}\n};\n\nexport let Redirect = class Redirect {\n\t/**\n\t * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status\n\t * @param {string} location\n\t */\n\tconstructor(status, location) {\n\t\tthis.status = status;\n\t\tthis.location = location;\n\t}\n};\n\n/**\n * @template {Record<string, unknown> | undefined} [T=undefined]\n */\nexport let ActionFailure = class ActionFailure {\n\t/**\n\t * @param {number} status\n\t * @param {T} [data]\n\t */\n\tconstructor(status, data) {\n\t\tthis.status = status;\n\t\tthis.data = data;\n\t}\n};\n\n/**\n * This is a grotesque hack that, in dev, allows us to replace the implementations\n * of these classes that you'd get by importing them from `@sveltejs/kit` with the\n * ones that are imported via Vite and loaded internally, so that instanceof\n * checks work even though SvelteKit imports this module via Vite and consumers\n * import it via Node\n * @param {{\n *   ActionFailure: typeof ActionFailure;\n *   HttpError: typeof HttpError;\n *   Redirect: typeof Redirect;\n * }} implementations\n */\nexport function replace_implementations(implementations) {\n\tActionFailure = implementations.ActionFailure;\n\tHttpError = implementations.HttpError;\n\tRedirect = implementations.Redirect;\n}\n"}},"env":{"directory":{"dynamic":{"directory":{"private.js":{"file":{"contents":"export { private_env as env } from '../../shared-server.js';\n"}},"public.js":{"file":{"contents":"export { public_env as env } from '../../shared-server.js';\n"}}}}}},"hash.js":{"file":{"contents":"/**\n * Hash using djb2\n * @param {import('types').StrictBody[]} values\n */\nexport function hash(...values) {\n\tlet hash = 5381;\n\n\tfor (const value of values) {\n\t\tif (typeof value === 'string') {\n\t\t\tlet i = value.length;\n\t\t\twhile (i) hash = (hash * 33) ^ value.charCodeAt(--i);\n\t\t} else if (ArrayBuffer.isView(value)) {\n\t\t\tconst buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t\t\tlet i = buffer.length;\n\t\t\twhile (i) hash = (hash * 33) ^ buffer[--i];\n\t\t} else {\n\t\t\tthrow new TypeError('value must be a string or TypedArray');\n\t\t}\n\t}\n\n\treturn (hash >>> 0).toString(36);\n}\n"}},"server":{"directory":{"ambient.d.ts":{"file":{"contents":"declare module '__SERVER__/internal.js' {\n\texport const options: import('types').SSROptions;\n\texport const get_hooks: () => Promise<{\n\t\thandle?: import('types').Handle;\n\t\thandleError?: import('types').HandleServerError;\n\t\thandleFetch?: import('types').HandleFetch;\n\t}>;\n}\n"}},"cookie.js":{"file":{"contents":"import { parse, serialize } from 'cookie';\nimport { normalize_path } from '../../utils/url.js';\n\n/**\n * Tracks all cookies set during dev mode so we can emit warnings\n * when we detect that there's likely cookie misusage due to wrong paths\n *\n * @type {Record<string, Set<string>>} */\nconst cookie_paths = {};\n\n/**\n * Cookies that are larger than this size (including the name and other\n * attributes) are discarded by browsers\n */\nconst MAX_COOKIE_SIZE = 4129;\n\n/**\n * @param {Request} request\n * @param {URL} url\n * @param {import('types').TrailingSlash} trailing_slash\n */\nexport function get_cookies(request, url, trailing_slash) {\n\tconst header = request.headers.get('cookie') ?? '';\n\tconst initial_cookies = parse(header, { decode: (value) => value });\n\n\tconst normalized_url = normalize_path(url.pathname, trailing_slash);\n\t// Emulate browser-behavior: if the cookie is set at '/foo/bar', its path is '/foo'\n\tconst default_path = normalized_url.split('/').slice(0, -1).join('/') || '/';\n\n\tif (__SVELTEKIT_DEV__) {\n\t\t// TODO this could theoretically be wrong if the cookie was set unencoded?\n\t\tconst initial_decoded_cookies = parse(header, { decode: decodeURIComponent });\n\t\t// Remove all cookies that no longer exist according to the request\n\t\tfor (const name of Object.keys(cookie_paths)) {\n\t\t\tcookie_paths[name] = new Set(\n\t\t\t\t[...cookie_paths[name]].filter(\n\t\t\t\t\t(path) => !path_matches(normalized_url, path) || name in initial_decoded_cookies\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\t// Add all new cookies we might not have seen before\n\t\tfor (const name in initial_decoded_cookies) {\n\t\t\tcookie_paths[name] = cookie_paths[name] ?? new Set();\n\t\t\tif (![...cookie_paths[name]].some((path) => path_matches(normalized_url, path))) {\n\t\t\t\tcookie_paths[name].add(default_path);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Record<string, import('./page/types').Cookie>} */\n\tconst new_cookies = {};\n\n\t/** @type {import('cookie').CookieSerializeOptions} */\n\tconst defaults = {\n\t\thttpOnly: true,\n\t\tsameSite: 'lax',\n\t\tsecure: url.hostname === 'localhost' && url.protocol === 'http:' ? false : true\n\t};\n\n\t/** @type {import('types').Cookies} */\n\tconst cookies = {\n\t\t// The JSDoc param annotations appearing below for get, set and delete\n\t\t// are necessary to expose the `cookie` library types to\n\t\t// typescript users. `@type {import('types').Cookies}` above is not\n\t\t// sufficient to do so.\n\n\t\t/**\n\t\t * @param {string} name\n\t\t * @param {import('cookie').CookieParseOptions} opts\n\t\t */\n\t\tget(name, opts) {\n\t\t\tconst c = new_cookies[name];\n\t\t\tif (\n\t\t\t\tc &&\n\t\t\t\tdomain_matches(url.hostname, c.options.domain) &&\n\t\t\t\tpath_matches(url.pathname, c.options.path)\n\t\t\t) {\n\t\t\t\treturn c.value;\n\t\t\t}\n\n\t\t\tconst decoder = opts?.decode || decodeURIComponent;\n\t\t\tconst req_cookies = parse(header, { decode: decoder });\n\t\t\tconst cookie = req_cookies[name]; // the decoded string or undefined\n\n\t\t\tif (!__SVELTEKIT_DEV__ || cookie) {\n\t\t\t\treturn cookie;\n\t\t\t}\n\n\t\t\tconst paths = new Set([...(cookie_paths[name] ?? [])]);\n\t\t\tif (c) {\n\t\t\t\tpaths.add(c.options.path ?? default_path);\n\t\t\t}\n\t\t\tif (paths.size > 0) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\t`Cookie with name '${name}' was not found at path '${url.pathname}', but a cookie with that name exists at these paths: '${[...paths].join(\"', '\")}'. Did you mean to set its 'path' to '/' instead?`\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @param {import('cookie').CookieParseOptions} opts\n\t\t */\n\t\tgetAll(opts) {\n\t\t\tconst decoder = opts?.decode || decodeURIComponent;\n\t\t\tconst cookies = parse(header, { decode: decoder });\n\n\t\t\tfor (const c of Object.values(new_cookies)) {\n\t\t\t\tif (\n\t\t\t\t\tdomain_matches(url.hostname, c.options.domain) &&\n\t\t\t\t\tpath_matches(url.pathname, c.options.path)\n\t\t\t\t) {\n\t\t\t\t\tcookies[c.name] = c.value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Object.entries(cookies).map(([name, value]) => ({ name, value }));\n\t\t},\n\n\t\t/**\n\t\t * @param {string} name\n\t\t * @param {string} value\n\t\t * @param {import('cookie').CookieSerializeOptions} opts\n\t\t */\n\t\tset(name, value, opts = {}) {\n\t\t\tlet path = opts.path ?? default_path;\n\n\t\t\tnew_cookies[name] = {\n\t\t\t\tname,\n\t\t\t\tvalue,\n\t\t\t\toptions: {\n\t\t\t\t\t...defaults,\n\t\t\t\t\t...opts,\n\t\t\t\t\tpath\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (__SVELTEKIT_DEV__) {\n\t\t\t\tconst serialized = serialize(name, value, new_cookies[name].options);\n\t\t\t\tif (new TextEncoder().encode(serialized).byteLength > MAX_COOKIE_SIZE) {\n\t\t\t\t\tthrow new Error(`Cookie \"${name}\" is too large, and will be discarded by the browser`);\n\t\t\t\t}\n\n\t\t\t\tcookie_paths[name] = cookie_paths[name] ?? new Set();\n\t\t\t\tif (!value) {\n\t\t\t\t\tif (!cookie_paths[name].has(path) && cookie_paths[name].size > 0) {\n\t\t\t\t\t\tconst paths = `'${Array.from(cookie_paths[name]).join(\"', '\")}'`;\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`Trying to delete cookie '${name}' at path '${path}', but a cookie with that name only exists at these paths: ${paths}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tcookie_paths[name].delete(path);\n\t\t\t\t} else {\n\t\t\t\t\t// We could also emit a warning here if the cookie already exists at a different path,\n\t\t\t\t\t// but that's more likely a false positive because it's valid to set the same name at different paths\n\t\t\t\t\tcookie_paths[name].add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @param {string} name\n\t\t * @param {import('cookie').CookieSerializeOptions} opts\n\t\t */\n\t\tdelete(name, opts = {}) {\n\t\t\tcookies.set(name, '', {\n\t\t\t\t...opts,\n\t\t\t\tmaxAge: 0\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @param {string} name\n\t\t * @param {string} value\n\t\t * @param {import('cookie').CookieSerializeOptions} opts\n\t\t */\n\t\tserialize(name, value, opts) {\n\t\t\treturn serialize(name, value, {\n\t\t\t\t...defaults,\n\t\t\t\t...opts\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * @param {URL} destination\n\t * @param {string | null} header\n\t */\n\tfunction get_cookie_header(destination, header) {\n\t\t/** @type {Record<string, string>} */\n\t\tconst combined_cookies = {\n\t\t\t// cookies sent by the user agent have lowest precedence\n\t\t\t...initial_cookies\n\t\t};\n\n\t\t// cookies previous set during this event with cookies.set have higher precedence\n\t\tfor (const key in new_cookies) {\n\t\t\tconst cookie = new_cookies[key];\n\t\t\tif (!domain_matches(destination.hostname, cookie.options.domain)) continue;\n\t\t\tif (!path_matches(destination.pathname, cookie.options.path)) continue;\n\n\t\t\tconst encoder = cookie.options.encode || encodeURIComponent;\n\t\t\tcombined_cookies[cookie.name] = encoder(cookie.value);\n\t\t}\n\n\t\t// explicit header has highest precedence\n\t\tif (header) {\n\t\t\tconst parsed = parse(header, { decode: (value) => value });\n\t\t\tfor (const name in parsed) {\n\t\t\t\tcombined_cookies[name] = parsed[name];\n\t\t\t}\n\t\t}\n\n\t\treturn Object.entries(combined_cookies)\n\t\t\t.map(([name, value]) => `${name}=${value}`)\n\t\t\t.join('; ');\n\t}\n\n\treturn { cookies, new_cookies, get_cookie_header };\n}\n\n/**\n * @param {string} hostname\n * @param {string} [constraint]\n */\nexport function domain_matches(hostname, constraint) {\n\tif (!constraint) return true;\n\n\tconst normalized = constraint[0] === '.' ? constraint.slice(1) : constraint;\n\n\tif (hostname === normalized) return true;\n\treturn hostname.endsWith('.' + normalized);\n}\n\n/**\n * @param {string} path\n * @param {string} [constraint]\n */\nexport function path_matches(path, constraint) {\n\tif (!constraint) return true;\n\n\tconst normalized = constraint.endsWith('/') ? constraint.slice(0, -1) : constraint;\n\n\tif (path === normalized) return true;\n\treturn path.startsWith(normalized + '/');\n}\n\n/**\n * @param {Headers} headers\n * @param {import('./page/types').Cookie[]} cookies\n */\nexport function add_cookies_to_headers(headers, cookies) {\n\tfor (const new_cookie of cookies) {\n\t\tconst { name, value, options } = new_cookie;\n\t\theaders.append('set-cookie', serialize(name, value, options));\n\t}\n}\n"}},"data":{"directory":{"index.js":{"file":{"contents":"import { HttpError, Redirect } from '../../control.js';\nimport { normalize_error } from '../../../utils/error.js';\nimport { once } from '../../../utils/functions.js';\nimport { load_server_data } from '../page/load_data.js';\nimport { clarify_devalue_error, handle_error_and_jsonify, stringify_uses } from '../utils.js';\nimport { normalize_path } from '../../../utils/url.js';\nimport { text } from '../../../exports/index.js';\nimport * as devalue from 'devalue';\nimport { create_async_iterator } from '../../../utils/streaming.js';\n\nexport const INVALIDATED_PARAM = 'x-sveltekit-invalidated';\n\nconst encoder = new TextEncoder();\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSRRoute} route\n * @param {import('types').SSROptions} options\n * @param {import('types').SSRManifest} manifest\n * @param {import('types').SSRState} state\n * @param {boolean[] | undefined} invalidated_data_nodes\n * @param {import('types').TrailingSlash} trailing_slash\n * @returns {Promise<Response>}\n */\nexport async function render_data(\n\tevent,\n\troute,\n\toptions,\n\tmanifest,\n\tstate,\n\tinvalidated_data_nodes,\n\ttrailing_slash\n) {\n\tif (!route.page) {\n\t\t// requesting /__data.json should fail for a +server.js\n\t\treturn new Response(undefined, {\n\t\t\tstatus: 404\n\t\t});\n\t}\n\n\ttry {\n\t\tconst node_ids = [...route.page.layouts, route.page.leaf];\n\t\tconst invalidated = invalidated_data_nodes ?? node_ids.map(() => true);\n\n\t\tlet aborted = false;\n\n\t\tconst url = new URL(event.url);\n\t\turl.pathname = normalize_path(url.pathname, trailing_slash);\n\n\t\tconst new_event = { ...event, url };\n\n\t\tconst functions = node_ids.map((n, i) => {\n\t\t\treturn once(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif (aborted) {\n\t\t\t\t\t\treturn /** @type {import('types').ServerDataSkippedNode} */ ({\n\t\t\t\t\t\t\ttype: 'skip'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// == because it could be undefined (in dev) or null (in build, because of JSON.stringify)\n\t\t\t\t\tconst node = n == undefined ? n : await manifest._.nodes[n]();\n\t\t\t\t\t// load this. for the child, return as is. for the final result, stream things\n\t\t\t\t\treturn load_server_data({\n\t\t\t\t\t\tevent: new_event,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tparent: async () => {\n\t\t\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\t\t\tconst data = {};\n\t\t\t\t\t\t\tfor (let j = 0; j < i; j += 1) {\n\t\t\t\t\t\t\t\tconst parent = /** @type {import('types').ServerDataNode | null} */ (\n\t\t\t\t\t\t\t\t\tawait functions[j]()\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t\t\t\tObject.assign(data, parent.data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\taborted = true;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tconst promises = functions.map(async (fn, i) => {\n\t\t\tif (!invalidated[i]) {\n\t\t\t\treturn /** @type {import('types').ServerDataSkippedNode} */ ({\n\t\t\t\t\ttype: 'skip'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn fn();\n\t\t});\n\n\t\tlet length = promises.length;\n\t\tconst nodes = await Promise.all(\n\t\t\tpromises.map((p, i) =>\n\t\t\t\tp.catch(async (error) => {\n\t\t\t\t\tif (error instanceof Redirect) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Math.min because array isn't guaranteed to resolve in order\n\t\t\t\t\tlength = Math.min(length, i + 1);\n\n\t\t\t\t\treturn /** @type {import('types').ServerErrorNode} */ ({\n\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\terror: await handle_error_and_jsonify(event, options, error),\n\t\t\t\t\t\tstatus: error instanceof HttpError ? error.status : undefined\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\n\t\tconst { data, chunks } = get_data_json(event, options, nodes);\n\n\t\tif (!chunks) {\n\t\t\t// use a normal JSON response where possible, so we get `content-length`\n\t\t\t// and can use browser JSON devtools for easier inspecting\n\t\t\treturn json_response(data);\n\t\t}\n\n\t\treturn new Response(\n\t\t\tnew ReadableStream({\n\t\t\t\tasync start(controller) {\n\t\t\t\t\tcontroller.enqueue(encoder.encode(data));\n\t\t\t\t\tfor await (const chunk of chunks) {\n\t\t\t\t\t\tcontroller.enqueue(encoder.encode(chunk));\n\t\t\t\t\t}\n\t\t\t\t\tcontroller.close();\n\t\t\t\t},\n\n\t\t\t\ttype: 'bytes'\n\t\t\t}),\n\t\t\t{\n\t\t\t\theaders: {\n\t\t\t\t\t// we use a proprietary content type to prevent buffering.\n\t\t\t\t\t// the `text` prefix makes it inspectable\n\t\t\t\t\t'content-type': 'text/sveltekit-data',\n\t\t\t\t\t'cache-control': 'private, no-store'\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t} catch (e) {\n\t\tconst error = normalize_error(e);\n\n\t\tif (error instanceof Redirect) {\n\t\t\treturn redirect_json_response(error);\n\t\t} else {\n\t\t\treturn json_response(await handle_error_and_jsonify(event, options, error), 500);\n\t\t}\n\t}\n}\n\n/**\n * @param {Record<string, any> | string} json\n * @param {number} [status]\n */\nfunction json_response(json, status = 200) {\n\treturn text(typeof json === 'string' ? json : JSON.stringify(json), {\n\t\tstatus,\n\t\theaders: {\n\t\t\t'content-type': 'application/json',\n\t\t\t'cache-control': 'private, no-store'\n\t\t}\n\t});\n}\n\n/**\n * @param {Redirect} redirect\n */\nexport function redirect_json_response(redirect) {\n\treturn json_response({\n\t\ttype: 'redirect',\n\t\tlocation: redirect.location\n\t});\n}\n\n/**\n * If the serialized data contains promises, `chunks` will be an\n * async iterable containing their resolutions\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSROptions} options\n * @param {Array<import('types').ServerDataSkippedNode | import('types').ServerDataNode | import('types').ServerErrorNode | null | undefined>} nodes\n *  @returns {{ data: string, chunks: AsyncIterable<string> | null }}\n */\nexport function get_data_json(event, options, nodes) {\n\tlet promise_id = 1;\n\tlet count = 0;\n\n\tconst { iterator, push, done } = create_async_iterator();\n\n\tconst reducers = {\n\t\t/** @param {any} thing */\n\t\tPromise: (thing) => {\n\t\t\tif (typeof thing?.then === 'function') {\n\t\t\t\tconst id = promise_id++;\n\t\t\t\tcount += 1;\n\n\t\t\t\t/** @type {'data' | 'error'} */\n\t\t\t\tlet key = 'data';\n\n\t\t\t\tthing\n\t\t\t\t\t.catch(\n\t\t\t\t\t\t/** @param {any} e */ async (e) => {\n\t\t\t\t\t\t\tkey = 'error';\n\t\t\t\t\t\t\treturn handle_error_and_jsonify(event, options, /** @type {any} */ (e));\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\t.then(\n\t\t\t\t\t\t/** @param {any} value */\n\t\t\t\t\t\tasync (value) => {\n\t\t\t\t\t\t\tlet str;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tstr = devalue.stringify(value, reducers);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tconst error = await handle_error_and_jsonify(\n\t\t\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\tnew Error(`Failed to serialize promise while rendering ${event.route.id}`)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tkey = 'error';\n\t\t\t\t\t\t\t\tstr = devalue.stringify(error, reducers);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcount -= 1;\n\n\t\t\t\t\t\t\tpush(`{\"type\":\"chunk\",\"id\":${id},\"${key}\":${str}}\\n`);\n\t\t\t\t\t\t\tif (count === 0) done();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\treturn id;\n\t\t\t}\n\t\t}\n\t};\n\n\ttry {\n\t\tconst strings = nodes.map((node) => {\n\t\t\tif (!node) return 'null';\n\n\t\t\tif (node.type === 'error' || node.type === 'skip') {\n\t\t\t\treturn JSON.stringify(node);\n\t\t\t}\n\n\t\t\treturn `{\"type\":\"data\",\"data\":${devalue.stringify(node.data, reducers)},${stringify_uses(\n\t\t\t\tnode\n\t\t\t)}${node.slash ? `,\"slash\":${JSON.stringify(node.slash)}` : ''}}`;\n\t\t});\n\n\t\treturn {\n\t\t\tdata: `{\"type\":\"data\",\"nodes\":[${strings.join(',')}]}\\n`,\n\t\t\tchunks: count > 0 ? iterator : null\n\t\t};\n\t} catch (e) {\n\t\tthrow new Error(clarify_devalue_error(event, /** @type {any} */ (e)));\n\t}\n}\n"}}}},"endpoint.js":{"file":{"contents":"import { negotiate } from '../../utils/http.js';\nimport { Redirect } from '../control.js';\nimport { method_not_allowed } from './utils.js';\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSREndpoint} mod\n * @param {import('types').SSRState} state\n * @returns {Promise<Response>}\n */\nexport async function render_endpoint(event, mod, state) {\n\tconst method = /** @type {import('types').HttpMethod} */ (event.request.method);\n\n\tlet handler = mod[method];\n\n\tif (!handler && method === 'HEAD') {\n\t\thandler = mod.GET;\n\t}\n\n\tif (!handler) {\n\t\treturn method_not_allowed(mod, method);\n\t}\n\n\tconst prerender = mod.prerender ?? state.prerender_default;\n\n\tif (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {\n\t\tthrow new Error('Cannot prerender endpoints that have mutative methods');\n\t}\n\n\tif (state.prerendering && !prerender) {\n\t\tif (state.depth > 0) {\n\t\t\t// if request came from a prerendered page, bail\n\t\t\tthrow new Error(`${event.route.id} is not prerenderable`);\n\t\t} else {\n\t\t\t// if request came direct from the crawler, signal that\n\t\t\t// this route cannot be prerendered, but don't bail\n\t\t\treturn new Response(undefined, { status: 204 });\n\t\t}\n\t}\n\n\ttry {\n\t\tconst response = await handler(\n\t\t\t/** @type {import('types').RequestEvent<Record<string, any>>} */ (event)\n\t\t);\n\n\t\tif (!(response instanceof Response)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid response from route ${event.url.pathname}: handler should return a Response object`\n\t\t\t);\n\t\t}\n\n\t\tif (state.prerendering) {\n\t\t\tresponse.headers.set('x-sveltekit-prerender', String(prerender));\n\t\t}\n\n\t\treturn response;\n\t} catch (e) {\n\t\tif (e instanceof Redirect) {\n\t\t\treturn new Response(undefined, {\n\t\t\t\tstatus: e.status,\n\t\t\t\theaders: { location: e.location }\n\t\t\t});\n\t\t}\n\n\t\tthrow e;\n\t}\n}\n\n/**\n * @param {import('types').RequestEvent} event\n */\nexport function is_endpoint_request(event) {\n\tconst { method, headers } = event.request;\n\n\tif (method === 'PUT' || method === 'PATCH' || method === 'DELETE' || method === 'OPTIONS') {\n\t\t// These methods exist exclusively for endpoints\n\t\treturn true;\n\t}\n\n\t// use:enhance uses a custom header to disambiguate\n\tif (method === 'POST' && headers.get('x-sveltekit-action') === 'true') return false;\n\n\t// GET/POST requests may be for endpoints or pages. We prefer endpoints if this isn't a text/html request\n\tconst accept = event.request.headers.get('accept') ?? '*/*';\n\treturn negotiate(accept, ['*', 'text/html']) !== 'text/html';\n}\n"}},"fetch.js":{"file":{"contents":"import * as set_cookie_parser from 'set-cookie-parser';\nimport { respond } from './respond.js';\nimport * as paths from '__sveltekit/paths';\n\n/**\n * @param {{\n *   event: import('types').RequestEvent;\n *   options: import('types').SSROptions;\n *   manifest: import('types').SSRManifest;\n *   state: import('types').SSRState;\n *   get_cookie_header: (url: URL, header: string | null) => string;\n * }} opts\n * @returns {typeof fetch}\n */\nexport function create_fetch({ event, options, manifest, state, get_cookie_header }) {\n\treturn async (info, init) => {\n\t\tconst original_request = normalize_fetch_input(info, init, event.url);\n\n\t\tconst request_body = init?.body;\n\n\t\t// some runtimes (e.g. Cloudflare) error if you access `request.mode`,\n\t\t// annoyingly, so we need to read the value from the `init` object instead\n\t\tlet mode = (info instanceof Request ? info.mode : init?.mode) ?? 'cors';\n\t\tlet credentials =\n\t\t\t(info instanceof Request ? info.credentials : init?.credentials) ?? 'same-origin';\n\n\t\treturn await options.hooks.handleFetch({\n\t\t\tevent,\n\t\t\trequest: original_request,\n\t\t\tfetch: async (info, init) => {\n\t\t\t\tconst request = normalize_fetch_input(info, init, event.url);\n\n\t\t\t\tconst url = new URL(request.url);\n\n\t\t\t\tif (!request.headers.has('origin')) {\n\t\t\t\t\trequest.headers.set('origin', event.url.origin);\n\t\t\t\t}\n\n\t\t\t\tif (info !== original_request) {\n\t\t\t\t\tmode = (info instanceof Request ? info.mode : init?.mode) ?? 'cors';\n\t\t\t\t\tcredentials =\n\t\t\t\t\t\t(info instanceof Request ? info.credentials : init?.credentials) ?? 'same-origin';\n\t\t\t\t}\n\n\t\t\t\t// Remove Origin, according to https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin#description\n\t\t\t\tif (\n\t\t\t\t\t(request.method === 'GET' || request.method === 'HEAD') &&\n\t\t\t\t\t((mode === 'no-cors' && url.origin !== event.url.origin) ||\n\t\t\t\t\t\turl.origin === event.url.origin)\n\t\t\t\t) {\n\t\t\t\t\trequest.headers.delete('origin');\n\t\t\t\t}\n\n\t\t\t\tif (url.origin !== event.url.origin) {\n\t\t\t\t\t// allow cookie passthrough for \"same-origin\"\n\t\t\t\t\t// if SvelteKit is serving my.domain.com:\n\t\t\t\t\t// -        domain.com WILL NOT receive cookies\n\t\t\t\t\t// -     my.domain.com WILL receive cookies\n\t\t\t\t\t// -    api.domain.dom WILL NOT receive cookies\n\t\t\t\t\t// - sub.my.domain.com WILL receive cookies\n\t\t\t\t\t// ports do not affect the resolution\n\t\t\t\t\t// leading dot prevents mydomain.com matching domain.com\n\t\t\t\t\tif (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== 'omit') {\n\t\t\t\t\t\tconst cookie = get_cookie_header(url, request.headers.get('cookie'));\n\t\t\t\t\t\tif (cookie) request.headers.set('cookie', cookie);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fetch(request);\n\t\t\t\t}\n\n\t\t\t\t/** @type {Response} */\n\t\t\t\tlet response;\n\n\t\t\t\t// handle fetch requests for static assets. e.g. prebaked data, etc.\n\t\t\t\t// we need to support everything the browser's fetch supports\n\t\t\t\tconst prefix = paths.assets || paths.base;\n\t\t\t\tconst decoded = decodeURIComponent(url.pathname);\n\t\t\t\tconst filename = (\n\t\t\t\t\tdecoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded\n\t\t\t\t).slice(1);\n\t\t\t\tconst filename_html = `${filename}/index.html`; // path may also match path/index.html\n\n\t\t\t\tconst is_asset = manifest.assets.has(filename);\n\t\t\t\tconst is_asset_html = manifest.assets.has(filename_html);\n\n\t\t\t\tif (is_asset || is_asset_html) {\n\t\t\t\t\tconst file = is_asset ? filename : filename_html;\n\n\t\t\t\t\tif (state.read) {\n\t\t\t\t\t\tconst type = is_asset\n\t\t\t\t\t\t\t? manifest.mimeTypes[filename.slice(filename.lastIndexOf('.'))]\n\t\t\t\t\t\t\t: 'text/html';\n\n\t\t\t\t\t\treturn new Response(state.read(file), {\n\t\t\t\t\t\t\theaders: type ? { 'content-type': type } : {}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn await fetch(request);\n\t\t\t\t}\n\n\t\t\t\tif (credentials !== 'omit') {\n\t\t\t\t\tconst cookie = get_cookie_header(url, request.headers.get('cookie'));\n\t\t\t\t\tif (cookie) {\n\t\t\t\t\t\trequest.headers.set('cookie', cookie);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst authorization = event.request.headers.get('authorization');\n\t\t\t\t\tif (authorization && !request.headers.has('authorization')) {\n\t\t\t\t\t\trequest.headers.set('authorization', authorization);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (request_body && typeof request_body !== 'string' && !ArrayBuffer.isView(request_body)) {\n\t\t\t\t\t// TODO is this still necessary? we just bail out below\n\t\t\t\t\t// per https://developer.mozilla.org/en-US/docs/Web/API/Request/Request, this can be a\n\t\t\t\t\t// Blob, BufferSource, FormData, URLSearchParams, USVString, or ReadableStream object.\n\t\t\t\t\t// non-string bodies are irksome to deal with, but luckily aren't particularly useful\n\t\t\t\t\t// in this context anyway, so we take the easy route and ban them\n\t\t\t\t\tthrow new Error('Request body must be a string or TypedArray');\n\t\t\t\t}\n\n\t\t\t\tif (!request.headers.has('accept')) {\n\t\t\t\t\trequest.headers.set('accept', '*/*');\n\t\t\t\t}\n\n\t\t\t\tif (!request.headers.has('accept-language')) {\n\t\t\t\t\trequest.headers.set(\n\t\t\t\t\t\t'accept-language',\n\t\t\t\t\t\t/** @type {string} */ (event.request.headers.get('accept-language'))\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresponse = await respond(request, options, manifest, {\n\t\t\t\t\t...state,\n\t\t\t\t\tdepth: state.depth + 1\n\t\t\t\t});\n\n\t\t\t\tconst set_cookie = response.headers.get('set-cookie');\n\t\t\t\tif (set_cookie) {\n\t\t\t\t\tfor (const str of set_cookie_parser.splitCookiesString(set_cookie)) {\n\t\t\t\t\t\tconst { name, value, ...options } = set_cookie_parser.parseString(str);\n\n\t\t\t\t\t\t// options.sameSite is string, something more specific is required - type cast is safe\n\t\t\t\t\t\tevent.cookies.set(\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t/** @type {import('cookie').CookieSerializeOptions} */ (options)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn response;\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * @param {RequestInfo | URL} info\n * @param {RequestInit | undefined} init\n * @param {URL} url\n */\nfunction normalize_fetch_input(info, init, url) {\n\tif (info instanceof Request) {\n\t\treturn info;\n\t}\n\n\treturn new Request(typeof info === 'string' ? new URL(info, url) : info, init);\n}\n"}},"index.js":{"file":{"contents":"import { respond } from './respond.js';\nimport { set_private_env, set_public_env } from '../shared-server.js';\nimport { options, get_hooks } from '__SERVER__/internal.js';\n\nexport class Server {\n\t/** @type {import('types').SSROptions} */\n\t#options;\n\n\t/** @type {import('types').SSRManifest} */\n\t#manifest;\n\n\t/** @param {import('types').SSRManifest} manifest */\n\tconstructor(manifest) {\n\t\t/** @type {import('types').SSROptions} */\n\t\tthis.#options = options;\n\t\tthis.#manifest = manifest;\n\t}\n\n\t/**\n\t * @param {{\n\t *   env: Record<string, string>\n\t * }} opts\n\t */\n\tasync init({ env }) {\n\t\t// Take care: Some adapters may have to call `Server.init` per-request to set env vars,\n\t\t// so anything that shouldn't be rerun should be wrapped in an `if` block to make sure it hasn't\n\t\t// been done already.\n\t\tconst entries = Object.entries(env);\n\n\t\tconst prefix = this.#options.env_public_prefix;\n\t\tconst prv = Object.fromEntries(entries.filter(([k]) => !k.startsWith(prefix)));\n\t\tconst pub = Object.fromEntries(entries.filter(([k]) => k.startsWith(prefix)));\n\n\t\tset_private_env(prv);\n\t\tset_public_env(pub);\n\n\t\tif (!this.#options.hooks) {\n\t\t\tconst module = await get_hooks();\n\n\t\t\tthis.#options.hooks = {\n\t\t\t\thandle: module.handle || (({ event, resolve }) => resolve(event)),\n\t\t\t\t// @ts-expect-error\n\t\t\t\thandleError: module.handleError || (({ error }) => console.error(error?.stack)),\n\t\t\t\thandleFetch: module.handleFetch || (({ request, fetch }) => fetch(request))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Request} request\n\t * @param {import('types').RequestOptions} options\n\t */\n\tasync respond(request, options) {\n\t\t// TODO this should probably have been removed for 1.0 — i think we can get rid of it?\n\t\tif (!(request instanceof Request)) {\n\t\t\tthrow new Error(\n\t\t\t\t'The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details'\n\t\t\t);\n\t\t}\n\n\t\treturn respond(request, this.#options, this.#manifest, {\n\t\t\t...options,\n\t\t\terror: false,\n\t\t\tdepth: 0\n\t\t});\n\t}\n}\n"}},"page":{"directory":{"actions.js":{"file":{"contents":"import * as devalue from 'devalue';\nimport { error, json } from '../../../exports/index.js';\nimport { normalize_error } from '../../../utils/error.js';\nimport { is_form_content_type, negotiate } from '../../../utils/http.js';\nimport { HttpError, Redirect, ActionFailure } from '../../control.js';\nimport { handle_error_and_jsonify } from '../utils.js';\n\n/** @param {import('types').RequestEvent} event */\nexport function is_action_json_request(event) {\n\tconst accept = negotiate(event.request.headers.get('accept') ?? '*/*', [\n\t\t'application/json',\n\t\t'text/html'\n\t]);\n\n\treturn accept === 'application/json' && event.request.method === 'POST';\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSROptions} options\n * @param {import('types').SSRNode['server'] | undefined} server\n */\nexport async function handle_action_json_request(event, options, server) {\n\tconst actions = server?.actions;\n\n\tif (!actions) {\n\t\t// TODO should this be a different error altogether?\n\t\tconst no_actions_error = error(405, 'POST method not allowed. No actions exist for this page');\n\t\treturn action_json(\n\t\t\t{\n\t\t\t\ttype: 'error',\n\t\t\t\terror: await handle_error_and_jsonify(event, options, no_actions_error)\n\t\t\t},\n\t\t\t{\n\t\t\t\tstatus: no_actions_error.status,\n\t\t\t\theaders: {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405\n\t\t\t\t\t// \"The server must generate an Allow header field in a 405 status code response\"\n\t\t\t\t\tallow: 'GET'\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\tcheck_named_default_separate(actions);\n\n\ttry {\n\t\tconst data = await call_action(event, actions);\n\n\t\tif (__SVELTEKIT_DEV__) {\n\t\t\tvalidate_action_return(data);\n\t\t}\n\n\t\tif (data instanceof ActionFailure) {\n\t\t\treturn action_json({\n\t\t\t\ttype: 'failure',\n\t\t\t\tstatus: data.status,\n\t\t\t\t// @ts-expect-error we assign a string to what is supposed to be an object. That's ok\n\t\t\t\t// because we don't use the object outside, and this way we have better code navigation\n\t\t\t\t// through knowing where the related interface is used.\n\t\t\t\tdata: stringify_action_response(data.data, /** @type {string} */ (event.route.id))\n\t\t\t});\n\t\t} else {\n\t\t\treturn action_json({\n\t\t\t\ttype: 'success',\n\t\t\t\tstatus: data ? 200 : 204,\n\t\t\t\t// @ts-expect-error see comment above\n\t\t\t\tdata: stringify_action_response(data, /** @type {string} */ (event.route.id))\n\t\t\t});\n\t\t}\n\t} catch (e) {\n\t\tconst err = normalize_error(e);\n\n\t\tif (err instanceof Redirect) {\n\t\t\treturn action_json({\n\t\t\t\ttype: 'redirect',\n\t\t\t\tstatus: err.status,\n\t\t\t\tlocation: err.location\n\t\t\t});\n\t\t}\n\n\t\treturn action_json(\n\t\t\t{\n\t\t\t\ttype: 'error',\n\t\t\t\terror: await handle_error_and_jsonify(event, options, check_incorrect_fail_use(err))\n\t\t\t},\n\t\t\t{\n\t\t\t\tstatus: err instanceof HttpError ? err.status : 500\n\t\t\t}\n\t\t);\n\t}\n}\n\n/**\n * @param {HttpError | Error} error\n */\nfunction check_incorrect_fail_use(error) {\n\treturn error instanceof ActionFailure\n\t\t? new Error(`Cannot \"throw fail()\". Use \"return fail()\"`)\n\t\t: error;\n}\n\n/**\n * @param {import('types').ActionResult} data\n * @param {ResponseInit} [init]\n */\nfunction action_json(data, init) {\n\treturn json(data, init);\n}\n\n/**\n * @param {import('types').RequestEvent} event\n */\nexport function is_action_request(event) {\n\treturn event.request.method === 'POST';\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSRNode['server'] | undefined} server\n * @returns {Promise<import('types').ActionResult>}\n */\nexport async function handle_action_request(event, server) {\n\tconst actions = server?.actions;\n\n\tif (!actions) {\n\t\t// TODO should this be a different error altogether?\n\t\tevent.setHeaders({\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405\n\t\t\t// \"The server must generate an Allow header field in a 405 status code response\"\n\t\t\tallow: 'GET'\n\t\t});\n\t\treturn {\n\t\t\ttype: 'error',\n\t\t\terror: error(405, 'POST method not allowed. No actions exist for this page')\n\t\t};\n\t}\n\n\tcheck_named_default_separate(actions);\n\n\ttry {\n\t\tconst data = await call_action(event, actions);\n\n\t\tif (__SVELTEKIT_DEV__) {\n\t\t\tvalidate_action_return(data);\n\t\t}\n\n\t\tif (data instanceof ActionFailure) {\n\t\t\treturn {\n\t\t\t\ttype: 'failure',\n\t\t\t\tstatus: data.status,\n\t\t\t\tdata: data.data\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: 'success',\n\t\t\t\tstatus: 200,\n\t\t\t\t// @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission\n\t\t\t\tdata\n\t\t\t};\n\t\t}\n\t} catch (e) {\n\t\tconst err = normalize_error(e);\n\n\t\tif (err instanceof Redirect) {\n\t\t\treturn {\n\t\t\t\ttype: 'redirect',\n\t\t\t\tstatus: err.status,\n\t\t\t\tlocation: err.location\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttype: 'error',\n\t\t\terror: check_incorrect_fail_use(err)\n\t\t};\n\t}\n}\n\n/**\n * @param {import('types').Actions} actions\n */\nfunction check_named_default_separate(actions) {\n\tif (actions.default && Object.keys(actions).length > 1) {\n\t\tthrow new Error(\n\t\t\t`When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions`\n\t\t);\n\t}\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {NonNullable<import('types').SSRNode['server']['actions']>} actions\n * @throws {Redirect | ActionFailure | HttpError | Error}\n */\nasync function call_action(event, actions) {\n\tconst url = new URL(event.request.url);\n\n\tlet name = 'default';\n\tfor (const param of url.searchParams) {\n\t\tif (param[0].startsWith('/')) {\n\t\t\tname = param[0].slice(1);\n\t\t\tif (name === 'default') {\n\t\t\t\tthrow new Error('Cannot use reserved action name \"default\"');\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst action = actions[name];\n\tif (!action) {\n\t\tthrow new Error(`No action with name '${name}' found`);\n\t}\n\n\tif (!is_form_content_type(event.request)) {\n\t\tthrow new Error(\n\t\t\t`Actions expect form-encoded data (received ${event.request.headers.get('content-type')}`\n\t\t);\n\t}\n\n\treturn action(event);\n}\n\n/** @param {any} data */\nfunction validate_action_return(data) {\n\tif (data instanceof Redirect) {\n\t\tthrow new Error(`Cannot \\`return redirect(...)\\` — use \\`throw redirect(...)\\` instead`);\n\t}\n\n\tif (data instanceof HttpError) {\n\t\tthrow new Error(\n\t\t\t`Cannot \\`return error(...)\\` — use \\`throw error(...)\\` or \\`return fail(...)\\` instead`\n\t\t);\n\t}\n}\n\n/**\n * Try to `devalue.uneval` the data object, and if it fails, return a proper Error with context\n * @param {any} data\n * @param {string} route_id\n */\nexport function uneval_action_response(data, route_id) {\n\treturn try_deserialize(data, devalue.uneval, route_id);\n}\n\n/**\n * Try to `devalue.stringify` the data object, and if it fails, return a proper Error with context\n * @param {any} data\n * @param {string} route_id\n */\nfunction stringify_action_response(data, route_id) {\n\treturn try_deserialize(data, devalue.stringify, route_id);\n}\n\n/**\n * @param {any} data\n * @param {(data: any) => string} fn\n * @param {string} route_id\n */\nfunction try_deserialize(data, fn, route_id) {\n\ttry {\n\t\treturn fn(data);\n\t} catch (e) {\n\t\t// If we're here, the data could not be serialized with devalue\n\t\tconst error = /** @type {any} */ (e);\n\n\t\tif ('path' in error) {\n\t\t\tlet message = `Data returned from action inside ${route_id} is not serializable: ${error.message}`;\n\t\t\tif (error.path !== '') message += ` (data.${error.path})`;\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n"}},"crypto.js":{"file":{"contents":"const encoder = new TextEncoder();\n\n/**\n * SHA-256 hashing function adapted from https://bitwiseshiftleft.github.io/sjcl\n * modified and redistributed under BSD license\n * @param {string} data\n */\nexport function sha256(data) {\n\tif (!key[0]) precompute();\n\n\tconst out = init.slice(0);\n\tconst array = encode(data);\n\n\tfor (let i = 0; i < array.length; i += 16) {\n\t\tconst w = array.subarray(i, i + 16);\n\n\t\tlet tmp;\n\t\tlet a;\n\t\tlet b;\n\n\t\tlet out0 = out[0];\n\t\tlet out1 = out[1];\n\t\tlet out2 = out[2];\n\t\tlet out3 = out[3];\n\t\tlet out4 = out[4];\n\t\tlet out5 = out[5];\n\t\tlet out6 = out[6];\n\t\tlet out7 = out[7];\n\n\t\t/* Rationale for placement of |0 :\n\t\t * If a value can overflow is original 32 bits by a factor of more than a few\n\t\t * million (2^23 ish), there is a possibility that it might overflow the\n\t\t * 53-bit mantissa and lose precision.\n\t\t *\n\t\t * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n\t\t * propagates around the loop, and on the hash state out[]. I don't believe\n\t\t * that the clamps on out4 and on out0 are strictly necessary, but it's close\n\t\t * (for out4 anyway), and better safe than sorry.\n\t\t *\n\t\t * The clamps on out[] are necessary for the output to be correct even in the\n\t\t * common case and for short inputs.\n\t\t */\n\n\t\tfor (let i = 0; i < 64; i++) {\n\t\t\t// load up the input word for this round\n\n\t\t\tif (i < 16) {\n\t\t\t\ttmp = w[i];\n\t\t\t} else {\n\t\t\t\ta = w[(i + 1) & 15];\n\n\t\t\t\tb = w[(i + 14) & 15];\n\n\t\t\t\ttmp = w[i & 15] =\n\t\t\t\t\t(((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +\n\t\t\t\t\t\t((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +\n\t\t\t\t\t\tw[i & 15] +\n\t\t\t\t\t\tw[(i + 9) & 15]) |\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\ttmp =\n\t\t\t\ttmp +\n\t\t\t\tout7 +\n\t\t\t\t((out4 >>> 6) ^ (out4 >>> 11) ^ (out4 >>> 25) ^ (out4 << 26) ^ (out4 << 21) ^ (out4 << 7)) +\n\t\t\t\t(out6 ^ (out4 & (out5 ^ out6))) +\n\t\t\t\tkey[i]; // | 0;\n\n\t\t\t// shift register\n\t\t\tout7 = out6;\n\t\t\tout6 = out5;\n\t\t\tout5 = out4;\n\n\t\t\tout4 = (out3 + tmp) | 0;\n\n\t\t\tout3 = out2;\n\t\t\tout2 = out1;\n\t\t\tout1 = out0;\n\n\t\t\tout0 =\n\t\t\t\t(tmp +\n\t\t\t\t\t((out1 & out2) ^ (out3 & (out1 ^ out2))) +\n\t\t\t\t\t((out1 >>> 2) ^\n\t\t\t\t\t\t(out1 >>> 13) ^\n\t\t\t\t\t\t(out1 >>> 22) ^\n\t\t\t\t\t\t(out1 << 30) ^\n\t\t\t\t\t\t(out1 << 19) ^\n\t\t\t\t\t\t(out1 << 10))) |\n\t\t\t\t0;\n\t\t}\n\n\t\tout[0] = (out[0] + out0) | 0;\n\t\tout[1] = (out[1] + out1) | 0;\n\t\tout[2] = (out[2] + out2) | 0;\n\t\tout[3] = (out[3] + out3) | 0;\n\t\tout[4] = (out[4] + out4) | 0;\n\t\tout[5] = (out[5] + out5) | 0;\n\t\tout[6] = (out[6] + out6) | 0;\n\t\tout[7] = (out[7] + out7) | 0;\n\t}\n\n\tconst bytes = new Uint8Array(out.buffer);\n\treverse_endianness(bytes);\n\n\treturn base64(bytes);\n}\n\n/** The SHA-256 initialization vector */\nconst init = new Uint32Array(8);\n\n/** The SHA-256 hash key */\nconst key = new Uint32Array(64);\n\n/** Function to precompute init and key. */\nfunction precompute() {\n\t/** @param {number} x */\n\tfunction frac(x) {\n\t\treturn (x - Math.floor(x)) * 0x100000000;\n\t}\n\n\tlet prime = 2;\n\n\tfor (let i = 0; i < 64; prime++) {\n\t\tlet is_prime = true;\n\n\t\tfor (let factor = 2; factor * factor <= prime; factor++) {\n\t\t\tif (prime % factor === 0) {\n\t\t\t\tis_prime = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is_prime) {\n\t\t\tif (i < 8) {\n\t\t\t\tinit[i] = frac(prime ** (1 / 2));\n\t\t\t}\n\n\t\t\tkey[i] = frac(prime ** (1 / 3));\n\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n/** @param {Uint8Array} bytes */\nfunction reverse_endianness(bytes) {\n\tfor (let i = 0; i < bytes.length; i += 4) {\n\t\tconst a = bytes[i + 0];\n\t\tconst b = bytes[i + 1];\n\t\tconst c = bytes[i + 2];\n\t\tconst d = bytes[i + 3];\n\n\t\tbytes[i + 0] = d;\n\t\tbytes[i + 1] = c;\n\t\tbytes[i + 2] = b;\n\t\tbytes[i + 3] = a;\n\t}\n}\n\n/** @param {string} str */\nfunction encode(str) {\n\tconst encoded = encoder.encode(str);\n\tconst length = encoded.length * 8;\n\n\t// result should be a multiple of 512 bits in length,\n\t// with room for a 1 (after the data) and two 32-bit\n\t// words containing the original input bit length\n\tconst size = 512 * Math.ceil((length + 65) / 512);\n\tconst bytes = new Uint8Array(size / 8);\n\tbytes.set(encoded);\n\n\t// append a 1\n\tbytes[encoded.length] = 0b10000000;\n\n\treverse_endianness(bytes);\n\n\t// add the input bit length\n\tconst words = new Uint32Array(bytes.buffer);\n\twords[words.length - 2] = Math.floor(length / 0x100000000); // this will always be zero for us\n\twords[words.length - 1] = length;\n\n\treturn words;\n}\n\n/*\n\tBased on https://gist.github.com/enepomnyaschih/72c423f727d395eeaa09697058238727\n\n\tMIT License\n\tCopyright (c) 2020 Egor Nepomnyaschih\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/** @param {Uint8Array} bytes */\nexport function base64(bytes) {\n\tconst l = bytes.length;\n\n\tlet result = '';\n\tlet i;\n\n\tfor (i = 2; i < l; i += 3) {\n\t\tresult += chars[bytes[i - 2] >> 2];\n\t\tresult += chars[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n\t\tresult += chars[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];\n\t\tresult += chars[bytes[i] & 0x3f];\n\t}\n\n\tif (i === l + 1) {\n\t\t// 1 octet yet to write\n\t\tresult += chars[bytes[i - 2] >> 2];\n\t\tresult += chars[(bytes[i - 2] & 0x03) << 4];\n\t\tresult += '==';\n\t}\n\n\tif (i === l) {\n\t\t// 2 octets yet to write\n\t\tresult += chars[bytes[i - 2] >> 2];\n\t\tresult += chars[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n\t\tresult += chars[(bytes[i - 1] & 0x0f) << 2];\n\t\tresult += '=';\n\t}\n\n\treturn result;\n}\n"}},"csp.js":{"file":{"contents":"import { escape_html_attr } from '../../../utils/escape.js';\nimport { base64, sha256 } from './crypto.js';\n\nconst array = new Uint8Array(16);\n\nfunction generate_nonce() {\n\tcrypto.getRandomValues(array);\n\treturn base64(array);\n}\n\nconst quoted = new Set([\n\t'self',\n\t'unsafe-eval',\n\t'unsafe-hashes',\n\t'unsafe-inline',\n\t'none',\n\t'strict-dynamic',\n\t'report-sample',\n\t'wasm-unsafe-eval',\n\t'script'\n]);\n\nconst crypto_pattern = /^(nonce|sha\\d\\d\\d)-/;\n\n// CSP and CSP Report Only are extremely similar with a few caveats\n// the easiest/DRYest way to express this is with some private encapsulation\nclass BaseProvider {\n\t/** @type {boolean} */\n\t#use_hashes;\n\n\t/** @type {boolean} */\n\t#script_needs_csp;\n\n\t/** @type {boolean} */\n\t#style_needs_csp;\n\n\t/** @type {import('types').CspDirectives} */\n\t#directives;\n\n\t/** @type {import('types').Csp.Source[]} */\n\t#script_src;\n\n\t/** @type {import('types').Csp.Source[]} */\n\t#style_src;\n\n\t/** @type {string} */\n\t#nonce;\n\n\t/**\n\t * @param {boolean} use_hashes\n\t * @param {import('types').CspDirectives} directives\n\t * @param {string} nonce\n\t */\n\tconstructor(use_hashes, directives, nonce) {\n\t\tthis.#use_hashes = use_hashes;\n\t\tthis.#directives = __SVELTEKIT_DEV__ ? { ...directives } : directives; // clone in dev so we can safely mutate\n\n\t\tconst d = this.#directives;\n\n\t\tif (__SVELTEKIT_DEV__) {\n\t\t\t// remove strict-dynamic in dev...\n\t\t\t// TODO reinstate this if we can figure out how to make strict-dynamic work\n\t\t\t// if (d['default-src']) {\n\t\t\t// \td['default-src'] = d['default-src'].filter((name) => name !== 'strict-dynamic');\n\t\t\t// \tif (d['default-src'].length === 0) delete d['default-src'];\n\t\t\t// }\n\n\t\t\t// if (d['script-src']) {\n\t\t\t// \td['script-src'] = d['script-src'].filter((name) => name !== 'strict-dynamic');\n\t\t\t// \tif (d['script-src'].length === 0) delete d['script-src'];\n\t\t\t// }\n\n\t\t\tconst effective_style_src = d['style-src'] || d['default-src'];\n\n\t\t\t// ...and add unsafe-inline so we can inject <style> elements\n\t\t\tif (effective_style_src && !effective_style_src.includes('unsafe-inline')) {\n\t\t\t\td['style-src'] = [...effective_style_src, 'unsafe-inline'];\n\t\t\t}\n\t\t}\n\n\t\tthis.#script_src = [];\n\t\tthis.#style_src = [];\n\n\t\tconst effective_script_src = d['script-src'] || d['default-src'];\n\t\tconst effective_style_src = d['style-src'] || d['default-src'];\n\n\t\tthis.#script_needs_csp =\n\t\t\t!!effective_script_src &&\n\t\t\teffective_script_src.filter((value) => value !== 'unsafe-inline').length > 0;\n\n\t\tthis.#style_needs_csp =\n\t\t\t!__SVELTEKIT_DEV__ &&\n\t\t\t!!effective_style_src &&\n\t\t\teffective_style_src.filter((value) => value !== 'unsafe-inline').length > 0;\n\n\t\tthis.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;\n\t\tthis.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;\n\t\tthis.#nonce = nonce;\n\t}\n\n\t/** @param {string} content */\n\tadd_script(content) {\n\t\tif (this.#script_needs_csp) {\n\t\t\tif (this.#use_hashes) {\n\t\t\t\tthis.#script_src.push(`sha256-${sha256(content)}`);\n\t\t\t} else if (this.#script_src.length === 0) {\n\t\t\t\tthis.#script_src.push(`nonce-${this.#nonce}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @param {string} content */\n\tadd_style(content) {\n\t\tif (this.#style_needs_csp) {\n\t\t\tif (this.#use_hashes) {\n\t\t\t\tthis.#style_src.push(`sha256-${sha256(content)}`);\n\t\t\t} else if (this.#style_src.length === 0) {\n\t\t\t\tthis.#style_src.push(`nonce-${this.#nonce}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {boolean} [is_meta]\n\t */\n\tget_header(is_meta = false) {\n\t\tconst header = [];\n\n\t\t// due to browser inconsistencies, we can't append sources to default-src\n\t\t// (specifically, Firefox appears to not ignore nonce-{nonce} directives\n\t\t// on default-src), so we ensure that script-src and style-src exist\n\n\t\tconst directives = { ...this.#directives };\n\n\t\tif (this.#style_src.length > 0) {\n\t\t\tdirectives['style-src'] = [\n\t\t\t\t...(directives['style-src'] || directives['default-src'] || []),\n\t\t\t\t...this.#style_src\n\t\t\t];\n\t\t}\n\n\t\tif (this.#script_src.length > 0) {\n\t\t\tdirectives['script-src'] = [\n\t\t\t\t...(directives['script-src'] || directives['default-src'] || []),\n\t\t\t\t...this.#script_src\n\t\t\t];\n\t\t}\n\n\t\tfor (const key in directives) {\n\t\t\tif (is_meta && (key === 'frame-ancestors' || key === 'report-uri' || key === 'sandbox')) {\n\t\t\t\t// these values cannot be used with a <meta> tag\n\t\t\t\t// TODO warn?\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// @ts-expect-error gimme a break typescript, `key` is obviously a member of internal_directives\n\t\t\tconst value = /** @type {string[] | true} */ (directives[key]);\n\n\t\t\tif (!value) continue;\n\n\t\t\tconst directive = [key];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue.forEach((value) => {\n\t\t\t\t\tif (quoted.has(value) || crypto_pattern.test(value)) {\n\t\t\t\t\t\tdirective.push(`'${value}'`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdirective.push(value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\theader.push(directive.join(' '));\n\t\t}\n\n\t\treturn header.join('; ');\n\t}\n}\n\nclass CspProvider extends BaseProvider {\n\tget_meta() {\n\t\tconst content = escape_html_attr(this.get_header(true));\n\t\treturn `<meta http-equiv=\"content-security-policy\" content=${content}>`;\n\t}\n}\n\nclass CspReportOnlyProvider extends BaseProvider {\n\t/**\n\t * @param {boolean} use_hashes\n\t * @param {import('types').CspDirectives} directives\n\t * @param {string} nonce\n\t */\n\tconstructor(use_hashes, directives, nonce) {\n\t\tsuper(use_hashes, directives, nonce);\n\n\t\tif (Object.values(directives).filter((v) => !!v).length > 0) {\n\t\t\t// If we're generating content-security-policy-report-only,\n\t\t\t// if there are any directives, we need a report-uri or report-to (or both)\n\t\t\t// else it's just an expensive noop.\n\t\t\tconst has_report_to = directives['report-to']?.length ?? 0 > 0;\n\t\t\tconst has_report_uri = directives['report-uri']?.length ?? 0 > 0;\n\t\t\tif (!has_report_to && !has_report_uri) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class Csp {\n\t/** @readonly */\n\tnonce = generate_nonce();\n\n\t/** @type {CspProvider} */\n\tcsp_provider;\n\n\t/** @type {CspReportOnlyProvider} */\n\treport_only_provider;\n\n\t/**\n\t * @param {import('./types').CspConfig} config\n\t * @param {import('./types').CspOpts} opts\n\t */\n\tconstructor({ mode, directives, reportOnly }, { prerender }) {\n\t\tconst use_hashes = mode === 'hash' || (mode === 'auto' && prerender);\n\t\tthis.csp_provider = new CspProvider(use_hashes, directives, this.nonce);\n\t\tthis.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);\n\t}\n\n\tget script_needs_nonce() {\n\t\treturn this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;\n\t}\n\n\tget style_needs_nonce() {\n\t\treturn this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;\n\t}\n\n\t/** @param {string} content */\n\tadd_script(content) {\n\t\tthis.csp_provider.add_script(content);\n\t\tthis.report_only_provider.add_script(content);\n\t}\n\n\t/** @param {string} content */\n\tadd_style(content) {\n\t\tthis.csp_provider.add_style(content);\n\t\tthis.report_only_provider.add_style(content);\n\t}\n}\n"}},"index.js":{"file":{"contents":"import { text } from '../../../exports/index.js';\nimport { compact } from '../../../utils/array.js';\nimport { normalize_error } from '../../../utils/error.js';\nimport { add_data_suffix } from '../../../utils/url.js';\nimport { HttpError, Redirect } from '../../control.js';\nimport { redirect_response, static_error_page, handle_error_and_jsonify } from '../utils.js';\nimport {\n\thandle_action_json_request,\n\thandle_action_request,\n\tis_action_json_request,\n\tis_action_request\n} from './actions.js';\nimport { load_data, load_server_data } from './load_data.js';\nimport { render_response } from './render.js';\nimport { respond_with_error } from './respond_with_error.js';\nimport { get_option } from '../../../utils/options.js';\nimport { get_data_json } from '../data/index.js';\n\n/**\n * The maximum request depth permitted before assuming we're stuck in an infinite loop\n */\nconst MAX_DEPTH = 10;\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').PageNodeIndexes} page\n * @param {import('types').SSROptions} options\n * @param {import('types').SSRManifest} manifest\n * @param {import('types').SSRState} state\n * @param {import('types').RequiredResolveOptions} resolve_opts\n * @returns {Promise<Response>}\n */\nexport async function render_page(event, page, options, manifest, state, resolve_opts) {\n\tif (state.depth > MAX_DEPTH) {\n\t\t// infinite request cycle detected\n\t\treturn text(`Not found: ${event.url.pathname}`, {\n\t\t\tstatus: 404 // TODO in some cases this should be 500. not sure how to differentiate\n\t\t});\n\t}\n\n\tif (is_action_json_request(event)) {\n\t\tconst node = await manifest._.nodes[page.leaf]();\n\t\treturn handle_action_json_request(event, options, node?.server);\n\t}\n\n\ttry {\n\t\tconst nodes = await Promise.all([\n\t\t\t// we use == here rather than === because [undefined] serializes as \"[null]\"\n\t\t\t...page.layouts.map((n) => (n == undefined ? n : manifest._.nodes[n]())),\n\t\t\tmanifest._.nodes[page.leaf]()\n\t\t]);\n\n\t\tconst leaf_node = /** @type {import('types').SSRNode} */ (nodes.at(-1));\n\n\t\tlet status = 200;\n\n\t\t/** @type {import('types').ActionResult | undefined} */\n\t\tlet action_result = undefined;\n\n\t\tif (is_action_request(event)) {\n\t\t\t// for action requests, first call handler in +page.server.js\n\t\t\t// (this also determines status code)\n\t\t\taction_result = await handle_action_request(event, leaf_node.server);\n\t\t\tif (action_result?.type === 'redirect') {\n\t\t\t\treturn redirect_response(action_result.status, action_result.location);\n\t\t\t}\n\t\t\tif (action_result?.type === 'error') {\n\t\t\t\tconst error = action_result.error;\n\t\t\t\tstatus = error instanceof HttpError ? error.status : 500;\n\t\t\t}\n\t\t\tif (action_result?.type === 'failure') {\n\t\t\t\tstatus = action_result.status;\n\t\t\t}\n\t\t}\n\n\t\tconst should_prerender_data = nodes.some((node) => node?.server);\n\t\tconst data_pathname = add_data_suffix(event.url.pathname);\n\n\t\t// it's crucial that we do this before returning the non-SSR response, otherwise\n\t\t// SvelteKit will erroneously believe that the path has been prerendered,\n\t\t// causing functions to be omitted from the manifesst generated later\n\t\tconst should_prerender = get_option(nodes, 'prerender');\n\n\t\tif (should_prerender) {\n\t\t\tconst mod = leaf_node.server;\n\t\t\tif (mod?.actions) {\n\t\t\t\tthrow new Error('Cannot prerender pages with actions');\n\t\t\t}\n\t\t} else if (state.prerendering) {\n\t\t\t// Try to render the shell when ssr is false and prerendering not explicitly disabled.\n\t\t\t// People can opt out of this behavior by explicitly setting prerender to false.\n\t\t\tif (\n\t\t\t\tshould_prerender !== false &&\n\t\t\t\tget_option(nodes, 'ssr') === false &&\n\t\t\t\t!leaf_node.server?.actions\n\t\t\t) {\n\t\t\t\treturn await render_response({\n\t\t\t\t\tbranch: [],\n\t\t\t\t\tfetched: [],\n\t\t\t\t\tpage_config: {\n\t\t\t\t\t\tssr: false,\n\t\t\t\t\t\tcsr: get_option(nodes, 'csr') ?? true\n\t\t\t\t\t},\n\t\t\t\t\tstatus,\n\t\t\t\t\terror: null,\n\t\t\t\t\tevent,\n\t\t\t\t\toptions,\n\t\t\t\t\tmanifest,\n\t\t\t\t\tstate,\n\t\t\t\t\tresolve_opts\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// if the page isn't marked as prerenderable, then bail out at this point\n\t\t\treturn new Response(undefined, {\n\t\t\t\tstatus: 204\n\t\t\t});\n\t\t}\n\n\t\t// if we fetch any endpoints while loading data for this page, they should\n\t\t// inherit the prerender option of the page\n\t\tstate.prerender_default = should_prerender;\n\n\t\t/** @type {import('./types').Fetched[]} */\n\t\tconst fetched = [];\n\n\t\tif (get_option(nodes, 'ssr') === false) {\n\t\t\treturn await render_response({\n\t\t\t\tbranch: [],\n\t\t\t\tfetched,\n\t\t\t\tpage_config: {\n\t\t\t\t\tssr: false,\n\t\t\t\t\tcsr: get_option(nodes, 'csr') ?? true\n\t\t\t\t},\n\t\t\t\tstatus,\n\t\t\t\terror: null,\n\t\t\t\tevent,\n\t\t\t\toptions,\n\t\t\t\tmanifest,\n\t\t\t\tstate,\n\t\t\t\tresolve_opts\n\t\t\t});\n\t\t}\n\n\t\t/** @type {Array<import('./types.js').Loaded | null>} */\n\t\tlet branch = [];\n\n\t\t/** @type {Error | null} */\n\t\tlet load_error = null;\n\n\t\t/** @type {Array<Promise<import('types').ServerDataNode | null>>} */\n\t\tconst server_promises = nodes.map((node, i) => {\n\t\t\tif (load_error) {\n\t\t\t\t// if an error happens immediately, don't bother with the rest of the nodes\n\t\t\t\tthrow load_error;\n\t\t\t}\n\n\t\t\treturn Promise.resolve().then(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif (node === leaf_node && action_result?.type === 'error') {\n\t\t\t\t\t\t// we wait until here to throw the error so that we can use\n\t\t\t\t\t\t// any nested +error.svelte components that were defined\n\t\t\t\t\t\tthrow action_result.error;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn await load_server_data({\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tparent: async () => {\n\t\t\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\t\t\tconst data = {};\n\t\t\t\t\t\t\tfor (let j = 0; j < i; j += 1) {\n\t\t\t\t\t\t\t\tconst parent = await server_promises[j];\n\t\t\t\t\t\t\t\tif (parent) Object.assign(data, await parent.data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tload_error = /** @type {Error} */ (e);\n\t\t\t\t\tthrow load_error;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tconst csr = get_option(nodes, 'csr') ?? true;\n\n\t\t/** @type {Array<Promise<Record<string, any> | null>>} */\n\t\tconst load_promises = nodes.map((node, i) => {\n\t\t\tif (load_error) throw load_error;\n\t\t\treturn Promise.resolve().then(async () => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await load_data({\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tfetched,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tparent: async () => {\n\t\t\t\t\t\t\tconst data = {};\n\t\t\t\t\t\t\tfor (let j = 0; j < i; j += 1) {\n\t\t\t\t\t\t\t\tObject.assign(data, await load_promises[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tresolve_opts,\n\t\t\t\t\t\tserver_data_promise: server_promises[i],\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tcsr\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tload_error = /** @type {Error} */ (e);\n\t\t\t\t\tthrow load_error;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\t// if we don't do this, rejections will be unhandled\n\t\tfor (const p of server_promises) p.catch(() => {});\n\t\tfor (const p of load_promises) p.catch(() => {});\n\n\t\tfor (let i = 0; i < nodes.length; i += 1) {\n\t\t\tconst node = nodes[i];\n\n\t\t\tif (node) {\n\t\t\t\ttry {\n\t\t\t\t\tconst server_data = await server_promises[i];\n\t\t\t\t\tconst data = await load_promises[i];\n\n\t\t\t\t\tbranch.push({ node, server_data, data });\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconst err = normalize_error(e);\n\n\t\t\t\t\tif (err instanceof Redirect) {\n\t\t\t\t\t\tif (state.prerendering && should_prerender_data) {\n\t\t\t\t\t\t\tconst body = JSON.stringify({\n\t\t\t\t\t\t\t\ttype: 'redirect',\n\t\t\t\t\t\t\t\tlocation: err.location\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tstate.prerendering.dependencies.set(data_pathname, {\n\t\t\t\t\t\t\t\tresponse: text(body),\n\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn redirect_response(err.status, err.location);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst status = err instanceof HttpError ? err.status : 500;\n\t\t\t\t\tconst error = await handle_error_and_jsonify(event, options, err);\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (page.errors[i]) {\n\t\t\t\t\t\t\tconst index = /** @type {number} */ (page.errors[i]);\n\t\t\t\t\t\t\tconst node = await manifest._.nodes[index]();\n\n\t\t\t\t\t\t\tlet j = i;\n\t\t\t\t\t\t\twhile (!branch[j]) j -= 1;\n\n\t\t\t\t\t\t\treturn await render_response({\n\t\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\tmanifest,\n\t\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\t\tresolve_opts,\n\t\t\t\t\t\t\t\tpage_config: { ssr: true, csr: true },\n\t\t\t\t\t\t\t\tstatus,\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t\tbranch: compact(branch.slice(0, j + 1)).concat({\n\t\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\t\t\t\tserver_data: null\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tfetched\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we're still here, it means the error happened in the root layout,\n\t\t\t\t\t// which means we have to fall back to error.html\n\t\t\t\t\treturn static_error_page(options, status, error.message);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// push an empty slot so we can rewind past gaps to the\n\t\t\t\t// layout that corresponds with an +error.svelte page\n\t\t\t\tbranch.push(null);\n\t\t\t}\n\t\t}\n\n\t\tif (state.prerendering && should_prerender_data) {\n\t\t\t// ndjson format\n\t\t\tlet { data, chunks } = get_data_json(\n\t\t\t\tevent,\n\t\t\t\toptions,\n\t\t\t\tbranch.map((node) => node?.server_data)\n\t\t\t);\n\n\t\t\tif (chunks) {\n\t\t\t\tfor await (const chunk of chunks) {\n\t\t\t\t\tdata += chunk;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.prerendering.dependencies.set(data_pathname, {\n\t\t\t\tresponse: text(data),\n\t\t\t\tbody: data\n\t\t\t});\n\t\t}\n\n\t\treturn await render_response({\n\t\t\tevent,\n\t\t\toptions,\n\t\t\tmanifest,\n\t\t\tstate,\n\t\t\tresolve_opts,\n\t\t\tpage_config: {\n\t\t\t\tcsr: get_option(nodes, 'csr') ?? true,\n\t\t\t\tssr: true\n\t\t\t},\n\t\t\tstatus,\n\t\t\terror: null,\n\t\t\tbranch: compact(branch),\n\t\t\taction_result,\n\t\t\tfetched\n\t\t});\n\t} catch (e) {\n\t\t// if we end up here, it means the data loaded successfully\n\t\t// but the page failed to render, or that a prerendering error occurred\n\t\treturn await respond_with_error({\n\t\t\tevent,\n\t\t\toptions,\n\t\t\tmanifest,\n\t\t\tstate,\n\t\t\tstatus: 500,\n\t\t\terror: e,\n\t\t\tresolve_opts\n\t\t});\n\t}\n}\n"}},"load_data.js":{"file":{"contents":"import { disable_search, make_trackable } from '../../../utils/url.js';\nimport { unwrap_promises } from '../../../utils/promises.js';\nimport { DEV } from 'esm-env';\nimport { validate_depends } from '../../shared.js';\n\n/**\n * Calls the user's server `load` function.\n * @param {{\n *   event: import('types').RequestEvent;\n *   state: import('types').SSRState;\n *   node: import('types').SSRNode | undefined;\n *   parent: () => Promise<Record<string, any>>;\n * }} opts\n * @returns {Promise<import('types').ServerDataNode | null>}\n */\nexport async function load_server_data({ event, state, node, parent }) {\n\tif (!node?.server) return null;\n\n\tlet done = false;\n\n\tconst uses = {\n\t\tdependencies: new Set(),\n\t\tparams: new Set(),\n\t\tparent: false,\n\t\troute: false,\n\t\turl: false\n\t};\n\n\tconst url = make_trackable(event.url, () => {\n\t\tif (DEV && done && !uses.url) {\n\t\t\tconsole.warn(\n\t\t\t\t`${node.server_id}: Accessing URL properties in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when the URL changes`\n\t\t\t);\n\t\t}\n\n\t\tuses.url = true;\n\t});\n\n\tif (state.prerendering) {\n\t\tdisable_search(url);\n\t}\n\n\tconst result = await node.server.load?.call(null, {\n\t\t...event,\n\t\tfetch: (info, init) => {\n\t\t\tconst url = new URL(info instanceof Request ? info.url : info, event.url);\n\n\t\t\tif (DEV && done && !uses.dependencies.has(url.href)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`${node.server_id}: Calling \\`event.fetch(...)\\` in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when the dependency is invalidated`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tuses.dependencies.add(url.href);\n\n\t\t\treturn event.fetch(info, init);\n\t\t},\n\t\t/** @param {string[]} deps */\n\t\tdepends: (...deps) => {\n\t\t\tfor (const dep of deps) {\n\t\t\t\tconst { href } = new URL(dep, event.url);\n\n\t\t\t\tif (DEV) {\n\t\t\t\t\tvalidate_depends(node.server_id, dep);\n\n\t\t\t\t\tif (done && !uses.dependencies.has(href)) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`${node.server_id}: Calling \\`depends(...)\\` in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when the dependency is invalidated`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuses.dependencies.add(href);\n\t\t\t}\n\t\t},\n\t\tparams: new Proxy(event.params, {\n\t\t\tget: (target, key) => {\n\t\t\t\tif (DEV && done && typeof key === 'string' && !uses.params.has(key)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`${node.server_id}: Accessing \\`params.${String(\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t)}\\` in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when the param changes`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tuses.params.add(key);\n\t\t\t\treturn target[/** @type {string} */ (key)];\n\t\t\t}\n\t\t}),\n\t\tparent: async () => {\n\t\t\tif (DEV && done && !uses.parent) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`${node.server_id}: Calling \\`parent(...)\\` in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when parent data changes`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tuses.parent = true;\n\t\t\treturn parent();\n\t\t},\n\t\troute: new Proxy(event.route, {\n\t\t\tget: (target, key) => {\n\t\t\t\tif (DEV && done && typeof key === 'string' && !uses.route) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`${node.server_id}: Accessing \\`route.${String(\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t)}\\` in a promise handler after \\`load(...)\\` has returned will not cause the function to re-run when the route changes`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tuses.route = true;\n\t\t\t\treturn target[/** @type {'id'} */ (key)];\n\t\t\t}\n\t\t}),\n\t\turl\n\t});\n\n\tconst data = result ? await unwrap_promises(result) : null;\n\tif (__SVELTEKIT_DEV__) {\n\t\tvalidate_load_response(data, /** @type {string} */ (event.route.id));\n\t}\n\n\tdone = true;\n\n\treturn {\n\t\ttype: 'data',\n\t\tdata,\n\t\tuses,\n\t\tslash: node.server.trailingSlash\n\t};\n}\n\n/**\n * Calls the user's `load` function.\n * @param {{\n *   event: import('types').RequestEvent;\n *   fetched: import('./types').Fetched[];\n *   node: import('types').SSRNode | undefined;\n *   parent: () => Promise<Record<string, any>>;\n *   resolve_opts: import('types').RequiredResolveOptions;\n *   server_data_promise: Promise<import('types').ServerDataNode | null>;\n *   state: import('types').SSRState;\n *   csr: boolean;\n * }} opts\n * @returns {Promise<Record<string, any | Promise<any>> | null>}\n */\nexport async function load_data({\n\tevent,\n\tfetched,\n\tnode,\n\tparent,\n\tserver_data_promise,\n\tstate,\n\tresolve_opts,\n\tcsr\n}) {\n\tconst server_data_node = await server_data_promise;\n\n\tif (!node?.universal?.load) {\n\t\treturn server_data_node?.data ?? null;\n\t}\n\n\tconst result = await node.universal.load.call(null, {\n\t\turl: event.url,\n\t\tparams: event.params,\n\t\tdata: server_data_node?.data ?? null,\n\t\troute: event.route,\n\t\tfetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),\n\t\tsetHeaders: event.setHeaders,\n\t\tdepends: () => {},\n\t\tparent\n\t});\n\n\tconst data = result ? await unwrap_promises(result) : null;\n\tif (__SVELTEKIT_DEV__) {\n\t\tvalidate_load_response(data, /** @type {string} */ (event.route.id));\n\t}\n\n\treturn data;\n}\n\n/**\n * @param {Pick<import('types').RequestEvent, 'fetch' | 'url' | 'request' | 'route'>} event\n * @param {import(\"types\").SSRState} state\n * @param {import(\"./types\").Fetched[]} fetched\n * @param {boolean} csr\n * @param {Pick<Required<import(\"types\").ResolveOptions>, 'filterSerializedResponseHeaders'>} resolve_opts\n */\nexport function create_universal_fetch(event, state, fetched, csr, resolve_opts) {\n\t/**\n\t * @param {URL | RequestInfo} input\n\t * @param {RequestInit} [init]\n\t */\n\treturn async (input, init) => {\n\t\tconst cloned_body = input instanceof Request && input.body ? input.clone().body : null;\n\t\tlet response = await event.fetch(input, init);\n\n\t\tconst url = new URL(input instanceof Request ? input.url : input, event.url);\n\t\tconst same_origin = url.origin === event.url.origin;\n\n\t\t/** @type {import('types').PrerenderDependency} */\n\t\tlet dependency;\n\n\t\tif (same_origin) {\n\t\t\tif (state.prerendering) {\n\t\t\t\tdependency = { response, body: null };\n\t\t\t\tstate.prerendering.dependencies.set(url.pathname, dependency);\n\t\t\t}\n\t\t} else {\n\t\t\t// simulate CORS errors and \"no access to body in no-cors mode\" server-side for consistency with client-side behaviour\n\t\t\tconst mode = input instanceof Request ? input.mode : init?.mode ?? 'cors';\n\t\t\tif (mode === 'no-cors') {\n\t\t\t\tresponse = new Response('', {\n\t\t\t\t\tstatus: response.status,\n\t\t\t\t\tstatusText: response.statusText,\n\t\t\t\t\theaders: response.headers\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst acao = response.headers.get('access-control-allow-origin');\n\t\t\t\tif (!acao || (acao !== event.url.origin && acao !== '*')) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`CORS error: ${\n\t\t\t\t\t\t\tacao ? 'Incorrect' : 'No'\n\t\t\t\t\t\t} 'Access-Control-Allow-Origin' header is present on the requested resource`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst proxy = new Proxy(response, {\n\t\t\tget(response, key, _receiver) {\n\t\t\t\tasync function text() {\n\t\t\t\t\tconst body = await response.text();\n\n\t\t\t\t\tif (!body || typeof body === 'string') {\n\t\t\t\t\t\tconst status_number = Number(response.status);\n\t\t\t\t\t\tif (isNaN(status_number)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`response.status is not a number. value: \"${\n\t\t\t\t\t\t\t\t\tresponse.status\n\t\t\t\t\t\t\t\t}\" type: ${typeof response.status}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfetched.push({\n\t\t\t\t\t\t\turl: same_origin ? url.href.slice(event.url.origin.length) : url.href,\n\t\t\t\t\t\t\tmethod: event.request.method,\n\t\t\t\t\t\t\trequest_body: /** @type {string | ArrayBufferView | undefined} */ (\n\t\t\t\t\t\t\t\tinput instanceof Request && cloned_body\n\t\t\t\t\t\t\t\t\t? await stream_to_string(cloned_body)\n\t\t\t\t\t\t\t\t\t: init?.body\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trequest_headers: init?.headers,\n\t\t\t\t\t\t\tresponse_body: body,\n\t\t\t\t\t\t\tresponse: response\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dependency) {\n\t\t\t\t\t\tdependency.body = body;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn body;\n\t\t\t\t}\n\n\t\t\t\tif (key === 'arrayBuffer') {\n\t\t\t\t\treturn async () => {\n\t\t\t\t\t\tconst buffer = await response.arrayBuffer();\n\n\t\t\t\t\t\tif (dependency) {\n\t\t\t\t\t\t\tdependency.body = new Uint8Array(buffer);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO should buffer be inlined into the page (albeit base64'd)?\n\t\t\t\t\t\t// any conditions in which it shouldn't be?\n\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (key === 'text') {\n\t\t\t\t\treturn text;\n\t\t\t\t}\n\n\t\t\t\tif (key === 'json') {\n\t\t\t\t\treturn async () => {\n\t\t\t\t\t\treturn JSON.parse(await text());\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn Reflect.get(response, key, response);\n\t\t\t}\n\t\t});\n\n\t\tif (csr) {\n\t\t\t// ensure that excluded headers can't be read\n\t\t\tconst get = response.headers.get;\n\t\t\tresponse.headers.get = (key) => {\n\t\t\t\tconst lower = key.toLowerCase();\n\t\t\t\tconst value = get.call(response.headers, lower);\n\t\t\t\tif (value && !lower.startsWith('x-sveltekit-')) {\n\t\t\t\t\tconst included = resolve_opts.filterSerializedResponseHeaders(lower, value);\n\t\t\t\t\tif (!included) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Failed to get response header \"${lower}\" — it must be included by the \\`filterSerializedResponseHeaders\\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}\n\n\t\treturn proxy;\n\t};\n}\n\n/**\n * @param {ReadableStream<Uint8Array>} stream\n */\nasync function stream_to_string(stream) {\n\tlet result = '';\n\tconst reader = stream.getReader();\n\tconst decoder = new TextDecoder();\n\twhile (true) {\n\t\tconst { done, value } = await reader.read();\n\t\tif (done) {\n\t\t\tbreak;\n\t\t}\n\t\tresult += decoder.decode(value);\n\t}\n\treturn result;\n}\n\n/**\n * @param {any} data\n * @param {string} [routeId]\n */\nfunction validate_load_response(data, routeId) {\n\tif (data != null && Object.getPrototypeOf(data) !== Object.prototype) {\n\t\tthrow new Error(\n\t\t\t`a load function related to route '${routeId}' returned ${\n\t\t\t\ttypeof data !== 'object'\n\t\t\t\t\t? `a ${typeof data}`\n\t\t\t\t\t: data instanceof Response\n\t\t\t\t\t? 'a Response object'\n\t\t\t\t\t: Array.isArray(data)\n\t\t\t\t\t? 'an array'\n\t\t\t\t\t: 'a non-plain object'\n\t\t\t}, but must return a plain object at the top level (i.e. \\`return {...}\\`)`\n\t\t);\n\t}\n}\n"}},"render.js":{"file":{"contents":"import * as devalue from 'devalue';\nimport { readable, writable } from 'svelte/store';\nimport { DEV } from 'esm-env';\nimport * as paths from '__sveltekit/paths';\nimport { hash } from '../../hash.js';\nimport { serialize_data } from './serialize_data.js';\nimport { s } from '../../../utils/misc.js';\nimport { Csp } from './csp.js';\nimport { uneval_action_response } from './actions.js';\nimport { clarify_devalue_error, stringify_uses, handle_error_and_jsonify } from '../utils.js';\nimport { public_env } from '../../shared-server.js';\nimport { text } from '../../../exports/index.js';\nimport { create_async_iterator } from '../../../utils/streaming.js';\nimport { SVELTE_KIT_ASSETS } from '../../../constants.js';\n\n// TODO rename this function/module\n\nconst updated = {\n\t...readable(false),\n\tcheck: () => false\n};\n\nconst encoder = new TextEncoder();\n\n/**\n * Creates the HTML response.\n * @param {{\n *   branch: Array<import('./types').Loaded>;\n *   fetched: Array<import('./types').Fetched>;\n *   options: import('types').SSROptions;\n *   manifest: import('types').SSRManifest;\n *   state: import('types').SSRState;\n *   page_config: { ssr: boolean; csr: boolean };\n *   status: number;\n *   error: App.Error | null;\n *   event: import('types').RequestEvent;\n *   resolve_opts: import('types').RequiredResolveOptions;\n *   action_result?: import('types').ActionResult;\n * }} opts\n */\nexport async function render_response({\n\tbranch,\n\tfetched,\n\toptions,\n\tmanifest,\n\tstate,\n\tpage_config,\n\tstatus,\n\terror = null,\n\tevent,\n\tresolve_opts,\n\taction_result\n}) {\n\tif (state.prerendering) {\n\t\tif (options.csp.mode === 'nonce') {\n\t\t\tthrow new Error('Cannot use prerendering if config.kit.csp.mode === \"nonce\"');\n\t\t}\n\n\t\tif (options.app_template_contains_nonce) {\n\t\t\tthrow new Error('Cannot use prerendering if page template contains %sveltekit.nonce%');\n\t\t}\n\t}\n\n\tconst { client } = manifest._;\n\n\tconst modulepreloads = new Set([...client.start.imports, ...client.app.imports]);\n\tconst stylesheets = new Set(client.app.stylesheets);\n\tconst fonts = new Set(client.app.fonts);\n\n\t/** @type {Set<string>} */\n\tconst link_header_preloads = new Set();\n\n\t/** @type {Map<string, string>} */\n\t// TODO if we add a client entry point one day, we will need to include inline_styles with the entry, otherwise stylesheets will be linked even if they are below inlineStyleThreshold\n\tconst inline_styles = new Map();\n\n\tlet rendered;\n\n\tconst form_value =\n\t\taction_result?.type === 'success' || action_result?.type === 'failure'\n\t\t\t? action_result.data ?? null\n\t\t\t: null;\n\n\t/** @type {string} */\n\tlet base = paths.base;\n\n\t/** @type {string} */\n\tlet assets = paths.assets;\n\n\t/**\n\t * An expression that will evaluate in the client to determine the resolved base path.\n\t * We use a relative path when possible to support IPFS, the internet archive, etc.\n\t */\n\tlet base_expression = s(paths.base);\n\n\t// if appropriate, use relative paths for greater portability\n\tif (paths.relative !== false && !state.prerendering?.fallback) {\n\t\tconst segments = event.url.pathname.slice(paths.base.length).split('/');\n\n\t\tif (segments.length === 1 && paths.base !== '') {\n\t\t\t// if we're on `/my-base-path`, relative links need to start `./my-base-path` rather than `.`\n\t\t\tbase = `./${paths.base.split('/').at(-1)}`;\n\n\t\t\tbase_expression = `new URL(${s(base)}, location).pathname`;\n\t\t} else {\n\t\t\tbase =\n\t\t\t\tsegments\n\t\t\t\t\t.slice(2)\n\t\t\t\t\t.map(() => '..')\n\t\t\t\t\t.join('/') || '.';\n\n\t\t\t// resolve e.g. '../..' against current location, then remove trailing slash\n\t\t\tbase_expression = `new URL(${s(base)}, location).pathname.slice(0, -1)`;\n\t\t}\n\n\t\tif (!paths.assets || (paths.assets[0] === '/' && paths.assets !== SVELTE_KIT_ASSETS)) {\n\t\t\tassets = base;\n\t\t}\n\t}\n\n\tif (page_config.ssr) {\n\t\tif (__SVELTEKIT_DEV__ && !branch.at(-1)?.node.component) {\n\t\t\t// Can only be the leaf, layouts have a fallback component generated\n\t\t\tthrow new Error(`Missing +page.svelte component for route ${event.route.id}`);\n\t\t}\n\n\t\t/** @type {Record<string, any>} */\n\t\tconst props = {\n\t\t\tstores: {\n\t\t\t\tpage: writable(null),\n\t\t\t\tnavigating: writable(null),\n\t\t\t\tupdated\n\t\t\t},\n\t\t\tconstructors: await Promise.all(branch.map(({ node }) => node.component())),\n\t\t\tform: form_value\n\t\t};\n\n\t\tlet data = {};\n\n\t\t// props_n (instead of props[n]) makes it easy to avoid\n\t\t// unnecessary updates for layout components\n\t\tfor (let i = 0; i < branch.length; i += 1) {\n\t\t\tdata = { ...data, ...branch[i].data };\n\t\t\tprops[`data_${i}`] = data;\n\t\t}\n\n\t\tprops.page = {\n\t\t\terror,\n\t\t\tparams: /** @type {Record<string, any>} */ (event.params),\n\t\t\troute: event.route,\n\t\t\tstatus,\n\t\t\turl: event.url,\n\t\t\tdata,\n\t\t\tform: form_value\n\t\t};\n\n\t\t// use relative paths during rendering, so that the resulting HTML is as\n\t\t// portable as possible, but reset afterwards\n\t\tif (paths.relative) paths.override({ base, assets });\n\n\t\tif (__SVELTEKIT_DEV__) {\n\t\t\tconst fetch = globalThis.fetch;\n\t\t\tlet warned = false;\n\t\t\tglobalThis.fetch = (info, init) => {\n\t\t\t\tif (typeof info === 'string' && !/^\\w+:\\/\\//.test(info)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot call \\`fetch\\` eagerly during server side rendering with relative URL (${info}) — put your \\`fetch\\` calls inside \\`onMount\\` or a \\`load\\` function instead`\n\t\t\t\t\t);\n\t\t\t\t} else if (!warned) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Avoid calling \\`fetch\\` eagerly during server side rendering — put your \\`fetch\\` calls inside \\`onMount\\` or a \\`load\\` function instead`\n\t\t\t\t\t);\n\t\t\t\t\twarned = true;\n\t\t\t\t}\n\n\t\t\t\treturn fetch(info, init);\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\trendered = options.root.render(props);\n\t\t\t} finally {\n\t\t\t\tglobalThis.fetch = fetch;\n\t\t\t\tpaths.reset();\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\trendered = options.root.render(props);\n\t\t\t} finally {\n\t\t\t\tpaths.reset();\n\t\t\t}\n\t\t}\n\n\t\tfor (const { node } of branch) {\n\t\t\tfor (const url of node.imports) modulepreloads.add(url);\n\t\t\tfor (const url of node.stylesheets) stylesheets.add(url);\n\t\t\tfor (const url of node.fonts) fonts.add(url);\n\n\t\t\tif (node.inline_styles) {\n\t\t\t\tObject.entries(await node.inline_styles()).forEach(([k, v]) => inline_styles.set(k, v));\n\t\t\t}\n\t\t}\n\t} else {\n\t\trendered = { head: '', html: '', css: { code: '', map: null } };\n\t}\n\n\tlet head = '';\n\tlet body = rendered.html;\n\n\tconst csp = new Csp(options.csp, {\n\t\tprerender: !!state.prerendering\n\t});\n\n\t/** @param {string} path */\n\tconst prefixed = (path) => {\n\t\tif (path.startsWith('/')) {\n\t\t\t// Vite makes the start script available through the base path and without it.\n\t\t\t// We load it via the base path in order to support remote IDE environments which proxy\n\t\t\t// all URLs under the base path during development.\n\t\t\treturn paths.base + path;\n\t\t}\n\t\treturn `${assets}/${path}`;\n\t};\n\n\tif (inline_styles.size > 0) {\n\t\tconst content = Array.from(inline_styles.values()).join('\\n');\n\n\t\tconst attributes = __SVELTEKIT_DEV__ ? [' data-sveltekit'] : [];\n\t\tif (csp.style_needs_nonce) attributes.push(` nonce=\"${csp.nonce}\"`);\n\n\t\tcsp.add_style(content);\n\n\t\thead += `\\n\\t<style${attributes.join('')}>${content}</style>`;\n\t}\n\n\tfor (const dep of stylesheets) {\n\t\tconst path = prefixed(dep);\n\n\t\tconst attributes = ['rel=\"stylesheet\"'];\n\n\t\tif (inline_styles.has(dep)) {\n\t\t\t// don't load stylesheets that are already inlined\n\t\t\t// include them in disabled state so that Vite can detect them and doesn't try to add them\n\t\t\tattributes.push('disabled', 'media=\"(max-width: 0)\"');\n\t\t} else {\n\t\t\tif (resolve_opts.preload({ type: 'css', path })) {\n\t\t\t\tconst preload_atts = ['rel=\"preload\"', 'as=\"style\"'];\n\t\t\t\tlink_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(';')}; nopush`);\n\t\t\t}\n\t\t}\n\n\t\thead += `\\n\\t\\t<link href=\"${path}\" ${attributes.join(' ')}>`;\n\t}\n\n\tfor (const dep of fonts) {\n\t\tconst path = prefixed(dep);\n\n\t\tif (resolve_opts.preload({ type: 'font', path })) {\n\t\t\tconst ext = dep.slice(dep.lastIndexOf('.') + 1);\n\t\t\tconst attributes = [\n\t\t\t\t'rel=\"preload\"',\n\t\t\t\t'as=\"font\"',\n\t\t\t\t`type=\"font/${ext}\"`,\n\t\t\t\t`href=\"${path}\"`,\n\t\t\t\t'crossorigin'\n\t\t\t];\n\n\t\t\thead += `\\n\\t\\t<link ${attributes.join(' ')}>`;\n\t\t}\n\t}\n\n\tconst global = `__sveltekit_${options.version_hash}`;\n\n\tconst { data, chunks } = get_data(\n\t\tevent,\n\t\toptions,\n\t\tbranch.map((b) => b.server_data),\n\t\tglobal\n\t);\n\n\tif (page_config.ssr && page_config.csr) {\n\t\tbody += `\\n\\t\\t\\t${fetched\n\t\t\t.map((item) =>\n\t\t\t\tserialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)\n\t\t\t)\n\t\t\t.join('\\n\\t\\t\\t')}`;\n\t}\n\n\tif (page_config.csr) {\n\t\tconst included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(\n\t\t\t(path) => resolve_opts.preload({ type: 'js', path })\n\t\t);\n\n\t\tfor (const path of included_modulepreloads) {\n\t\t\t// see the kit.output.preloadStrategy option for details on why we have multiple options here\n\t\t\tlink_header_preloads.add(`<${encodeURI(path)}>; rel=\"modulepreload\"; nopush`);\n\t\t\tif (options.preload_strategy !== 'modulepreload') {\n\t\t\t\thead += `\\n\\t\\t<link rel=\"preload\" as=\"script\" crossorigin=\"anonymous\" href=\"${path}\">`;\n\t\t\t} else if (state.prerendering) {\n\t\t\t\thead += `\\n\\t\\t<link rel=\"modulepreload\" href=\"${path}\">`;\n\t\t\t}\n\t\t}\n\n\t\tconst blocks = [];\n\n\t\tconst properties = [\n\t\t\t`env: ${s(public_env)}`,\n\t\t\tpaths.assets && `assets: ${s(paths.assets)}`,\n\t\t\t`base: ${base_expression}`,\n\t\t\t`element: document.currentScript.parentElement`\n\t\t].filter(Boolean);\n\n\t\tif (chunks) {\n\t\t\tblocks.push(`const deferred = new Map();`);\n\n\t\t\tproperties.push(`defer: (id) => new Promise((fulfil, reject) => {\n\t\t\t\t\t\t\tdeferred.set(id, { fulfil, reject });\n\t\t\t\t\t\t})`);\n\n\t\t\tproperties.push(`resolve: ({ id, data, error }) => {\n\t\t\t\t\t\t\tconst { fulfil, reject } = deferred.get(id);\n\t\t\t\t\t\t\tdeferred.delete(id);\n\n\t\t\t\t\t\t\tif (error) reject(error);\n\t\t\t\t\t\t\telse fulfil(data);\n\t\t\t\t\t\t}`);\n\t\t}\n\n\t\tblocks.push(`${global} = {\n\t\t\t\t\t\t${properties.join(',\\n\\t\\t\\t\\t\\t\\t')}\n\t\t\t\t\t};`);\n\n\t\tconst args = [`app`, `${global}.element`];\n\n\t\tif (page_config.ssr) {\n\t\t\tconst serialized = { form: 'null', error: 'null' };\n\n\t\t\tblocks.push(`const data = ${data};`);\n\n\t\t\tif (form_value) {\n\t\t\t\tserialized.form = uneval_action_response(\n\t\t\t\t\tform_value,\n\t\t\t\t\t/** @type {string} */ (event.route.id)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tserialized.error = devalue.uneval(error);\n\t\t\t}\n\n\t\t\tconst hydrate = [\n\t\t\t\t`node_ids: [${branch.map(({ node }) => node.index).join(', ')}]`,\n\t\t\t\t`data`,\n\t\t\t\t`form: ${serialized.form}`,\n\t\t\t\t`error: ${serialized.error}`\n\t\t\t];\n\n\t\t\tif (status !== 200) {\n\t\t\t\thydrate.push(`status: ${status}`);\n\t\t\t}\n\n\t\t\tif (options.embedded) {\n\t\t\t\thydrate.push(`params: ${devalue.uneval(event.params)}`, `route: ${s(event.route)}`);\n\t\t\t}\n\n\t\t\targs.push(`{\\n\\t\\t\\t\\t\\t\\t\\t${hydrate.join(',\\n\\t\\t\\t\\t\\t\\t\\t')}\\n\\t\\t\\t\\t\\t\\t}`);\n\t\t}\n\n\t\tblocks.push(`Promise.all([\n\t\t\t\t\t\timport(${s(prefixed(client.start.file))}),\n\t\t\t\t\t\timport(${s(prefixed(client.app.file))})\n\t\t\t\t\t]).then(([kit, app]) => {\n\t\t\t\t\t\tkit.start(${args.join(', ')});\n\t\t\t\t\t});`);\n\n\t\tif (options.service_worker) {\n\t\t\tconst opts = __SVELTEKIT_DEV__ ? `, { type: 'module' }` : '';\n\n\t\t\t// we use an anonymous function instead of an arrow function to support\n\t\t\t// older browsers (https://github.com/sveltejs/kit/pull/5417)\n\t\t\tblocks.push(`if ('serviceWorker' in navigator) {\n\t\t\t\t\t\taddEventListener('load', function () {\n\t\t\t\t\t\t\tnavigator.serviceWorker.register('${prefixed('service-worker.js')}'${opts});\n\t\t\t\t\t\t});\n\t\t\t\t\t}`);\n\t\t}\n\n\t\tconst init_app = `\n\t\t\t\t{\n\t\t\t\t\t${blocks.join('\\n\\n\\t\\t\\t\\t\\t')}\n\t\t\t\t}\n\t\t\t`;\n\t\tcsp.add_script(init_app);\n\n\t\tbody += `\\n\\t\\t\\t<script${\n\t\t\tcsp.script_needs_nonce ? ` nonce=\"${csp.nonce}\"` : ''\n\t\t}>${init_app}</script>\\n\\t\\t`;\n\t}\n\n\tconst headers = new Headers({\n\t\t'x-sveltekit-page': 'true',\n\t\t'content-type': 'text/html'\n\t});\n\n\tif (state.prerendering) {\n\t\t// TODO read headers set with setHeaders and convert into http-equiv where possible\n\t\tconst http_equiv = [];\n\n\t\tconst csp_headers = csp.csp_provider.get_meta();\n\t\tif (csp_headers) {\n\t\t\thttp_equiv.push(csp_headers);\n\t\t}\n\n\t\tif (state.prerendering.cache) {\n\t\t\thttp_equiv.push(`<meta http-equiv=\"cache-control\" content=\"${state.prerendering.cache}\">`);\n\t\t}\n\n\t\tif (http_equiv.length > 0) {\n\t\t\thead = http_equiv.join('\\n') + head;\n\t\t}\n\t} else {\n\t\tconst csp_header = csp.csp_provider.get_header();\n\t\tif (csp_header) {\n\t\t\theaders.set('content-security-policy', csp_header);\n\t\t}\n\t\tconst report_only_header = csp.report_only_provider.get_header();\n\t\tif (report_only_header) {\n\t\t\theaders.set('content-security-policy-report-only', report_only_header);\n\t\t}\n\n\t\tif (link_header_preloads.size) {\n\t\t\theaders.set('link', Array.from(link_header_preloads).join(', '));\n\t\t}\n\t}\n\n\t// add the content after the script/css links so the link elements are parsed first\n\thead += rendered.head;\n\n\tconst html = options.templates.app({\n\t\thead,\n\t\tbody,\n\t\tassets,\n\t\tnonce: /** @type {string} */ (csp.nonce),\n\t\tenv: public_env\n\t});\n\n\t// TODO flush chunks as early as we can\n\tconst transformed =\n\t\t(await resolve_opts.transformPageChunk({\n\t\t\thtml,\n\t\t\tdone: true\n\t\t})) || '';\n\n\tif (!chunks) {\n\t\theaders.set('etag', `\"${hash(transformed)}\"`);\n\t}\n\n\tif (DEV) {\n\t\tif (page_config.csr) {\n\t\t\tif (transformed.split('<!--').length < html.split('<!--').length) {\n\t\t\t\t// the \\u001B stuff is ANSI codes, so that we don't need to add a library to the runtime\n\t\t\t\t// https://svelte.dev/repl/1b3f49696f0c44c881c34587f2537aa2\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"\\u001B[1m\\u001B[31mRemoving comments in transformPageChunk can break Svelte's hydration\\u001B[39m\\u001B[22m\"\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (chunks) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'\\u001B[1m\\u001B[31mReturning promises from server `load` functions will only work if `csr === true`\\u001B[39m\\u001B[22m'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn !chunks\n\t\t? text(transformed, {\n\t\t\t\tstatus,\n\t\t\t\theaders\n\t\t  })\n\t\t: new Response(\n\t\t\t\tnew ReadableStream({\n\t\t\t\t\tasync start(controller) {\n\t\t\t\t\t\tcontroller.enqueue(encoder.encode(transformed + '\\n'));\n\t\t\t\t\t\tfor await (const chunk of chunks) {\n\t\t\t\t\t\t\tcontroller.enqueue(encoder.encode(chunk));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t},\n\n\t\t\t\t\ttype: 'bytes'\n\t\t\t\t}),\n\t\t\t\t{\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'text/html'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t  );\n}\n\n/**\n * If the serialized data contains promises, `chunks` will be an\n * async iterable containing their resolutions\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSROptions} options\n * @param {Array<import('types').ServerDataNode | null>} nodes\n * @param {string} global\n * @returns {{ data: string, chunks: AsyncIterable<string> | null }}\n */\nfunction get_data(event, options, nodes, global) {\n\tlet promise_id = 1;\n\tlet count = 0;\n\n\tconst { iterator, push, done } = create_async_iterator();\n\n\t/** @param {any} thing */\n\tfunction replacer(thing) {\n\t\tif (typeof thing?.then === 'function') {\n\t\t\tconst id = promise_id++;\n\t\t\tcount += 1;\n\n\t\t\tthing\n\t\t\t\t.then(/** @param {any} data */ (data) => ({ data }))\n\t\t\t\t.catch(\n\t\t\t\t\t/** @param {any} error */ async (error) => ({\n\t\t\t\t\t\terror: await handle_error_and_jsonify(event, options, error)\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t.then(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {{data: any; error: any}} result\n\t\t\t\t\t */\n\t\t\t\t\tasync ({ data, error }) => {\n\t\t\t\t\t\tcount -= 1;\n\n\t\t\t\t\t\tlet str;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstr = devalue.uneval({ id, data, error }, replacer);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\terror = await handle_error_and_jsonify(\n\t\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\tnew Error(`Failed to serialize promise while rendering ${event.route.id}`)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdata = undefined;\n\t\t\t\t\t\t\tstr = devalue.uneval({ id, data, error }, replacer);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpush(`<script>${global}.resolve(${str})</script>\\n`);\n\t\t\t\t\t\tif (count === 0) done();\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\treturn `${global}.defer(${id})`;\n\t\t}\n\t}\n\n\ttry {\n\t\tconst strings = nodes.map((node) => {\n\t\t\tif (!node) return 'null';\n\n\t\t\treturn `{\"type\":\"data\",\"data\":${devalue.uneval(node.data, replacer)},${stringify_uses(node)}${\n\t\t\t\tnode.slash ? `,\"slash\":${JSON.stringify(node.slash)}` : ''\n\t\t\t}}`;\n\t\t});\n\n\t\treturn {\n\t\t\tdata: `[${strings.join(',')}]`,\n\t\t\tchunks: count > 0 ? iterator : null\n\t\t};\n\t} catch (e) {\n\t\tthrow new Error(clarify_devalue_error(event, /** @type {any} */ (e)));\n\t}\n}\n"}},"respond_with_error.js":{"file":{"contents":"import { render_response } from './render.js';\nimport { load_data, load_server_data } from './load_data.js';\nimport { handle_error_and_jsonify, static_error_page, redirect_response } from '../utils.js';\nimport { get_option } from '../../../utils/options.js';\nimport { HttpError, Redirect } from '../../control.js';\n\n/**\n * @typedef {import('./types.js').Loaded} Loaded\n */\n\n/**\n * @param {{\n *   event: import('types').RequestEvent;\n *   options: import('types').SSROptions;\n *   manifest: import('types').SSRManifest;\n *   state: import('types').SSRState;\n *   status: number;\n *   error: unknown;\n *   resolve_opts: import('types').RequiredResolveOptions;\n * }} opts\n */\nexport async function respond_with_error({\n\tevent,\n\toptions,\n\tmanifest,\n\tstate,\n\tstatus,\n\terror,\n\tresolve_opts\n}) {\n\t/** @type {import('./types').Fetched[]} */\n\tconst fetched = [];\n\n\ttry {\n\t\tconst branch = [];\n\t\tconst default_layout = await manifest._.nodes[0](); // 0 is always the root layout\n\t\tconst ssr = get_option([default_layout], 'ssr') ?? true;\n\t\tconst csr = get_option([default_layout], 'csr') ?? true;\n\n\t\tif (ssr) {\n\t\t\tstate.error = true;\n\n\t\t\tconst server_data_promise = load_server_data({\n\t\t\t\tevent,\n\t\t\t\tstate,\n\t\t\t\tnode: default_layout,\n\t\t\t\tparent: async () => ({})\n\t\t\t});\n\n\t\t\tconst server_data = await server_data_promise;\n\n\t\t\tconst data = await load_data({\n\t\t\t\tevent,\n\t\t\t\tfetched,\n\t\t\t\tnode: default_layout,\n\t\t\t\tparent: async () => ({}),\n\t\t\t\tresolve_opts,\n\t\t\t\tserver_data_promise,\n\t\t\t\tstate,\n\t\t\t\tcsr\n\t\t\t});\n\n\t\t\tbranch.push(\n\t\t\t\t{\n\t\t\t\t\tnode: default_layout,\n\t\t\t\t\tserver_data,\n\t\t\t\t\tdata\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tnode: await manifest._.nodes[1](), // 1 is always the root error\n\t\t\t\t\tdata: null,\n\t\t\t\t\tserver_data: null\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn await render_response({\n\t\t\toptions,\n\t\t\tmanifest,\n\t\t\tstate,\n\t\t\tpage_config: {\n\t\t\t\tssr,\n\t\t\t\tcsr: get_option([default_layout], 'csr') ?? true\n\t\t\t},\n\t\t\tstatus,\n\t\t\terror: await handle_error_and_jsonify(event, options, error),\n\t\t\tbranch,\n\t\t\tfetched,\n\t\t\tevent,\n\t\t\tresolve_opts\n\t\t});\n\t} catch (e) {\n\t\t// Edge case: If route is a 404 and the user redirects to somewhere from the root layout,\n\t\t// we end up here.\n\t\tif (e instanceof Redirect) {\n\t\t\treturn redirect_response(e.status, e.location);\n\t\t}\n\n\t\treturn static_error_page(\n\t\t\toptions,\n\t\t\te instanceof HttpError ? e.status : 500,\n\t\t\t(await handle_error_and_jsonify(event, options, e)).message\n\t\t);\n\t}\n}\n"}},"serialize_data.js":{"file":{"contents":"import { escape_html_attr } from '../../../utils/escape.js';\nimport { hash } from '../../hash.js';\n\n/**\n * Inside a script element, only `</script` and `<!--` hold special meaning to the HTML parser.\n *\n * The first closes the script element, so everything after is treated as raw HTML.\n * The second disables further parsing until `-->`, so the script element might be unexpectedly\n * kept open until until an unrelated HTML comment in the page.\n *\n * U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR are escaped for the sake of pre-2018\n * browsers.\n *\n * @see tests for unsafe parsing examples.\n * @see https://html.spec.whatwg.org/multipage/scripting.html#restrictions-for-contents-of-script-elements\n * @see https://html.spec.whatwg.org/multipage/syntax.html#cdata-rcdata-restrictions\n * @see https://html.spec.whatwg.org/multipage/parsing.html#script-data-state\n * @see https://html.spec.whatwg.org/multipage/parsing.html#script-data-double-escaped-state\n * @see https://github.com/tc39/proposal-json-superset\n * @type {Record<string, string>}\n */\nconst replacements = {\n\t'<': '\\\\u003C',\n\t'\\u2028': '\\\\u2028',\n\t'\\u2029': '\\\\u2029'\n};\n\nconst pattern = new RegExp(`[${Object.keys(replacements).join('')}]`, 'g');\n\n/**\n * Generates a raw HTML string containing a safe script element carrying data and associated attributes.\n *\n * It escapes all the special characters needed to guarantee the element is unbroken, but care must\n * be taken to ensure it is inserted in the document at an acceptable position for a script element,\n * and that the resulting string isn't further modified.\n *\n * @param {import('./types.js').Fetched} fetched\n * @param {(name: string, value: string) => boolean} filter\n * @param {boolean} [prerendering]\n * @returns {string} The raw HTML of a script element carrying the JSON payload.\n * @example const html = serialize_data('/data.json', null, { foo: 'bar' });\n */\nexport function serialize_data(fetched, filter, prerendering = false) {\n\t/** @type {Record<string, string>} */\n\tconst headers = {};\n\n\tlet cache_control = null;\n\tlet age = null;\n\tlet vary = false;\n\n\tfor (const [key, value] of fetched.response.headers) {\n\t\tif (filter(key, value)) {\n\t\t\theaders[key] = value;\n\t\t}\n\n\t\tif (key === 'cache-control') cache_control = value;\n\t\tif (key === 'age') age = value;\n\t\tif (key === 'vary') vary = true;\n\t}\n\n\tconst payload = {\n\t\tstatus: fetched.response.status,\n\t\tstatusText: fetched.response.statusText,\n\t\theaders,\n\t\tbody: fetched.response_body\n\t};\n\n\tconst safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);\n\n\tconst attrs = [\n\t\t'type=\"application/json\"',\n\t\t'data-sveltekit-fetched',\n\t\t`data-url=${escape_html_attr(fetched.url)}`\n\t];\n\n\tif (fetched.request_headers || fetched.request_body) {\n\t\t/** @type {import('types').StrictBody[]} */\n\t\tconst values = [];\n\n\t\tif (fetched.request_headers) {\n\t\t\tvalues.push([...new Headers(fetched.request_headers)].join(','));\n\t\t}\n\n\t\tif (fetched.request_body) {\n\t\t\tvalues.push(fetched.request_body);\n\t\t}\n\n\t\tattrs.push(`data-hash=\"${hash(...values)}\"`);\n\t}\n\n\t// Compute the time the response should be cached, taking into account max-age and age.\n\t// Do not cache at all if a vary header is present, as this indicates that the cache is\n\t// likely to get busted. It would also mean we'd have to add more logic to computing the\n\t// selector on the client which results in more code for 99% of people for the 1% who use vary.\n\tif (!prerendering && fetched.method === 'GET' && cache_control && !vary) {\n\t\tconst match = /s-maxage=(\\d+)/g.exec(cache_control) ?? /max-age=(\\d+)/g.exec(cache_control);\n\t\tif (match) {\n\t\t\tconst ttl = +match[1] - +(age ?? '0');\n\t\t\tattrs.push(`data-ttl=\"${ttl}\"`);\n\t\t}\n\t}\n\n\treturn `<script ${attrs.join(' ')}>${safe_payload}</script>`;\n}\n"}},"types.d.ts":{"file":{"contents":"import { CookieSerializeOptions } from 'cookie';\nimport { SSRNode, CspDirectives, ServerDataNode } from 'types';\n\nexport interface Fetched {\n\turl: string;\n\tmethod: string;\n\trequest_body?: string | ArrayBufferView | null;\n\trequest_headers?: HeadersInit | undefined;\n\tresponse_body: string;\n\tresponse: Response;\n}\n\nexport type Loaded = {\n\tnode: SSRNode;\n\tdata: Record<string, any> | null;\n\tserver_data: ServerDataNode | null;\n};\n\ntype CspMode = 'hash' | 'nonce' | 'auto';\n\nexport interface CspConfig {\n\tmode: CspMode;\n\tdirectives: CspDirectives;\n\treportOnly: CspDirectives;\n}\n\nexport interface CspOpts {\n\tprerender: boolean;\n}\n\nexport interface Cookie {\n\tname: string;\n\tvalue: string;\n\toptions: CookieSerializeOptions;\n}\n"}}}},"respond.js":{"file":{"contents":"import { DEV } from 'esm-env';\nimport { base } from '__sveltekit/paths';\nimport { is_endpoint_request, render_endpoint } from './endpoint.js';\nimport { render_page } from './page/index.js';\nimport { render_response } from './page/render.js';\nimport { respond_with_error } from './page/respond_with_error.js';\nimport { is_form_content_type } from '../../utils/http.js';\nimport { handle_fatal_error, redirect_response } from './utils.js';\nimport {\n\tdecode_pathname,\n\tdecode_params,\n\tdisable_search,\n\thas_data_suffix,\n\tnormalize_path,\n\tstrip_data_suffix\n} from '../../utils/url.js';\nimport { exec } from '../../utils/routing.js';\nimport { INVALIDATED_PARAM, redirect_json_response, render_data } from './data/index.js';\nimport { add_cookies_to_headers, get_cookies } from './cookie.js';\nimport { create_fetch } from './fetch.js';\nimport { Redirect } from '../control.js';\nimport {\n\tvalidate_common_exports,\n\tvalidate_page_server_exports,\n\tvalidate_server_exports\n} from '../../utils/exports.js';\nimport { get_option } from '../../utils/options.js';\nimport { error, json, text } from '../../exports/index.js';\n\n/* global __SVELTEKIT_ADAPTER_NAME__ */\n\n/** @type {import('types').RequiredResolveOptions['transformPageChunk']} */\nconst default_transform = ({ html }) => html;\n\n/** @type {import('types').RequiredResolveOptions['filterSerializedResponseHeaders']} */\nconst default_filter = () => false;\n\n/** @type {import('types').RequiredResolveOptions['preload']} */\nconst default_preload = ({ type }) => type === 'js' || type === 'css';\n\n/**\n * @param {Request} request\n * @param {import('types').SSROptions} options\n * @param {import('types').SSRManifest} manifest\n * @param {import('types').SSRState} state\n * @returns {Promise<Response>}\n */\nexport async function respond(request, options, manifest, state) {\n\t/** URL but stripped from the potential `/__data.json` suffix and its search param  */\n\tlet url = new URL(request.url);\n\n\tif (options.csrf_check_origin) {\n\t\tconst forbidden =\n\t\t\trequest.method === 'POST' &&\n\t\t\trequest.headers.get('origin') !== url.origin &&\n\t\t\tis_form_content_type(request);\n\n\t\tif (forbidden) {\n\t\t\tconst csrf_error = error(403, `Cross-site ${request.method} form submissions are forbidden`);\n\t\t\tif (request.headers.get('accept') === 'application/json') {\n\t\t\t\treturn json(csrf_error.body, { status: csrf_error.status });\n\t\t\t}\n\t\t\treturn text(csrf_error.body.message, { status: csrf_error.status });\n\t\t}\n\t}\n\n\tlet decoded;\n\ttry {\n\t\tdecoded = decode_pathname(url.pathname);\n\t} catch {\n\t\treturn text('Malformed URI', { status: 400 });\n\t}\n\n\t/** @type {import('types').SSRRoute | null} */\n\tlet route = null;\n\n\t/** @type {Record<string, string>} */\n\tlet params = {};\n\n\tif (base && !state.prerendering?.fallback) {\n\t\tif (!decoded.startsWith(base)) {\n\t\t\treturn text('Not found', { status: 404 });\n\t\t}\n\t\tdecoded = decoded.slice(base.length) || '/';\n\t}\n\n\tconst is_data_request = has_data_suffix(decoded);\n\t/** @type {boolean[] | undefined} */\n\tlet invalidated_data_nodes;\n\tif (is_data_request) {\n\t\tdecoded = strip_data_suffix(decoded) || '/';\n\t\turl.pathname = strip_data_suffix(url.pathname) || '/';\n\t\tinvalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split('_').map(Boolean);\n\t\turl.searchParams.delete(INVALIDATED_PARAM);\n\t}\n\n\tif (!state.prerendering?.fallback) {\n\t\t// TODO this could theoretically break — should probably be inside a try-catch\n\t\tconst matchers = await manifest._.matchers();\n\n\t\tfor (const candidate of manifest._.routes) {\n\t\t\tconst match = candidate.pattern.exec(decoded);\n\t\t\tif (!match) continue;\n\n\t\t\tconst matched = exec(match, candidate.params, matchers);\n\t\t\tif (matched) {\n\t\t\t\troute = candidate;\n\t\t\t\tparams = decode_params(matched);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {import('types').TrailingSlash | void} */\n\tlet trailing_slash = undefined;\n\n\t/** @type {Record<string, string>} */\n\tconst headers = {};\n\n\t/** @type {Record<string, import('./page/types').Cookie>} */\n\tlet cookies_to_add = {};\n\n\t/** @type {import('types').RequestEvent} */\n\tconst event = {\n\t\t// @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself\n\t\tcookies: null,\n\t\t// @ts-expect-error\n\t\tfetch: null,\n\t\tgetClientAddress:\n\t\t\tstate.getClientAddress ||\n\t\t\t(() => {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`${__SVELTEKIT_ADAPTER_NAME__} does not specify getClientAddress. Please raise an issue`\n\t\t\t\t);\n\t\t\t}),\n\t\tlocals: {},\n\t\tparams,\n\t\tplatform: state.platform,\n\t\trequest,\n\t\troute: { id: route?.id ?? null },\n\t\tsetHeaders: (new_headers) => {\n\t\t\tfor (const key in new_headers) {\n\t\t\t\tconst lower = key.toLowerCase();\n\t\t\t\tconst value = new_headers[key];\n\n\t\t\t\tif (lower === 'set-cookie') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Use \\`event.cookies.set(name, value, options)\\` instead of \\`event.setHeaders\\` to set cookies`\n\t\t\t\t\t);\n\t\t\t\t} else if (lower in headers) {\n\t\t\t\t\tthrow new Error(`\"${key}\" header is already set`);\n\t\t\t\t} else {\n\t\t\t\t\theaders[lower] = value;\n\n\t\t\t\t\tif (state.prerendering && lower === 'cache-control') {\n\t\t\t\t\t\tstate.prerendering.cache = /** @type {string} */ (value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\turl,\n\t\tisDataRequest: is_data_request\n\t};\n\n\t/** @type {import('types').RequiredResolveOptions} */\n\tlet resolve_opts = {\n\t\ttransformPageChunk: default_transform,\n\t\tfilterSerializedResponseHeaders: default_filter,\n\t\tpreload: default_preload\n\t};\n\n\ttry {\n\t\t// determine whether we need to redirect to add/remove a trailing slash\n\t\tif (route && !is_data_request) {\n\t\t\tif (route.page) {\n\t\t\t\tconst nodes = await Promise.all([\n\t\t\t\t\t// we use == here rather than === because [undefined] serializes as \"[null]\"\n\t\t\t\t\t...route.page.layouts.map((n) => (n == undefined ? n : manifest._.nodes[n]())),\n\t\t\t\t\tmanifest._.nodes[route.page.leaf]()\n\t\t\t\t]);\n\n\t\t\t\tif (DEV) {\n\t\t\t\t\tconst layouts = nodes.slice(0, -1);\n\t\t\t\t\tconst page = nodes.at(-1);\n\n\t\t\t\t\tfor (const layout of layouts) {\n\t\t\t\t\t\tif (layout) {\n\t\t\t\t\t\t\tvalidate_common_exports(layout.server, /** @type {string} */ (layout.server_id));\n\t\t\t\t\t\t\tvalidate_common_exports(\n\t\t\t\t\t\t\t\tlayout.universal,\n\t\t\t\t\t\t\t\t/** @type {string} */ (layout.universal_id)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (page) {\n\t\t\t\t\t\tvalidate_page_server_exports(page.server, /** @type {string} */ (page.server_id));\n\t\t\t\t\t\tvalidate_common_exports(page.universal, /** @type {string} */ (page.universal_id));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttrailing_slash = get_option(nodes, 'trailingSlash');\n\t\t\t} else if (route.endpoint) {\n\t\t\t\tconst node = await route.endpoint();\n\t\t\t\ttrailing_slash = node.trailingSlash;\n\n\t\t\t\tif (DEV) {\n\t\t\t\t\tvalidate_server_exports(node, /** @type {string} */ (route.endpoint_id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst normalized = normalize_path(url.pathname, trailing_slash ?? 'never');\n\n\t\t\tif (normalized !== url.pathname && !state.prerendering?.fallback) {\n\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\tstatus: 301,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-sveltekit-normalize': '1',\n\t\t\t\t\t\tlocation:\n\t\t\t\t\t\t\t// ensure paths starting with '//' are not treated as protocol-relative\n\t\t\t\t\t\t\t(normalized.startsWith('//') ? url.origin + normalized : normalized) +\n\t\t\t\t\t\t\t(url.search === '?' ? '' : url.search)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst { cookies, new_cookies, get_cookie_header } = get_cookies(\n\t\t\trequest,\n\t\t\turl,\n\t\t\ttrailing_slash ?? 'never'\n\t\t);\n\n\t\tcookies_to_add = new_cookies;\n\t\tevent.cookies = cookies;\n\t\tevent.fetch = create_fetch({ event, options, manifest, state, get_cookie_header });\n\n\t\tif (state.prerendering && !state.prerendering.fallback) disable_search(url);\n\n\t\tconst response = await options.hooks.handle({\n\t\t\tevent,\n\t\t\tresolve: (event, opts) =>\n\t\t\t\tresolve(event, opts).then((response) => {\n\t\t\t\t\t// add headers/cookies here, rather than inside `resolve`, so that we\n\t\t\t\t\t// can do it once for all responses instead of once per `return`\n\t\t\t\t\tfor (const key in headers) {\n\t\t\t\t\t\tconst value = headers[key];\n\t\t\t\t\t\tresponse.headers.set(key, /** @type {string} */ (value));\n\t\t\t\t\t}\n\n\t\t\t\t\tadd_cookies_to_headers(response.headers, Object.values(cookies_to_add));\n\n\t\t\t\t\tif (state.prerendering && event.route.id !== null) {\n\t\t\t\t\t\tresponse.headers.set('x-sveltekit-routeid', encodeURI(event.route.id));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn response;\n\t\t\t\t})\n\t\t});\n\n\t\t// respond with 304 if etag matches\n\t\tif (response.status === 200 && response.headers.has('etag')) {\n\t\t\tlet if_none_match_value = request.headers.get('if-none-match');\n\n\t\t\t// ignore W/ prefix https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match#directives\n\t\t\tif (if_none_match_value?.startsWith('W/\"')) {\n\t\t\t\tif_none_match_value = if_none_match_value.substring(2);\n\t\t\t}\n\n\t\t\tconst etag = /** @type {string} */ (response.headers.get('etag'));\n\n\t\t\tif (if_none_match_value === etag) {\n\t\t\t\tconst headers = new Headers({ etag });\n\n\t\t\t\t// https://datatracker.ietf.org/doc/html/rfc7232#section-4.1 + set-cookie\n\t\t\t\tfor (const key of [\n\t\t\t\t\t'cache-control',\n\t\t\t\t\t'content-location',\n\t\t\t\t\t'date',\n\t\t\t\t\t'expires',\n\t\t\t\t\t'vary',\n\t\t\t\t\t'set-cookie'\n\t\t\t\t]) {\n\t\t\t\t\tconst value = response.headers.get(key);\n\t\t\t\t\tif (value) headers.set(key, value);\n\t\t\t\t}\n\n\t\t\t\treturn new Response(undefined, {\n\t\t\t\t\tstatus: 304,\n\t\t\t\t\theaders\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Edge case: If user does `return Response(30x)` in handle hook while processing a data request,\n\t\t// we need to transform the redirect response to a corresponding JSON response.\n\t\tif (is_data_request && response.status >= 300 && response.status <= 308) {\n\t\t\tconst location = response.headers.get('location');\n\t\t\tif (location) {\n\t\t\t\treturn redirect_json_response(new Redirect(/** @type {any} */ (response.status), location));\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t} catch (e) {\n\t\tif (e instanceof Redirect) {\n\t\t\tconst response = is_data_request\n\t\t\t\t? redirect_json_response(e)\n\t\t\t\t: redirect_response(e.status, e.location);\n\t\t\tadd_cookies_to_headers(response.headers, Object.values(cookies_to_add));\n\t\t\treturn response;\n\t\t}\n\t\treturn await handle_fatal_error(event, options, e);\n\t}\n\n\t/**\n\t *\n\t * @param {import('types').RequestEvent} event\n\t * @param {import('types').ResolveOptions} [opts]\n\t */\n\tasync function resolve(event, opts) {\n\t\ttry {\n\t\t\tif (opts) {\n\t\t\t\tif ('ssr' in opts) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'ssr has been removed, set it in the appropriate +layout.js instead. See the PR for more information: https://github.com/sveltejs/kit/pull/6197'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresolve_opts = {\n\t\t\t\t\ttransformPageChunk: opts.transformPageChunk || default_transform,\n\t\t\t\t\tfilterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,\n\t\t\t\t\tpreload: opts.preload || default_preload\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (state.prerendering?.fallback) {\n\t\t\t\treturn await render_response({\n\t\t\t\t\tevent,\n\t\t\t\t\toptions,\n\t\t\t\t\tmanifest,\n\t\t\t\t\tstate,\n\t\t\t\t\tpage_config: { ssr: false, csr: true },\n\t\t\t\t\tstatus: 200,\n\t\t\t\t\terror: null,\n\t\t\t\t\tbranch: [],\n\t\t\t\t\tfetched: [],\n\t\t\t\t\tresolve_opts\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (route) {\n\t\t\t\t/** @type {Response} */\n\t\t\t\tlet response;\n\n\t\t\t\tif (is_data_request) {\n\t\t\t\t\tresponse = await render_data(\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\troute,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tmanifest,\n\t\t\t\t\t\tstate,\n\t\t\t\t\t\tinvalidated_data_nodes,\n\t\t\t\t\t\ttrailing_slash ?? 'never'\n\t\t\t\t\t);\n\t\t\t\t} else if (route.endpoint && (!route.page || is_endpoint_request(event))) {\n\t\t\t\t\tresponse = await render_endpoint(event, await route.endpoint(), state);\n\t\t\t\t} else if (route.page) {\n\t\t\t\t\tresponse = await render_page(event, route.page, options, manifest, state, resolve_opts);\n\t\t\t\t} else {\n\t\t\t\t\t// a route will always have a page or an endpoint, but TypeScript\n\t\t\t\t\t// doesn't know that\n\t\t\t\t\tthrow new Error('This should never happen');\n\t\t\t\t}\n\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\tif (state.error) {\n\t\t\t\treturn text('Internal Server Error', {\n\t\t\t\t\tstatus: 500\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// if this request came direct from the user, rather than\n\t\t\t// via our own `fetch`, render a 404 page\n\t\t\tif (state.depth === 0) {\n\t\t\t\treturn await respond_with_error({\n\t\t\t\t\tevent,\n\t\t\t\t\toptions,\n\t\t\t\t\tmanifest,\n\t\t\t\t\tstate,\n\t\t\t\t\tstatus: 404,\n\t\t\t\t\terror: new Error(`Not found: ${event.url.pathname}`),\n\t\t\t\t\tresolve_opts\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (state.prerendering) {\n\t\t\t\treturn text('not found', { status: 404 });\n\t\t\t}\n\n\t\t\t// we can't load the endpoint from our own manifest,\n\t\t\t// so we need to make an actual HTTP request\n\t\t\treturn await fetch(request);\n\t\t} catch (e) {\n\t\t\t// TODO if `e` is instead named `error`, some fucked up Vite transformation happens\n\t\t\t// and I don't even know how to describe it. need to investigate at some point\n\n\t\t\t// HttpError from endpoint can end up here - TODO should it be handled there instead?\n\t\t\treturn await handle_fatal_error(event, options, e);\n\t\t} finally {\n\t\t\tevent.cookies.set = () => {\n\t\t\t\tthrow new Error('Cannot use `cookies.set(...)` after the response has been generated');\n\t\t\t};\n\n\t\t\tevent.setHeaders = () => {\n\t\t\t\tthrow new Error('Cannot use `setHeaders(...)` after the response has been generated');\n\t\t\t};\n\t\t}\n\t}\n}\n"}},"utils.js":{"file":{"contents":"import { json, text } from '../../exports/index.js';\nimport { coalesce_to_error } from '../../utils/error.js';\nimport { negotiate } from '../../utils/http.js';\nimport { HttpError } from '../control.js';\nimport { fix_stack_trace } from '../shared-server.js';\n\n/** @param {any} body */\nexport function is_pojo(body) {\n\tif (typeof body !== 'object') return false;\n\n\tif (body) {\n\t\tif (body instanceof Uint8Array) return false;\n\t\tif (body instanceof ReadableStream) return false;\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {Partial<Record<import('types').HttpMethod, any>>} mod\n * @param {import('types').HttpMethod} method\n */\nexport function method_not_allowed(mod, method) {\n\treturn text(`${method} method not allowed`, {\n\t\tstatus: 405,\n\t\theaders: {\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405\n\t\t\t// \"The server must generate an Allow header field in a 405 status code response\"\n\t\t\tallow: allowed_methods(mod).join(', ')\n\t\t}\n\t});\n}\n\n/** @param {Partial<Record<import('types').HttpMethod, any>>} mod */\nexport function allowed_methods(mod) {\n\tconst allowed = [];\n\n\tfor (const method in ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']) {\n\t\tif (method in mod) allowed.push(method);\n\t}\n\n\tif (mod.GET || mod.HEAD) allowed.push('HEAD');\n\n\treturn allowed;\n}\n\n/**\n * Return as a response that renders the error.html\n *\n * @param {import('types').SSROptions} options\n * @param {number} status\n * @param {string} message\n */\nexport function static_error_page(options, status, message) {\n\treturn text(options.templates.error({ status, message }), {\n\t\theaders: { 'content-type': 'text/html; charset=utf-8' },\n\t\tstatus\n\t});\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSROptions} options\n * @param {unknown} error\n */\nexport async function handle_fatal_error(event, options, error) {\n\terror = error instanceof HttpError ? error : coalesce_to_error(error);\n\tconst status = error instanceof HttpError ? error.status : 500;\n\tconst body = await handle_error_and_jsonify(event, options, error);\n\n\t// ideally we'd use sec-fetch-dest instead, but Safari — quelle surprise — doesn't support it\n\tconst type = negotiate(event.request.headers.get('accept') || 'text/html', [\n\t\t'application/json',\n\t\t'text/html'\n\t]);\n\n\tif (event.isDataRequest || type === 'application/json') {\n\t\treturn json(body, {\n\t\t\tstatus\n\t\t});\n\t}\n\n\treturn static_error_page(options, status, body.message);\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {import('types').SSROptions} options\n * @param {any} error\n * @returns {Promise<App.Error>}\n */\nexport async function handle_error_and_jsonify(event, options, error) {\n\tif (error instanceof HttpError) {\n\t\treturn error.body;\n\t} else {\n\t\tif (__SVELTEKIT_DEV__ && typeof error == 'object') {\n\t\t\terror = new Proxy(error, {\n\t\t\t\tget: (target, property) => {\n\t\t\t\t\tif (property === 'stack') {\n\t\t\t\t\t\treturn fix_stack_trace(target.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.get(target, property, target);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn (\n\t\t\t(await options.hooks.handleError({ error, event })) ?? {\n\t\t\t\tmessage: event.route.id != null ? 'Internal Error' : 'Not Found'\n\t\t\t}\n\t\t);\n\t}\n}\n\n/**\n * @param {number} status\n * @param {string} location\n */\nexport function redirect_response(status, location) {\n\tconst response = new Response(undefined, {\n\t\tstatus,\n\t\theaders: { location }\n\t});\n\treturn response;\n}\n\n/**\n * @param {import('types').RequestEvent} event\n * @param {Error & { path: string }} error\n */\nexport function clarify_devalue_error(event, error) {\n\tif (error.path) {\n\t\treturn `Data returned from \\`load\\` while rendering ${event.route.id} is not serializable: ${error.message} (data${error.path})`;\n\t}\n\n\tif (error.path === '') {\n\t\treturn `Data returned from \\`load\\` while rendering ${event.route.id} is not a plain object`;\n\t}\n\n\t// belt and braces — this should never happen\n\treturn error.message;\n}\n\n/**\n * @param {import('types').ServerDataNode} node\n */\nexport function stringify_uses(node) {\n\tconst uses = [];\n\n\tif (node.uses && node.uses.dependencies.size > 0) {\n\t\tuses.push(`\"dependencies\":${JSON.stringify(Array.from(node.uses.dependencies))}`);\n\t}\n\n\tif (node.uses && node.uses.params.size > 0) {\n\t\tuses.push(`\"params\":${JSON.stringify(Array.from(node.uses.params))}`);\n\t}\n\n\tif (node.uses?.parent) uses.push(`\"parent\":1`);\n\tif (node.uses?.route) uses.push(`\"route\":1`);\n\tif (node.uses?.url) uses.push(`\"url\":1`);\n\n\treturn `\"uses\":{${uses.join(',')}}`;\n}\n"}}}},"shared-server.js":{"file":{"contents":"/** @type {Record<string, string>} */\nexport let private_env = {};\n\n/** @type {Record<string, string>} */\nexport let public_env = {};\n\n/** @param {string} stack */\nexport let fix_stack_trace = (stack) => stack;\n\n/** @type {(environment: Record<string, string>) => void} */\nexport function set_private_env(environment) {\n\tprivate_env = environment;\n}\n\n/** @type {(environment: Record<string, string>) => void} */\nexport function set_public_env(environment) {\n\tpublic_env = environment;\n}\n\n/** @param {(stack: string) => string} value */\nexport function set_fix_stack_trace(value) {\n\tfix_stack_trace = value;\n}\n"}},"shared.js":{"file":{"contents":"/**\n * @param {string} route_id\n * @param {string} dep\n */\nexport function validate_depends(route_id, dep) {\n\tconst match = /^(moz-icon|view-source|jar):/.exec(dep);\n\tif (match) {\n\t\tconsole.warn(\n\t\t\t`${route_id}: Calling \\`depends('${dep}')\\` will throw an error in Firefox because \\`${match[1]}\\` is a special URI scheme`\n\t\t);\n\t}\n}\n"}}}},"utils":{"directory":{"array.js":{"file":{"contents":"/**\n * Removes nullish values from an array.\n *\n * @template T\n * @param {Array<T>} arr\n */\nexport function compact(arr) {\n\treturn arr.filter(/** @returns {val is NonNullable<T>} */ (val) => val != null);\n}\n"}},"error.js":{"file":{"contents":"import { HttpError, Redirect } from '../runtime/control.js';\n\n/**\n * @param {unknown} err\n * @return {Error}\n */\nexport function coalesce_to_error(err) {\n\treturn err instanceof Error ||\n\t\t(err && /** @type {any} */ (err).name && /** @type {any} */ (err).message)\n\t\t? /** @type {Error} */ (err)\n\t\t: new Error(JSON.stringify(err));\n}\n\n/**\n * This is an identity function that exists to make TypeScript less\n * paranoid about people throwing things that aren't errors, which\n * frankly is not something we should care about\n * @param {unknown} error\n */\nexport function normalize_error(error) {\n\treturn /** @type {Redirect | HttpError | Error} */ (error);\n}\n"}},"escape.js":{"file":{"contents":"/**\n * When inside a double-quoted attribute value, only `&` and `\"` hold special meaning.\n * @see https://html.spec.whatwg.org/multipage/parsing.html#attribute-value-(double-quoted)-state\n * @type {Record<string, string>}\n */\nconst escape_html_attr_dict = {\n\t'&': '&amp;',\n\t'\"': '&quot;'\n};\n\nconst escape_html_attr_regex = new RegExp(\n\t// special characters\n\t`[${Object.keys(escape_html_attr_dict).join('')}]|` +\n\t\t// high surrogate without paired low surrogate\n\t\t'[\\\\ud800-\\\\udbff](?![\\\\udc00-\\\\udfff])|' +\n\t\t// a valid surrogate pair, the only match with 2 code units\n\t\t// we match it so that we can match unpaired low surrogates in the same pass\n\t\t// TODO: use lookbehind assertions once they are widely supported: (?<![\\ud800-udbff])[\\udc00-\\udfff]\n\t\t'[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|' +\n\t\t// unpaired low surrogate (see previous match)\n\t\t'[\\\\udc00-\\\\udfff]',\n\t'g'\n);\n\n/**\n * Formats a string to be used as an attribute's value in raw HTML.\n *\n * It escapes unpaired surrogates (which are allowed in js strings but invalid in HTML), escapes\n * characters that are special in attributes, and surrounds the whole string in double-quotes.\n *\n * @param {string} str\n * @returns {string} Escaped string surrounded by double-quotes.\n * @example const html = `<tag data-value=${escape_html_attr('value')}>...</tag>`;\n */\nexport function escape_html_attr(str) {\n\tconst escaped_str = str.replace(escape_html_attr_regex, (match) => {\n\t\tif (match.length === 2) {\n\t\t\t// valid surrogate pair\n\t\t\treturn match;\n\t\t}\n\n\t\treturn escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;\n\t});\n\n\treturn `\"${escaped_str}\"`;\n}\n"}},"exports.js":{"file":{"contents":"/**\n * @param {string[]} expected\n */\nfunction validator(expected) {\n\tconst set = new Set(expected);\n\n\t/**\n\t * @param {any} module\n\t * @param {string} [file]\n\t */\n\tfunction validate(module, file) {\n\t\tif (!module) return;\n\n\t\tfor (const key in module) {\n\t\t\tif (key[0] === '_' || set.has(key)) continue; // key is valid in this module\n\n\t\t\tconst hint =\n\t\t\t\thint_for_supported_files(key, file?.slice(file.lastIndexOf('.'))) ??\n\t\t\t\t`valid exports are ${expected.join(', ')}, or anything with a '_' prefix`;\n\n\t\t\tthrow new Error(`Invalid export '${key}'${file ? ` in ${file}` : ''} (${hint})`);\n\t\t}\n\t}\n\n\treturn validate;\n}\n\n/**\n * @param {string} key\n * @param {string} ext\n * @returns {string | void}\n */\nfunction hint_for_supported_files(key, ext = '.js') {\n\tlet supported_files = [];\n\n\tif (valid_common_exports.includes(key)) {\n\t\tsupported_files.push(`+page${ext}`);\n\t}\n\n\tif (valid_page_server_exports.includes(key)) {\n\t\tsupported_files.push(`+page.server${ext}`);\n\t}\n\n\tif (valid_server_exports.includes(key)) {\n\t\tsupported_files.push(`+server${ext}`);\n\t}\n\n\tif (supported_files.length > 0) {\n\t\treturn `'${key}' is a valid export in ${supported_files.join(` or `)}`;\n\t}\n}\n\nconst valid_common_exports = ['load', 'prerender', 'csr', 'ssr', 'trailingSlash', 'config'];\nconst valid_page_server_exports = [\n\t'load',\n\t'prerender',\n\t'csr',\n\t'ssr',\n\t'actions',\n\t'trailingSlash',\n\t'config'\n];\nconst valid_server_exports = [\n\t'GET',\n\t'POST',\n\t'PATCH',\n\t'PUT',\n\t'DELETE',\n\t'OPTIONS',\n\t'prerender',\n\t'trailingSlash',\n\t'config'\n];\n\nexport const validate_common_exports = validator(valid_common_exports);\nexport const validate_page_server_exports = validator(valid_page_server_exports);\nexport const validate_server_exports = validator(valid_server_exports);\n"}},"filesystem.js":{"file":{"contents":"import fs from 'node:fs';\nimport path from 'node:path';\n\n/** @param {string} dir */\nexport function mkdirp(dir) {\n\ttry {\n\t\tfs.mkdirSync(dir, { recursive: true });\n\t} catch (/** @type {any} */ e) {\n\t\tif (e.code === 'EEXIST') {\n\t\t\tif (!fs.statSync(dir).isDirectory()) {\n\t\t\t\tthrow new Error(`Cannot create directory ${dir}, a file already exists at this position`);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthrow e;\n\t}\n}\n\n/** @param {string} path */\nexport function rimraf(path) {\n\tfs.rmSync(path, { force: true, recursive: true });\n}\n\n/**\n * @param {string} source\n * @param {string} target\n * @param {{\n *   filter?: (basename: string) => boolean;\n *   replace?: Record<string, string>;\n * }} opts\n */\nexport function copy(source, target, opts = {}) {\n\tif (!fs.existsSync(source)) return [];\n\n\t/** @type {string[]} */\n\tconst files = [];\n\n\tconst prefix = posixify(target) + '/';\n\n\tconst regex = opts.replace\n\t\t? new RegExp(`\\\\b(${Object.keys(opts.replace).join('|')})\\\\b`, 'g')\n\t\t: null;\n\n\t/**\n\t * @param {string} from\n\t * @param {string} to\n\t */\n\tfunction go(from, to) {\n\t\tif (opts.filter && !opts.filter(path.basename(from))) return;\n\n\t\tconst stats = fs.statSync(from);\n\n\t\tif (stats.isDirectory()) {\n\t\t\tfs.readdirSync(from).forEach((file) => {\n\t\t\t\tgo(path.join(from, file), path.join(to, file));\n\t\t\t});\n\t\t} else {\n\t\t\tmkdirp(path.dirname(to));\n\n\t\t\tif (opts.replace) {\n\t\t\t\tconst data = fs.readFileSync(from, 'utf-8');\n\t\t\t\tfs.writeFileSync(\n\t\t\t\t\tto,\n\t\t\t\t\tdata.replace(\n\t\t\t\t\t\t/** @type {RegExp} */ (regex),\n\t\t\t\t\t\t(_match, key) => /** @type {Record<string, string>} */ (opts.replace)[key]\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfs.copyFileSync(from, to);\n\t\t\t}\n\n\t\t\tfiles.push(to === target ? posixify(path.basename(to)) : posixify(to).replace(prefix, ''));\n\t\t}\n\t}\n\n\tgo(source, target);\n\n\treturn files;\n}\n\n/**\n * Get a list of all files in a directory\n * @param {string} cwd - the directory to walk\n * @param {boolean} [dirs] - whether to include directories in the result\n * @returns {string[]} a list of all found files (and possibly directories) relative to `cwd`\n */\nexport function walk(cwd, dirs = false) {\n\t/** @type {string[]} */\n\tconst all_files = [];\n\n\t/** @param {string} dir */\n\tfunction walk_dir(dir) {\n\t\tconst files = fs.readdirSync(path.join(cwd, dir));\n\n\t\tfor (const file of files) {\n\t\t\tconst joined = path.join(dir, file);\n\t\t\tconst stats = fs.statSync(path.join(cwd, joined));\n\t\t\tif (stats.isDirectory()) {\n\t\t\t\tif (dirs) all_files.push(joined);\n\t\t\t\twalk_dir(joined);\n\t\t\t} else {\n\t\t\t\tall_files.push(joined);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn walk_dir(''), all_files;\n}\n\n/** @param {string} str */\nexport function posixify(str) {\n\treturn str.replace(/\\\\/g, '/');\n}\n\n/**\n * Like `path.join`, but posixified and with a leading `./` if necessary\n * @param {string[]} str\n */\nexport function join_relative(...str) {\n\tlet result = posixify(path.join(...str));\n\tif (!result.startsWith('.')) {\n\t\tresult = `./${result}`;\n\t}\n\treturn result;\n}\n\n/**\n * Like `path.relative`, but always posixified and with a leading `./` if necessary.\n * Useful for JS imports so the path can safely reside inside of `node_modules`.\n * Otherwise paths could be falsely interpreted as package paths.\n * @param {string} from\n * @param {string} to\n */\nexport function relative_path(from, to) {\n\treturn join_relative(path.relative(from, to));\n}\n\n/**\n * Prepend given path with `/@fs` prefix\n * @param {string} str\n */\nexport function to_fs(str) {\n\tstr = posixify(str);\n\treturn `/@fs${\n\t\t// Windows/Linux separation - Windows starts with a drive letter, we need a / in front there\n\t\tstr.startsWith('/') ? '' : '/'\n\t}${str}`;\n}\n\n/**\n * Given an entry point like [cwd]/src/hooks, returns a filename like [cwd]/src/hooks.js or [cwd]/src/hooks/index.js\n * @param {string} entry\n * @returns {string|null}\n */\nexport function resolve_entry(entry) {\n\tif (fs.existsSync(entry)) {\n\t\tconst stats = fs.statSync(entry);\n\t\tif (stats.isDirectory()) {\n\t\t\treturn resolve_entry(path.join(entry, 'index'));\n\t\t}\n\n\t\treturn entry;\n\t} else {\n\t\tconst dir = path.dirname(entry);\n\n\t\tif (fs.existsSync(dir)) {\n\t\t\tconst base = path.basename(entry);\n\t\t\tconst files = fs.readdirSync(dir);\n\n\t\t\tconst found = files.find((file) => file.replace(/\\.[^.]+$/, '') === base);\n\n\t\t\tif (found) return path.join(dir, found);\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/** @param {string} file */\nexport function read(file) {\n\treturn fs.readFileSync(file, 'utf-8');\n}\n"}},"fork.js":{"file":{"contents":"import { fileURLToPath } from 'node:url';\nimport child_process from 'node:child_process';\n\n/**\n * Runs a task in a subprocess so any dangling stuff gets killed upon completion.\n * The subprocess needs to be the file `forked` is called in, and `forked` needs to be called eagerly at the top level.\n * @template T\n * @template U\n * @param {string} module `import.meta.url` of the file\n * @param {(opts: T) => U} callback The function that is invoked in the subprocess\n * @returns {(opts: T) => Promise<U>} A function that when called starts the subprocess\n */\nexport function forked(module, callback) {\n\tif (process.env.SVELTEKIT_FORK && process.send) {\n\t\tprocess.send({ type: 'ready', module });\n\n\t\tprocess.on(\n\t\t\t'message',\n\t\t\t/** @param {any} data */ async (data) => {\n\t\t\t\tif (data?.type === 'args' && data.module === module) {\n\t\t\t\t\tif (process.send) {\n\t\t\t\t\t\tprocess.send({\n\t\t\t\t\t\t\ttype: 'result',\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tpayload: await callback(data.payload)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {T} opts\n\t * @returns {Promise<U>}\n\t */\n\tconst fn = function (opts) {\n\t\treturn new Promise((fulfil, reject) => {\n\t\t\tconst child = child_process.fork(fileURLToPath(module), {\n\t\t\t\tstdio: 'inherit',\n\t\t\t\tenv: {\n\t\t\t\t\t...process.env,\n\t\t\t\t\tSVELTEKIT_FORK: 'true'\n\t\t\t\t},\n\t\t\t\tserialization: 'advanced'\n\t\t\t});\n\n\t\t\tchild.on(\n\t\t\t\t'message',\n\t\t\t\t/** @param {any} data */ (data) => {\n\t\t\t\t\tif (data?.type === 'ready' && data.module === module) {\n\t\t\t\t\t\tchild.send({\n\t\t\t\t\t\t\ttype: 'args',\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tpayload: opts\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data?.type === 'result' && data.module === module) {\n\t\t\t\t\t\tchild.kill();\n\t\t\t\t\t\tfulfil(data.payload);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tchild.on('exit', (code) => {\n\t\t\t\tif (code) {\n\t\t\t\t\treject(new Error(`Failed with code ${code}`));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\treturn fn;\n}\n"}},"functions.js":{"file":{"contents":"/**\n * @template T\n * @param {() => T} fn\n */\nexport function once(fn) {\n\tlet done = false;\n\n\t/** @type T */\n\tlet result;\n\n\treturn () => {\n\t\tif (done) return result;\n\t\tdone = true;\n\t\treturn (result = fn());\n\t};\n}\n"}},"http.js":{"file":{"contents":"/**\n * Given an Accept header and a list of possible content types, pick\n * the most suitable one to respond with\n * @param {string} accept\n * @param {string[]} types\n */\nexport function negotiate(accept, types) {\n\t/** @type {Array<{ type: string, subtype: string, q: number, i: number }>} */\n\tconst parts = [];\n\n\taccept.split(',').forEach((str, i) => {\n\t\tconst match = /([^/]+)\\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);\n\n\t\t// no match equals invalid header — ignore\n\t\tif (match) {\n\t\t\tconst [, type, subtype, q = '1'] = match;\n\t\t\tparts.push({ type, subtype, q: +q, i });\n\t\t}\n\t});\n\n\tparts.sort((a, b) => {\n\t\tif (a.q !== b.q) {\n\t\t\treturn b.q - a.q;\n\t\t}\n\n\t\tif ((a.subtype === '*') !== (b.subtype === '*')) {\n\t\t\treturn a.subtype === '*' ? 1 : -1;\n\t\t}\n\n\t\tif ((a.type === '*') !== (b.type === '*')) {\n\t\t\treturn a.type === '*' ? 1 : -1;\n\t\t}\n\n\t\treturn a.i - b.i;\n\t});\n\n\tlet accepted;\n\tlet min_priority = Infinity;\n\n\tfor (const mimetype of types) {\n\t\tconst [type, subtype] = mimetype.split('/');\n\t\tconst priority = parts.findIndex(\n\t\t\t(part) =>\n\t\t\t\t(part.type === type || part.type === '*') &&\n\t\t\t\t(part.subtype === subtype || part.subtype === '*')\n\t\t);\n\n\t\tif (priority !== -1 && priority < min_priority) {\n\t\t\taccepted = mimetype;\n\t\t\tmin_priority = priority;\n\t\t}\n\t}\n\n\treturn accepted;\n}\n\n/**\n * Returns `true` if the request contains a `content-type` header with the given type\n * @param {Request} request\n * @param  {...string} types\n */\nexport function is_content_type(request, ...types) {\n\tconst type = request.headers.get('content-type')?.split(';', 1)[0].trim() ?? '';\n\treturn types.includes(type);\n}\n\n/**\n * @param {Request} request\n */\nexport function is_form_content_type(request) {\n\treturn is_content_type(request, 'application/x-www-form-urlencoded', 'multipart/form-data');\n}\n"}},"misc.js":{"file":{"contents":"export const s = JSON.stringify;\n"}},"options.js":{"file":{"contents":"/**\n * @template {'prerender' | 'ssr' | 'csr' | 'trailingSlash'} Option\n * @template {Option extends 'prerender' ? import('types').PrerenderOption : Option extends 'trailingSlash' ? import('types').TrailingSlash : boolean} Value\n *\n * @param {Array<import('types').SSRNode | undefined>} nodes\n * @param {Option} option\n *\n * @returns {Value | undefined}\n */\nexport function get_option(nodes, option) {\n\treturn nodes.reduce((value, node) => {\n\t\treturn /** @type {any} TypeScript's too dumb to understand this */ (\n\t\t\tnode?.universal?.[option] ?? node?.server?.[option] ?? value\n\t\t);\n\t}, /** @type {Value | undefined} */ (undefined));\n}\n"}},"platform.js":{"file":{"contents":"export const should_polyfill = typeof Deno === 'undefined' && typeof Bun === 'undefined';\n"}},"promises.js":{"file":{"contents":"/**\n * Given an object, return a new object where all top level values are awaited\n *\n * @param {Record<string, any>} object\n * @returns {Promise<Record<string, any>>}\n */\nexport async function unwrap_promises(object) {\n\tfor (const key in object) {\n\t\tif (typeof object[key]?.then === 'function') {\n\t\t\treturn Object.fromEntries(\n\t\t\t\tawait Promise.all(Object.entries(object).map(async ([key, value]) => [key, await value]))\n\t\t\t);\n\t\t}\n\t}\n\n\treturn object;\n}\n"}},"routing.js":{"file":{"contents":"const param_pattern = /^(\\[)?(\\.\\.\\.)?(\\w+)(?:=(\\w+))?(\\])?$/;\n\n/**\n * Creates the regex pattern, extracts parameter names, and generates types for a route\n * @param {string} id\n */\nexport function parse_route_id(id) {\n\t/** @type {import('types').RouteParam[]} */\n\tconst params = [];\n\n\tconst pattern =\n\t\tid === '/'\n\t\t\t? /^\\/$/\n\t\t\t: new RegExp(\n\t\t\t\t\t`^${get_route_segments(id)\n\t\t\t\t\t\t.map((segment) => {\n\t\t\t\t\t\t\t// special case — /[...rest]/ could contain zero segments\n\t\t\t\t\t\t\tconst rest_match = /^\\[\\.\\.\\.(\\w+)(?:=(\\w+))?\\]$/.exec(segment);\n\t\t\t\t\t\t\tif (rest_match) {\n\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\tname: rest_match[1],\n\t\t\t\t\t\t\t\t\tmatcher: rest_match[2],\n\t\t\t\t\t\t\t\t\toptional: false,\n\t\t\t\t\t\t\t\t\trest: true,\n\t\t\t\t\t\t\t\t\tchained: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn '(?:/(.*))?';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// special case — /[[optional]]/ could contain zero segments\n\t\t\t\t\t\t\tconst optional_match = /^\\[\\[(\\w+)(?:=(\\w+))?\\]\\]$/.exec(segment);\n\t\t\t\t\t\t\tif (optional_match) {\n\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\tname: optional_match[1],\n\t\t\t\t\t\t\t\t\tmatcher: optional_match[2],\n\t\t\t\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\t\t\t\trest: false,\n\t\t\t\t\t\t\t\t\tchained: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn '(?:/([^/]+))?';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segment) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst parts = segment.split(/\\[(.+?)\\](?!\\])/);\n\t\t\t\t\t\t\tconst result = parts\n\t\t\t\t\t\t\t\t.map((content, i) => {\n\t\t\t\t\t\t\t\t\tif (i % 2) {\n\t\t\t\t\t\t\t\t\t\tif (content.startsWith('x+')) {\n\t\t\t\t\t\t\t\t\t\t\treturn escape(String.fromCharCode(parseInt(content.slice(2), 16)));\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (content.startsWith('u+')) {\n\t\t\t\t\t\t\t\t\t\t\treturn escape(\n\t\t\t\t\t\t\t\t\t\t\t\tString.fromCharCode(\n\t\t\t\t\t\t\t\t\t\t\t\t\t...content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.slice(2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.split('-')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.map((code) => parseInt(code, 16))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst match = param_pattern.exec(content);\n\t\t\t\t\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst [, is_optional, is_rest, name, matcher] = match;\n\t\t\t\t\t\t\t\t\t\t// It's assumed that the following invalid route id cases are already checked\n\t\t\t\t\t\t\t\t\t\t// - unbalanced brackets\n\t\t\t\t\t\t\t\t\t\t// - optional param following rest param\n\n\t\t\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\t\t\t\t\t\toptional: !!is_optional,\n\t\t\t\t\t\t\t\t\t\t\trest: !!is_rest,\n\t\t\t\t\t\t\t\t\t\t\tchained: is_rest ? i === 1 && parts[0] === '' : false\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\treturn is_rest ? '(.*?)' : is_optional ? '([^/]*)?' : '([^/]+?)';\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn escape(content);\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.join('');\n\n\t\t\t\t\t\t\treturn '/' + result;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join('')}/?$`\n\t\t\t  );\n\n\treturn { pattern, params };\n}\n\n/**\n * Returns `false` for `(group)` segments\n * @param {string} segment\n */\nfunction affects_path(segment) {\n\treturn !/^\\([^)]+\\)$/.test(segment);\n}\n\n/**\n * Splits a route id into its segments, removing segments that\n * don't affect the path (i.e. groups). The root route is represented by `/`\n * and will be returned as `['']`.\n * @param {string} route\n * @returns string[]\n */\nexport function get_route_segments(route) {\n\treturn route.slice(1).split('/').filter(affects_path);\n}\n\n/**\n * @param {RegExpMatchArray} match\n * @param {import('types').RouteParam[]} params\n * @param {Record<string, import('types').ParamMatcher>} matchers\n */\nexport function exec(match, params, matchers) {\n\t/** @type {Record<string, string>} */\n\tconst result = {};\n\n\tconst values = match.slice(1);\n\n\tlet buffered = 0;\n\n\tfor (let i = 0; i < params.length; i += 1) {\n\t\tconst param = params[i];\n\t\tconst value = values[i - buffered];\n\n\t\t// in the `[[a=b]]/.../[...rest]` case, if one or more optional parameters\n\t\t// weren't matched, roll the skipped values into the rest\n\t\tif (param.chained && param.rest && buffered) {\n\t\t\tresult[param.name] = values\n\t\t\t\t.slice(i - buffered, i + 1)\n\t\t\t\t.filter((s) => s)\n\t\t\t\t.join('/');\n\n\t\t\tbuffered = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// if `value` is undefined, it means this is an optional or rest parameter\n\t\tif (value === undefined) {\n\t\t\tif (param.rest) result[param.name] = '';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!param.matcher || matchers[param.matcher](value)) {\n\t\t\tresult[param.name] = value;\n\n\t\t\t// Now that the params match, reset the buffer if the next param isn't the [...rest]\n\t\t\t// and the next value is defined, otherwise the buffer will cause us to skip values\n\t\t\tconst next_param = params[i + 1];\n\t\t\tconst next_value = values[i + 1];\n\t\t\tif (next_param && !next_param.rest && next_value) {\n\t\t\t\tbuffered = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// in the `/[[a=b]]/...` case, if the value didn't satisfy the matcher,\n\t\t// keep track of the number of skipped optional parameters and continue\n\t\tif (param.optional && param.chained) {\n\t\t\tbuffered++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// otherwise, if the matcher returns `false`, the route did not match\n\t\treturn;\n\t}\n\n\tif (buffered) return;\n\treturn result;\n}\n\n/** @param {string} str */\nfunction escape(str) {\n\treturn (\n\t\tstr\n\t\t\t.normalize()\n\t\t\t// escape [ and ] before escaping other characters, since they are used in the replacements\n\t\t\t.replace(/[[\\]]/g, '\\\\$&')\n\t\t\t// replace %, /, ? and # with their encoded versions because decode_pathname leaves them untouched\n\t\t\t.replace(/%/g, '%25')\n\t\t\t.replace(/\\//g, '%2[Ff]')\n\t\t\t.replace(/\\?/g, '%3[Ff]')\n\t\t\t.replace(/#/g, '%23')\n\t\t\t// escape characters that have special meaning in regex\n\t\t\t.replace(/[.*+?^${}()|\\\\]/g, '\\\\$&')\n\t);\n}\n"}},"streaming.js":{"file":{"contents":"/**\n * @returns {import(\"types\").Deferred & { promise: Promise<any> }}}\n */\nfunction defer() {\n\tlet fulfil;\n\tlet reject;\n\n\tconst promise = new Promise((f, r) => {\n\t\tfulfil = f;\n\t\treject = r;\n\t});\n\n\t// @ts-expect-error\n\treturn { promise, fulfil, reject };\n}\n\n/**\n * Create an async iterator and a function to push values into it\n * @returns {{\n *   iterator: AsyncIterable<any>;\n *   push: (value: any) => void;\n *   done: () => void;\n * }}\n */\nexport function create_async_iterator() {\n\tlet deferred = defer();\n\n\treturn {\n\t\titerator: {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn {\n\t\t\t\t\tnext: () => deferred.promise\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tpush: (value) => {\n\t\t\tdeferred.fulfil({ value, done: false });\n\t\t\tdeferred = defer();\n\t\t},\n\t\tdone: () => {\n\t\t\tdeferred.fulfil({ done: true });\n\t\t}\n\t};\n}\n"}},"unit_test.js":{"file":{"contents":"import { suite } from 'uvu';\n\n/**\n * @param {string} name\n * @param {(suite: import('uvu').Test<import('uvu').Context>) => void} fn\n */\nexport function describe(name, fn) {\n\tconst s = suite(name);\n\tfn(s);\n\ts.run();\n}\n"}},"url.js":{"file":{"contents":"import { BROWSER } from 'esm-env';\n\nconst absolute = /^([a-z]+:)?\\/?\\//;\nconst scheme = /^[a-z]+:/;\n\n/**\n * @param {string} base\n * @param {string} path\n */\nexport function resolve(base, path) {\n\tif (scheme.test(path)) return path;\n\tif (path[0] === '#') return base + path;\n\n\tconst base_match = absolute.exec(base);\n\tconst path_match = absolute.exec(path);\n\n\tif (!base_match) {\n\t\tthrow new Error(`bad base path: \"${base}\"`);\n\t}\n\n\tconst baseparts = path_match ? [] : base.slice(base_match[0].length).split('/');\n\tconst pathparts = path_match ? path.slice(path_match[0].length).split('/') : path.split('/');\n\n\tbaseparts.pop();\n\n\tfor (let i = 0; i < pathparts.length; i += 1) {\n\t\tconst part = pathparts[i];\n\t\tif (part === '.') continue;\n\t\telse if (part === '..') baseparts.pop();\n\t\telse baseparts.push(part);\n\t}\n\n\tconst prefix = (path_match && path_match[0]) || (base_match && base_match[0]) || '';\n\n\treturn `${prefix}${baseparts.join('/')}`;\n}\n\n/** @param {string} path */\nexport function is_root_relative(path) {\n\treturn path[0] === '/' && path[1] !== '/';\n}\n\n/**\n * @param {string} path\n * @param {import('types').TrailingSlash} trailing_slash\n */\nexport function normalize_path(path, trailing_slash) {\n\tif (path === '/' || trailing_slash === 'ignore') return path;\n\n\tif (trailing_slash === 'never') {\n\t\treturn path.endsWith('/') ? path.slice(0, -1) : path;\n\t} else if (trailing_slash === 'always' && !path.endsWith('/')) {\n\t\treturn path + '/';\n\t}\n\n\treturn path;\n}\n\n/**\n * Decode pathname excluding %25 to prevent further double decoding of params\n * @param {string} pathname\n */\nexport function decode_pathname(pathname) {\n\treturn pathname.split('%25').map(decodeURI).join('%25');\n}\n\n/** @param {Record<string, string>} params */\nexport function decode_params(params) {\n\tfor (const key in params) {\n\t\t// input has already been decoded by decodeURI\n\t\t// now handle the rest\n\t\tparams[key] = decodeURIComponent(params[key]);\n\t}\n\n\treturn params;\n}\n\n/**\n * The error when a URL is malformed is not very helpful, so we augment it with the URI\n * @param {string} uri\n */\nexport function decode_uri(uri) {\n\ttry {\n\t\treturn decodeURI(uri);\n\t} catch (e) {\n\t\tif (e instanceof Error) {\n\t\t\te.message = `Failed to decode URI: ${uri}\\n` + e.message;\n\t\t}\n\t\tthrow e;\n\t}\n}\n\n/**\n * URL properties that could change during the lifetime of the page,\n * which excludes things like `origin`\n * @type {Array<keyof URL>}\n */\nconst tracked_url_properties = ['href', 'pathname', 'search', 'searchParams', 'toString', 'toJSON'];\n\n/**\n * @param {URL} url\n * @param {() => void} callback\n */\nexport function make_trackable(url, callback) {\n\tconst tracked = new URL(url);\n\n\tfor (const property of tracked_url_properties) {\n\t\tlet value = tracked[property];\n\n\t\tObject.defineProperty(tracked, property, {\n\t\t\tget() {\n\t\t\t\tcallback();\n\t\t\t\treturn value;\n\t\t\t},\n\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\tif (!BROWSER) {\n\t\t// @ts-ignore\n\t\ttracked[Symbol.for('nodejs.util.inspect.custom')] = (depth, opts, inspect) => {\n\t\t\treturn inspect(url, opts);\n\t\t};\n\t}\n\n\tdisable_hash(tracked);\n\n\treturn tracked;\n}\n\n/**\n * Disallow access to `url.hash` on the server and in `load`\n * @param {URL} url\n */\nexport function disable_hash(url) {\n\tObject.defineProperty(url, 'hash', {\n\t\tget() {\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead'\n\t\t\t);\n\t\t}\n\t});\n}\n\n/**\n * Disallow access to `url.search` and `url.searchParams` during prerendering\n * @param {URL} url\n */\nexport function disable_search(url) {\n\tfor (const property of ['search', 'searchParams']) {\n\t\tObject.defineProperty(url, property, {\n\t\t\tget() {\n\t\t\t\tthrow new Error(`Cannot access url.${property} on a page with prerendering enabled`);\n\t\t\t}\n\t\t});\n\t}\n}\n\nconst DATA_SUFFIX = '/__data.json';\n\n/** @param {string} pathname */\nexport function has_data_suffix(pathname) {\n\treturn pathname.endsWith(DATA_SUFFIX);\n}\n\n/** @param {string} pathname */\nexport function add_data_suffix(pathname) {\n\treturn pathname.replace(/\\/$/, '') + DATA_SUFFIX;\n}\n\n/** @param {string} pathname */\nexport function strip_data_suffix(pathname) {\n\treturn pathname.slice(0, -DATA_SUFFIX.length);\n}\n"}}}}}},"svelte-kit.js":{"file":{"contents":"#!/usr/bin/env node\nimport './src/cli.js';\n"}},"types":{"directory":{"ambient.d.ts":{"file":{"contents":"/**\n * It's possible to tell SvelteKit how to type objects inside your app by declaring the `App` namespace. By default, a new project will have a file called `src/app.d.ts` containing the following:\n *\n * ```ts\n * declare global {\n * \tnamespace App {\n * \t\t// interface Error {}\n * \t\t// interface Locals {}\n * \t\t// interface PageData {}\n * \t\t// interface Platform {}\n * \t}\n * }\n *\n * export {};\n * ```\n *\n * The `export {}` line exists because without it, the file would be treated as an _ambient module_ which prevents you from adding `import` declarations.\n * If you need to add ambient `declare module` declarations, do so in a separate file like `src/ambient.d.ts`.\n *\n * By populating these interfaces, you will gain type safety when using `event.locals`, `event.platform`, and `data` from `load` functions.\n */\ndeclare namespace App {\n\t/**\n\t * Defines the common shape of expected and unexpected errors. Expected errors are thrown using the `error` function. Unexpected errors are handled by the `handleError` hooks which should return this shape.\n\t */\n\texport interface Error {\n\t\tmessage: string;\n\t}\n\n\t/**\n\t * The interface that defines `event.locals`, which can be accessed in [hooks](https://kit.svelte.dev/docs/hooks) (`handle`, and `handleError`), server-only `load` functions, and `+server.js` files.\n\t */\n\texport interface Locals {}\n\n\t/**\n\t * Defines the common shape of the [$page.data store](https://kit.svelte.dev/docs/modules#$app-stores-page) - that is, the data that is shared between all pages.\n\t * The `Load` and `ServerLoad` functions in `./$types` will be narrowed accordingly.\n\t * Use optional properties for data that is only present on specific pages. Do not add an index signature (`[key: string]: any`).\n\t */\n\texport interface PageData {}\n\n\t/**\n\t * If your adapter provides [platform-specific context](https://kit.svelte.dev/docs/adapters#platform-specific-context) via `event.platform`, you can specify it here.\n\t */\n\texport interface Platform {}\n}\n\ndeclare module '$app/environment' {\n\t/**\n\t * `true` if the app is running in the browser.\n\t */\n\texport const browser: boolean;\n\n\t/**\n\t * SvelteKit analyses your app during the `build` step by running it. During this process, `building` is `true`. This also applies during prerendering.\n\t */\n\texport const building: boolean;\n\n\t/**\n\t * Whether the dev server is running. This is not guaranteed to correspond to `NODE_ENV` or `MODE`.\n\t */\n\texport const dev: boolean;\n\n\t/**\n\t * The value of `config.kit.version.name`.\n\t */\n\texport const version: string;\n}\n\ndeclare module '$app/forms' {\n\timport type { ActionResult } from '@sveltejs/kit';\n\n\ttype MaybePromise<T> = T | Promise<T>;\n\n\t// this is duplicated in @sveltejs/kit because create-svelte tests fail\n\t// if we use the imported version. See https://github.com/sveltejs/kit/pull/7003#issuecomment-1330921789\n\t// for why this happens (it's likely a bug in TypeScript, but one that is so rare that it's unlikely to be fixed)\n\ttype SubmitFunction<\n\t\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\t\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n\t> = (input: {\n\t\taction: URL;\n\t\tdata: FormData;\n\t\tform: HTMLFormElement;\n\t\tcontroller: AbortController;\n\t\tcancel(): void;\n\t}) => MaybePromise<\n\t\t| void\n\t\t| ((opts: {\n\t\t\t\tform: HTMLFormElement;\n\t\t\t\taction: URL;\n\t\t\t\tresult: ActionResult<Success, Invalid>;\n\t\t\t\t/**\n\t\t\t\t * Call this to get the default behavior of a form submission response.\n\t\t\t\t * @param options Set `reset: false` if you don't want the `<form>` values to be reset after a successful submission.\n\t\t\t\t */\n\t\t\t\tupdate(options?: { reset: boolean }): Promise<void>;\n\t\t  }) => void)\n\t>;\n\n\t/**\n\t * This action enhances a `<form>` element that otherwise would work without JavaScript.\n\t * @param form The form element\n\t * @param options Callbacks for different states of the form lifecycle\n\t */\n\texport function enhance<\n\t\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\t\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n\t>(\n\t\tform: HTMLFormElement,\n\t\t/**\n\t\t * Called upon submission with the given FormData and the `action` that should be triggered.\n\t\t * If `cancel` is called, the form will not be submitted.\n\t\t * You can use the abort `controller` to cancel the submission in case another one starts.\n\t\t * If a function is returned, that function is called with the response from the server.\n\t\t * If nothing is returned, the fallback will be used.\n\t\t *\n\t\t * If this function or its return value isn't set, it\n\t\t * - falls back to updating the `form` prop with the returned data if the action is one same page as the form\n\t\t * - updates `$page.status`\n\t\t * - resets the `<form>` element and invalidates all data in case of successful submission with no redirect response\n\t\t * - redirects in case of a redirect response\n\t\t * - redirects to the nearest error page in case of an unexpected error\n\t\t *\n\t\t * If you provide a custom function with a callback and want to use the default behavior, invoke `update` in your callback.\n\t\t */\n\t\tsubmit?: SubmitFunction<Success, Invalid>\n\t): { destroy(): void };\n\n\t/**\n\t * This action updates the `form` property of the current page with the given data and updates `$page.status`.\n\t * In case of an error, it redirects to the nearest error page.\n\t */\n\texport function applyAction<\n\t\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\t\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n\t>(result: ActionResult<Success, Invalid>): Promise<void>;\n\n\t/**\n\t * Use this function to deserialize the response from a form submission.\n\t * Usage:\n\t *\n\t * ```js\n\t * import { deserialize } from '$app/forms';\n\t *\n\t * async function handleSubmit(event) {\n\t *   const response = await fetch('/form?/action', {\n\t *     method: 'POST',\n\t *     body: new FormData(event.target)\n\t *   });\n\t *\n\t *   const result = deserialize(await response.text());\n\t *   // ...\n\t * }\n\t * ```\n\t */\n\texport function deserialize<\n\t\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\t\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n\t>(serialized: string): ActionResult<Success, Invalid>;\n}\n\ndeclare module '$app/navigation' {\n\timport { BeforeNavigate, AfterNavigate } from '@sveltejs/kit';\n\n\t/**\n\t * If called when the page is being updated following a navigation (in `onMount` or `afterNavigate` or an action, for example), this disables SvelteKit's built-in scroll handling.\n\t * This is generally discouraged, since it breaks user expectations.\n\t */\n\texport function disableScrollHandling(): void;\n\t/**\n\t * Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified `url`.\n\t * For external URLs, use `window.location = url` instead of calling `goto(url)`.\n\t *\n\t * @param url Where to navigate to. Note that if you've set [`config.kit.paths.base`](https://kit.svelte.dev/docs/configuration#paths) and the URL is root-relative, you need to prepend the base path if you want to navigate within the app.\n\t * @param opts Options related to the navigation\n\t */\n\texport function goto(\n\t\turl: string | URL,\n\t\topts?: {\n\t\t\t/**\n\t\t\t * If `true`, will replace the current `history` entry rather than creating a new one with `pushState`\n\t\t\t */\n\t\t\treplaceState?: boolean;\n\t\t\t/**\n\t\t\t * If `true`, the browser will maintain its scroll position rather than scrolling to the top of the page after navigation\n\t\t\t */\n\t\t\tnoScroll?: boolean;\n\t\t\t/**\n\t\t\t * If `true`, the currently focused element will retain focus after navigation. Otherwise, focus will be reset to the body\n\t\t\t */\n\t\t\tkeepFocus?: boolean;\n\t\t\t/**\n\t\t\t * The state of the new/updated history entry\n\t\t\t */\n\t\t\tstate?: any;\n\t\t\t/**\n\t\t\t * If `true`, all `load` functions of the page will be rerun. See https://kit.svelte.dev/docs/load#rerunning-load-functions for more info on invalidation.\n\t\t\t */\n\t\t\tinvalidateAll?: boolean;\n\t\t}\n\t): Promise<void>;\n\t/**\n\t * Causes any `load` functions belonging to the currently active page to re-run if they depend on the `url` in question, via `fetch` or `depends`. Returns a `Promise` that resolves when the page is subsequently updated.\n\t *\n\t * If the argument is given as a `string` or `URL`, it must resolve to the same URL that was passed to `fetch` or `depends` (including query parameters).\n\t * To create a custom identifier, use a string beginning with `[a-z]+:` (e.g. `custom:state`) — this is a valid URL.\n\t *\n\t * The `function` argument can be used define a custom predicate. It receives the full `URL` and causes `load` to rerun if `true` is returned.\n\t * This can be useful if you want to invalidate based on a pattern instead of a exact match.\n\t *\n\t * ```ts\n\t * // Example: Match '/path' regardless of the query parameters\n\t * import { invalidate } from '$app/navigation';\n\t *\n\t * invalidate((url) => url.pathname === '/path');\n\t * ```\n\t * @param url The invalidated URL\n\t */\n\texport function invalidate(url: string | URL | ((url: URL) => boolean)): Promise<void>;\n\t/**\n\t * Causes all `load` functions belonging to the currently active page to re-run. Returns a `Promise` that resolves when the page is subsequently updated.\n\t */\n\texport function invalidateAll(): Promise<void>;\n\t/**\n\t * Programmatically preloads the given page, which means\n\t *  1. ensuring that the code for the page is loaded, and\n\t *  2. calling the page's load function with the appropriate options.\n\t *\n\t * This is the same behaviour that SvelteKit triggers when the user taps or mouses over an `<a>` element with `data-sveltekit-preload-data`.\n\t * If the next navigation is to `href`, the values returned from load will be used, making navigation instantaneous.\n\t * Returns a Promise that resolves when the preload is complete.\n\t *\n\t * @param href Page to preload\n\t */\n\texport function preloadData(href: string): Promise<void>;\n\t/**\n\t * Programmatically imports the code for routes that haven't yet been fetched.\n\t * Typically, you might call this to speed up subsequent navigation.\n\t *\n\t * You can specify routes by any matching pathname such as `/about` (to match `src/routes/about/+page.svelte`) or `/blog/*` (to match `src/routes/blog/[slug]/+page.svelte`).\n\t *\n\t * Unlike `preloadData`, this won't call `load` functions.\n\t * Returns a Promise that resolves when the modules have been imported.\n\t */\n\texport function preloadCode(...urls: string[]): Promise<void>;\n\n\t/**\n\t * A navigation interceptor that triggers before we navigate to a new URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls.\n\t * Calling `cancel()` will prevent the navigation from completing. If the navigation would have directly unloaded the current page, calling `cancel` will trigger the native\n\t * browser unload confirmation dialog. In these cases, `navigation.willUnload` is `true`.\n\t *\n\t * When a navigation isn't client side, `navigation.to.route.id` will be `null`.\n\t *\n\t * `beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n\t */\n\texport function beforeNavigate(callback: (navigation: BeforeNavigate) => void): void;\n\n\t/**\n\t * A lifecycle function that runs the supplied `callback` when the current component mounts, and also whenever we navigate to a new URL.\n\t *\n\t * `afterNavigate` must be called during a component initialization. It remains active as long as the component is mounted.\n\t */\n\texport function afterNavigate(callback: (navigation: AfterNavigate) => void): void;\n}\n\ndeclare module '$app/paths' {\n\t/**\n\t * A string that matches [`config.kit.paths.base`](https://kit.svelte.dev/docs/configuration#paths).\n\t *\n\t * Example usage: `<a href=\"{base}/your-page\">Link</a>`\n\t */\n\texport const base: `/${string}`;\n\t/**\n\t * An absolute path that matches [`config.kit.paths.assets`](https://kit.svelte.dev/docs/configuration#paths).\n\t *\n\t * > If a value for `config.kit.paths.assets` is specified, it will be replaced with `'/_svelte_kit_assets'` during `vite dev` or `vite preview`, since the assets don't yet live at their eventual URL.\n\t */\n\texport const assets: `https://${string}` | `http://${string}`;\n}\n\n/**\n * Stores on the server are _contextual_ — they are added to the [context](https://svelte.dev/tutorial/context-api) of your root component. This means that `page` is unique to each request, rather than shared between multiple requests handled by the same server simultaneously.\n *\n * Because of that, you must subscribe to the stores during component initialization (which happens automatically if you reference the store value, e.g. as `$page`, in a component) before you can use them.\n *\n * In the browser, we don't need to worry about this, and stores can be accessed from anywhere. Code that will only ever run on the browser can refer to (or subscribe to) any of these stores at any time.\n */\ndeclare module '$app/stores' {\n\timport { Readable } from 'svelte/store';\n\timport { Navigation, Page } from '@sveltejs/kit';\n\n\t/**\n\t * A readable store whose value contains page data.\n\t *\n\t * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n\t */\n\texport const page: Readable<Page>;\n\t/**\n\t * A readable store.\n\t * When navigating starts, its value is a `Navigation` object with `from`, `to`, `type` and (if `type === 'popstate'`) `delta` properties.\n\t * When navigating finishes, its value reverts to `null`.\n\t *\n\t * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n\t */\n\texport const navigating: Readable<Navigation | null>;\n\t/**\n\t * A readable store whose initial value is `false`. If [`version.pollInterval`](https://kit.svelte.dev/docs/configuration#version) is a non-zero value, SvelteKit will poll for new versions of the app and update the store value to `true` when it detects one. `updated.check()` will force an immediate check, regardless of polling.\n\t *\n\t * On the server, this store can only be subscribed to during component initialization. In the browser, it can be subscribed to at any time.\n\t */\n\texport const updated: Readable<boolean> & { check(): Promise<boolean> };\n\n\t/**\n\t * A function that returns all of the contextual stores. On the server, this must be called during component initialization.\n\t * Only use this if you need to defer store subscription until after the component has mounted, for some reason.\n\t */\n\texport function getStores(): {\n\t\tnavigating: typeof navigating;\n\t\tpage: typeof page;\n\t\tupdated: typeof updated;\n\t};\n}\n\n/**\n * This module is only available to [service workers](https://kit.svelte.dev/docs/service-workers).\n */\ndeclare module '$service-worker' {\n\t/**\n\t * An array of URL strings representing the files generated by Vite, suitable for caching with `cache.addAll(build)`.\n\t * During development, this is an empty array.\n\t */\n\texport const build: string[];\n\t/**\n\t * An array of URL strings representing the files in your static directory, or whatever directory is specified by `config.kit.files.assets`. You can customize which files are included from `static` directory using [`config.kit.serviceWorker.files`](https://kit.svelte.dev/docs/configuration)\n\t */\n\texport const files: string[];\n\t/**\n\t * An array of pathnames corresponding to prerendered pages and endpoints.\n\t * During development, this is an empty array.\n\t */\n\texport const prerendered: string[];\n\t/**\n\t * See [`config.kit.version`](https://kit.svelte.dev/docs/configuration#version). It's useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.\n\t */\n\texport const version: string;\n}\n\ndeclare module '@sveltejs/kit/hooks' {\n\timport { Handle } from '@sveltejs/kit';\n\n\t/**\n\t * A helper function for sequencing multiple `handle` calls in a middleware-like manner.\n\t *\n\t * ```js\n\t * /// file: src/hooks.server.js\n\t * import { sequence } from '@sveltejs/kit/hooks';\n\t *\n\t * /// type: import('@sveltejs/kit').Handle\n\t * async function first({ event, resolve }) {\n\t * \tconsole.log('first pre-processing');\n\t * \tconst result = await resolve(event, {\n\t * \t\ttransformPageChunk: ({ html }) => {\n\t * \t\t\t// transforms are applied in reverse order\n\t * \t\t\tconsole.log('first transform');\n\t * \t\t\treturn html;\n\t * \t\t}\n\t * \t});\n\t * \tconsole.log('first post-processing');\n\t * \treturn result;\n\t * }\n\t *\n\t * /// type: import('@sveltejs/kit').Handle\n\t * async function second({ event, resolve }) {\n\t * \tconsole.log('second pre-processing');\n\t * \tconst result = await resolve(event, {\n\t * \t\ttransformPageChunk: ({ html }) => {\n\t * \t\t\tconsole.log('second transform');\n\t * \t\t\treturn html;\n\t * \t\t}\n\t * \t});\n\t * \tconsole.log('second post-processing');\n\t * \treturn result;\n\t * }\n\t *\n\t * export const handle = sequence(first, second);\n\t * ```\n\t *\n\t * The example above would print:\n\t *\n\t * ```\n\t * first pre-processing\n\t * second pre-processing\n\t * second transform\n\t * first transform\n\t * second post-processing\n\t * first post-processing\n\t * ```\n\t *\n\t * @param handlers The chain of `handle` functions\n\t */\n\texport function sequence(...handlers: Handle[]): Handle;\n}\n\n/**\n * A polyfill for `fetch` and its related interfaces, used by adapters for environments that don't provide a native implementation.\n */\ndeclare module '@sveltejs/kit/node/polyfills' {\n\t/**\n\t * Make various web APIs available as globals:\n\t * - `crypto`\n\t * - `fetch`\n\t * - `Headers`\n\t * - `Request`\n\t * - `Response`\n\t */\n\texport function installPolyfills(): void;\n}\n\n/**\n * Utilities used by adapters for Node-like environments.\n */\ndeclare module '@sveltejs/kit/node' {\n\texport function getRequest(opts: {\n\t\tbase: string;\n\t\trequest: import('http').IncomingMessage;\n\t\tbodySizeLimit?: number;\n\t}): Promise<Request>;\n\texport function setResponse(res: import('http').ServerResponse, response: Response): void;\n}\n\ndeclare module '@sveltejs/kit/vite' {\n\timport { Plugin } from 'vite';\n\n\t/**\n\t * Returns the SvelteKit Vite plugins.\n\t */\n\texport function sveltekit(): Promise<Plugin[]>;\n\texport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n}\n"}},"index.d.ts":{"file":{"contents":"/// <reference types=\"svelte\" />\n/// <reference types=\"vite/client\" />\n\nimport './ambient.js';\n\nimport { CompileOptions } from 'svelte/types/compiler/interfaces';\nimport {\n\tAdapterEntry,\n\tCspDirectives,\n\tHttpMethod,\n\tLogger,\n\tMaybePromise,\n\tPrerendered,\n\tPrerenderHttpErrorHandlerValue,\n\tPrerenderMissingIdHandlerValue,\n\tPrerenderOption,\n\tRequestOptions,\n\tRouteSegment,\n\tUniqueInterface\n} from './private.js';\nimport { AssetDependencies, SSRNodeLoader, SSRRoute, ValidatedConfig } from './internal.js';\n\nexport { PrerenderOption } from './private.js';\n\n/**\n * [Adapters](https://kit.svelte.dev/docs/adapters) are responsible for taking the production build and turning it into something that can be deployed to a platform of your choosing.\n */\nexport interface Adapter {\n\t/**\n\t * The name of the adapter, using for logging. Will typically correspond to the package name.\n\t */\n\tname: string;\n\t/**\n\t * This function is called after SvelteKit has built your app.\n\t * @param builder An object provided by SvelteKit that contains methods for adapting the app\n\t */\n\tadapt(builder: Builder): MaybePromise<void>;\n}\n\ntype AwaitedPropertiesUnion<input extends Record<string, any> | void> = input extends void\n\t? undefined // needs to be undefined, because void will break intellisense\n\t: input extends Record<string, any>\n\t? {\n\t\t\t[key in keyof input]: Awaited<input[key]>;\n\t  }\n\t: {} extends input // handles the any case\n\t? input\n\t: unknown;\n\nexport type AwaitedProperties<input extends Record<string, any> | void> =\n\tAwaitedPropertiesUnion<input> extends Record<string, any>\n\t\t? OptionalUnion<AwaitedPropertiesUnion<input>>\n\t\t: AwaitedPropertiesUnion<input>;\n\nexport type AwaitedActions<T extends Record<string, (...args: any) => any>> = OptionalUnion<\n\t{\n\t\t[Key in keyof T]: UnpackValidationError<Awaited<ReturnType<T[Key]>>>;\n\t}[keyof T]\n>;\n\n// Takes a union type and returns a union type where each type also has all properties\n// of all possible types (typed as undefined), making accessing them more ergonomic\ntype OptionalUnion<\n\tU extends Record<string, any>, // not unknown, else interfaces don't satisfy this constraint\n\tA extends keyof U = U extends U ? keyof U : never\n> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;\n\ntype UnpackValidationError<T> = T extends ActionFailure<infer X>\n\t? X\n\t: T extends void\n\t? undefined // needs to be undefined, because void will corrupt union type\n\t: T;\n\n/**\n * This object is passed to the `adapt` function of adapters.\n * It contains various methods and properties that are useful for adapting the app.\n */\nexport interface Builder {\n\t/** Print messages to the console. `log.info` and `log.minor` are silent unless Vite's `logLevel` is `info`. */\n\tlog: Logger;\n\t/** Remove `dir` and all its contents. */\n\trimraf(dir: string): void;\n\t/** Create `dir` and any required parent directories. */\n\tmkdirp(dir: string): void;\n\n\t/** The fully resolved `svelte.config.js`. */\n\tconfig: ValidatedConfig;\n\t/** Information about prerendered pages and assets, if any. */\n\tprerendered: Prerendered;\n\t/** An array of dynamic (not prerendered) routes */\n\troutes: RouteDefinition[];\n\n\t/**\n\t * Create separate functions that map to one or more routes of your app.\n\t * @param fn A function that groups a set of routes into an entry point\n\t * @deprecated Use `builder.routes` instead\n\t */\n\tcreateEntries(fn: (route: RouteDefinition) => AdapterEntry): Promise<void>;\n\n\t/**\n\t * Generate a fallback page for a static webserver to use when no route is matched. Useful for single-page apps.\n\t */\n\tgenerateFallback(dest: string): Promise<void>;\n\n\t/**\n\t * Generate a server-side manifest to initialise the SvelteKit [server](https://kit.svelte.dev/docs/types#public-types-server) with.\n\t * @param opts a relative path to the base directory of the app and optionally in which format (esm or cjs) the manifest should be generated\n\t */\n\tgenerateManifest(opts: { relativePath: string; routes?: RouteDefinition[] }): string;\n\n\t/**\n\t * Resolve a path to the `name` directory inside `outDir`, e.g. `/path/to/.svelte-kit/my-adapter`.\n\t * @param name path to the file, relative to the build directory\n\t */\n\tgetBuildDirectory(name: string): string;\n\t/** Get the fully resolved path to the directory containing client-side assets, including the contents of your `static` directory. */\n\tgetClientDirectory(): string;\n\t/** Get the fully resolved path to the directory containing server-side code. */\n\tgetServerDirectory(): string;\n\t/** Get the application path including any configured `base` path, e.g. `/my-base-path/_app`. */\n\tgetAppPath(): string;\n\n\t/**\n\t * Write client assets to `dest`.\n\t * @param dest the destination folder\n\t * @returns an array of files written to `dest`\n\t */\n\twriteClient(dest: string): string[];\n\t/**\n\t * Write prerendered files to `dest`.\n\t * @param dest the destination folder\n\t * @returns an array of files written to `dest`\n\t */\n\twritePrerendered(dest: string): string[];\n\t/**\n\t * Write server-side code to `dest`.\n\t * @param dest the destination folder\n\t * @returns an array of files written to `dest`\n\t */\n\twriteServer(dest: string): string[];\n\t/**\n\t * Copy a file or directory.\n\t * @param from the source file or directory\n\t * @param to the destination file or directory\n\t * @param opts.filter a function to determine whether a file or directory should be copied\n\t * @param opts.replace a map of strings to replace\n\t * @returns an array of files that were copied\n\t */\n\tcopy(\n\t\tfrom: string,\n\t\tto: string,\n\t\topts?: {\n\t\t\tfilter?(basename: string): boolean;\n\t\t\treplace?: Record<string, string>;\n\t\t}\n\t): string[];\n\n\t/**\n\t * Compress files in `directory` with gzip and brotli, where appropriate. Generates `.gz` and `.br` files alongside the originals.\n\t * @param {string} directory The directory containing the files to be compressed\n\t */\n\tcompress(directory: string): Promise<void>;\n}\n\nexport interface Config {\n\t/**\n\t * Options passed to [`svelte.compile`](https://svelte.dev/docs#compile-time-svelte-compile).\n\t * @default {}\n\t */\n\tcompilerOptions?: CompileOptions;\n\t/**\n\t * List of file extensions that should be treated as Svelte files.\n\t * @default [\".svelte\"]\n\t */\n\textensions?: string[];\n\t/** SvelteKit options */\n\tkit?: KitConfig;\n\t/** [`@sveltejs/package`](/docs/packaging) options. */\n\tpackage?: {\n\t\tsource?: string;\n\t\tdir?: string;\n\t\temitTypes?: boolean;\n\t\texports?(filepath: string): boolean;\n\t\tfiles?(filepath: string): boolean;\n\t};\n\t/** Preprocessor options, if any. Preprocessing can alternatively also be done through Vite's preprocessor capabilities. */\n\tpreprocess?: any;\n\t/** Any additional options required by tooling that integrates with Svelte. */\n\t[key: string]: any;\n}\n\nexport interface Cookies {\n\t/**\n\t * Gets a cookie that was previously set with `cookies.set`, or from the request headers.\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directly to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tget(name: string, opts?: import('cookie').CookieParseOptions): string | undefined;\n\n\t/**\n\t * Gets all cookies that were previously set with `cookies.set`, or from the request headers.\n\t * @param opts the options, passed directily to `cookie.parse`. See documentation [here](https://github.com/jshttp/cookie#cookieparsestr-options)\n\t */\n\tgetAll(opts?: import('cookie').CookieParseOptions): Array<{ name: string; value: string }>;\n\n\t/**\n\t * Sets a cookie. This will add a `set-cookie` header to the response, but also make the cookie available via `cookies.get` or `cookies.getAll` during the current request.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * By default, the `path` of a cookie is the 'directory' of the current pathname. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app.\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directory to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tset(name: string, value: string, opts?: import('cookie').CookieSerializeOptions): void;\n\n\t/**\n\t * Deletes a cookie by setting its value to an empty string and setting the expiry date in the past.\n\t *\n\t * By default, the `path` of a cookie is the 'directory' of the current pathname. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app.\n\t * @param name the name of the cookie\n\t * @param opts the options, passed directory to `cookie.serialize`. The `path` must match the path of the cookie you want to delete. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tdelete(name: string, opts?: import('cookie').CookieSerializeOptions): void;\n\n\t/**\n\t * Serialize a cookie name-value pair into a `Set-Cookie` header string, but don't apply it to the response.\n\t *\n\t * The `httpOnly` and `secure` options are `true` by default (except on http://localhost, where `secure` is `false`), and must be explicitly disabled if you want cookies to be readable by client-side JavaScript and/or transmitted over HTTP. The `sameSite` option defaults to `lax`.\n\t *\n\t * By default, the `path` of a cookie is the current pathname. In most cases you should explicitly set `path: '/'` to make the cookie available throughout your app.\n\t *\n\t * @param name the name of the cookie\n\t * @param value the cookie value\n\t * @param opts the options, passed directory to `cookie.serialize`. See documentation [here](https://github.com/jshttp/cookie#cookieserializename-value-options)\n\t */\n\tserialize(name: string, value: string, opts?: import('cookie').CookieSerializeOptions): string;\n}\n\nexport interface KitConfig {\n\t/**\n\t * Your [adapter](https://kit.svelte.dev/docs/adapters) is run when executing `vite build`. It determines how the output is converted for different platforms.\n\t * @default undefined\n\t */\n\tadapter?: Adapter;\n\t/**\n\t * An object containing zero or more aliases used to replace values in `import` statements. These aliases are automatically passed to Vite and TypeScript.\n\t *\n\t * ```js\n\t * /// file: svelte.config.js\n\t * /// type: import('@sveltejs/kit').Config\n\t * const config = {\n\t *   kit: {\n\t *     alias: {\n\t *       // this will match a file\n\t *       'my-file': 'path/to/my-file.js',\n\t *\n\t *       // this will match a directory and its contents\n\t *       // (`my-directory/x` resolves to `path/to/my-directory/x`)\n\t *       'my-directory': 'path/to/my-directory',\n\t *\n\t *       // an alias ending /* will only match\n\t *       // the contents of a directory, not the directory itself\n\t *       'my-directory/*': 'path/to/my-directory/*'\n\t *     }\n\t *   }\n\t * };\n\t * ```\n\t *\n\t * > The built-in `$lib` alias is controlled by `config.kit.files.lib` as it is used for packaging.\n\t *\n\t * > You will need to run `npm run dev` to have SvelteKit automatically generate the required alias configuration in `jsconfig.json` or `tsconfig.json`.\n\t * @default {}\n\t */\n\talias?: Record<string, string>;\n\t/**\n\t * The directory relative to `paths.assets` where the built JS and CSS (and imported assets) are served from. (The filenames therein contain content-based hashes, meaning they can be cached indefinitely). Must not start or end with `/`.\n\t * @default \"_app\"\n\t */\n\tappDir?: string;\n\t/**\n\t * [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...\n\t *\n\t * ```js\n\t * /// file: svelte.config.js\n\t * /// type: import('@sveltejs/kit').Config\n\t * const config = {\n\t *   kit: {\n\t *     csp: {\n\t *       directives: {\n\t *         'script-src': ['self']\n\t *       },\n\t *       reportOnly: {\n\t *         'script-src': ['self']\n\t *       }\n\t *     }\n\t *   }\n\t * };\n\t *\n\t * export default config;\n\t * ```\n\t *\n\t * ...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on `mode`) for any inline styles and scripts it generates.\n\t *\n\t * To add a nonce for scripts and links manually included in `src/app.html`, you may use the placeholder `%sveltekit.nonce%` (for example `<script nonce=\"%sveltekit.nonce%\">`).\n\t *\n\t * When pages are prerendered, the CSP header is added via a `<meta http-equiv>` tag (note that in this case, `frame-ancestors`, `report-uri` and `sandbox` directives will be ignored).\n\t *\n\t * > When `mode` is `'auto'`, SvelteKit will use nonces for dynamically rendered pages and hashes for prerendered pages. Using nonces with prerendered pages is insecure and therefore forbidden.\n\t *\n\t * > Note that most [Svelte transitions](https://svelte.dev/tutorial/transition) work by creating an inline `<style>` element. If you use these in your app, you must either leave the `style-src` directive unspecified or add `unsafe-inline`.\n\t *\n\t * If this level of configuration is insufficient and you have more dynamic requirements, you can use the [`handle` hook](https://kit.svelte.dev/docs/hooks#server-hooks-handle) to roll your own CSP.\n\t */\n\tcsp?: {\n\t\t/**\n\t\t * Whether to use hashes or nonces to restrict `<script>` and `<style>` elements. `'auto'` will use hashes for prerendered pages, and nonces for dynamically rendered pages.\n\t\t */\n\t\tmode?: 'hash' | 'nonce' | 'auto';\n\t\t/**\n\t\t * Directives that will be added to `Content-Security-Policy` headers.\n\t\t */\n\t\tdirectives?: CspDirectives;\n\t\t/**\n\t\t * Directives that will be added to `Content-Security-Policy-Report-Only` headers.\n\t\t */\n\t\treportOnly?: CspDirectives;\n\t};\n\t/**\n\t * Protection against [cross-site request forgery](https://owasp.org/www-community/attacks/csrf) attacks.\n\t */\n\tcsrf?: {\n\t\t/**\n\t\t * Whether to check the incoming `origin` header for `POST` form submissions and verify that it matches the server's origin.\n\t\t *\n\t\t * To allow people to make `POST` form submissions to your app from other origins, you will need to disable this option. Be careful!\n\t\t * @default true\n\t\t */\n\t\tcheckOrigin?: boolean;\n\t};\n\t/**\n\t * Whether or not the app is embedded inside a larger app. If `true`, SvelteKit will add its event listeners related to navigation etc on the parent of `%sveltekit.body%` instead of `window`, and will pass `params` from the server rather than inferring them from `location.pathname`.\n\t * @default false\n\t */\n\tembedded?: boolean;\n\t/**\n\t * Environment variable configuration\n\t */\n\tenv?: {\n\t\t/**\n\t\t * The directory to search for `.env` files.\n\t\t * @default \".\"\n\t\t */\n\t\tdir?: string;\n\t\t/**\n\t\t * A prefix that signals that an environment variable is safe to expose to client-side code. See [`$env/static/public`](/docs/modules#$env-static-public) and [`$env/dynamic/public`](/docs/modules#$env-dynamic-public). Note that Vite's [`envPrefix`](https://vitejs.dev/config/shared-options.html#envprefix) must be set separately if you are using Vite's environment variable handling - though use of that feature should generally be unnecessary.\n\t\t * @default \"PUBLIC_\"\n\t\t */\n\t\tpublicPrefix?: string;\n\t};\n\t/**\n\t * Where to find various files within your project.\n\t */\n\tfiles?: {\n\t\t/**\n\t\t * a place to put static files that should have stable URLs and undergo no processing, such as `favicon.ico` or `manifest.json`\n\t\t * @default \"static\"\n\t\t */\n\t\tassets?: string;\n\t\thooks?: {\n\t\t\t/**\n\t\t\t * The location of your client [hooks](https://kit.svelte.dev/docs/hooks).\n\t\t\t * @default \"src/hooks.client\"\n\t\t\t */\n\t\t\tclient?: string;\n\t\t\t/**\n\t\t\t * The location of your server [hooks](https://kit.svelte.dev/docs/hooks).\n\t\t\t * @default \"src/hooks.server\"\n\t\t\t */\n\t\t\tserver?: string;\n\t\t};\n\t\t/**\n\t\t * your app's internal library, accessible throughout the codebase as `$lib`\n\t\t * @default \"src/lib\"\n\t\t */\n\t\tlib?: string;\n\t\t/**\n\t\t * a directory containing [parameter matchers](https://kit.svelte.dev/docs/advanced-routing#matching)\n\t\t * @default \"src/params\"\n\t\t */\n\t\tparams?: string;\n\t\t/**\n\t\t * the files that define the structure of your app (see [Routing](https://kit.svelte.dev/docs/routing))\n\t\t * @default \"src/routes\"\n\t\t */\n\t\troutes?: string;\n\t\t/**\n\t\t * the location of your service worker's entry point (see [Service workers](https://kit.svelte.dev/docs/service-workers))\n\t\t * @default \"src/service-worker\"\n\t\t */\n\t\tserviceWorker?: string;\n\t\t/**\n\t\t * the location of the template for HTML responses\n\t\t * @default \"src/app.html\"\n\t\t */\n\t\tappTemplate?: string;\n\t\t/**\n\t\t * the location of the template for fallback error responses\n\t\t * @default \"src/error.html\"\n\t\t */\n\t\terrorTemplate?: string;\n\t};\n\t/**\n\t * Inline CSS inside a `<style>` block at the head of the HTML. This option is a number that specifies the maximum length of a CSS file to be inlined. All CSS files needed for the page and smaller than this value are merged and inlined in a `<style>` block.\n\t *\n\t * > This results in fewer initial requests and can improve your [First Contentful Paint](https://web.dev/first-contentful-paint) score. However, it generates larger HTML output and reduces the effectiveness of browser caches. Use it advisedly.\n\t * @default 0\n\t */\n\tinlineStyleThreshold?: number;\n\t/**\n\t * An array of file extensions that SvelteKit will treat as modules. Files with extensions that match neither `config.extensions` nor `config.kit.moduleExtensions` will be ignored by the router.\n\t * @default [\".js\", \".ts\"]\n\t */\n\tmoduleExtensions?: string[];\n\t/**\n\t * The directory that SvelteKit writes files to during `dev` and `build`. You should exclude this directory from version control.\n\t * @default \".svelte-kit\"\n\t */\n\toutDir?: string;\n\t/**\n\t * Options related to the build output format\n\t */\n\toutput?: {\n\t\t/**\n\t\t * SvelteKit will preload the JavaScript modules needed for the initial page to avoid import 'waterfalls', resulting in faster application startup. There\n\t\t * are three strategies with different trade-offs:\n\t\t * - `modulepreload` - uses `<link rel=\"modulepreload\">`. This delivers the best results in Chromium-based browsers, but is currently ignored by Firefox and Safari (though support is coming to Safari soon).\n\t\t * - `preload-js` - uses `<link rel=\"preload\">`. Prevents waterfalls in Chromium and Safari, but Chromium will parse each module twice (once as a script, once as a module). Causes modules to be requested twice in Firefox. This is a good setting if you want to maximise performance for users on iOS devices at the cost of a very slight degradation for Chromium users.\n\t\t * - `preload-mjs` - uses `<link rel=\"preload\">` but with the `.mjs` extension which prevents double-parsing in Chromium. Some static webservers will fail to serve .mjs files with a `Content-Type: application/javascript` header, which will cause your application to break. If that doesn't apply to you, this is the option that will deliver the best performance for the largest number of users, until `modulepreload` is more widely supported.\n\t\t * @default \"modulepreload\"\n\t\t */\n\t\tpreloadStrategy?: 'modulepreload' | 'preload-js' | 'preload-mjs';\n\t};\n\tpaths?: {\n\t\t/**\n\t\t * An absolute path that your app's files are served from. This is useful if your files are served from a storage bucket of some kind.\n\t\t * @default \"\"\n\t\t */\n\t\tassets?: '' | `http://${string}` | `https://${string}`;\n\t\t/**\n\t\t * A root-relative path that must start, but not end with `/` (e.g. `/base-path`), unless it is the empty string. This specifies where your app is served from and allows the app to live on a non-root path. Note that you need to prepend all your root-relative links with the base value or they will point to the root of your domain, not your `base` (this is how the browser works). You can use [`base` from `$app/paths`](/docs/modules#$app-paths-base) for that: `<a href=\"{base}/your-page\">Link</a>`. If you find yourself writing this often, it may make sense to extract this into a reusable component.\n\t\t * @default \"\"\n\t\t */\n\t\tbase?: '' | `/${string}`;\n\t\t/**\n\t\t * Whether to use relative asset paths. By default, if `paths.assets` is not external, SvelteKit will replace `%sveltekit.assets%` with a relative path and use relative paths to reference build artifacts, but `base` and `assets` imported from `$app/paths` will be as specified in your config.\n\t\t *\n\t\t * If `true`, `base` and `assets` imported from `$app/paths` will be replaced with relative asset paths during server-side rendering, resulting in portable HTML.\n\t\t * If `false`, `%sveltekit.assets%` and references to build artifacts will always be root-relative paths, unless `paths.assets` is an external URL\n\t\t * @default undefined\n\t\t */\n\t\trelative?: boolean | undefined;\n\t};\n\t/**\n\t * See [Prerendering](https://kit.svelte.dev/docs/page-options#prerender).\n\t */\n\tprerender?: {\n\t\t/**\n\t\t * How many pages can be prerendered simultaneously. JS is single-threaded, but in cases where prerendering performance is network-bound (for example loading content from a remote CMS) this can speed things up by processing other tasks while waiting on the network response.\n\t\t * @default 1\n\t\t */\n\t\tconcurrency?: number;\n\t\t/**\n\t\t * Whether SvelteKit should find pages to prerender by following links from `entries`.\n\t\t * @default true\n\t\t */\n\t\tcrawl?: boolean;\n\t\t/**\n\t\t * An array of pages to prerender, or start crawling from (if `crawl: true`). The `*` string includes all non-dynamic routes (i.e. pages with no `[parameters]`, because SvelteKit doesn't know what value the parameters should have).\n\t\t * @default [\"*\"]\n\t\t */\n\t\tentries?: Array<'*' | `/${string}`>;\n\t\t/**\n\t\t * How to respond to HTTP errors encountered while prerendering the app.\n\t\t *\n\t\t * - `'fail'` — fail the build\n\t\t * - `'ignore'` - silently ignore the failure and continue\n\t\t * - `'warn'` — continue, but print a warning\n\t\t * - `(details) => void` — a custom error handler that takes a `details` object with `status`, `path`, `referrer`, `referenceType` and `message` properties. If you `throw` from this function, the build will fail\n\t\t *\n\t\t * ```js\n\t\t * /// file: svelte.config.js\n\t\t * /// type: import('@sveltejs/kit').Config\n\t\t * const config = {\n\t\t *   kit: {\n\t\t *     prerender: {\n\t\t *       handleHttpError: ({ path, referrer, message }) => {\n\t\t *         // ignore deliberate link to shiny 404 page\n\t\t *         if (path === '/not-found' && referrer === '/blog/how-we-built-our-404-page') {\n\t\t *           return;\n\t\t *         }\n\t\t *\n\t\t *         // otherwise fail the build\n\t\t *         throw new Error(message);\n\t\t *       }\n\t\t *     }\n\t\t *   }\n\t\t * };\n\t\t * ```\n\t\t *\n\t\t * @default \"fail\"\n\t\t */\n\t\thandleHttpError?: PrerenderHttpErrorHandlerValue;\n\t\t/**\n\t\t * How to respond to hash links from one prerendered page to another that don't correspond to an `id` on the destination page\n\t\t *\n\t\t * - `'fail'` — fail the build\n\t\t * - `'ignore'` - silently ignore the failure and continue\n\t\t * - `'warn'` — continue, but print a warning\n\t\t * - `(details) => void` — a custom error handler that takes a `details` object with `path`, `id`, `referrers` and `message` properties. If you `throw` from this function, the build will fail\n\t\t *\n\t\t * @default \"fail\"\n\t\t */\n\t\thandleMissingId?: PrerenderMissingIdHandlerValue;\n\t\t/**\n\t\t * The value of `url.origin` during prerendering; useful if it is included in rendered content.\n\t\t * @default \"http://sveltekit-prerender\"\n\t\t */\n\t\torigin?: string;\n\t};\n\tserviceWorker?: {\n\t\t/**\n\t\t * Whether to automatically register the service worker, if it exists.\n\t\t * @default true\n\t\t */\n\t\tregister?: boolean;\n\t\t/**\n\t\t * Determine which files in your `static` directory will be available in `$service-worker.files`.\n\t\t * @default (filename) => !/\\.DS_Store/.test(filename)\n\t\t */\n\t\tfiles?(filepath: string): boolean;\n\t};\n\ttypescript?: {\n\t\t/**\n\t\t * A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one.\n\t\t * This is useful for extending a shared `tsconfig.json` in a monorepo root, for example.\n\t\t * @default (config) => config\n\t\t */\n\t\tconfig?: (config: Record<string, any>) => Record<string, any> | void;\n\t};\n\t/**\n\t * Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn't, the app's route manifest may point to a JavaScript file that no longer exists.\n\t * SvelteKit helps you solve this problem through version management.\n\t * If SvelteKit encounters an error while loading the page and detects that a new version has been deployed (using the `name` specified here, which defaults to a timestamp of the build) it will fall back to traditional full-page navigation.\n\t * Not all navigations will result in an error though, for example if the JavaScript for the next page is already loaded. If you still want to force a full-page navigation in these cases, use techniques such as setting the `pollInterval` and then using `beforeNavigate`:\n\t * ```html\n\t * /// +layout.svelte\n\t * <script>\n\t * import { beforeNavigate } from '$app/navigation';\n\t * import { updated } from '$app/stores';\n\t *\n\t * beforeNavigate(({ willUnload, to }) => {\n\t *   if ($updated && !willUnload && to?.url) {\n\t *     location.href = to.url.href;\n\t *   }\n\t * });\n\t * </script>\n\t * ```\n\t *\n\t * If you set `pollInterval` to a non-zero value, SvelteKit will poll for new versions in the background and set the value of the [`updated`](/docs/modules#$app-stores-updated) store to `true` when it detects one.\n\t */\n\tversion?: {\n\t\t/**\n\t\t * The current app version string. If specified, this must be deterministic (e.g. a commit ref rather than `Math.random()` or `Date.now().toString()`), otherwise defaults to a timestamp of the build\n\t\t */\n\t\tname?: string;\n\t\t/**\n\t\t * The interval in milliseconds to poll for version changes. If this is `0`, no polling occurs.\n\t\t * @default 0\n\t\t */\n\t\tpollInterval?: number;\n\t};\n}\n\n/**\n * The [`handle`](https://kit.svelte.dev/docs/hooks#server-hooks-handle) hook runs every time the SvelteKit server receives a [request](https://kit.svelte.dev/docs/web-standards#fetch-apis-request) and\n * determines the [response](https://kit.svelte.dev/docs/web-standards#fetch-apis-response).\n * It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`.\n * This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).\n */\nexport interface Handle {\n\t(input: {\n\t\tevent: RequestEvent;\n\t\tresolve(event: RequestEvent, opts?: ResolveOptions): MaybePromise<Response>;\n\t}): MaybePromise<Response>;\n}\n\n/**\n * The server-side [`handleError`](https://kit.svelte.dev/docs/hooks#shared-hooks-handleerror) hook runs when an unexpected error is thrown while responding to a request.\n *\n * If an unexpected error is thrown during loading or rendering, this function will be called with the error and the event.\n * Make sure that this function _never_ throws an error.\n */\nexport interface HandleServerError {\n\t(input: { error: unknown; event: RequestEvent }): MaybePromise<void | App.Error>;\n}\n\n/**\n * The client-side [`handleError`](https://kit.svelte.dev/docs/hooks#shared-hooks-handleerror) hook runs when an unexpected error is thrown while navigating.\n *\n * If an unexpected error is thrown during loading or the following render, this function will be called with the error and the event.\n * Make sure that this function _never_ throws an error.\n */\nexport interface HandleClientError {\n\t(input: { error: unknown; event: NavigationEvent }): MaybePromise<void | App.Error>;\n}\n\n/**\n * The [`handleFetch`](https://kit.svelte.dev/docs/hooks#server-hooks-handlefetch) hook allows you to modify (or replace) a `fetch` request that happens inside a `load` function that runs on the server (or during pre-rendering)\n */\nexport interface HandleFetch {\n\t(input: { event: RequestEvent; request: Request; fetch: typeof fetch }): MaybePromise<Response>;\n}\n\n/**\n * The generic form of `PageLoad` and `LayoutLoad`. You should import those from `./$types` (see [generated types](https://kit.svelte.dev/docs/types#generated-types))\n * rather than using `Load` directly.\n */\nexport interface Load<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tInputData extends Record<string, unknown> | null = Record<string, any> | null,\n\tParentData extends Record<string, unknown> = Record<string, any>,\n\tOutputData extends Record<string, unknown> | void = Record<string, any> | void,\n\tRouteId extends string | null = string | null\n> {\n\t(event: LoadEvent<Params, InputData, ParentData, RouteId>): MaybePromise<OutputData>;\n}\n\n/**\n * The generic form of `PageLoadEvent` and `LayoutLoadEvent`. You should import those from `./$types` (see [generated types](https://kit.svelte.dev/docs/types#generated-types))\n * rather than using `LoadEvent` directly.\n */\nexport interface LoadEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tData extends Record<string, unknown> | null = Record<string, any> | null,\n\tParentData extends Record<string, unknown> = Record<string, any>,\n\tRouteId extends string | null = string | null\n> extends NavigationEvent<Params, RouteId> {\n\t/**\n\t * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:\n\t *\n\t * - it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request\n\t * - it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)\n\t * - internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call\n\t * - during server-side rendering, the response will be captured and inlined into the rendered HTML. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](https://kit.svelte.dev/docs/hooks#server-hooks-handle)\n\t * - during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request\n\t *\n\t * > Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.\n\t */\n\tfetch: typeof fetch;\n\t/**\n\t * Contains the data returned by the route's server `load` function (in `+layout.server.js` or `+page.server.js`), if any.\n\t */\n\tdata: Data;\n\t/**\n\t * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:\n\t *\n\t *\t```js\n\t *\t/// file: src/routes/blog/+page.js\n\t *\texport async function load({ fetch, setHeaders }) {\n\t *\t\tconst url = `https://cms.example.com/articles.json`;\n\t *\t\tconst response = await fetch(url);\n\t *\n\t *\t\tsetHeaders({\n\t *\t\t\tage: response.headers.get('age'),\n\t *\t\t\t'cache-control': response.headers.get('cache-control')\n\t *\t\t});\n\t *\n\t *\t\treturn response.json();\n\t *\t}\n\t *\t```\n\t *\n\t * Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.\n\t *\n\t * You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](https://kit.svelte.dev/docs/types#public-types-cookies) API in a server-only `load` function instead.\n\t *\n\t * `setHeaders` has no effect when a `load` function runs in the browser.\n\t */\n\tsetHeaders(headers: Record<string, string>): void;\n\t/**\n\t * `await parent()` returns data from parent `+layout.js` `load` functions.\n\t * Implicitly, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will return and forward data from parent `+layout.server.js` files.\n\t *\n\t * Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.\n\t */\n\tparent(): Promise<ParentData>;\n\t/**\n\t * This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/modules#$app-navigation-invalidate) to cause `load` to rerun.\n\t *\n\t * Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`.\n\t *\n\t * URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).\n\t *\n\t * Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).\n\t *\n\t * The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.\n\t *\n\t * ```js\n\t * /// file: src/routes/+page.js\n\t * let count = 0;\n\t * export async function load({ depends }) {\n\t * \tdepends('increase:count');\n\t *\n\t * \treturn { count: count++ };\n\t * }\n\t * ```\n\t *\n\t * ```html\n\t * /// file: src/routes/+page.svelte\n\t * <script>\n\t * \timport { invalidate } from '$app/navigation';\n\t *\n\t * \texport let data;\n\t *\n\t * \tconst increase = async () => {\n\t * \t\tawait invalidate('increase:count');\n\t * \t}\n\t * </script>\n\t *\n\t * <p>{data.count}<p>\n\t * <button on:click={increase}>Increase Count</button>\n\t * ```\n\t */\n\tdepends(...deps: string[]): void;\n}\n\nexport interface NavigationEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tRouteId extends string | null = string | null\n> {\n\t/**\n\t * The parameters of the current page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object\n\t */\n\tparams: Params;\n\t/**\n\t * Info about the current route\n\t */\n\troute: {\n\t\t/**\n\t\t * The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`\n\t\t */\n\t\tid: RouteId;\n\t};\n\t/**\n\t * The URL of the current page\n\t */\n\turl: URL;\n}\n\n/**\n * Information about the target of a specific navigation.\n */\nexport interface NavigationTarget {\n\t/**\n\t * Parameters of the target page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object.\n\t * Is `null` if the target is not part of the SvelteKit app (could not be resolved to a route).\n\t */\n\tparams: Record<string, string> | null;\n\t/**\n\t * Info about the target route\n\t */\n\troute: { id: string | null };\n\t/**\n\t * The URL that is navigated to\n\t */\n\turl: URL;\n}\n\n/**\n * - `enter`: The app has hydrated\n * - `form`: The user submitted a `<form>`\n * - `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document\n * - `link`: Navigation was triggered by a link click\n * - `goto`: Navigation was triggered by a `goto(...)` call or a redirect\n * - `popstate`: Navigation was triggered by back/forward navigation\n */\nexport type NavigationType = 'enter' | 'form' | 'leave' | 'link' | 'goto' | 'popstate';\n\nexport interface Navigation {\n\t/**\n\t * Where navigation was triggered from\n\t */\n\tfrom: NavigationTarget | null;\n\t/**\n\t * Where navigation is going to/has gone to\n\t */\n\tto: NavigationTarget | null;\n\t/**\n\t * The type of navigation:\n\t * - `form`: The user submitted a `<form>`\n\t * - `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document\n\t * - `link`: Navigation was triggered by a link click\n\t * - `goto`: Navigation was triggered by a `goto(...)` call or a redirect\n\t * - `popstate`: Navigation was triggered by back/forward navigation\n\t */\n\ttype: Omit<NavigationType, 'enter'>;\n\t/**\n\t * Whether or not the navigation will result in the page being unloaded (i.e. not a client-side navigation)\n\t */\n\twillUnload: boolean;\n\t/**\n\t * In case of a history back/forward navigation, the number of steps to go back/forward\n\t */\n\tdelta?: number;\n}\n\n/**\n * The argument passed to [`beforeNavigate`](https://kit.svelte.dev/docs/modules#$app-navigation-beforenavigate) callbacks.\n */\nexport interface BeforeNavigate extends Navigation {\n\t/**\n\t * Call this to prevent the navigation from starting.\n\t */\n\tcancel(): void;\n}\n\n/**\n * The argument passed to [`afterNavigate`](https://kit.svelte.dev/docs/modules#$app-navigation-afternavigate) callbacks.\n */\nexport interface AfterNavigate extends Navigation {\n\t/**\n\t * The type of navigation:\n\t * - `enter`: The app has hydrated\n\t * - `form`: The user submitted a `<form>`\n\t * - `link`: Navigation was triggered by a link click\n\t * - `goto`: Navigation was triggered by a `goto(...)` call or a redirect\n\t * - `popstate`: Navigation was triggered by back/forward navigation\n\t */\n\ttype: Omit<NavigationType, 'leave'>;\n\t/**\n\t * Since `afterNavigate` is called after a navigation completes, it will never be called with a navigation that unloads the page.\n\t */\n\twillUnload: false;\n}\n\n/**\n * The shape of the `$page` store\n */\nexport interface Page<\n\tParams extends Record<string, string> = Record<string, string>,\n\tRouteId extends string | null = string | null\n> {\n\t/**\n\t * The URL of the current page\n\t */\n\turl: URL;\n\t/**\n\t * The parameters of the current page - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object\n\t */\n\tparams: Params;\n\t/**\n\t * Info about the current route\n\t */\n\troute: {\n\t\t/**\n\t\t * The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`\n\t\t */\n\t\tid: RouteId;\n\t};\n\t/**\n\t * Http status code of the current page\n\t */\n\tstatus: number;\n\t/**\n\t * The error object of the current page, if any. Filled from the `handleError` hooks.\n\t */\n\terror: App.Error | null;\n\t/**\n\t * The merged result of all data from all `load` functions on the current page. You can type a common denominator through `App.PageData`.\n\t */\n\tdata: App.PageData & Record<string, any>;\n\t/**\n\t * Filled only after a form submission. See [form actions](https://kit.svelte.dev/docs/form-actions) for more info.\n\t */\n\tform: any;\n}\n\n/**\n * The shape of a param matcher. See [matching](https://kit.svelte.dev/docs/advanced-routing#matching) for more info.\n */\nexport interface ParamMatcher {\n\t(param: string): boolean;\n}\n\nexport interface RequestEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tRouteId extends string | null = string | null\n> {\n\t/**\n\t * Get or set cookies related to the current request\n\t */\n\tcookies: Cookies;\n\t/**\n\t * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:\n\t *\n\t * - it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request\n\t * - it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)\n\t * - internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call\n\t *\n\t * > Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.\n\t */\n\tfetch: typeof fetch;\n\t/**\n\t * The client's IP address, set by the adapter.\n\t */\n\tgetClientAddress(): string;\n\t/**\n\t * Contains custom data that was added to the request within the [`handle hook`](https://kit.svelte.dev/docs/hooks#server-hooks-handle).\n\t */\n\tlocals: App.Locals;\n\t/**\n\t * The parameters of the current route - e.g. for a route like `/blog/[slug]`, a `{ slug: string }` object\n\t */\n\tparams: Params;\n\t/**\n\t * Additional data made available through the adapter.\n\t */\n\tplatform: Readonly<App.Platform> | undefined;\n\t/**\n\t * The original request object\n\t */\n\trequest: Request;\n\t/**\n\t * Info about the current route\n\t */\n\troute: {\n\t\t/**\n\t\t * The ID of the current route - e.g. for `src/routes/blog/[slug]`, it would be `/blog/[slug]`\n\t\t */\n\t\tid: RouteId;\n\t};\n\t/**\n\t * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:\n\t *\n\t *\t```js\n\t *\t/// file: src/routes/blog/+page.js\n\t *\texport async function load({ fetch, setHeaders }) {\n\t *\t\tconst url = `https://cms.example.com/articles.json`;\n\t *\t\tconst response = await fetch(url);\n\t *\n\t *\t\tsetHeaders({\n\t *\t\t\tage: response.headers.get('age'),\n\t *\t\t\t'cache-control': response.headers.get('cache-control')\n\t *\t\t});\n\t *\n\t *\t\treturn response.json();\n\t *\t}\n\t *\t```\n\t *\n\t * Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.\n\t *\n\t * You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](https://kit.svelte.dev/docs/types#public-types-cookies) API instead.\n\t */\n\tsetHeaders(headers: Record<string, string>): void;\n\t/**\n\t * The requested URL.\n\t */\n\turl: URL;\n\t/**\n\t * `true` if the request comes from the client asking for `+page/layout.server.js` data. The `url` property will be stripped of the internal information\n\t * related to the data request in this case. Use this property instead if the distinction is important to you.\n\t */\n\tisDataRequest: boolean;\n}\n\n/**\n * A `(event: RequestEvent) => Response` function exported from a `+server.js` file that corresponds to an HTTP verb (`GET`, `PUT`, `PATCH`, etc) and handles requests with that method.\n *\n * It receives `Params` as the first generic argument, which you can skip by using [generated types](https://kit.svelte.dev/docs/types#generated-types) instead.\n */\nexport interface RequestHandler<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tRouteId extends string | null = string | null\n> {\n\t(event: RequestEvent<Params, RouteId>): MaybePromise<Response>;\n}\n\nexport interface ResolveOptions {\n\t/**\n\t * Applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML\n\t * (they could include an element's opening tag but not its closing tag, for example)\n\t * but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n\t * @param input the html chunk and the info if this is the last chunk\n\t */\n\ttransformPageChunk?(input: { html: string; done: boolean }): MaybePromise<string | undefined>;\n\t/**\n\t * Determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`.\n\t * By default, none will be included.\n\t * @param name header name\n\t * @param value header value\n\t */\n\tfilterSerializedResponseHeaders?(name: string, value: string): boolean;\n\t/**\n\t * Determines what should be added to the `<head>` tag to preload it.\n\t * By default, `js`, `css` and `font` files will be preloaded.\n\t * @param input the type of the file and its path\n\t */\n\tpreload?(input: { type: 'font' | 'css' | 'js' | 'asset'; path: string }): boolean;\n}\n\nexport interface RouteDefinition<Config = any> {\n\tid: string;\n\tapi: {\n\t\tmethods: HttpMethod[];\n\t};\n\tpage: {\n\t\tmethods: Extract<HttpMethod, 'GET' | 'POST'>[];\n\t};\n\tpattern: RegExp;\n\tprerender: PrerenderOption;\n\tsegments: RouteSegment[];\n\tmethods: HttpMethod[];\n\tconfig: Config;\n}\n\nexport class Server {\n\tconstructor(manifest: SSRManifest);\n\tinit(options: ServerInitOptions): Promise<void>;\n\trespond(request: Request, options: RequestOptions): Promise<Response>;\n}\n\nexport interface ServerInitOptions {\n\tenv: Record<string, string>;\n}\n\nexport interface SSRManifest {\n\tappDir: string;\n\tappPath: string;\n\tassets: Set<string>;\n\tmimeTypes: Record<string, string>;\n\n\t/** private fields */\n\t_: {\n\t\tclient: {\n\t\t\tstart: AssetDependencies;\n\t\t\tapp: AssetDependencies;\n\t\t};\n\t\tnodes: SSRNodeLoader[];\n\t\troutes: SSRRoute[];\n\t\tmatchers(): Promise<Record<string, ParamMatcher>>;\n\t};\n}\n\n/**\n * The generic form of `PageServerLoad` and `LayoutServerLoad`. You should import those from `./$types` (see [generated types](https://kit.svelte.dev/docs/types#generated-types))\n * rather than using `ServerLoad` directly.\n */\nexport interface ServerLoad<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tParentData extends Record<string, any> = Record<string, any>,\n\tOutputData extends Record<string, any> | void = Record<string, any> | void,\n\tRouteId extends string | null = string | null\n> {\n\t(event: ServerLoadEvent<Params, ParentData, RouteId>): MaybePromise<OutputData>;\n}\n\nexport interface ServerLoadEvent<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tParentData extends Record<string, any> = Record<string, any>,\n\tRouteId extends string | null = string | null\n> extends RequestEvent<Params, RouteId> {\n\t/**\n\t * `await parent()` returns data from parent `+layout.server.js` `load` functions.\n\t *\n\t * Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.\n\t */\n\tparent(): Promise<ParentData>;\n\t/**\n\t * This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/modules#$app-navigation-invalidate) to cause `load` to rerun.\n\t *\n\t * Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`.\n\t *\n\t * URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).\n\t *\n\t * Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).\n\t *\n\t * The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.\n\t *\n\t * ```js\n\t * /// file: src/routes/+page.js\n\t * let count = 0;\n\t * export async function load({ depends }) {\n\t * \tdepends('increase:count');\n\t *\n\t * \treturn { count: count++ };\n\t * }\n\t * ```\n\t *\n\t * ```html\n\t * /// file: src/routes/+page.svelte\n\t * <script>\n\t * \timport { invalidate } from '$app/navigation';\n\t *\n\t * \texport let data;\n\t *\n\t * \tconst increase = async () => {\n\t * \t\tawait invalidate('increase:count');\n\t * \t}\n\t * </script>\n\t *\n\t * <p>{data.count}<p>\n\t * <button on:click={increase}>Increase Count</button>\n\t * ```\n\t */\n\tdepends(...deps: string[]): void;\n}\n\n/**\n * Shape of a form action method that is part of `export const actions = {..}` in `+page.server.js`.\n * See [form actions](https://kit.svelte.dev/docs/form-actions) for more information.\n */\nexport interface Action<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tOutputData extends Record<string, any> | void = Record<string, any> | void,\n\tRouteId extends string | null = string | null\n> {\n\t(event: RequestEvent<Params, RouteId>): MaybePromise<OutputData>;\n}\n\n/**\n * Shape of the `export const actions = {..}` object in `+page.server.js`.\n * See [form actions](https://kit.svelte.dev/docs/form-actions) for more information.\n */\nexport type Actions<\n\tParams extends Partial<Record<string, string>> = Partial<Record<string, string>>,\n\tOutputData extends Record<string, any> | void = Record<string, any> | void,\n\tRouteId extends string | null = string | null\n> = Record<string, Action<Params, OutputData, RouteId>>;\n\n/**\n * When calling a form action via fetch, the response will be one of these shapes.\n * ```svelte\n * <form method=\"post\" use:enhance={() => {\n *   return ({ result }) => {\n * \t\t// result is of type ActionResult\n *   };\n * }}\n * ```\n */\nexport type ActionResult<\n\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n> =\n\t| { type: 'success'; status: number; data?: Success }\n\t| { type: 'failure'; status: number; data?: Invalid }\n\t| { type: 'redirect'; status: number; location: string }\n\t| { type: 'error'; status?: number; error: any };\n\n/**\n * Creates an `HttpError` object with an HTTP status code and an optional message.\n * This object, if thrown during request handling, will cause SvelteKit to\n * return an error response without invoking `handleError`.\n * Make sure you're not catching the thrown error, which would prevent SvelteKit from handling it.\n * @param status The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses). Must be in the range 400-599.\n * @param body An object that conforms to the App.Error type. If a string is passed, it will be used as the message property.\n */\nexport function error(status: number, body: App.Error): HttpError;\nexport function error(\n\tstatus: number,\n\t// this overload ensures you can omit the argument or pass in a string if App.Error is of type { message: string }\n\tbody?: { message: string } extends App.Error ? App.Error | string | undefined : never\n): HttpError;\n\n/**\n * The object returned by the [`error`](https://kit.svelte.dev/docs/modules#sveltejs-kit-error) function.\n */\nexport interface HttpError {\n\t/** The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses), in the range 400-599. */\n\tstatus: number;\n\t/** The content of the error. */\n\tbody: App.Error;\n}\n\n/**\n * Create a `Redirect` object. If thrown during request handling, SvelteKit will return a redirect response.\n * Make sure you're not catching the thrown redirect, which would prevent SvelteKit from handling it.\n * @param status The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages). Must be in the range 300-308.\n * @param location The location to redirect to.\n */\nexport function redirect(\n\tstatus: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308,\n\tlocation: string\n): Redirect;\n\n/**\n * The object returned by the [`redirect`](https://kit.svelte.dev/docs/modules#sveltejs-kit-redirect) function\n */\nexport interface Redirect {\n\t/** The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages), in the range 300-308. */\n\tstatus: 300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308;\n\t/** The location to redirect to. */\n\tlocation: string;\n}\n\n/**\n * Create a JSON `Response` object from the supplied data.\n * @param data The value that will be serialized as JSON.\n * @param init Options such as `status` and `headers` that will be added to the response. `Content-Type: application/json` and `Content-Length` headers will be added automatically.\n */\nexport function json(data: any, init?: ResponseInit): Response;\n\n/**\n * Create a `Response` object from the supplied body.\n * @param body The value that will be used as-is.\n * @param init Options such as `status` and `headers` that will be added to the response. A `Content-Length` header will be added automatically.\n */\nexport function text(body: string, init?: ResponseInit): Response;\n\n/**\n * Create an `ActionFailure` object.\n * @param status The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses). Must be in the range 400-599.\n * @param data Data associated with the failure (e.g. validation errors)\n */\nexport function fail<T extends Record<string, unknown> | undefined>(\n\tstatus: number,\n\tdata?: T\n): ActionFailure<T>;\n\n/**\n * The object returned by the [`fail`](https://kit.svelte.dev/docs/modules#sveltejs-kit-fail) function\n */\nexport interface ActionFailure<T extends Record<string, unknown> | undefined = undefined>\n\textends UniqueInterface {\n\t/** The [HTTP status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses), in the range 400-599. */\n\tstatus: number;\n\t/** Data associated with the failure (e.g. validation errors) */\n\tdata: T;\n}\n\nexport interface SubmitFunction<\n\tSuccess extends Record<string, unknown> | undefined = Record<string, any>,\n\tInvalid extends Record<string, unknown> | undefined = Record<string, any>\n> {\n\t(input: {\n\t\taction: URL;\n\t\tdata: FormData;\n\t\tform: HTMLFormElement;\n\t\tcontroller: AbortController;\n\t\tcancel(): void;\n\t}): MaybePromise<\n\t\t| void\n\t\t| ((opts: {\n\t\t\t\tform: HTMLFormElement;\n\t\t\t\taction: URL;\n\t\t\t\tresult: ActionResult<Success, Invalid>;\n\t\t\t\t/**\n\t\t\t\t * Call this to get the default behavior of a form submission response.\n\t\t\t\t * @param options Set `reset: false` if you don't want the `<form>` values to be reset after a successful submission.\n\t\t\t\t */\n\t\t\t\tupdate(options?: { reset: boolean }): Promise<void>;\n\t\t  }) => void)\n\t>;\n}\n\n/**\n * The type of `export const snapshot` exported from a page or layout component.\n */\nexport interface Snapshot<T = any> {\n\tcapture: () => T;\n\trestore: (snapshot: T) => void;\n}\n"}},"internal.d.ts":{"file":{"contents":"import { SvelteComponent } from 'svelte/internal';\nimport {\n\tConfig,\n\tServerLoad,\n\tHandle,\n\tHandleServerError,\n\tKitConfig,\n\tLoad,\n\tRequestHandler,\n\tResolveOptions,\n\tServer,\n\tServerInitOptions,\n\tSSRManifest,\n\tHandleFetch,\n\tActions,\n\tHandleClientError\n} from './index.js';\nimport {\n\tHttpMethod,\n\tMaybePromise,\n\tPrerenderOption,\n\tRequestOptions,\n\tTrailingSlash\n} from './private.js';\n\nexport interface ServerModule {\n\tServer: typeof InternalServer;\n}\n\nexport interface ServerInternalModule {\n\tset_building(building: boolean): void;\n\tset_assets(path: string): void;\n\tset_private_env(environment: Record<string, string>): void;\n\tset_public_env(environment: Record<string, string>): void;\n\tset_version(version: string): void;\n\tset_fix_stack_trace(fix_stack_trace: (stack: string) => string): void;\n}\n\nexport interface Asset {\n\tfile: string;\n\tsize: number;\n\ttype: string | null;\n}\n\nexport interface AssetDependencies {\n\tfile: string;\n\timports: string[];\n\tstylesheets: string[];\n\tfonts: string[];\n}\n\nexport interface BuildData {\n\tapp_dir: string;\n\tapp_path: string;\n\tmanifest_data: ManifestData;\n\tservice_worker: string | null;\n\tclient: {\n\t\tstart: AssetDependencies;\n\t\tapp: AssetDependencies;\n\t} | null;\n\tserver_manifest: import('vite').Manifest;\n}\n\nexport interface CSRPageNode {\n\tcomponent: typeof SvelteComponent;\n\tuniversal: {\n\t\tload?: Load;\n\t\ttrailingSlash?: TrailingSlash;\n\t};\n}\n\nexport type CSRPageNodeLoader = () => Promise<CSRPageNode>;\n\n/**\n * Definition of a client side route.\n * The boolean in the tuples indicates whether the route has a server load.\n */\nexport type CSRRoute = {\n\tid: string;\n\texec(path: string): undefined | Record<string, string>;\n\terrors: Array<CSRPageNodeLoader | undefined>;\n\tlayouts: Array<[has_server_load: boolean, node_loader: CSRPageNodeLoader] | undefined>;\n\tleaf: [has_server_load: boolean, node_loader: CSRPageNodeLoader];\n};\n\nexport interface Deferred {\n\tfulfil: (value: any) => void;\n\treject: (error: Error) => void;\n}\n\nexport type GetParams = (match: RegExpExecArray) => Record<string, string>;\n\nexport interface ServerHooks {\n\thandleFetch: HandleFetch;\n\thandle: Handle;\n\thandleError: HandleServerError;\n}\n\nexport interface ClientHooks {\n\thandleError: HandleClientError;\n}\n\nexport interface Env {\n\tprivate: Record<string, string>;\n\tpublic: Record<string, string>;\n}\n\nexport class InternalServer extends Server {\n\tinit(options: ServerInitOptions): Promise<void>;\n\trespond(\n\t\trequest: Request,\n\t\toptions: RequestOptions & {\n\t\t\tprerendering?: PrerenderOptions;\n\t\t\tread: (file: string) => Buffer;\n\t\t}\n\t): Promise<Response>;\n}\n\nexport interface ManifestData {\n\tassets: Asset[];\n\tnodes: PageNode[];\n\troutes: RouteData[];\n\tmatchers: Record<string, string>;\n}\n\nexport interface PageNode {\n\tdepth: number;\n\tcomponent?: string; // TODO supply default component if it's missing (bit of an edge case)\n\tuniversal?: string;\n\tserver?: string;\n\tparent_id?: string;\n\tparent?: PageNode;\n\t/**\n\t * Filled with the pages that reference this layout (if this is a layout)\n\t */\n\tchild_pages?: PageNode[];\n}\n\nexport interface PrerenderDependency {\n\tresponse: Response;\n\tbody: null | string | Uint8Array;\n}\n\nexport interface PrerenderOptions {\n\tcache?: string; // including this here is a bit of a hack, but it makes it easy to add <meta http-equiv>\n\tfallback?: boolean;\n\tdependencies: Map<string, PrerenderDependency>;\n}\n\nexport type RecursiveRequired<T> = {\n\t// Recursive implementation of TypeScript's Required utility type.\n\t// Will recursively continue until it reaches a primitive or Function\n\t[K in keyof T]-?: Extract<T[K], Function> extends never // If it does not have a Function type\n\t\t? RecursiveRequired<T[K]> // recursively continue through.\n\t\t: T[K]; // Use the exact type for everything else\n};\n\nexport type RequiredResolveOptions = Required<ResolveOptions>;\n\nexport interface RouteParam {\n\tname: string;\n\tmatcher: string;\n\toptional: boolean;\n\trest: boolean;\n\tchained: boolean;\n}\n\n/**\n * Represents a route segment in the app. It can either be an intermediate node\n * with only layout/error pages, or a leaf, at which point either `page` and `leaf`\n * or `endpoint` is set.\n */\nexport interface RouteData {\n\tid: string;\n\tparent: RouteData | null;\n\n\tsegment: string;\n\tpattern: RegExp;\n\tparams: RouteParam[];\n\n\tlayout: PageNode | null;\n\terror: PageNode | null;\n\tleaf: PageNode | null;\n\n\tpage: {\n\t\tlayouts: Array<number | undefined>;\n\t\terrors: Array<number | undefined>;\n\t\tleaf: number;\n\t} | null;\n\n\tendpoint: {\n\t\tfile: string;\n\t} | null;\n}\n\nexport type ServerRedirectNode = {\n\ttype: 'redirect';\n\tlocation: string;\n};\n\nexport type ServerNodesResponse = {\n\ttype: 'data';\n\t/**\n\t * If `null`, then there was no load function <- TODO is this outdated now with the recent changes?\n\t */\n\tnodes: Array<ServerDataNode | ServerDataSkippedNode | ServerErrorNode | null>;\n};\n\nexport type ServerDataResponse = ServerRedirectNode | ServerNodesResponse;\n\n/**\n * Signals a successful response of the server `load` function.\n * The `uses` property tells the client when it's possible to reuse this data\n * in a subsequent request.\n */\nexport interface ServerDataNode {\n\ttype: 'data';\n\t/**\n\t * The serialized version of this contains a serialized representation of any deferred promises,\n\t * which will be resolved later through chunk nodes.\n\t */\n\tdata: Record<string, any> | null;\n\tuses: Uses;\n\tslash?: TrailingSlash;\n}\n\n/**\n * Resolved data/error of a deferred promise.\n */\nexport interface ServerDataChunkNode {\n\ttype: 'chunk';\n\tid: number;\n\tdata?: Record<string, any>;\n\terror?: any;\n}\n\n/**\n * Signals that the server `load` function was not run, and the\n * client should use what it has in memory\n */\nexport interface ServerDataSkippedNode {\n\ttype: 'skip';\n}\n\n/**\n * Signals that the server `load` function failed\n */\nexport interface ServerErrorNode {\n\ttype: 'error';\n\terror: App.Error;\n\t/**\n\t * Only set for HttpErrors\n\t */\n\tstatus?: number;\n}\n\nexport interface ServerMetadataRoute {\n\tconfig: any;\n\tapi: {\n\t\tmethods: HttpMethod[];\n\t};\n\tpage: {\n\t\tmethods: Array<'GET' | 'POST'>;\n\t};\n\tmethods: HttpMethod[];\n\tprerender: PrerenderOption | undefined;\n}\n\nexport interface ServerMetadata {\n\tnodes: Array<{ has_server_load: boolean }>;\n\troutes: Map<string, ServerMetadataRoute>;\n}\n\nexport interface SSRComponent {\n\tdefault: {\n\t\trender(props: Record<string, any>): {\n\t\t\thtml: string;\n\t\t\thead: string;\n\t\t\tcss: {\n\t\t\t\tcode: string;\n\t\t\t\tmap: any; // TODO\n\t\t\t};\n\t\t};\n\t};\n}\n\nexport type SSRComponentLoader = () => Promise<SSRComponent>;\n\nexport interface SSRNode {\n\tcomponent: SSRComponentLoader;\n\t/** index into the `components` array in client/manifest.js */\n\tindex: number;\n\t/** client-side module URL for this component */\n\tfile: string;\n\t/** external JS files */\n\timports: string[];\n\t/** external CSS files */\n\tstylesheets: string[];\n\t/** external font files */\n\tfonts: string[];\n\t/** inlined styles */\n\tinline_styles?(): MaybePromise<Record<string, string>>;\n\n\tuniversal: {\n\t\tload?: Load;\n\t\tprerender?: PrerenderOption;\n\t\tssr?: boolean;\n\t\tcsr?: boolean;\n\t\ttrailingSlash?: TrailingSlash;\n\t\tconfig?: any;\n\t};\n\n\tserver: {\n\t\tload?: ServerLoad;\n\t\tprerender?: PrerenderOption;\n\t\tssr?: boolean;\n\t\tcsr?: boolean;\n\t\ttrailingSlash?: TrailingSlash;\n\t\tactions?: Actions;\n\t\tconfig?: any;\n\t};\n\n\tuniversal_id: string;\n\tserver_id: string;\n}\n\nexport type SSRNodeLoader = () => Promise<SSRNode>;\n\nexport interface SSROptions {\n\tapp_template_contains_nonce: boolean;\n\tcsp: ValidatedConfig['kit']['csp'];\n\tcsrf_check_origin: boolean;\n\tembedded: boolean;\n\tenv_public_prefix: string;\n\thooks: ServerHooks;\n\tpreload_strategy: ValidatedConfig['kit']['output']['preloadStrategy'];\n\troot: SSRComponent['default'];\n\tservice_worker: boolean;\n\ttemplates: {\n\t\tapp(values: {\n\t\t\thead: string;\n\t\t\tbody: string;\n\t\t\tassets: string;\n\t\t\tnonce: string;\n\t\t\tenv: Record<string, string>;\n\t\t}): string;\n\t\terror(values: { message: string; status: number }): string;\n\t};\n\tversion_hash: string;\n}\n\nexport interface PageNodeIndexes {\n\terrors: Array<number | undefined>;\n\tlayouts: Array<number | undefined>;\n\tleaf: number;\n}\n\nexport type SSREndpoint = Partial<Record<HttpMethod, RequestHandler>> & {\n\tprerender?: PrerenderOption;\n\ttrailingSlash?: TrailingSlash;\n\tconfig?: any;\n};\n\nexport interface SSRRoute {\n\tid: string;\n\tpattern: RegExp;\n\tparams: RouteParam[];\n\tpage: PageNodeIndexes | null;\n\tendpoint: (() => Promise<SSREndpoint>) | null;\n\tendpoint_id?: string;\n}\n\nexport interface SSRState {\n\tfallback?: string;\n\tgetClientAddress(): string;\n\t/**\n\t * True if we're currently attempting to render an error page\n\t */\n\terror: boolean;\n\t/**\n\t * Allows us to prevent `event.fetch` from making infinitely looping internal requests\n\t */\n\tdepth: number;\n\tplatform?: any;\n\tprerendering?: PrerenderOptions;\n\t/**\n\t * When fetching data from a +server.js endpoint in `load`, the page's\n\t * prerender option is inherited by the endpoint, unless overridden\n\t */\n\tprerender_default?: PrerenderOption;\n\tread?: (file: string) => Buffer;\n}\n\nexport type StrictBody = string | ArrayBufferView;\n\nexport interface Uses {\n\tdependencies: Set<string>;\n\tparams: Set<string>;\n\tparent: boolean;\n\troute: boolean;\n\turl: boolean;\n}\n\nexport type ValidatedConfig = RecursiveRequired<Config>;\n\nexport type ValidatedKitConfig = RecursiveRequired<KitConfig>;\n\nexport * from './index';\nexport * from './private';\n\ndeclare global {\n\tconst __SVELTEKIT_ADAPTER_NAME__: string;\n\tconst __SVELTEKIT_APP_VERSION_FILE__: string;\n\tconst __SVELTEKIT_APP_VERSION_POLL_INTERVAL__: number;\n\tconst __SVELTEKIT_DEV__: boolean;\n\tconst __SVELTEKIT_EMBEDDED__: boolean;\n\tvar Bun: object;\n\tvar Deno: object;\n}\n"}},"private.d.ts":{"file":{"contents":"// This module contains types that are visible in the documentation,\n// but which cannot be imported from `@sveltejs/kit`. Care should\n// be taken to avoid breaking changes when editing this file\n\nimport { RouteDefinition } from './index.js';\n\nexport interface AdapterEntry {\n\t/**\n\t * A string that uniquely identifies an HTTP service (e.g. serverless function) and is used for deduplication.\n\t * For example, `/foo/a-[b]` and `/foo/[c]` are different routes, but would both\n\t * be represented in a Netlify _redirects file as `/foo/:param`, so they share an ID\n\t */\n\tid: string;\n\n\t/**\n\t * A function that compares the candidate route with the current route to determine\n\t * if it should be grouped with the current route.\n\t *\n\t * Use cases:\n\t * - Fallback pages: `/foo/[c]` is a fallback for `/foo/a-[b]`, and `/[...catchall]` is a fallback for all routes\n\t * - Grouping routes that share a common `config`: `/foo` should be deployed to the edge, `/bar` and `/baz` should be deployed to a serverless function\n\t */\n\tfilter(route: RouteDefinition): boolean;\n\n\t/**\n\t * A function that is invoked once the entry has been created. This is where you\n\t * should write the function to the filesystem and generate redirect manifests.\n\t */\n\tcomplete(entry: { generateManifest(opts: { relativePath: string }): string }): MaybePromise<void>;\n}\n\n// Based on https://github.com/josh-hemphill/csp-typed-directives/blob/latest/src/csp.types.ts\n//\n// MIT License\n//\n// Copyright (c) 2021-present, Joshua Hemphill\n// Copyright (c) 2021, Tecnico Corporation\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nexport namespace Csp {\n\ttype ActionSource = 'strict-dynamic' | 'report-sample';\n\ttype BaseSource =\n\t\t| 'self'\n\t\t| 'unsafe-eval'\n\t\t| 'unsafe-hashes'\n\t\t| 'unsafe-inline'\n\t\t| 'wasm-unsafe-eval'\n\t\t| 'none';\n\ttype CryptoSource = `${'nonce' | 'sha256' | 'sha384' | 'sha512'}-${string}`;\n\ttype FrameSource = HostSource | SchemeSource | 'self' | 'none';\n\ttype HostNameScheme = `${string}.${string}` | 'localhost';\n\ttype HostSource = `${HostProtocolSchemes}${HostNameScheme}${PortScheme}`;\n\ttype HostProtocolSchemes = `${string}://` | '';\n\ttype HttpDelineator = '/' | '?' | '#' | '\\\\';\n\ttype PortScheme = `:${number}` | '' | ':*';\n\ttype SchemeSource = 'http:' | 'https:' | 'data:' | 'mediastream:' | 'blob:' | 'filesystem:';\n\ttype Source = HostSource | SchemeSource | CryptoSource | BaseSource;\n\ttype Sources = Source[];\n\ttype UriPath = `${HttpDelineator}${string}`;\n}\n\nexport interface CspDirectives {\n\t'child-src'?: Csp.Sources;\n\t'default-src'?: Array<Csp.Source | Csp.ActionSource>;\n\t'frame-src'?: Csp.Sources;\n\t'worker-src'?: Csp.Sources;\n\t'connect-src'?: Csp.Sources;\n\t'font-src'?: Csp.Sources;\n\t'img-src'?: Csp.Sources;\n\t'manifest-src'?: Csp.Sources;\n\t'media-src'?: Csp.Sources;\n\t'object-src'?: Csp.Sources;\n\t'prefetch-src'?: Csp.Sources;\n\t'script-src'?: Array<Csp.Source | Csp.ActionSource>;\n\t'script-src-elem'?: Csp.Sources;\n\t'script-src-attr'?: Csp.Sources;\n\t'style-src'?: Array<Csp.Source | Csp.ActionSource>;\n\t'style-src-elem'?: Csp.Sources;\n\t'style-src-attr'?: Csp.Sources;\n\t'base-uri'?: Array<Csp.Source | Csp.ActionSource>;\n\tsandbox?: Array<\n\t\t| 'allow-downloads-without-user-activation'\n\t\t| 'allow-forms'\n\t\t| 'allow-modals'\n\t\t| 'allow-orientation-lock'\n\t\t| 'allow-pointer-lock'\n\t\t| 'allow-popups'\n\t\t| 'allow-popups-to-escape-sandbox'\n\t\t| 'allow-presentation'\n\t\t| 'allow-same-origin'\n\t\t| 'allow-scripts'\n\t\t| 'allow-storage-access-by-user-activation'\n\t\t| 'allow-top-navigation'\n\t\t| 'allow-top-navigation-by-user-activation'\n\t>;\n\t'form-action'?: Array<Csp.Source | Csp.ActionSource>;\n\t'frame-ancestors'?: Array<Csp.HostSource | Csp.SchemeSource | Csp.FrameSource>;\n\t'navigate-to'?: Array<Csp.Source | Csp.ActionSource>;\n\t'report-uri'?: Csp.UriPath[];\n\t'report-to'?: string[];\n\n\t'require-trusted-types-for'?: Array<'script'>;\n\t'trusted-types'?: Array<'none' | 'allow-duplicates' | '*' | string>;\n\t'upgrade-insecure-requests'?: boolean;\n\n\t/** @deprecated */\n\t'require-sri-for'?: Array<'script' | 'style' | 'script style'>;\n\n\t/** @deprecated */\n\t'block-all-mixed-content'?: boolean;\n\n\t/** @deprecated */\n\t'plugin-types'?: Array<`${string}/${string}` | 'none'>;\n\n\t/** @deprecated */\n\treferrer?: Array<\n\t\t| 'no-referrer'\n\t\t| 'no-referrer-when-downgrade'\n\t\t| 'origin'\n\t\t| 'origin-when-cross-origin'\n\t\t| 'same-origin'\n\t\t| 'strict-origin'\n\t\t| 'strict-origin-when-cross-origin'\n\t\t| 'unsafe-url'\n\t\t| 'none'\n\t>;\n}\n\nexport type HttpMethod = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'OPTIONS';\n\nexport interface Logger {\n\t(msg: string): void;\n\tsuccess(msg: string): void;\n\terror(msg: string): void;\n\twarn(msg: string): void;\n\tminor(msg: string): void;\n\tinfo(msg: string): void;\n}\n\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface Prerendered {\n\t/**\n\t * A map of `path` to `{ file }` objects, where a path like `/foo` corresponds to `foo.html` and a path like `/bar/` corresponds to `bar/index.html`.\n\t */\n\tpages: Map<\n\t\tstring,\n\t\t{\n\t\t\t/** The location of the .html file relative to the output directory */\n\t\t\tfile: string;\n\t\t}\n\t>;\n\t/**\n\t * A map of `path` to `{ type }` objects.\n\t */\n\tassets: Map<\n\t\tstring,\n\t\t{\n\t\t\t/** The MIME type of the asset */\n\t\t\ttype: string;\n\t\t}\n\t>;\n\t/**\n\t * A map of redirects encountered during prerendering.\n\t */\n\tredirects: Map<\n\t\tstring,\n\t\t{\n\t\t\tstatus: number;\n\t\t\tlocation: string;\n\t\t}\n\t>;\n\t/** An array of prerendered paths (without trailing slashes, regardless of the trailingSlash config) */\n\tpaths: string[];\n}\n\nexport interface PrerenderHttpErrorHandler {\n\t(details: {\n\t\tstatus: number;\n\t\tpath: string;\n\t\treferrer: string | null;\n\t\treferenceType: 'linked' | 'fetched';\n\t\tmessage: string;\n\t}): void;\n}\n\nexport interface PrerenderMissingIdHandler {\n\t(details: { path: string; id: string; referrers: string[]; message: string }): void;\n}\n\nexport type PrerenderHttpErrorHandlerValue = 'fail' | 'warn' | 'ignore' | PrerenderHttpErrorHandler;\nexport type PrerenderMissingIdHandlerValue = 'fail' | 'warn' | 'ignore' | PrerenderMissingIdHandler;\n\nexport type PrerenderOption = boolean | 'auto';\n\nexport type PrerenderMap = Map<string, PrerenderOption>;\n\nexport interface RequestOptions {\n\tgetClientAddress(): string;\n\tplatform?: App.Platform;\n}\n\nexport interface RouteSegment {\n\tcontent: string;\n\tdynamic: boolean;\n\trest: boolean;\n}\n\nexport type TrailingSlash = 'never' | 'always' | 'ignore';\n\n/**\n * This doesn't actually exist, it's a way to better distinguish the type\n */\ndeclare const uniqueSymbol: unique symbol;\n\nexport interface UniqueInterface {\n\treadonly [uniqueSymbol]: unknown;\n}\n"}},"synthetic":{"directory":{"$env+dynamic+private.md":{"file":{"contents":"This module provides access to runtime environment variables, as defined by the platform you're running on. For example if you're using [`adapter-node`](https://github.com/sveltejs/kit/tree/master/packages/adapter-node) (or running [`vite preview`](https://kit.svelte.dev/docs/cli)), this is equivalent to `process.env`. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env).\n\nThis module cannot be imported into client-side code.\n\n```ts\nimport { env } from '$env/dynamic/private';\nconsole.log(env.DEPLOYMENT_SPECIFIC_VARIABLE);\n```\n\n> In `dev`, `$env/dynamic` always includes environment variables from `.env`. In `prod`, this behavior will depend on your adapter.\n"}},"$env+dynamic+public.md":{"file":{"contents":"Similar to [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), but only includes variables that begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.\n\nNote that public dynamic environment variables must all be sent from the server to the client, causing larger network requests — when possible, use `$env/static/public` instead.\n\n```ts\nimport { env } from '$env/dynamic/public';\nconsole.log(env.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE);\n```\n"}},"$env+static+private.md":{"file":{"contents":"Environment variables [loaded by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files) from `.env` files and `process.env`. Like [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), this module cannot be imported into client-side code. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env).\n\n_Unlike_ [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination.\n\n```ts\nimport { API_KEY } from '$env/static/private';\n```\n\nNote that all environment variables referenced in your code should be declared (for example in an `.env` file), even if they don't have a value until the app is deployed:\n\n```\nMY_FEATURE_FLAG=\"\"\n```\n\nYou can override `.env` values from the command line like so:\n\n```bash\nMY_FEATURE_FLAG=\"enabled\" npm run dev\n```\n"}},"$env+static+public.md":{"file":{"contents":"Similar to [`$env/static/private`](https://kit.svelte.dev/docs/modules#$env-static-private), except that it only includes environment variables that begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.\n\nValues are replaced statically at build time.\n\n```ts\nimport { PUBLIC_BASE_URL } from '$env/static/public';\n```\n"}},"$lib.md":{"file":{"contents":"This is a simple alias to `src/lib`, or whatever directory is specified as [`config.kit.files.lib`](https://kit.svelte.dev/docs/configuration#files). It allows you to access common components and utility modules without `../../../../` nonsense.\n\n### `$lib/server`\n\nA subdirectory of `$lib`. SvelteKit will prevent you from importing any modules in `$lib/server` into client-side code. See [server-only modules](/docs/server-only-modules).\n"}}}}}}}},"vite-plugin-svelte":{"directory":{"dist":{"directory":{"index.d.ts":{"file":{"contents":"import { InlineConfig, ResolvedConfig, UserConfig, Plugin } from 'vite';\nimport { CompileOptions, Warning } from 'svelte/types/compiler/interfaces';\nexport { CompileOptions, Warning } from 'svelte/types/compiler/interfaces';\nimport { PreprocessorGroup } from 'svelte/types/compiler/preprocess';\nexport { MarkupPreprocessor, Preprocessor, PreprocessorGroup, Processed } from 'svelte/types/compiler/preprocess';\n\ntype Options = Omit<SvelteOptions, 'vitePlugin'> & PluginOptionsInline;\ninterface PluginOptionsInline extends PluginOptions {\n    /**\n     * Path to a svelte config file, either absolute or relative to Vite root\n     *\n     * set to `false` to ignore the svelte config file\n     *\n     * @see https://vitejs.dev/config/#root\n     */\n    configFile?: string | false;\n}\ninterface PluginOptions {\n    /**\n     * A `picomatch` pattern, or array of patterns, which specifies the files the plugin should\n     * operate on. By default, all svelte files are included.\n     *\n     * @see https://github.com/micromatch/picomatch\n     */\n    include?: Arrayable<string>;\n    /**\n     * A `picomatch` pattern, or array of patterns, which specifies the files to be ignored by the\n     * plugin. By default, no files are ignored.\n     *\n     * @see https://github.com/micromatch/picomatch\n     */\n    exclude?: Arrayable<string>;\n    /**\n     * Emit Svelte styles as virtual CSS files for Vite and other plugins to process\n     *\n     * @default true\n     */\n    emitCss?: boolean;\n    /**\n     * Enable or disable Hot Module Replacement.\n     *\n     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     *\n     * DO NOT CUSTOMIZE SVELTE-HMR OPTIONS UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING\n     *\n     *                             YOU HAVE BEEN WARNED\n     *\n     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     *\n     * Set an object to pass custom options to svelte-hmr\n     *\n     * @see https://github.com/rixo/svelte-hmr#options\n     * @default true for development, always false for production\n     */\n    hot?: boolean | {\n        injectCss?: boolean;\n        partialAccept?: boolean;\n        [key: string]: any;\n    };\n    /**\n     * Some Vite plugins can contribute additional preprocessors by defining `api.sveltePreprocess`.\n     * If you don't want to use them, set this to true to ignore them all or use an array of strings\n     * with plugin names to specify which.\n     *\n     * @default false\n     */\n    ignorePluginPreprocessors?: boolean | string[];\n    /**\n     * vite-plugin-svelte automatically handles excluding svelte libraries and reinclusion of their dependencies\n     * in vite.optimizeDeps.\n     *\n     * `disableDependencyReinclusion: true` disables all reinclusions\n     * `disableDependencyReinclusion: ['foo','bar']` disables reinclusions for dependencies of foo and bar\n     *\n     * This should be used for hybrid packages that contain both node and browser dependencies, eg Routify\n     *\n     * @default false\n     */\n    disableDependencyReinclusion?: boolean | string[];\n    /**\n     * Enable support for Vite's dependency optimization to prebundle Svelte libraries.\n     *\n     * To disable prebundling for a specific library, add it to `optimizeDeps.exclude`.\n     *\n     * @default true for dev, false for build\n     */\n    prebundleSvelteLibraries?: boolean;\n    /**\n     * These options are considered experimental and breaking changes to them can occur in any release\n     */\n    experimental?: ExperimentalOptions;\n}\ninterface SvelteOptions {\n    /**\n     * A list of file extensions to be compiled by Svelte\n     *\n     * @default ['.svelte']\n     */\n    extensions?: string[];\n    /**\n     * An array of preprocessors to transform the Svelte source code before compilation\n     *\n     * @see https://svelte.dev/docs#svelte_preprocess\n     */\n    preprocess?: Arrayable<PreprocessorGroup>;\n    /**\n     * The options to be passed to the Svelte compiler. A few options are set by default,\n     * including `dev` and `css`. However, some options are non-configurable, like\n     * `filename`, `format`, `generate`, and `cssHash` (in dev).\n     *\n     * @see https://svelte.dev/docs#svelte_compile\n     */\n    compilerOptions?: Omit<CompileOptions, 'filename' | 'format' | 'generate'>;\n    /**\n     * Handles warning emitted from the Svelte compiler\n     */\n    onwarn?: (warning: Warning, defaultHandler?: (warning: Warning) => void) => void;\n    /**\n     * Options for vite-plugin-svelte\n     */\n    vitePlugin?: PluginOptions;\n}\n/**\n * These options are considered experimental and breaking changes to them can occur in any release\n */\ninterface ExperimentalOptions {\n    /**\n     * A function to update `compilerOptions` before compilation\n     *\n     * `data.filename` - The file to be compiled\n     * `data.code` - The preprocessed Svelte code\n     * `data.compileOptions` - The current compiler options\n     *\n     * To change part of the compiler options, return an object with the changes you need.\n     *\n     * @example\n     * ```\n     * ({ filename, compileOptions }) => {\n     *   // Dynamically set hydration per Svelte file\n     *   if (compileWithHydratable(filename) && !compileOptions.hydratable) {\n     *     return { hydratable: true };\n     *   }\n     * }\n     * ```\n     */\n    dynamicCompileOptions?: (data: {\n        filename: string;\n        code: string;\n        compileOptions: Partial<CompileOptions>;\n    }) => Promise<Partial<CompileOptions> | void> | Partial<CompileOptions> | void;\n    /**\n     * enable svelte inspector\n     */\n    inspector?: InspectorOptions | boolean;\n    /**\n     * send a websocket message with svelte compiler warnings during dev\n     *\n     */\n    sendWarningsToBrowser?: boolean;\n    /**\n     * disable svelte compile statistics\n     *\n     * @default false\n     */\n    disableCompileStats?: 'dev' | 'build' | boolean;\n}\ninterface InspectorOptions {\n    /**\n     * define a key combo to toggle inspector,\n     * @default 'control-shift' on windows, 'meta-shift' on other os\n     *\n     * any number of modifiers `control` `shift` `alt` `meta` followed by zero or one regular key, separated by -\n     * examples: control-shift, control-o, control-alt-s  meta-x control-meta\n     * Some keys have native behavior (e.g. alt-s opens history menu on firefox).\n     * To avoid conflicts or accidentally typing into inputs, modifier only combinations are recommended.\n     */\n    toggleKeyCombo?: string;\n    /**\n     * define keys to select elements with via keyboard\n     * @default {parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' }\n     *\n     * improves accessibility and also helps when you want to select elements that do not have a hoverable surface area\n     * due to tight wrapping\n     *\n     * A note for users of screen-readers:\n     * If you are using arrow keys to navigate the page itself, change the navKeys to avoid conflicts.\n     * e.g. navKeys: {parent: 'w', prev: 'a', child: 's', next: 'd'}\n     *\n     *\n     * parent: select closest parent\n     * child: select first child (or grandchild)\n     * next: next sibling (or parent if no next sibling exists)\n     * prev: previous sibling (or parent if no prev sibling exists)\n     */\n    navKeys?: {\n        parent: string;\n        child: string;\n        next: string;\n        prev: string;\n    };\n    /**\n     * define key to open the editor for the currently selected dom node\n     *\n     * @default 'Enter'\n     */\n    openKey?: string;\n    /**\n     * inspector is automatically disabled when releasing toggleKeyCombo after holding it for a longpress\n     * @default false\n     */\n    holdMode?: boolean;\n    /**\n     * when to show the toggle button\n     * @default 'active'\n     */\n    showToggleButton?: 'always' | 'active' | 'never';\n    /**\n     * where to display the toggle button\n     * @default top-right\n     */\n    toggleButtonPos?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\n    /**\n     * inject custom styles when inspector is active\n     */\n    customStyles?: boolean;\n    /**\n     * append an import to the module id ending with `appendTo` instead of adding a script into body\n     * useful for frameworks that do not support trannsformIndexHtml hook\n     *\n     * WARNING: only set this if you know exactly what it does.\n     * Regular users of vite-plugin-svelte or SvelteKit do not need it\n     */\n    appendTo?: string;\n}\ntype ModuleFormat = NonNullable<CompileOptions['format']>;\ntype CssHashGetter = NonNullable<CompileOptions['cssHash']>;\ntype Arrayable<T> = T | T[];\n\ndeclare function vitePreprocess(opts?: {\n    script?: boolean;\n    style?: boolean | InlineConfig | ResolvedConfig;\n}): PreprocessorGroup;\n\ndeclare function loadSvelteConfig(viteConfig?: UserConfig, inlineOptions?: Partial<Options>): Promise<Partial<SvelteOptions> | undefined>;\n\ntype SvelteWarningsMessage = {\n    id: string;\n    filename: string;\n    normalizedFilename: string;\n    timestamp: number;\n    warnings: Warning[];\n    allWarnings: Warning[];\n    rawWarnings: Warning[];\n};\n\ndeclare function svelte(inlineOptions?: Partial<Options>): Plugin[];\n\nexport { Arrayable, CssHashGetter, ModuleFormat, Options, PluginOptions, SvelteOptions, SvelteWarningsMessage, loadSvelteConfig, svelte, vitePreprocess };\n"}},"index.js":{"file":{"contents":"var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/index.ts\nimport fs8 from \"fs\";\nimport { isDepExcluded as isDepExcluded2 } from \"vitefu\";\n\n// src/utils/log.ts\nimport { cyan, yellow, red } from \"kleur/colors\";\nimport debug from \"debug\";\nvar levels = [\"debug\", \"info\", \"warn\", \"error\", \"silent\"];\nvar prefix = \"vite-plugin-svelte\";\nvar loggers = {\n  debug: {\n    log: debug(`vite:${prefix}`),\n    enabled: false,\n    isDebug: true\n  },\n  info: {\n    color: cyan,\n    log: console.log,\n    enabled: true\n  },\n  warn: {\n    color: yellow,\n    log: console.warn,\n    enabled: true\n  },\n  error: {\n    color: red,\n    log: console.error,\n    enabled: true\n  },\n  silent: {\n    enabled: false\n  }\n};\nvar _level = \"info\";\nfunction setLevel(level) {\n  if (level === _level) {\n    return;\n  }\n  const levelIndex = levels.indexOf(level);\n  if (levelIndex > -1) {\n    _level = level;\n    for (let i = 0; i < levels.length; i++) {\n      loggers[levels[i]].enabled = i >= levelIndex;\n    }\n  } else {\n    _log(loggers.error, `invalid log level: ${level} `);\n  }\n}\nfunction _log(logger, message, payload) {\n  if (!logger.enabled) {\n    return;\n  }\n  if (logger.isDebug) {\n    payload !== void 0 ? logger.log(message, payload) : logger.log(message);\n  } else {\n    logger.log(logger.color(`${(/* @__PURE__ */ new Date()).toLocaleTimeString()} [${prefix}] ${message}`));\n    if (payload) {\n      logger.log(payload);\n    }\n  }\n}\nfunction createLogger(level) {\n  const logger = loggers[level];\n  const logFn = _log.bind(null, logger);\n  const logged = /* @__PURE__ */ new Set();\n  const once = function(message, payload) {\n    if (logged.has(message)) {\n      return;\n    }\n    logged.add(message);\n    logFn.apply(null, [message, payload]);\n  };\n  Object.defineProperty(logFn, \"enabled\", {\n    get() {\n      return logger.enabled;\n    }\n  });\n  Object.defineProperty(logFn, \"once\", {\n    get() {\n      return once;\n    }\n  });\n  return logFn;\n}\nvar log = {\n  debug: createLogger(\"debug\"),\n  info: createLogger(\"info\"),\n  warn: createLogger(\"warn\"),\n  error: createLogger(\"error\"),\n  setLevel\n};\nfunction logCompilerWarnings(svelteRequest, warnings, options) {\n  const { emitCss, onwarn, isBuild } = options;\n  const sendViaWS = !isBuild && options.experimental?.sendWarningsToBrowser;\n  let warn = isBuild ? warnBuild : warnDev;\n  const handledByDefaultWarn = [];\n  const notIgnored = warnings?.filter((w) => !ignoreCompilerWarning(w, isBuild, emitCss));\n  const extra = buildExtraWarnings(warnings, isBuild);\n  const allWarnings = [...notIgnored, ...extra];\n  if (sendViaWS) {\n    const _warn = warn;\n    warn = (w) => {\n      handledByDefaultWarn.push(w);\n      _warn(w);\n    };\n  }\n  allWarnings.forEach((warning) => {\n    if (onwarn) {\n      onwarn(warning, warn);\n    } else {\n      warn(warning);\n    }\n  });\n  if (sendViaWS) {\n    const message = {\n      id: svelteRequest.id,\n      filename: svelteRequest.filename,\n      normalizedFilename: svelteRequest.normalizedFilename,\n      timestamp: svelteRequest.timestamp,\n      warnings: handledByDefaultWarn,\n      // allWarnings filtered by warnings where onwarn did not call the default handler\n      allWarnings,\n      // includes warnings filtered by onwarn and our extra vite plugin svelte warnings\n      rawWarnings: warnings\n      // raw compiler output\n    };\n    log.debug(`sending svelte:warnings message for ${svelteRequest.normalizedFilename}`);\n    options.server?.ws?.send(\"svelte:warnings\", message);\n  }\n}\nfunction ignoreCompilerWarning(warning, isBuild, emitCss) {\n  return !emitCss && warning.code === \"css-unused-selector\" || // same as rollup-plugin-svelte\n  !isBuild && isNoScopableElementWarning(warning);\n}\nfunction isNoScopableElementWarning(warning) {\n  return warning.code === \"css-unused-selector\" && warning.message.includes('\"*\"');\n}\nfunction buildExtraWarnings(warnings, isBuild) {\n  const extraWarnings = [];\n  if (!isBuild) {\n    const noScopableElementWarnings = warnings.filter((w) => isNoScopableElementWarning(w));\n    if (noScopableElementWarnings.length > 0) {\n      const noScopableElementWarning = noScopableElementWarnings[noScopableElementWarnings.length - 1];\n      extraWarnings.push({\n        ...noScopableElementWarning,\n        code: \"vite-plugin-svelte-css-no-scopable-elements\",\n        message: `No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles.`\n      });\n    }\n  }\n  return extraWarnings;\n}\nfunction warnDev(w) {\n  log.info.enabled && log.info(buildExtendedLogMessage(w));\n}\nfunction warnBuild(w) {\n  log.warn.enabled && log.warn(buildExtendedLogMessage(w), w.frame);\n}\nfunction buildExtendedLogMessage(w) {\n  const parts = [];\n  if (w.filename) {\n    parts.push(w.filename);\n  }\n  if (w.start) {\n    parts.push(\":\", w.start.line, \":\", w.start.column);\n  }\n  if (w.message) {\n    if (parts.length > 0) {\n      parts.push(\" \");\n    }\n    parts.push(w.message);\n  }\n  return parts.join(\"\");\n}\n\n// src/utils/error.ts\nfunction toRollupError(error, options) {\n  const { filename, frame, start, code, name, stack } = error;\n  const rollupError = {\n    name,\n    // needed otherwise sveltekit coalesce_to_error turns it into a string\n    id: filename,\n    message: buildExtendedLogMessage(error),\n    // include filename:line:column so that it's clickable\n    frame: formatFrameForVite(frame),\n    code,\n    stack: options.isBuild || options.isDebug || !frame ? stack : \"\"\n  };\n  if (start) {\n    rollupError.loc = {\n      line: start.line,\n      column: start.column,\n      file: filename\n    };\n  }\n  return rollupError;\n}\nfunction toESBuildError(error, options) {\n  const { filename, frame, start, stack } = error;\n  const partialMessage = {\n    text: buildExtendedLogMessage(error)\n  };\n  if (start) {\n    partialMessage.location = {\n      line: start.line,\n      column: start.column,\n      file: filename,\n      lineText: lineFromFrame(start.line, frame)\n      // needed to get a meaningful error message on cli\n    };\n  }\n  if (options.isBuild || options.isDebug || !frame) {\n    partialMessage.detail = stack;\n  }\n  return partialMessage;\n}\nfunction lineFromFrame(lineNo, frame) {\n  if (!frame) {\n    return \"\";\n  }\n  const lines = frame.split(\"\\n\");\n  const errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));\n  return errorLine ? errorLine.substring(errorLine.indexOf(\": \") + 3) : \"\";\n}\nfunction formatFrameForVite(frame) {\n  if (!frame) {\n    return \"\";\n  }\n  return frame.split(\"\\n\").map((line) => line.match(/^\\s+\\^/) ? \"   \" + line : \" \" + line.replace(\":\", \" | \")).join(\"\\n\");\n}\n\n// src/handle-hot-update.ts\nasync function handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options) {\n  if (!cache.has(svelteRequest)) {\n    log.debug(`handleHotUpdate called before initial transform for ${svelteRequest.id}`);\n    return;\n  }\n  const { read, server, modules } = ctx;\n  const cachedJS = cache.getJS(svelteRequest);\n  const cachedCss = cache.getCSS(svelteRequest);\n  const content = await read();\n  let compileData;\n  try {\n    compileData = await compileSvelte2(svelteRequest, content, options);\n    cache.update(compileData);\n  } catch (e) {\n    cache.setError(svelteRequest, e);\n    throw toRollupError(e, options);\n  }\n  const affectedModules = [...modules];\n  const cssIdx = modules.findIndex((m) => m.id === svelteRequest.cssId);\n  if (cssIdx > -1) {\n    const cssUpdated = cssChanged(cachedCss, compileData.compiled.css);\n    if (!cssUpdated) {\n      log.debug(`skipping unchanged css for ${svelteRequest.cssId}`);\n      affectedModules.splice(cssIdx, 1);\n    }\n  }\n  const jsIdx = modules.findIndex((m) => m.id === svelteRequest.id);\n  if (jsIdx > -1) {\n    const jsUpdated = jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);\n    if (!jsUpdated) {\n      log.debug(`skipping unchanged js for ${svelteRequest.id}`);\n      affectedModules.splice(jsIdx, 1);\n      logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\n    }\n  }\n  const ssrModulesToInvalidate = affectedModules.filter((m) => !!m.ssrTransformResult);\n  if (ssrModulesToInvalidate.length > 0) {\n    log.debug(`invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(\", \")}`);\n    ssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));\n  }\n  if (affectedModules.length > 0) {\n    log.debug(\n      `handleHotUpdate for ${svelteRequest.id} result: ${affectedModules.map((m) => m.id).join(\", \")}`\n    );\n  }\n  return affectedModules;\n}\nfunction cssChanged(prev, next) {\n  return !isCodeEqual(prev?.code, next?.code);\n}\nfunction jsChanged(prev, next, filename) {\n  const prevJs = prev?.code;\n  const nextJs = next?.code;\n  const isStrictEqual = isCodeEqual(prevJs, nextJs);\n  if (isStrictEqual) {\n    return false;\n  }\n  const isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));\n  if (!isStrictEqual && isLooseEqual) {\n    log.warn(\n      `ignoring compiler output js change for ${filename} as it is equal to previous output after normalization`\n    );\n  }\n  return !isLooseEqual;\n}\nfunction isCodeEqual(prev, next) {\n  if (!prev && !next) {\n    return true;\n  }\n  if (!prev && next || prev && !next) {\n    return false;\n  }\n  return prev === next;\n}\nfunction normalizeJsCode(code) {\n  if (!code) {\n    return code;\n  }\n  return code.replace(/\\s*\\badd_location\\s*\\([^)]*\\)\\s*;?/g, \"\");\n}\n\n// src/utils/compile.ts\nimport { compile, preprocess, walk } from \"svelte/compiler\";\nimport { createMakeHot } from \"svelte-hmr\";\n\n// src/utils/hash.ts\nimport * as crypto from \"crypto\";\nvar hashes = /* @__PURE__ */ Object.create(null);\nvar hash_length = 12;\nfunction safeBase64Hash(input) {\n  if (hashes[input]) {\n    return hashes[input];\n  }\n  const md5 = crypto.createHash(\"md5\");\n  md5.update(input);\n  const hash = toSafe(md5.digest(\"base64\")).slice(0, hash_length);\n  hashes[input] = hash;\n  return hash;\n}\nvar replacements = {\n  \"+\": \"-\",\n  \"/\": \"_\",\n  \"=\": \"\"\n};\nvar replaceRE = new RegExp(`[${Object.keys(replacements).join(\"\")}]`, \"g\");\nfunction toSafe(base64) {\n  return base64.replace(replaceRE, (x) => replacements[x]);\n}\n\n// src/utils/preprocess.ts\nimport MagicString from \"magic-string\";\nimport path from \"path\";\nfunction createInjectScopeEverythingRulePreprocessorGroup() {\n  return {\n    style({ content, filename }) {\n      const s = new MagicString(content);\n      s.append(\" *{}\");\n      return {\n        code: s.toString(),\n        map: s.generateDecodedMap({\n          source: filename ? path.basename(filename) : void 0,\n          hires: true\n        })\n      };\n    }\n  };\n}\nfunction buildExtraPreprocessors(options, config) {\n  const prependPreprocessors = [];\n  const appendPreprocessors = [];\n  const pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p?.sveltePreprocess);\n  if (pluginsWithPreprocessorsDeprecated.length > 0) {\n    log.warn(\n      `The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated.map((p) => p.name).join(\", \")}`\n    );\n    pluginsWithPreprocessorsDeprecated.forEach((p) => {\n      if (!p.api) {\n        p.api = {};\n      }\n      if (p.api.sveltePreprocess === void 0) {\n        p.api.sveltePreprocess = p.sveltePreprocess;\n      } else {\n        log.error(\n          `ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`\n        );\n      }\n    });\n  }\n  const pluginsWithPreprocessors = config.plugins.filter((p) => p?.api?.sveltePreprocess);\n  const ignored = [], included = [];\n  for (const p of pluginsWithPreprocessors) {\n    if (options.ignorePluginPreprocessors === true || Array.isArray(options.ignorePluginPreprocessors) && options.ignorePluginPreprocessors?.includes(p.name)) {\n      ignored.push(p);\n    } else {\n      included.push(p);\n    }\n  }\n  if (ignored.length > 0) {\n    log.debug(\n      `Ignoring svelte preprocessors defined by these vite plugins: ${ignored.map((p) => p.name).join(\", \")}`\n    );\n  }\n  if (included.length > 0) {\n    log.debug(\n      `Adding svelte preprocessors defined by these vite plugins: ${included.map((p) => p.name).join(\", \")}`\n    );\n    appendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));\n  }\n  return { prependPreprocessors, appendPreprocessors };\n}\nfunction addExtraPreprocessors(options, config) {\n  const { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);\n  if (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {\n    if (!options.preprocess) {\n      options.preprocess = [...prependPreprocessors, ...appendPreprocessors];\n    } else if (Array.isArray(options.preprocess)) {\n      options.preprocess.unshift(...prependPreprocessors);\n      options.preprocess.push(...appendPreprocessors);\n    } else {\n      options.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];\n    }\n  }\n}\n\n// src/utils/sourcemaps.ts\nimport path2 from \"path\";\nfunction mapSourcesToRelative(map, filename) {\n  if (map?.sources) {\n    map.sources = map.sources.map((s) => {\n      if (path2.isAbsolute(s)) {\n        const relative = path2.relative(filename, s);\n        return relative === \"\" ? path2.basename(filename) : relative;\n      } else {\n        return s;\n      }\n    });\n  }\n}\n\n// src/utils/compile.ts\nvar scriptLangRE = /<script [^>]*lang=[\"']?([^\"' >]+)[\"']?[^>]*>/;\nvar _createCompileSvelte = (makeHot) => {\n  let stats;\n  const devStylePreprocessor = createInjectScopeEverythingRulePreprocessorGroup();\n  return async function compileSvelte2(svelteRequest, code, options) {\n    const { filename, normalizedFilename, cssId, ssr, raw } = svelteRequest;\n    const { emitCss = true } = options;\n    const dependencies = [];\n    if (options.stats) {\n      if (options.isBuild) {\n        if (!stats) {\n          stats = options.stats.startCollection(`${ssr ? \"ssr\" : \"dom\"} compile`, {\n            logInProgress: () => false\n          });\n        }\n      } else {\n        if (ssr && !stats) {\n          stats = options.stats.startCollection(\"ssr compile\");\n        }\n        if (!ssr && stats) {\n          stats.finish();\n          stats = void 0;\n        }\n      }\n    }\n    const compileOptions = {\n      ...options.compilerOptions,\n      filename: normalizedFilename,\n      // use normalized here to avoid bleeding absolute fs path\n      generate: ssr ? \"ssr\" : \"dom\",\n      format: \"esm\"\n    };\n    if (options.hot && options.emitCss) {\n      const hash = `s-${safeBase64Hash(normalizedFilename)}`;\n      log.debug(`setting cssHash ${hash} for ${normalizedFilename}`);\n      compileOptions.cssHash = () => hash;\n    }\n    if (ssr && compileOptions.enableSourcemap !== false) {\n      if (typeof compileOptions.enableSourcemap === \"object\") {\n        compileOptions.enableSourcemap.css = false;\n      } else {\n        compileOptions.enableSourcemap = { js: true, css: false };\n      }\n    }\n    let preprocessed;\n    let preprocessors = options.preprocess;\n    if (!options.isBuild && options.emitCss && options.hot) {\n      if (!Array.isArray(preprocessors)) {\n        preprocessors = preprocessors ? [preprocessors, devStylePreprocessor] : [devStylePreprocessor];\n      } else {\n        preprocessors = preprocessors.concat(devStylePreprocessor);\n      }\n    }\n    if (preprocessors) {\n      try {\n        preprocessed = await preprocess(code, preprocessors, { filename });\n      } catch (e) {\n        e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : \"\"}`;\n        throw e;\n      }\n      if (preprocessed.dependencies)\n        dependencies.push(...preprocessed.dependencies);\n      if (preprocessed.map)\n        compileOptions.sourcemap = preprocessed.map;\n    }\n    if (typeof preprocessed?.map === \"object\") {\n      mapSourcesToRelative(preprocessed?.map, filename);\n    }\n    if (raw && svelteRequest.query.type === \"preprocessed\") {\n      return { preprocessed: preprocessed ?? { code } };\n    }\n    const finalCode = preprocessed ? preprocessed.code : code;\n    const dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\n      filename,\n      code: finalCode,\n      compileOptions\n    });\n    if (dynamicCompileOptions && log.debug.enabled) {\n      log.debug(\n        `dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`\n      );\n    }\n    const finalCompileOptions = dynamicCompileOptions ? {\n      ...compileOptions,\n      ...dynamicCompileOptions\n    } : compileOptions;\n    const endStat = stats?.start(filename);\n    const compiled = compile(finalCode, finalCompileOptions);\n    if (endStat) {\n      endStat();\n    }\n    mapSourcesToRelative(compiled.js?.map, filename);\n    mapSourcesToRelative(compiled.css?.map, filename);\n    if (!raw) {\n      const hasCss = compiled.css?.code?.trim().length > 0;\n      if (emitCss && hasCss) {\n        compiled.js.code += `\nimport ${JSON.stringify(cssId)};\n`;\n      }\n      if (!ssr && makeHot) {\n        compiled.js.code = makeHot({\n          id: filename,\n          compiledCode: compiled.js.code,\n          //@ts-expect-error hot isn't a boolean at this point\n          hotOptions: { ...options.hot, injectCss: options.hot?.injectCss === true && hasCss },\n          compiled,\n          originalCode: code,\n          compileOptions: finalCompileOptions\n        });\n      }\n    }\n    compiled.js.dependencies = dependencies;\n    return {\n      filename,\n      normalizedFilename,\n      lang: code.match(scriptLangRE)?.[1] || \"js\",\n      // @ts-ignore\n      compiled,\n      ssr,\n      dependencies,\n      preprocessed: preprocessed ?? { code }\n    };\n  };\n};\nfunction buildMakeHot(options) {\n  const needsMakeHot = options.hot !== false && options.isServe && !options.isProduction;\n  if (needsMakeHot) {\n    const hotApi = options?.hot?.hotApi;\n    const adapter = options?.hot?.adapter;\n    return createMakeHot({\n      walk,\n      hotApi,\n      adapter,\n      hotOptions: { noOverlay: true, ...options.hot }\n    });\n  }\n}\nfunction createCompileSvelte(options) {\n  const makeHot = buildMakeHot(options);\n  return _createCompileSvelte(makeHot);\n}\n\n// src/utils/id.ts\nimport { createFilter } from \"vite\";\nimport { normalizePath } from \"vite\";\nimport * as fs from \"fs\";\nvar VITE_FS_PREFIX = \"/@fs/\";\nvar IS_WINDOWS = process.platform === \"win32\";\nvar SUPPORTED_COMPILER_OPTIONS = [\n  \"generate\",\n  \"dev\",\n  \"css\",\n  \"hydratable\",\n  \"customElement\",\n  \"immutable\",\n  \"enableSourcemap\"\n];\nvar TYPES_WITH_COMPILER_OPTIONS = [\"style\", \"script\", \"all\"];\nfunction splitId(id) {\n  const parts = id.split(`?`, 2);\n  const filename = parts[0];\n  const rawQuery = parts[1];\n  return { filename, rawQuery };\n}\nfunction parseToSvelteRequest(id, filename, rawQuery, root, timestamp, ssr) {\n  const query = parseRequestQuery(rawQuery);\n  const rawOrDirect = !!(query.raw || query.direct);\n  if (query.url || !query.svelte && rawOrDirect) {\n    return;\n  }\n  const raw = rawOrDirect;\n  const normalizedFilename = normalize(filename, root);\n  const cssId = createVirtualImportId(filename, root, \"style\");\n  return {\n    id,\n    filename,\n    normalizedFilename,\n    cssId,\n    query,\n    timestamp,\n    ssr,\n    raw\n  };\n}\nfunction createVirtualImportId(filename, root, type) {\n  const parts = [\"svelte\", `type=${type}`];\n  if (type === \"style\") {\n    parts.push(\"lang.css\");\n  }\n  if (existsInRoot(filename, root)) {\n    filename = root + filename;\n  } else if (filename.startsWith(VITE_FS_PREFIX)) {\n    filename = IS_WINDOWS ? filename.slice(VITE_FS_PREFIX.length) : filename.slice(VITE_FS_PREFIX.length - 1);\n  }\n  return `${filename}?${parts.join(\"&\")}`;\n}\nfunction parseRequestQuery(rawQuery) {\n  const query = Object.fromEntries(new URLSearchParams(rawQuery));\n  for (const key in query) {\n    if (query[key] === \"\") {\n      query[key] = true;\n    }\n  }\n  const compilerOptions = query.compilerOptions;\n  if (compilerOptions) {\n    if (!((query.raw || query.direct) && TYPES_WITH_COMPILER_OPTIONS.includes(query.type))) {\n      throw new Error(\n        `Invalid compilerOptions in query ${rawQuery}. CompilerOptions are only supported for raw or direct queries with type in \"${TYPES_WITH_COMPILER_OPTIONS.join(\n          \", \"\n        )}\" e.g. '?svelte&raw&type=script&compilerOptions={\"generate\":\"ssr\",\"dev\":false}`\n      );\n    }\n    try {\n      const parsed = JSON.parse(compilerOptions);\n      const invalid = Object.keys(parsed).filter(\n        (key) => !SUPPORTED_COMPILER_OPTIONS.includes(key)\n      );\n      if (invalid.length) {\n        throw new Error(\n          `Invalid compilerOptions in query ${rawQuery}: ${invalid.join(\n            \", \"\n          )}. Supported: ${SUPPORTED_COMPILER_OPTIONS.join(\", \")}`\n        );\n      }\n      query.compilerOptions = parsed;\n    } catch (e) {\n      log.error(\"failed to parse request query compilerOptions\", e);\n      throw e;\n    }\n  }\n  return query;\n}\nfunction normalize(filename, normalizedRoot) {\n  return stripRoot(normalizePath(filename), normalizedRoot);\n}\nfunction existsInRoot(filename, root) {\n  if (filename.startsWith(VITE_FS_PREFIX)) {\n    return false;\n  }\n  return fs.existsSync(root + filename);\n}\nfunction stripRoot(normalizedFilename, normalizedRoot) {\n  return normalizedFilename.startsWith(normalizedRoot + \"/\") ? normalizedFilename.slice(normalizedRoot.length) : normalizedFilename;\n}\nfunction buildFilter(include, exclude, extensions) {\n  const rollupFilter = createFilter(include, exclude);\n  return (filename) => rollupFilter(filename) && extensions.some((ext) => filename.endsWith(ext));\n}\nfunction buildIdParser(options) {\n  const { include, exclude, extensions, root } = options;\n  const normalizedRoot = normalizePath(root);\n  const filter = buildFilter(include, exclude, extensions);\n  return (id, ssr, timestamp = Date.now()) => {\n    const { filename, rawQuery } = splitId(id);\n    if (filter(filename)) {\n      return parseToSvelteRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);\n    }\n  };\n}\n\n// src/utils/options.ts\nimport { normalizePath as normalizePath3 } from \"vite\";\n\n// src/utils/load-svelte-config.ts\nimport { createRequire } from \"module\";\nimport path3 from \"path\";\nimport fs2 from \"fs\";\nimport { pathToFileURL } from \"url\";\nvar esmRequire;\nvar knownSvelteConfigNames = [\n  \"svelte.config.js\",\n  \"svelte.config.cjs\",\n  \"svelte.config.mjs\"\n];\nvar dynamicImportDefault = new Function(\n  \"path\",\n  \"timestamp\",\n  'return import(path + \"?t=\" + timestamp).then(m => m.default)'\n);\nasync function loadSvelteConfig(viteConfig, inlineOptions) {\n  if (inlineOptions?.configFile === false) {\n    return;\n  }\n  const configFile = findConfigToLoad(viteConfig, inlineOptions);\n  if (configFile) {\n    let err;\n    if (configFile.endsWith(\".js\") || configFile.endsWith(\".mjs\")) {\n      try {\n        const result = await dynamicImportDefault(\n          pathToFileURL(configFile).href,\n          fs2.statSync(configFile).mtimeMs\n        );\n        if (result != null) {\n          return {\n            ...result,\n            configFile\n          };\n        } else {\n          throw new Error(`invalid export in ${configFile}`);\n        }\n      } catch (e) {\n        log.error(`failed to import config ${configFile}`, e);\n        err = e;\n      }\n    }\n    if (!configFile.endsWith(\".mjs\")) {\n      try {\n        const _require = import.meta.url ? esmRequire ?? (esmRequire = createRequire(import.meta.url)) : __require;\n        delete _require.cache[_require.resolve(configFile)];\n        const result = _require(configFile);\n        if (result != null) {\n          return {\n            ...result,\n            configFile\n          };\n        } else {\n          throw new Error(`invalid export in ${configFile}`);\n        }\n      } catch (e) {\n        log.error(`failed to require config ${configFile}`, e);\n        if (!err) {\n          err = e;\n        }\n      }\n    }\n    throw err;\n  }\n}\nfunction findConfigToLoad(viteConfig, inlineOptions) {\n  const root = viteConfig?.root || process.cwd();\n  if (inlineOptions?.configFile) {\n    const abolutePath = path3.isAbsolute(inlineOptions.configFile) ? inlineOptions.configFile : path3.resolve(root, inlineOptions.configFile);\n    if (!fs2.existsSync(abolutePath)) {\n      throw new Error(`failed to find svelte config file ${abolutePath}.`);\n    }\n    return abolutePath;\n  } else {\n    const existingKnownConfigFiles = knownSvelteConfigNames.map((candidate) => path3.resolve(root, candidate)).filter((file) => fs2.existsSync(file));\n    if (existingKnownConfigFiles.length === 0) {\n      log.debug(`no svelte config found at ${root}`);\n      return;\n    } else if (existingKnownConfigFiles.length > 1) {\n      log.warn(\n        `found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,\n        existingKnownConfigFiles\n      );\n    }\n    return existingKnownConfigFiles[0];\n  }\n}\n\n// src/utils/constants.ts\nvar VITE_RESOLVE_MAIN_FIELDS = [\"module\", \"jsnext:main\", \"jsnext\"];\nvar SVELTE_RESOLVE_MAIN_FIELDS = [\"svelte\"];\nvar SVELTE_IMPORTS = [\n  \"svelte/animate\",\n  \"svelte/easing\",\n  \"svelte/internal\",\n  \"svelte/motion\",\n  \"svelte/ssr\",\n  \"svelte/store\",\n  \"svelte/transition\",\n  \"svelte\"\n];\nvar SVELTE_HMR_IMPORTS = [\n  \"svelte-hmr/runtime/hot-api-esm.js\",\n  \"svelte-hmr/runtime/proxy-adapter-dom.js\",\n  \"svelte-hmr\"\n];\nvar SVELTE_EXPORT_CONDITIONS = [\"svelte\"];\n\n// src/utils/options.ts\nimport path5 from \"path\";\n\n// src/utils/esbuild.ts\nimport { readFileSync } from \"fs\";\nimport { compile as compile2, preprocess as preprocess2 } from \"svelte/compiler\";\nvar facadeEsbuildSveltePluginName = \"vite-plugin-svelte:facade\";\nfunction esbuildSveltePlugin(options) {\n  return {\n    name: \"vite-plugin-svelte:optimize-svelte\",\n    setup(build) {\n      if (build.initialOptions.plugins?.some((v) => v.name === \"vite:dep-scan\"))\n        return;\n      const svelteExtensions = (options.extensions ?? [\".svelte\"]).map((ext) => ext.slice(1));\n      const svelteFilter = new RegExp(`\\\\.(` + svelteExtensions.join(\"|\") + `)(\\\\?.*)?$`);\n      let statsCollection;\n      build.onStart(() => {\n        statsCollection = options.stats?.startCollection(\"prebundle libraries\", {\n          logResult: (c) => c.stats.length > 1\n        });\n      });\n      build.onLoad({ filter: svelteFilter }, async ({ path: filename }) => {\n        const code = readFileSync(filename, \"utf8\");\n        try {\n          const contents = await compileSvelte(options, { filename, code }, statsCollection);\n          return { contents };\n        } catch (e) {\n          return { errors: [toESBuildError(e, options)] };\n        }\n      });\n      build.onEnd(() => {\n        statsCollection?.finish();\n      });\n    }\n  };\n}\nasync function compileSvelte(options, { filename, code }, statsCollection) {\n  let css = options.compilerOptions.css;\n  if (css !== \"none\") {\n    css = \"injected\";\n  }\n  const compileOptions = {\n    ...options.compilerOptions,\n    css,\n    filename,\n    format: \"esm\",\n    generate: \"dom\"\n  };\n  let preprocessed;\n  if (options.preprocess) {\n    try {\n      preprocessed = await preprocess2(code, options.preprocess, { filename });\n    } catch (e) {\n      e.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : \"\"}`;\n      throw e;\n    }\n    if (preprocessed.map)\n      compileOptions.sourcemap = preprocessed.map;\n  }\n  const finalCode = preprocessed ? preprocessed.code : code;\n  const dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\n    filename,\n    code: finalCode,\n    compileOptions\n  });\n  if (dynamicCompileOptions && log.debug.enabled) {\n    log.debug(`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`);\n  }\n  const finalCompileOptions = dynamicCompileOptions ? {\n    ...compileOptions,\n    ...dynamicCompileOptions\n  } : compileOptions;\n  const endStat = statsCollection?.start(filename);\n  const compiled = compile2(finalCode, finalCompileOptions);\n  if (endStat) {\n    endStat();\n  }\n  return compiled.js.code + \"//# sourceMappingURL=\" + compiled.js.map.toUrl();\n}\n\n// src/utils/options.ts\nimport deepmerge from \"deepmerge\";\nimport {\n  crawlFrameworkPkgs,\n  isDepExcluded,\n  isDepExternaled,\n  isDepIncluded,\n  isDepNoExternaled\n} from \"vitefu\";\n\n// src/utils/dependencies.ts\nimport path4 from \"path\";\nimport fs3 from \"fs/promises\";\nimport { findDepPkgJsonPath } from \"vitefu\";\nasync function resolveDependencyData(dep, parent) {\n  const depDataPath = await findDepPkgJsonPath(dep, parent);\n  if (!depDataPath)\n    return void 0;\n  try {\n    return {\n      dir: path4.dirname(depDataPath),\n      pkg: JSON.parse(await fs3.readFile(depDataPath, \"utf-8\"))\n    };\n  } catch {\n    return void 0;\n  }\n}\nvar COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [\n  \"@lukeed/uuid\",\n  \"@playwright/test\",\n  \"@sveltejs/vite-plugin-svelte\",\n  \"@sveltejs/kit\",\n  \"autoprefixer\",\n  \"cookie\",\n  \"dotenv\",\n  \"esbuild\",\n  \"eslint\",\n  \"jest\",\n  \"mdsvex\",\n  \"playwright\",\n  \"postcss\",\n  \"prettier\",\n  \"svelte\",\n  \"svelte-check\",\n  \"svelte-hmr\",\n  \"svelte-preprocess\",\n  \"tslib\",\n  \"typescript\",\n  \"vite\",\n  \"vitest\",\n  \"__vite-browser-external\"\n  // see https://github.com/sveltejs/vite-plugin-svelte/issues/362\n];\nvar COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [\n  \"@fontsource/\",\n  \"@postcss-plugins/\",\n  \"@rollup/\",\n  \"@sveltejs/adapter-\",\n  \"@types/\",\n  \"@typescript-eslint/\",\n  \"eslint-\",\n  \"jest-\",\n  \"postcss-plugin-\",\n  \"prettier-plugin-\",\n  \"rollup-plugin-\",\n  \"vite-plugin-\"\n];\nfunction isCommonDepWithoutSvelteField(dependency) {\n  return COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) || COMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some(\n    (prefix2) => prefix2.startsWith(\"@\") ? dependency.startsWith(prefix2) : dependency.substring(dependency.lastIndexOf(\"/\") + 1).startsWith(prefix2)\n    // check prefix omitting @scope/\n  );\n}\n\n// src/utils/vite-plugin-svelte-stats.ts\nimport { findClosestPkgJsonPath } from \"vitefu\";\nimport { readFileSync as readFileSync2 } from \"fs\";\nimport { dirname } from \"path\";\nimport { performance } from \"perf_hooks\";\nimport { normalizePath as normalizePath2 } from \"vite\";\nvar defaultCollectionOptions = {\n  // log after 500ms and more than one file processed\n  logInProgress: (c, now) => now - c.collectionStart > 500 && c.stats.length > 1,\n  // always log results\n  logResult: () => true\n};\nfunction humanDuration(n) {\n  return n < 100 ? `${n.toFixed(1)}ms` : `${(n / 1e3).toFixed(2)}s`;\n}\nfunction formatPackageStats(pkgStats) {\n  const statLines = pkgStats.map((pkgStat) => {\n    const duration = pkgStat.duration;\n    const avg = duration / pkgStat.files;\n    return [pkgStat.pkg, `${pkgStat.files}`, humanDuration(duration), humanDuration(avg)];\n  });\n  statLines.unshift([\"package\", \"files\", \"time\", \"avg\"]);\n  const columnWidths = statLines.reduce(\n    (widths, row) => {\n      for (let i = 0; i < row.length; i++) {\n        const cell = row[i];\n        if (widths[i] < cell.length) {\n          widths[i] = cell.length;\n        }\n      }\n      return widths;\n    },\n    statLines[0].map(() => 0)\n  );\n  const table = statLines.map(\n    (row) => row.map((cell, i) => {\n      if (i === 0) {\n        return cell.padEnd(columnWidths[i], \" \");\n      } else {\n        return cell.padStart(columnWidths[i], \" \");\n      }\n    }).join(\"\t\")\n  ).join(\"\\n\");\n  return table;\n}\nasync function getClosestNamedPackage(file) {\n  let name = \"$unknown\";\n  let path10 = await findClosestPkgJsonPath(file, (pkgPath) => {\n    const pkg = JSON.parse(readFileSync2(pkgPath, \"utf-8\"));\n    if (pkg.name != null) {\n      name = pkg.name;\n      return true;\n    }\n    return false;\n  });\n  path10 = normalizePath2(dirname(path10 ?? file)) + \"/\";\n  return { name, path: path10 };\n}\nvar VitePluginSvelteStats = class {\n  constructor() {\n    // package directory -> package name\n    this._packages = [];\n    this._collections = [];\n  }\n  startCollection(name, opts) {\n    const options = {\n      ...defaultCollectionOptions,\n      ...opts\n    };\n    const stats = [];\n    const collectionStart = performance.now();\n    const _this = this;\n    let hasLoggedProgress = false;\n    const collection = {\n      name,\n      options,\n      stats,\n      collectionStart,\n      finished: false,\n      start(file) {\n        if (collection.finished) {\n          throw new Error(\"called after finish() has been used\");\n        }\n        file = normalizePath2(file);\n        const start = performance.now();\n        const stat = { file, start, end: start };\n        return () => {\n          const now = performance.now();\n          stat.end = now;\n          stats.push(stat);\n          if (!hasLoggedProgress && options.logInProgress(collection, now)) {\n            hasLoggedProgress = true;\n            log.info(`${name} in progress ...`);\n          }\n        };\n      },\n      async finish() {\n        await _this._finish(collection);\n      }\n    };\n    _this._collections.push(collection);\n    return collection;\n  }\n  async finishAll() {\n    await Promise.all(this._collections.map((c) => c.finish()));\n  }\n  async _finish(collection) {\n    try {\n      collection.finished = true;\n      const now = performance.now();\n      collection.duration = now - collection.collectionStart;\n      const logResult = collection.options.logResult(collection);\n      if (logResult) {\n        await this._aggregateStatsResult(collection);\n        log.info(`${collection.name} done.`, formatPackageStats(collection.packageStats));\n      }\n      const index = this._collections.indexOf(collection);\n      this._collections.splice(index, 1);\n      collection.stats.length = 0;\n      collection.stats = [];\n      if (collection.packageStats) {\n        collection.packageStats.length = 0;\n        collection.packageStats = [];\n      }\n      collection.start = () => () => {\n      };\n      collection.finish = () => {\n      };\n    } catch (e) {\n      log.debug.once(`failed to finish stats for ${collection.name}`, e);\n    }\n  }\n  async _aggregateStatsResult(collection) {\n    const stats = collection.stats;\n    for (const stat of stats) {\n      let pkg = this._packages.find((p) => stat.file.startsWith(p.path));\n      if (!pkg) {\n        pkg = await getClosestNamedPackage(stat.file);\n        this._packages.push(pkg);\n      }\n      stat.pkg = pkg.name;\n    }\n    const grouped = {};\n    stats.forEach((stat) => {\n      const pkg = stat.pkg;\n      let group = grouped[pkg];\n      if (!group) {\n        group = grouped[pkg] = {\n          files: 0,\n          duration: 0,\n          pkg\n        };\n      }\n      group.files += 1;\n      group.duration += stat.end - stat.start;\n    });\n    const groups = Object.values(grouped);\n    groups.sort((a, b) => b.duration - a.duration);\n    collection.packageStats = groups;\n  }\n};\n\n// src/utils/options.ts\nvar allowedPluginOptions = /* @__PURE__ */ new Set([\n  \"include\",\n  \"exclude\",\n  \"emitCss\",\n  \"hot\",\n  \"ignorePluginPreprocessors\",\n  \"disableDependencyReinclusion\",\n  \"prebundleSvelteLibraries\",\n  \"experimental\"\n]);\nvar knownRootOptions = /* @__PURE__ */ new Set([\"extensions\", \"compilerOptions\", \"preprocess\", \"onwarn\"]);\nvar allowedInlineOptions = /* @__PURE__ */ new Set([\n  \"configFile\",\n  \"kit\",\n  // only for internal use by sveltekit\n  ...allowedPluginOptions,\n  ...knownRootOptions\n]);\nfunction validateInlineOptions(inlineOptions) {\n  const invalidKeys = Object.keys(inlineOptions || {}).filter(\n    (key) => !allowedInlineOptions.has(key)\n  );\n  if (invalidKeys.length) {\n    log.warn(`invalid plugin options \"${invalidKeys.join(\", \")}\" in inline config`, inlineOptions);\n  }\n}\nfunction convertPluginOptions(config) {\n  if (!config) {\n    return;\n  }\n  const invalidRootOptions = Object.keys(config).filter((key) => allowedPluginOptions.has(key));\n  if (invalidRootOptions.length > 0) {\n    throw new Error(\n      `Invalid options in svelte config. Move the following options into 'vitePlugin:{...}': ${invalidRootOptions.join(\n        \", \"\n      )}`\n    );\n  }\n  if (!config.vitePlugin) {\n    return config;\n  }\n  const pluginOptions = config.vitePlugin;\n  const pluginOptionKeys = Object.keys(pluginOptions);\n  const rootOptionsInPluginOptions = pluginOptionKeys.filter((key) => knownRootOptions.has(key));\n  if (rootOptionsInPluginOptions.length > 0) {\n    throw new Error(\n      `Invalid options in svelte config under vitePlugin:{...}', move them to the config root : ${rootOptionsInPluginOptions.join(\n        \", \"\n      )}`\n    );\n  }\n  const duplicateOptions = pluginOptionKeys.filter(\n    (key) => Object.prototype.hasOwnProperty.call(config, key)\n  );\n  if (duplicateOptions.length > 0) {\n    throw new Error(\n      `Invalid duplicate options in svelte config under vitePlugin:{...}', they are defined in root too and must only exist once: ${duplicateOptions.join(\n        \", \"\n      )}`\n    );\n  }\n  const unknownPluginOptions = pluginOptionKeys.filter((key) => !allowedPluginOptions.has(key));\n  if (unknownPluginOptions.length > 0) {\n    log.warn(\n      `ignoring unknown plugin options in svelte config under vitePlugin:{...}: ${unknownPluginOptions.join(\n        \", \"\n      )}`\n    );\n    unknownPluginOptions.forEach((unkownOption) => {\n      delete pluginOptions[unkownOption];\n    });\n  }\n  const result = {\n    ...config,\n    ...pluginOptions\n  };\n  delete result.vitePlugin;\n  return result;\n}\nasync function preResolveOptions(inlineOptions = {}, viteUserConfig, viteEnv) {\n  const viteConfigWithResolvedRoot = {\n    ...viteUserConfig,\n    root: resolveViteRoot(viteUserConfig)\n  };\n  const isBuild = viteEnv.command === \"build\";\n  const defaultOptions = {\n    extensions: [\".svelte\"],\n    emitCss: true,\n    prebundleSvelteLibraries: !isBuild\n  };\n  const svelteConfig = convertPluginOptions(\n    await loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions)\n  );\n  const extraOptions = {\n    root: viteConfigWithResolvedRoot.root,\n    isBuild,\n    isServe: viteEnv.command === \"serve\",\n    isDebug: process.env.DEBUG != null\n  };\n  const merged = mergeConfigs(\n    defaultOptions,\n    svelteConfig,\n    inlineOptions,\n    extraOptions\n  );\n  if (svelteConfig?.configFile) {\n    merged.configFile = svelteConfig.configFile;\n  }\n  return merged;\n}\nfunction mergeConfigs(...configs) {\n  let result = {};\n  for (const config of configs.filter((x) => x != null)) {\n    result = deepmerge(result, config, {\n      // replace arrays\n      arrayMerge: (target, source) => source ?? target\n    });\n  }\n  return result;\n}\nfunction resolveOptions(preResolveOptions2, viteConfig) {\n  const css = preResolveOptions2.emitCss ? \"external\" : \"injected\";\n  const defaultOptions = {\n    hot: viteConfig.isProduction ? false : {\n      injectCss: css === \"injected\",\n      partialAccept: !!viteConfig.experimental?.hmrPartialAccept\n    },\n    compilerOptions: {\n      css,\n      dev: !viteConfig.isProduction\n    }\n  };\n  const extraOptions = {\n    root: viteConfig.root,\n    isProduction: viteConfig.isProduction\n  };\n  const merged = mergeConfigs(defaultOptions, preResolveOptions2, extraOptions);\n  removeIgnoredOptions(merged);\n  handleDeprecatedOptions(merged);\n  addSvelteKitOptions(merged);\n  addExtraPreprocessors(merged, viteConfig);\n  enforceOptionsForHmr(merged);\n  enforceOptionsForProduction(merged);\n  const isLogLevelInfo = [void 0, \"info\"].includes(viteConfig.logLevel);\n  const disableCompileStats = merged.experimental?.disableCompileStats;\n  const statsEnabled = disableCompileStats !== true && disableCompileStats !== (merged.isBuild ? \"build\" : \"dev\");\n  if (statsEnabled && isLogLevelInfo) {\n    merged.stats = new VitePluginSvelteStats();\n  }\n  return merged;\n}\nfunction enforceOptionsForHmr(options) {\n  if (options.hot) {\n    if (!options.compilerOptions.dev) {\n      log.warn(\"hmr is enabled but compilerOptions.dev is false, forcing it to true\");\n      options.compilerOptions.dev = true;\n    }\n    if (options.emitCss) {\n      if (options.hot !== true && options.hot.injectCss) {\n        log.warn(\"hmr and emitCss are enabled but hot.injectCss is true, forcing it to false\");\n        options.hot.injectCss = false;\n      }\n      const css = options.compilerOptions.css;\n      if (css === true || css === \"injected\") {\n        const forcedCss = \"external\";\n        log.warn(\n          `hmr and emitCss are enabled but compilerOptions.css is ${css}, forcing it to ${forcedCss}`\n        );\n        options.compilerOptions.css = forcedCss;\n      }\n    } else {\n      if (options.hot === true || !options.hot.injectCss) {\n        log.warn(\n          \"hmr with emitCss disabled requires option hot.injectCss to be enabled, forcing it to true\"\n        );\n        if (options.hot === true) {\n          options.hot = { injectCss: true };\n        } else {\n          options.hot.injectCss = true;\n        }\n      }\n      const css = options.compilerOptions.css;\n      if (!(css === true || css === \"injected\")) {\n        const forcedCss = \"injected\";\n        log.warn(\n          `hmr with emitCss disabled requires compilerOptions.css to be enabled, forcing it to ${forcedCss}`\n        );\n        options.compilerOptions.css = forcedCss;\n      }\n    }\n  }\n}\nfunction enforceOptionsForProduction(options) {\n  if (options.isProduction) {\n    if (options.hot) {\n      log.warn(\"options.hot is enabled but does not work on production build, forcing it to false\");\n      options.hot = false;\n    }\n    if (options.compilerOptions.dev) {\n      log.warn(\n        \"you are building for production but compilerOptions.dev is true, forcing it to false\"\n      );\n      options.compilerOptions.dev = false;\n    }\n  }\n}\nfunction removeIgnoredOptions(options) {\n  const ignoredCompilerOptions = [\"generate\", \"format\", \"filename\"];\n  if (options.hot && options.emitCss) {\n    ignoredCompilerOptions.push(\"cssHash\");\n  }\n  const passedCompilerOptions = Object.keys(options.compilerOptions || {});\n  const passedIgnored = passedCompilerOptions.filter((o) => ignoredCompilerOptions.includes(o));\n  if (passedIgnored.length) {\n    log.warn(\n      `The following Svelte compilerOptions are controlled by vite-plugin-svelte and essential to its functionality. User-specified values are ignored. Please remove them from your configuration: ${passedIgnored.join(\n        \", \"\n      )}`\n    );\n    passedIgnored.forEach((ignored) => {\n      delete options.compilerOptions[ignored];\n    });\n  }\n}\nfunction addSvelteKitOptions(options) {\n  if (options?.kit != null && options.compilerOptions.hydratable == null) {\n    log.debug(`Setting compilerOptions.hydratable = true for SvelteKit`);\n    options.compilerOptions.hydratable = true;\n  }\n}\nfunction handleDeprecatedOptions(options) {\n  if (options.experimental?.prebundleSvelteLibraries) {\n    options.prebundleSvelteLibraries = options.experimental?.prebundleSvelteLibraries;\n    log.warn(\n      \"experimental.prebundleSvelteLibraries is no longer experimental and has moved to prebundleSvelteLibraries\"\n    );\n  }\n  if (options.experimental?.generateMissingPreprocessorSourcemaps) {\n    log.warn(\"experimental.generateMissingPreprocessorSourcemaps has been removed.\");\n  }\n}\nfunction resolveViteRoot(viteConfig) {\n  return normalizePath3(viteConfig.root ? path5.resolve(viteConfig.root) : process.cwd());\n}\nasync function buildExtraViteConfig(options, config) {\n  if (!config.resolve) {\n    config.resolve = {};\n  }\n  config.resolve.mainFields = [\n    ...SVELTE_RESOLVE_MAIN_FIELDS,\n    ...config.resolve.mainFields ?? VITE_RESOLVE_MAIN_FIELDS\n  ];\n  const extraViteConfig = {\n    resolve: {\n      dedupe: [...SVELTE_IMPORTS, ...SVELTE_HMR_IMPORTS],\n      conditions: [...SVELTE_EXPORT_CONDITIONS]\n    }\n    // this option is still awaiting a PR in vite to be supported\n    // see https://github.com/sveltejs/vite-plugin-svelte/issues/60\n    // @ts-ignore\n    // knownJsSrcExtensions: options.extensions\n  };\n  const extraSvelteConfig = buildExtraConfigForSvelte(config);\n  const extraDepsConfig = await buildExtraConfigForDependencies(options, config);\n  extraViteConfig.optimizeDeps = {\n    include: [\n      ...extraSvelteConfig.optimizeDeps.include,\n      ...extraDepsConfig.optimizeDeps.include.filter(\n        (dep) => !isDepExcluded(dep, extraSvelteConfig.optimizeDeps.exclude)\n      )\n    ],\n    exclude: [\n      ...extraSvelteConfig.optimizeDeps.exclude,\n      ...extraDepsConfig.optimizeDeps.exclude.filter(\n        (dep) => !isDepIncluded(dep, extraSvelteConfig.optimizeDeps.include)\n      )\n    ]\n  };\n  extraViteConfig.ssr = {\n    external: [\n      ...extraSvelteConfig.ssr.external,\n      ...extraDepsConfig.ssr.external.filter(\n        (dep) => !isDepNoExternaled(dep, extraSvelteConfig.ssr.noExternal)\n      )\n    ],\n    noExternal: [\n      ...extraSvelteConfig.ssr.noExternal,\n      ...extraDepsConfig.ssr.noExternal.filter(\n        (dep) => !isDepExternaled(dep, extraSvelteConfig.ssr.external)\n      )\n    ]\n  };\n  if (options.prebundleSvelteLibraries) {\n    extraViteConfig.optimizeDeps = {\n      ...extraViteConfig.optimizeDeps,\n      // Experimental Vite API to allow these extensions to be scanned and prebundled\n      // @ts-ignore\n      extensions: options.extensions ?? [\".svelte\"],\n      // Add esbuild plugin to prebundle Svelte files.\n      // Currently a placeholder as more information is needed after Vite config is resolved,\n      // the real Svelte plugin is added in `patchResolvedViteConfig()`\n      esbuildOptions: {\n        plugins: [{ name: facadeEsbuildSveltePluginName, setup: () => {\n        } }]\n      }\n    };\n  }\n  if ((options.hot == null || options.hot === true || options.hot && options.hot.partialAccept !== false) && // deviate from svelte-hmr, default to true\n  config.experimental?.hmrPartialAccept !== false) {\n    log.debug('enabling \"experimental.hmrPartialAccept\" in vite config');\n    extraViteConfig.experimental = { hmrPartialAccept: true };\n  }\n  validateViteConfig(extraViteConfig, config, options);\n  return extraViteConfig;\n}\nfunction validateViteConfig(extraViteConfig, config, options) {\n  const { prebundleSvelteLibraries, isBuild } = options;\n  if (prebundleSvelteLibraries) {\n    const isEnabled = (option) => option !== true && option !== (isBuild ? \"build\" : \"dev\");\n    const logWarning = (name, value, recommendation) => log.warn.once(\n      `Incompatible options: \\`prebundleSvelteLibraries: true\\` and vite \\`${name}: ${JSON.stringify(\n        value\n      )}\\` ${isBuild ? \"during build.\" : \".\"} ${recommendation}`\n    );\n    const viteOptimizeDepsDisabled = config.optimizeDeps?.disabled ?? \"build\";\n    const isOptimizeDepsEnabled = isEnabled(viteOptimizeDepsDisabled);\n    if (!isBuild && !isOptimizeDepsEnabled) {\n      logWarning(\n        \"optimizeDeps.disabled\",\n        viteOptimizeDepsDisabled,\n        'Forcing `optimizeDeps.disabled: \"build\"`. Disable prebundleSvelteLibraries or update your vite config to enable optimizeDeps during dev.'\n      );\n      extraViteConfig.optimizeDeps.disabled = \"build\";\n    } else if (isBuild && isOptimizeDepsEnabled) {\n      logWarning(\n        \"optimizeDeps.disabled\",\n        viteOptimizeDepsDisabled,\n        \"Disable optimizeDeps or prebundleSvelteLibraries for build if you experience errors.\"\n      );\n    }\n  }\n}\nasync function buildExtraConfigForDependencies(options, config) {\n  const depsConfig = await crawlFrameworkPkgs({\n    root: options.root,\n    isBuild: options.isBuild,\n    viteUserConfig: config,\n    isFrameworkPkgByJson(pkgJson) {\n      let hasSvelteCondition = false;\n      if (typeof pkgJson.exports === \"object\") {\n        JSON.stringify(pkgJson.exports, (key, value) => {\n          if (SVELTE_EXPORT_CONDITIONS.includes(key)) {\n            hasSvelteCondition = true;\n          }\n          return value;\n        });\n      }\n      return hasSvelteCondition || !!pkgJson.svelte;\n    },\n    isSemiFrameworkPkgByJson(pkgJson) {\n      return !!pkgJson.dependencies?.svelte || !!pkgJson.peerDependencies?.svelte;\n    },\n    isFrameworkPkgByName(pkgName) {\n      const isNotSveltePackage = isCommonDepWithoutSvelteField(pkgName);\n      if (isNotSveltePackage) {\n        return false;\n      } else {\n        return void 0;\n      }\n    }\n  });\n  log.debug(\"extra config for dependencies generated by vitefu\", depsConfig);\n  if (options.prebundleSvelteLibraries) {\n    depsConfig.optimizeDeps.exclude = [];\n    const userExclude = config.optimizeDeps?.exclude;\n    depsConfig.optimizeDeps.include = !userExclude ? [] : depsConfig.optimizeDeps.include.filter((dep) => {\n      return dep.includes(\">\") && dep.split(\">\").slice(0, -1).some((d) => isDepExcluded(d.trim(), userExclude));\n    });\n  }\n  if (options.disableDependencyReinclusion === true) {\n    depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter(\n      (dep) => !dep.includes(\">\")\n    );\n  } else if (Array.isArray(options.disableDependencyReinclusion)) {\n    const disabledDeps = options.disableDependencyReinclusion;\n    depsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter((dep) => {\n      if (!dep.includes(\">\"))\n        return true;\n      const trimDep = dep.replace(/\\s+/g, \"\");\n      return disabledDeps.some((disabled) => trimDep.includes(`${disabled}>`));\n    });\n  }\n  log.debug(\"post-processed extra config for dependencies\", depsConfig);\n  return depsConfig;\n}\nfunction buildExtraConfigForSvelte(config) {\n  const include = [];\n  const exclude = [\"svelte-hmr\"];\n  if (!isDepExcluded(\"svelte\", config.optimizeDeps?.exclude ?? [])) {\n    const svelteImportsToInclude = SVELTE_IMPORTS.filter((x) => x !== \"svelte/ssr\");\n    log.debug(\n      `adding bare svelte packages to optimizeDeps.include: ${svelteImportsToInclude.join(\", \")} `\n    );\n    include.push(...svelteImportsToInclude);\n  } else {\n    log.debug('\"svelte\" is excluded in optimizeDeps.exclude, skipped adding it to include.');\n  }\n  const noExternal = [];\n  const external = [];\n  if (!isDepExternaled(\"svelte\", config.ssr?.external ?? [])) {\n    noExternal.push(\"svelte\", /^svelte\\//);\n  }\n  return { optimizeDeps: { include, exclude }, ssr: { noExternal, external } };\n}\nfunction patchResolvedViteConfig(viteConfig, options) {\n  if (options.preprocess) {\n    for (const preprocessor of arraify(options.preprocess)) {\n      if (preprocessor.style && \"__resolvedConfig\" in preprocessor.style) {\n        preprocessor.style.__resolvedConfig = viteConfig;\n      }\n    }\n  }\n  const facadeEsbuildSveltePlugin = viteConfig.optimizeDeps.esbuildOptions?.plugins?.find(\n    (plugin) => plugin.name === facadeEsbuildSveltePluginName\n  );\n  if (facadeEsbuildSveltePlugin) {\n    Object.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));\n  }\n}\nfunction arraify(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n// src/utils/watch.ts\nimport fs4 from \"fs\";\nimport path6 from \"path\";\nfunction setupWatchers(options, cache, requestParser) {\n  const { server, configFile: svelteConfigFile } = options;\n  if (!server) {\n    return;\n  }\n  const { watcher, ws } = server;\n  const { root, server: serverConfig } = server.config;\n  const emitChangeEventOnDependants = (filename) => {\n    const dependants = cache.getDependants(filename);\n    dependants.forEach((dependant) => {\n      if (fs4.existsSync(dependant)) {\n        log.debug(\n          `emitting virtual change event for \"${dependant}\" because depdendency \"${filename}\" changed`\n        );\n        watcher.emit(\"change\", dependant);\n      }\n    });\n  };\n  const removeUnlinkedFromCache = (filename) => {\n    const svelteRequest = requestParser(filename, false);\n    if (svelteRequest) {\n      const removedFromCache = cache.remove(svelteRequest);\n      if (removedFromCache) {\n        log.debug(`cleared VitePluginSvelteCache for deleted file ${filename}`);\n      }\n    }\n  };\n  const triggerViteRestart = (filename) => {\n    if (serverConfig.middlewareMode) {\n      const message = \"Svelte config change detected, restart your dev process to apply the changes.\";\n      log.info(message, filename);\n      ws.send({\n        type: \"error\",\n        err: { message, stack: \"\", plugin: \"vite-plugin-svelte\", id: filename }\n      });\n    } else {\n      log.info(`svelte config changed: restarting vite server. - file: ${filename}`);\n      server.restart();\n    }\n  };\n  const listenerCollection = {\n    add: [],\n    change: [emitChangeEventOnDependants],\n    unlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]\n  };\n  if (svelteConfigFile !== false) {\n    const possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => path6.join(root, cfg));\n    const restartOnConfigAdd = (filename) => {\n      if (possibleSvelteConfigs.includes(filename)) {\n        triggerViteRestart(filename);\n      }\n    };\n    const restartOnConfigChange = (filename) => {\n      if (filename === svelteConfigFile) {\n        triggerViteRestart(filename);\n      }\n    };\n    if (svelteConfigFile) {\n      listenerCollection.change.push(restartOnConfigChange);\n      listenerCollection.unlink.push(restartOnConfigChange);\n    } else {\n      listenerCollection.add.push(restartOnConfigAdd);\n    }\n  }\n  Object.entries(listenerCollection).forEach(([evt, listeners]) => {\n    if (listeners.length > 0) {\n      watcher.on(evt, (filename) => listeners.forEach((listener) => listener(filename)));\n    }\n  });\n}\nfunction ensureWatchedFile(watcher, file, root) {\n  if (file && // only need to watch if out of root\n  !file.startsWith(root + \"/\") && // some rollup plugins use null bytes for private resolved Ids\n  !file.includes(\"\\0\") && fs4.existsSync(file)) {\n    watcher.add(path6.resolve(file));\n  }\n}\n\n// src/utils/resolve.ts\nimport path7 from \"path\";\nimport { builtinModules } from \"module\";\nasync function resolveViaPackageJsonSvelte(importee, importer, cache) {\n  if (importer && isBareImport(importee) && !isNodeInternal(importee) && !isCommonDepWithoutSvelteField(importee)) {\n    const cached = cache.getResolvedSvelteField(importee, importer);\n    if (cached) {\n      return cached;\n    }\n    const pkgData = await resolveDependencyData(importee, importer);\n    if (pkgData) {\n      const { pkg, dir } = pkgData;\n      if (pkg.svelte) {\n        const result = path7.resolve(dir, pkg.svelte);\n        cache.setResolvedSvelteField(importee, importer, result);\n        return result;\n      }\n    }\n  }\n}\nfunction isNodeInternal(importee) {\n  return importee.startsWith(\"node:\") || builtinModules.includes(importee);\n}\nfunction isBareImport(importee) {\n  if (!importee || importee[0] === \".\" || importee[0] === \"\\0\" || importee.includes(\":\") || path7.isAbsolute(importee)) {\n    return false;\n  }\n  const parts = importee.split(\"/\");\n  switch (parts.length) {\n    case 1:\n      return true;\n    case 2:\n      return parts[0].startsWith(\"@\");\n    default:\n      return false;\n  }\n}\n\n// src/utils/optimizer.ts\nimport { promises as fs5 } from \"fs\";\nimport path8 from \"path\";\nvar PREBUNDLE_SENSITIVE_OPTIONS = [\n  \"compilerOptions\",\n  \"configFile\",\n  \"experimental\",\n  \"extensions\",\n  \"ignorePluginPreprocessors\",\n  \"preprocess\"\n];\nasync function saveSvelteMetadata(cacheDir, options) {\n  const svelteMetadata = generateSvelteMetadata(options);\n  const svelteMetadataPath = path8.resolve(cacheDir, \"_svelte_metadata.json\");\n  const currentSvelteMetadata = JSON.stringify(svelteMetadata, (_, value) => {\n    return typeof value === \"function\" ? value.toString() : value;\n  });\n  let existingSvelteMetadata;\n  try {\n    existingSvelteMetadata = await fs5.readFile(svelteMetadataPath, \"utf8\");\n  } catch {\n  }\n  await fs5.mkdir(cacheDir, { recursive: true });\n  await fs5.writeFile(svelteMetadataPath, currentSvelteMetadata);\n  return currentSvelteMetadata !== existingSvelteMetadata;\n}\nfunction generateSvelteMetadata(options) {\n  const metadata = {};\n  for (const key of PREBUNDLE_SENSITIVE_OPTIONS) {\n    metadata[key] = options[key];\n  }\n  return metadata;\n}\n\n// src/ui/inspector/plugin.ts\nimport { normalizePath as normalizePath4 } from \"vite\";\nimport path9 from \"path\";\nimport { fileURLToPath } from \"url\";\nimport fs6 from \"fs\";\n\n// src/ui/inspector/utils.ts\nvar FS_PREFIX = `/@fs/`;\nvar IS_WINDOWS2 = process.platform === \"win32\";\nvar queryRE = /\\?.*$/s;\nvar hashRE = /#.*$/s;\nfunction idToFile(id) {\n  if (id.startsWith(FS_PREFIX)) {\n    id = id = id.slice(IS_WINDOWS2 ? FS_PREFIX.length : FS_PREFIX.length - 1);\n  }\n  return id.replace(hashRE, \"\").replace(queryRE, \"\");\n}\n\n// src/ui/inspector/plugin.ts\nvar defaultInspectorOptions = {\n  toggleKeyCombo: process.platform === \"win32\" ? \"control-shift\" : \"meta-shift\",\n  navKeys: { parent: \"ArrowUp\", child: \"ArrowDown\", next: \"ArrowRight\", prev: \"ArrowLeft\" },\n  openKey: \"Enter\",\n  holdMode: false,\n  showToggleButton: \"active\",\n  toggleButtonPos: \"top-right\",\n  customStyles: true\n};\nfunction getInspectorPath() {\n  const pluginPath = normalizePath4(path9.dirname(fileURLToPath(import.meta.url)));\n  return pluginPath.replace(/\\/vite-plugin-svelte\\/dist$/, \"/vite-plugin-svelte/src/ui/inspector/\");\n}\nfunction svelteInspector() {\n  const inspectorPath = getInspectorPath();\n  log.debug.enabled && log.debug(`svelte inspector path: ${inspectorPath}`);\n  let inspectorOptions;\n  let appendTo;\n  let disabled = false;\n  return {\n    name: \"vite-plugin-svelte:inspector\",\n    apply: \"serve\",\n    enforce: \"pre\",\n    configResolved(config) {\n      const vps = config.plugins.find((p) => p.name === \"vite-plugin-svelte\");\n      const options = vps?.api?.options?.experimental?.inspector;\n      if (!vps || !options) {\n        log.debug(\"inspector disabled, could not find config\");\n        disabled = true;\n        return;\n      }\n      inspectorOptions = {\n        ...defaultInspectorOptions,\n        ...options\n      };\n      const isSvelteKit = config.plugins.some((p) => p.name.startsWith(\"vite-plugin-sveltekit\"));\n      if (isSvelteKit && !inspectorOptions.appendTo) {\n        inspectorOptions.appendTo = `/generated/root.svelte`;\n      }\n      appendTo = inspectorOptions.appendTo;\n    },\n    async resolveId(importee, importer, options) {\n      if (options?.ssr || disabled) {\n        return;\n      }\n      if (importee.startsWith(\"virtual:svelte-inspector-options\")) {\n        return importee;\n      } else if (importee.startsWith(\"virtual:svelte-inspector-path:\")) {\n        const resolved = importee.replace(\"virtual:svelte-inspector-path:\", inspectorPath);\n        log.debug.enabled && log.debug(`resolved ${importee} with ${resolved}`);\n        return resolved;\n      }\n    },\n    async load(id, options) {\n      if (options?.ssr || disabled) {\n        return;\n      }\n      if (id === \"virtual:svelte-inspector-options\") {\n        return `export default ${JSON.stringify(inspectorOptions ?? {})}`;\n      } else if (id.startsWith(inspectorPath)) {\n        const file = idToFile(id);\n        if (fs6.existsSync(file)) {\n          return await fs6.promises.readFile(file, \"utf-8\");\n        } else {\n          log.error(`failed to find file for svelte-inspector: ${file}, referenced by id ${id}.`);\n        }\n      }\n    },\n    transform(code, id, options) {\n      if (options?.ssr || disabled || !appendTo) {\n        return;\n      }\n      if (id.endsWith(appendTo)) {\n        return { code: `${code}\nimport 'virtual:svelte-inspector-path:load-inspector.js'` };\n      }\n    },\n    transformIndexHtml(html) {\n      if (disabled || appendTo) {\n        return;\n      }\n      return {\n        html,\n        tags: [\n          {\n            tag: \"script\",\n            injectTo: \"body\",\n            attrs: {\n              type: \"module\",\n              // /@id/ is needed, otherwise the virtual: is seen as protocol by browser and cors error happens\n              src: \"/@id/virtual:svelte-inspector-path:load-inspector.js\"\n            }\n          }\n        ]\n      };\n    }\n  };\n}\n\n// src/utils/vite-plugin-svelte-cache.ts\nvar VitePluginSvelteCache = class {\n  constructor() {\n    this._css = /* @__PURE__ */ new Map();\n    this._js = /* @__PURE__ */ new Map();\n    this._dependencies = /* @__PURE__ */ new Map();\n    this._dependants = /* @__PURE__ */ new Map();\n    this._resolvedSvelteFields = /* @__PURE__ */ new Map();\n    this._errors = /* @__PURE__ */ new Map();\n  }\n  update(compileData) {\n    this._errors.delete(compileData.normalizedFilename);\n    this.updateCSS(compileData);\n    this.updateJS(compileData);\n    this.updateDependencies(compileData);\n  }\n  has(svelteRequest) {\n    const id = svelteRequest.normalizedFilename;\n    return this._errors.has(id) || this._js.has(id) || this._css.has(id);\n  }\n  setError(svelteRequest, error) {\n    this.remove(svelteRequest, true);\n    this._errors.set(svelteRequest.normalizedFilename, error);\n  }\n  updateCSS(compileData) {\n    this._css.set(compileData.normalizedFilename, compileData.compiled.css);\n  }\n  updateJS(compileData) {\n    if (!compileData.ssr) {\n      this._js.set(compileData.normalizedFilename, compileData.compiled.js);\n    }\n  }\n  updateDependencies(compileData) {\n    const id = compileData.normalizedFilename;\n    const prevDependencies = this._dependencies.get(id) || [];\n    const dependencies = compileData.dependencies;\n    this._dependencies.set(id, dependencies);\n    const removed = prevDependencies.filter((d) => !dependencies.includes(d));\n    const added = dependencies.filter((d) => !prevDependencies.includes(d));\n    added.forEach((d) => {\n      if (!this._dependants.has(d)) {\n        this._dependants.set(d, /* @__PURE__ */ new Set());\n      }\n      this._dependants.get(d).add(compileData.filename);\n    });\n    removed.forEach((d) => {\n      this._dependants.get(d).delete(compileData.filename);\n    });\n  }\n  remove(svelteRequest, keepDependencies = false) {\n    const id = svelteRequest.normalizedFilename;\n    let removed = false;\n    if (this._errors.delete(id)) {\n      removed = true;\n    }\n    if (this._js.delete(id)) {\n      removed = true;\n    }\n    if (this._css.delete(id)) {\n      removed = true;\n    }\n    if (!keepDependencies) {\n      const dependencies = this._dependencies.get(id);\n      if (dependencies) {\n        removed = true;\n        dependencies.forEach((d) => {\n          const dependants = this._dependants.get(d);\n          if (dependants && dependants.has(svelteRequest.filename)) {\n            dependants.delete(svelteRequest.filename);\n          }\n        });\n        this._dependencies.delete(id);\n      }\n    }\n    return removed;\n  }\n  getCSS(svelteRequest) {\n    return this._css.get(svelteRequest.normalizedFilename);\n  }\n  getJS(svelteRequest) {\n    if (!svelteRequest.ssr) {\n      return this._js.get(svelteRequest.normalizedFilename);\n    }\n  }\n  getError(svelteRequest) {\n    return this._errors.get(svelteRequest.normalizedFilename);\n  }\n  getDependants(path10) {\n    const dependants = this._dependants.get(path10);\n    return dependants ? [...dependants] : [];\n  }\n  getResolvedSvelteField(name, importer) {\n    return this._resolvedSvelteFields.get(this._getResolvedSvelteFieldKey(name, importer));\n  }\n  setResolvedSvelteField(importee, importer = void 0, resolvedSvelte) {\n    this._resolvedSvelteFields.set(\n      this._getResolvedSvelteFieldKey(importee, importer),\n      resolvedSvelte\n    );\n  }\n  _getResolvedSvelteFieldKey(importee, importer) {\n    return importer ? `${importer} > ${importee}` : importee;\n  }\n};\n\n// src/utils/load-raw.ts\nimport fs7 from \"fs\";\nasync function loadRaw(svelteRequest, compileSvelte2, options) {\n  const { id, filename, query } = svelteRequest;\n  let compileData;\n  const source = fs7.readFileSync(filename, \"utf-8\");\n  try {\n    svelteRequest.ssr = query.compilerOptions?.generate === \"ssr\";\n    const type = query.type;\n    compileData = await compileSvelte2(svelteRequest, source, {\n      ...options,\n      // don't use dynamic vite-plugin-svelte defaults here to ensure stable result between ssr,dev and build\n      compilerOptions: {\n        dev: false,\n        css: false,\n        hydratable: false,\n        enableSourcemap: query.sourcemap ? {\n          js: type === \"script\" || type === \"all\",\n          css: type === \"style\" || type === \"all\"\n        } : false,\n        ...svelteRequest.query.compilerOptions\n      },\n      hot: false,\n      emitCss: true\n    });\n  } catch (e) {\n    throw toRollupError(e, options);\n  }\n  let result;\n  if (query.type === \"style\") {\n    result = compileData.compiled.css;\n  } else if (query.type === \"script\") {\n    result = compileData.compiled.js;\n  } else if (query.type === \"preprocessed\") {\n    result = compileData.preprocessed;\n  } else if (query.type === \"all\" && query.raw) {\n    return allToRawExports(compileData, source);\n  } else {\n    throw new Error(\n      `invalid \"type=${query.type}\" in ${id}. supported are script, style, preprocessed, all`\n    );\n  }\n  if (query.direct) {\n    const supportedDirectTypes = [\"script\", \"style\"];\n    if (!supportedDirectTypes.includes(query.type)) {\n      throw new Error(\n        `invalid \"type=${query.type}\" combined with direct in ${id}. supported are: ${supportedDirectTypes.join(\", \")}`\n      );\n    }\n    log.debug(`load returns direct result for ${id}`);\n    let directOutput = result.code;\n    if (query.sourcemap && result.map?.toUrl) {\n      const map = `sourceMappingURL=${result.map.toUrl()}`;\n      if (query.type === \"style\") {\n        directOutput += `\n\n/*# ${map} */\n`;\n      } else if (query.type === \"script\") {\n        directOutput += `\n\n//# ${map}\n`;\n      }\n    }\n    return directOutput;\n  } else if (query.raw) {\n    log.debug(`load returns raw result for ${id}`);\n    return toRawExports(result);\n  } else {\n    throw new Error(`invalid raw mode in ${id}, supported are raw, direct`);\n  }\n}\nfunction allToRawExports(compileData, source) {\n  const exports = {\n    ...compileData,\n    ...compileData.compiled,\n    source\n  };\n  delete exports.compiled;\n  delete exports.filename;\n  return toRawExports(exports);\n}\nfunction toRawExports(object) {\n  let exports = Object.entries(object).filter(([key, value]) => typeof value !== \"function\").sort(([a], [b]) => a < b ? -1 : a === b ? 0 : 1).map(([key, value]) => `export const ${key}=${JSON.stringify(value)}`).join(\"\\n\") + \"\\n\";\n  if (Object.prototype.hasOwnProperty.call(object, \"code\")) {\n    exports += `export default code\n`;\n  }\n  return exports;\n}\n\n// src/preprocess.ts\nimport { preprocessCSS, resolveConfig, transformWithEsbuild } from \"vite\";\nvar supportedStyleLangs = [\"css\", \"less\", \"sass\", \"scss\", \"styl\", \"stylus\", \"postcss\", \"sss\"];\nvar supportedScriptLangs = [\"ts\"];\nfunction vitePreprocess(opts) {\n  const preprocessor = {};\n  if (opts?.script !== false) {\n    preprocessor.script = viteScript().script;\n  }\n  if (opts?.style !== false) {\n    const styleOpts = typeof opts?.style == \"object\" ? opts?.style : void 0;\n    preprocessor.style = viteStyle(styleOpts).style;\n  }\n  return preprocessor;\n}\nfunction viteScript() {\n  return {\n    async script({ attributes, content, filename = \"\" }) {\n      const lang = attributes.lang;\n      if (!supportedScriptLangs.includes(lang))\n        return;\n      const { code, map } = await transformWithEsbuild(content, filename, {\n        loader: lang,\n        target: \"esnext\",\n        tsconfigRaw: {\n          compilerOptions: {\n            // svelte typescript needs this flag to work with type imports\n            importsNotUsedAsValues: \"preserve\",\n            preserveValueImports: true\n          }\n        }\n      });\n      mapSourcesToRelative(map, filename);\n      return {\n        code,\n        map\n      };\n    }\n  };\n}\nfunction viteStyle(config = {}) {\n  let transform;\n  const style = async ({ attributes, content, filename = \"\" }) => {\n    const lang = attributes.lang;\n    if (!supportedStyleLangs.includes(lang))\n      return;\n    if (!transform) {\n      let resolvedConfig;\n      if (style.__resolvedConfig) {\n        resolvedConfig = style.__resolvedConfig;\n      } else if (isResolvedConfig(config)) {\n        resolvedConfig = config;\n      } else {\n        resolvedConfig = await resolveConfig(\n          config,\n          process.env.NODE_ENV === \"production\" ? \"build\" : \"serve\"\n        );\n      }\n      transform = getCssTransformFn(resolvedConfig);\n    }\n    const moduleId = `${filename}.${lang}`;\n    const { code, map } = await transform(content, moduleId);\n    mapSourcesToRelative(map, moduleId);\n    return {\n      code,\n      map: map ?? void 0\n    };\n  };\n  style.__resolvedConfig = null;\n  return { style };\n}\nfunction getCssTransformFn(config) {\n  return async (code, filename) => {\n    return preprocessCSS(code, filename, config);\n  };\n}\nfunction isResolvedConfig(config) {\n  return !!config.inlineConfig;\n}\n\n// src/index.ts\nfunction svelte(inlineOptions) {\n  if (process.env.DEBUG != null) {\n    log.setLevel(\"debug\");\n  }\n  validateInlineOptions(inlineOptions);\n  const cache = new VitePluginSvelteCache();\n  let requestParser;\n  let options;\n  let viteConfig;\n  let compileSvelte2;\n  let resolvedSvelteSSR;\n  const api = {};\n  const plugins = [\n    {\n      name: \"vite-plugin-svelte\",\n      // make sure our resolver runs before vite internal resolver to resolve svelte field correctly\n      enforce: \"pre\",\n      api,\n      async config(config, configEnv) {\n        if (process.env.DEBUG) {\n          log.setLevel(\"debug\");\n        } else if (config.logLevel) {\n          log.setLevel(config.logLevel);\n        }\n        options = await preResolveOptions(inlineOptions, config, configEnv);\n        const extraViteConfig = await buildExtraViteConfig(options, config);\n        log.debug(\"additional vite config\", extraViteConfig);\n        return extraViteConfig;\n      },\n      async configResolved(config) {\n        options = resolveOptions(options, config);\n        patchResolvedViteConfig(config, options);\n        requestParser = buildIdParser(options);\n        compileSvelte2 = createCompileSvelte(options);\n        viteConfig = config;\n        api.options = options;\n        log.debug(\"resolved options\", options);\n      },\n      async buildStart() {\n        if (!options.prebundleSvelteLibraries)\n          return;\n        const isSvelteMetadataChanged = await saveSvelteMetadata(viteConfig.cacheDir, options);\n        if (isSvelteMetadataChanged) {\n          viteConfig.optimizeDeps.force = true;\n        }\n      },\n      configureServer(server) {\n        options.server = server;\n        setupWatchers(options, cache, requestParser);\n      },\n      async load(id, opts) {\n        const ssr = !!opts?.ssr;\n        const svelteRequest = requestParser(id, !!ssr);\n        if (svelteRequest) {\n          const { filename, query, raw } = svelteRequest;\n          if (raw) {\n            return loadRaw(svelteRequest, compileSvelte2, options);\n          } else {\n            if (query.svelte && query.type === \"style\") {\n              const css = cache.getCSS(svelteRequest);\n              if (css) {\n                log.debug(`load returns css for ${filename}`);\n                return css;\n              }\n            }\n            if (viteConfig.assetsInclude(filename)) {\n              log.debug(`load returns raw content for ${filename}`);\n              return fs8.readFileSync(filename, \"utf-8\");\n            }\n          }\n        }\n      },\n      async resolveId(importee, importer, opts) {\n        const ssr = !!opts?.ssr;\n        const svelteRequest = requestParser(importee, ssr);\n        if (svelteRequest?.query.svelte) {\n          if (svelteRequest.query.type === \"style\" && !svelteRequest.raw) {\n            log.debug(`resolveId resolved virtual css module ${svelteRequest.cssId}`);\n            return svelteRequest.cssId;\n          }\n        }\n        if (ssr && importee === \"svelte\") {\n          if (!resolvedSvelteSSR) {\n            resolvedSvelteSSR = this.resolve(\"svelte/ssr\", void 0, { skipSelf: true }).then(\n              (svelteSSR) => {\n                log.debug(\"resolved svelte to svelte/ssr\");\n                return svelteSSR;\n              },\n              (err) => {\n                log.debug(\n                  \"failed to resolve svelte to svelte/ssr. Update svelte to a version that exports it\",\n                  err\n                );\n                return null;\n              }\n            );\n          }\n          return resolvedSvelteSSR;\n        }\n        const scan = !!opts?.scan;\n        const isPrebundled = options.prebundleSvelteLibraries && viteConfig.optimizeDeps?.disabled !== true && viteConfig.optimizeDeps?.disabled !== (options.isBuild ? \"build\" : \"dev\") && !isDepExcluded2(importee, viteConfig.optimizeDeps?.exclude ?? []);\n        if (ssr || scan || !isPrebundled) {\n          try {\n            const resolved = await resolveViaPackageJsonSvelte(importee, importer, cache);\n            if (resolved) {\n              log.debug(\n                `resolveId resolved ${resolved} via package.json svelte field of ${importee}`\n              );\n              return resolved;\n            }\n          } catch (e) {\n            log.debug.once(\n              `error trying to resolve ${importee} from ${importer} via package.json svelte field `,\n              e\n            );\n          }\n        }\n      },\n      async transform(code, id, opts) {\n        const ssr = !!opts?.ssr;\n        const svelteRequest = requestParser(id, ssr);\n        if (!svelteRequest || svelteRequest.query.type === \"style\" || svelteRequest.raw) {\n          return;\n        }\n        let compileData;\n        try {\n          compileData = await compileSvelte2(svelteRequest, code, options);\n        } catch (e) {\n          cache.setError(svelteRequest, e);\n          throw toRollupError(e, options);\n        }\n        logCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\n        cache.update(compileData);\n        if (compileData.dependencies?.length && options.server) {\n          compileData.dependencies.forEach((d) => {\n            ensureWatchedFile(options.server.watcher, d, options.root);\n          });\n        }\n        log.debug(`transform returns compiled js for ${svelteRequest.filename}`);\n        return {\n          ...compileData.compiled.js,\n          meta: {\n            vite: {\n              lang: compileData.lang\n            }\n          }\n        };\n      },\n      handleHotUpdate(ctx) {\n        if (!options.hot || !options.emitCss) {\n          return;\n        }\n        const svelteRequest = requestParser(ctx.file, false, ctx.timestamp);\n        if (svelteRequest) {\n          return handleHotUpdate(compileSvelte2, ctx, svelteRequest, cache, options);\n        }\n      },\n      async buildEnd() {\n        await options.stats?.finishAll();\n      }\n    }\n  ];\n  plugins.push(svelteInspector());\n  return plugins.filter(Boolean);\n}\nexport {\n  loadSvelteConfig,\n  svelte,\n  vitePreprocess\n};\n//# sourceMappingURL=index.js.map"}},"index.js.map":{"file":{"contents":"{\"version\":3,\"sources\":[\"../src/index.ts\",\"../src/utils/log.ts\",\"../src/utils/error.ts\",\"../src/handle-hot-update.ts\",\"../src/utils/compile.ts\",\"../src/utils/hash.ts\",\"../src/utils/preprocess.ts\",\"../src/utils/sourcemaps.ts\",\"../src/utils/id.ts\",\"../src/utils/options.ts\",\"../src/utils/load-svelte-config.ts\",\"../src/utils/constants.ts\",\"../src/utils/esbuild.ts\",\"../src/utils/dependencies.ts\",\"../src/utils/vite-plugin-svelte-stats.ts\",\"../src/utils/watch.ts\",\"../src/utils/resolve.ts\",\"../src/utils/optimizer.ts\",\"../src/ui/inspector/plugin.ts\",\"../src/ui/inspector/utils.ts\",\"../src/utils/vite-plugin-svelte-cache.ts\",\"../src/utils/load-raw.ts\",\"../src/preprocess.ts\"],\"sourcesContent\":[\"import fs from 'fs';\\nimport { HmrContext, ModuleNode, Plugin, ResolvedConfig, UserConfig } from 'vite';\\n// eslint-disable-next-line node/no-missing-import\\nimport { isDepExcluded } from 'vitefu';\\nimport { handleHotUpdate } from './handle-hot-update';\\nimport { log, logCompilerWarnings } from './utils/log';\\nimport { type CompileSvelte, createCompileSvelte } from './utils/compile';\\nimport { buildIdParser, IdParser } from './utils/id';\\nimport {\\n\\tbuildExtraViteConfig,\\n\\tvalidateInlineOptions,\\n\\tOptions,\\n\\tResolvedOptions,\\n\\tresolveOptions,\\n\\tpatchResolvedViteConfig,\\n\\tpreResolveOptions\\n} from './utils/options';\\n\\nimport { ensureWatchedFile, setupWatchers } from './utils/watch';\\nimport { resolveViaPackageJsonSvelte } from './utils/resolve';\\nimport { PartialResolvedId } from 'rollup';\\nimport { toRollupError } from './utils/error';\\nimport { saveSvelteMetadata } from './utils/optimizer';\\nimport { svelteInspector } from './ui/inspector/plugin';\\nimport { VitePluginSvelteCache } from './utils/vite-plugin-svelte-cache';\\nimport { loadRaw } from './utils/load-raw';\\n\\ninterface PluginAPI {\\n\\t/**\\n\\t * must not be modified, should not be used outside of vite-plugin-svelte repo\\n\\t * @internal\\n\\t * @experimental\\n\\t */\\n\\toptions?: ResolvedOptions;\\n\\t// TODO expose compile cache here so other utility plugins can use it\\n}\\n\\nexport function svelte(inlineOptions?: Partial<Options>): Plugin[] {\\n\\tif (process.env.DEBUG != null) {\\n\\t\\tlog.setLevel('debug');\\n\\t}\\n\\tvalidateInlineOptions(inlineOptions);\\n\\tconst cache = new VitePluginSvelteCache();\\n\\t// updated in configResolved hook\\n\\tlet requestParser: IdParser;\\n\\tlet options: ResolvedOptions;\\n\\tlet viteConfig: ResolvedConfig;\\n\\t/* eslint-disable no-unused-vars */\\n\\tlet compileSvelte: CompileSvelte;\\n\\t/* eslint-enable no-unused-vars */\\n\\n\\tlet resolvedSvelteSSR: Promise<PartialResolvedId | null>;\\n\\tconst api: PluginAPI = {};\\n\\tconst plugins: Plugin[] = [\\n\\t\\t{\\n\\t\\t\\tname: 'vite-plugin-svelte',\\n\\t\\t\\t// make sure our resolver runs before vite internal resolver to resolve svelte field correctly\\n\\t\\t\\tenforce: 'pre',\\n\\t\\t\\tapi,\\n\\t\\t\\tasync config(config, configEnv): Promise<Partial<UserConfig>> {\\n\\t\\t\\t\\t// setup logger\\n\\t\\t\\t\\tif (process.env.DEBUG) {\\n\\t\\t\\t\\t\\tlog.setLevel('debug');\\n\\t\\t\\t\\t} else if (config.logLevel) {\\n\\t\\t\\t\\t\\tlog.setLevel(config.logLevel);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// @ts-expect-error temporarily lend the options variable until fixed in configResolved\\n\\t\\t\\t\\toptions = await preResolveOptions(inlineOptions, config, configEnv);\\n\\t\\t\\t\\t// extra vite config\\n\\t\\t\\t\\tconst extraViteConfig = await buildExtraViteConfig(options, config);\\n\\t\\t\\t\\tlog.debug('additional vite config', extraViteConfig);\\n\\t\\t\\t\\treturn extraViteConfig;\\n\\t\\t\\t},\\n\\n\\t\\t\\tasync configResolved(config) {\\n\\t\\t\\t\\toptions = resolveOptions(options, config);\\n\\t\\t\\t\\tpatchResolvedViteConfig(config, options);\\n\\t\\t\\t\\trequestParser = buildIdParser(options);\\n\\t\\t\\t\\tcompileSvelte = createCompileSvelte(options);\\n\\t\\t\\t\\tviteConfig = config;\\n\\t\\t\\t\\t// TODO deep clone to avoid mutability from outside?\\n\\t\\t\\t\\tapi.options = options;\\n\\t\\t\\t\\tlog.debug('resolved options', options);\\n\\t\\t\\t},\\n\\n\\t\\t\\tasync buildStart() {\\n\\t\\t\\t\\tif (!options.prebundleSvelteLibraries) return;\\n\\t\\t\\t\\tconst isSvelteMetadataChanged = await saveSvelteMetadata(viteConfig.cacheDir, options);\\n\\t\\t\\t\\tif (isSvelteMetadataChanged) {\\n\\t\\t\\t\\t\\t// Force Vite to optimize again. Although we mutate the config here, it works because\\n\\t\\t\\t\\t\\t// Vite's optimizer runs after `buildStart()`.\\n\\t\\t\\t\\t\\tviteConfig.optimizeDeps.force = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tconfigureServer(server) {\\n\\t\\t\\t\\t// eslint-disable-next-line no-unused-vars\\n\\t\\t\\t\\toptions.server = server;\\n\\t\\t\\t\\tsetupWatchers(options, cache, requestParser);\\n\\t\\t\\t},\\n\\n\\t\\t\\tasync load(id, opts) {\\n\\t\\t\\t\\tconst ssr = !!opts?.ssr;\\n\\t\\t\\t\\tconst svelteRequest = requestParser(id, !!ssr);\\n\\t\\t\\t\\tif (svelteRequest) {\\n\\t\\t\\t\\t\\tconst { filename, query, raw } = svelteRequest;\\n\\t\\t\\t\\t\\tif (raw) {\\n\\t\\t\\t\\t\\t\\treturn loadRaw(svelteRequest, compileSvelte, options);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (query.svelte && query.type === 'style') {\\n\\t\\t\\t\\t\\t\\t\\tconst css = cache.getCSS(svelteRequest);\\n\\t\\t\\t\\t\\t\\t\\tif (css) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlog.debug(`load returns css for ${filename}`);\\n\\t\\t\\t\\t\\t\\t\\t\\treturn css;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// prevent vite asset plugin from loading files as url that should be compiled in transform\\n\\t\\t\\t\\t\\t\\tif (viteConfig.assetsInclude(filename)) {\\n\\t\\t\\t\\t\\t\\t\\tlog.debug(`load returns raw content for ${filename}`);\\n\\t\\t\\t\\t\\t\\t\\treturn fs.readFileSync(filename, 'utf-8');\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tasync resolveId(importee, importer, opts) {\\n\\t\\t\\t\\tconst ssr = !!opts?.ssr;\\n\\t\\t\\t\\tconst svelteRequest = requestParser(importee, ssr);\\n\\t\\t\\t\\tif (svelteRequest?.query.svelte) {\\n\\t\\t\\t\\t\\tif (svelteRequest.query.type === 'style' && !svelteRequest.raw) {\\n\\t\\t\\t\\t\\t\\t// return cssId with root prefix so postcss pipeline of vite finds the directory correctly\\n\\t\\t\\t\\t\\t\\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/14\\n\\t\\t\\t\\t\\t\\tlog.debug(`resolveId resolved virtual css module ${svelteRequest.cssId}`);\\n\\t\\t\\t\\t\\t\\treturn svelteRequest.cssId;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (ssr && importee === 'svelte') {\\n\\t\\t\\t\\t\\tif (!resolvedSvelteSSR) {\\n\\t\\t\\t\\t\\t\\tresolvedSvelteSSR = this.resolve('svelte/ssr', undefined, { skipSelf: true }).then(\\n\\t\\t\\t\\t\\t\\t\\t(svelteSSR) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tlog.debug('resolved svelte to svelte/ssr');\\n\\t\\t\\t\\t\\t\\t\\t\\treturn svelteSSR;\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\t(err) => {\\n\\t\\t\\t\\t\\t\\t\\t\\tlog.debug(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t'failed to resolve svelte to svelte/ssr. Update svelte to a version that exports it',\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terr\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\treturn null; // returning null here leads to svelte getting resolved regularly\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn resolvedSvelteSSR;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//@ts-expect-error scan\\n\\t\\t\\t\\tconst scan = !!opts?.scan; // scanner phase of optimizeDeps\\n\\t\\t\\t\\tconst isPrebundled =\\n\\t\\t\\t\\t\\toptions.prebundleSvelteLibraries &&\\n\\t\\t\\t\\t\\tviteConfig.optimizeDeps?.disabled !== true &&\\n\\t\\t\\t\\t\\tviteConfig.optimizeDeps?.disabled !== (options.isBuild ? 'build' : 'dev') &&\\n\\t\\t\\t\\t\\t!isDepExcluded(importee, viteConfig.optimizeDeps?.exclude ?? []);\\n\\t\\t\\t\\t// for prebundled libraries we let vite resolve the prebundling result\\n\\t\\t\\t\\t// for ssr, during scanning and non-prebundled, we do it\\n\\t\\t\\t\\tif (ssr || scan || !isPrebundled) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tconst resolved = await resolveViaPackageJsonSvelte(importee, importer, cache);\\n\\t\\t\\t\\t\\t\\tif (resolved) {\\n\\t\\t\\t\\t\\t\\t\\tlog.debug(\\n\\t\\t\\t\\t\\t\\t\\t\\t`resolveId resolved ${resolved} via package.json svelte field of ${importee}`\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\treturn resolved;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t\\tlog.debug.once(\\n\\t\\t\\t\\t\\t\\t\\t`error trying to resolve ${importee} from ${importer} via package.json svelte field `,\\n\\t\\t\\t\\t\\t\\t\\te\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t// this error most likely happens due to non-svelte related importee/importers so swallow it here\\n\\t\\t\\t\\t\\t\\t// in case it really way a svelte library, users will notice anyway. (lib not working due to failed resolve)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tasync transform(code, id, opts) {\\n\\t\\t\\t\\tconst ssr = !!opts?.ssr;\\n\\t\\t\\t\\tconst svelteRequest = requestParser(id, ssr);\\n\\t\\t\\t\\tif (!svelteRequest || svelteRequest.query.type === 'style' || svelteRequest.raw) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlet compileData;\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tcompileData = await compileSvelte(svelteRequest, code, options);\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\tcache.setError(svelteRequest, e);\\n\\t\\t\\t\\t\\tthrow toRollupError(e, options);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlogCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\\n\\t\\t\\t\\tcache.update(compileData);\\n\\t\\t\\t\\tif (compileData.dependencies?.length && options.server) {\\n\\t\\t\\t\\t\\tcompileData.dependencies.forEach((d) => {\\n\\t\\t\\t\\t\\t\\tensureWatchedFile(options.server!.watcher, d, options.root);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlog.debug(`transform returns compiled js for ${svelteRequest.filename}`);\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t...compileData.compiled.js,\\n\\t\\t\\t\\t\\tmeta: {\\n\\t\\t\\t\\t\\t\\tvite: {\\n\\t\\t\\t\\t\\t\\t\\tlang: compileData.lang\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t},\\n\\n\\t\\t\\thandleHotUpdate(ctx: HmrContext): void | Promise<Array<ModuleNode> | void> {\\n\\t\\t\\t\\tif (!options.hot || !options.emitCss) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst svelteRequest = requestParser(ctx.file, false, ctx.timestamp);\\n\\t\\t\\t\\tif (svelteRequest) {\\n\\t\\t\\t\\t\\treturn handleHotUpdate(compileSvelte, ctx, svelteRequest, cache, options);\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tasync buildEnd() {\\n\\t\\t\\t\\tawait options.stats?.finishAll();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t];\\n\\tplugins.push(svelteInspector());\\n\\treturn plugins.filter(Boolean);\\n}\\n\\nexport { vitePreprocess } from './preprocess';\\nexport { loadSvelteConfig } from './utils/load-svelte-config';\\n\\nexport {\\n\\tOptions,\\n\\tPluginOptions,\\n\\tSvelteOptions,\\n\\tPreprocessor,\\n\\tPreprocessorGroup,\\n\\tCompileOptions,\\n\\tCssHashGetter,\\n\\tArrayable,\\n\\tMarkupPreprocessor,\\n\\tModuleFormat,\\n\\tProcessed,\\n\\tWarning\\n} from './utils/options';\\n\\nexport { SvelteWarningsMessage } from './utils/log';\\n\",\"/* eslint-disable no-unused-vars,no-console */\\nimport { cyan, yellow, red } from 'kleur/colors';\\nimport debug from 'debug';\\nimport { ResolvedOptions, Warning } from './options';\\nimport { SvelteRequest } from './id';\\n\\nconst levels: string[] = ['debug', 'info', 'warn', 'error', 'silent'];\\nconst prefix = 'vite-plugin-svelte';\\nconst loggers: { [key: string]: any } = {\\n\\tdebug: {\\n\\t\\tlog: debug(`vite:${prefix}`),\\n\\t\\tenabled: false,\\n\\t\\tisDebug: true\\n\\t},\\n\\tinfo: {\\n\\t\\tcolor: cyan,\\n\\t\\tlog: console.log,\\n\\t\\tenabled: true\\n\\t},\\n\\twarn: {\\n\\t\\tcolor: yellow,\\n\\t\\tlog: console.warn,\\n\\t\\tenabled: true\\n\\t},\\n\\terror: {\\n\\t\\tcolor: red,\\n\\t\\tlog: console.error,\\n\\t\\tenabled: true\\n\\t},\\n\\tsilent: {\\n\\t\\tenabled: false\\n\\t}\\n};\\n\\nlet _level: string = 'info';\\nfunction setLevel(level: string) {\\n\\tif (level === _level) {\\n\\t\\treturn;\\n\\t}\\n\\tconst levelIndex = levels.indexOf(level);\\n\\tif (levelIndex > -1) {\\n\\t\\t_level = level;\\n\\t\\tfor (let i = 0; i < levels.length; i++) {\\n\\t\\t\\tloggers[levels[i]].enabled = i >= levelIndex;\\n\\t\\t}\\n\\t} else {\\n\\t\\t_log(loggers.error, `invalid log level: ${level} `);\\n\\t}\\n}\\n\\nfunction _log(logger: any, message: string, payload?: any) {\\n\\tif (!logger.enabled) {\\n\\t\\treturn;\\n\\t}\\n\\tif (logger.isDebug) {\\n\\t\\tpayload !== undefined ? logger.log(message, payload) : logger.log(message);\\n\\t} else {\\n\\t\\tlogger.log(logger.color(`${new Date().toLocaleTimeString()} [${prefix}] ${message}`));\\n\\t\\tif (payload) {\\n\\t\\t\\tlogger.log(payload);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport interface LogFn {\\n\\t(message: string, payload?: any): void;\\n\\tenabled: boolean;\\n\\tonce: (message: string, payload?: any) => void;\\n}\\n\\nfunction createLogger(level: string): LogFn {\\n\\tconst logger = loggers[level];\\n\\tconst logFn: LogFn = _log.bind(null, logger) as LogFn;\\n\\tconst logged = new Set<String>();\\n\\tconst once = function (message: string, payload?: any) {\\n\\t\\tif (logged.has(message)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tlogged.add(message);\\n\\t\\tlogFn.apply(null, [message, payload]);\\n\\t};\\n\\tObject.defineProperty(logFn, 'enabled', {\\n\\t\\tget() {\\n\\t\\t\\treturn logger.enabled;\\n\\t\\t}\\n\\t});\\n\\tObject.defineProperty(logFn, 'once', {\\n\\t\\tget() {\\n\\t\\t\\treturn once;\\n\\t\\t}\\n\\t});\\n\\treturn logFn;\\n}\\n\\nexport const log = {\\n\\tdebug: createLogger('debug'),\\n\\tinfo: createLogger('info'),\\n\\twarn: createLogger('warn'),\\n\\terror: createLogger('error'),\\n\\tsetLevel\\n};\\n\\nexport type SvelteWarningsMessage = {\\n\\tid: string;\\n\\tfilename: string;\\n\\tnormalizedFilename: string;\\n\\ttimestamp: number;\\n\\twarnings: Warning[]; // allWarnings filtered by warnings where onwarn did not call the default handler\\n\\tallWarnings: Warning[]; // includes warnings filtered by onwarn and our extra vite plugin svelte warnings\\n\\trawWarnings: Warning[]; // raw compiler output\\n};\\n\\nexport function logCompilerWarnings(\\n\\tsvelteRequest: SvelteRequest,\\n\\twarnings: Warning[],\\n\\toptions: ResolvedOptions\\n) {\\n\\tconst { emitCss, onwarn, isBuild } = options;\\n\\tconst sendViaWS = !isBuild && options.experimental?.sendWarningsToBrowser;\\n\\tlet warn = isBuild ? warnBuild : warnDev;\\n\\tconst handledByDefaultWarn: Warning[] = [];\\n\\tconst notIgnored = warnings?.filter((w) => !ignoreCompilerWarning(w, isBuild, emitCss));\\n\\tconst extra = buildExtraWarnings(warnings, isBuild);\\n\\tconst allWarnings = [...notIgnored, ...extra];\\n\\tif (sendViaWS) {\\n\\t\\tconst _warn = warn;\\n\\t\\twarn = (w: Warning) => {\\n\\t\\t\\thandledByDefaultWarn.push(w);\\n\\t\\t\\t_warn(w);\\n\\t\\t};\\n\\t}\\n\\tallWarnings.forEach((warning) => {\\n\\t\\tif (onwarn) {\\n\\t\\t\\tonwarn(warning, warn);\\n\\t\\t} else {\\n\\t\\t\\twarn(warning);\\n\\t\\t}\\n\\t});\\n\\tif (sendViaWS) {\\n\\t\\tconst message: SvelteWarningsMessage = {\\n\\t\\t\\tid: svelteRequest.id,\\n\\t\\t\\tfilename: svelteRequest.filename,\\n\\t\\t\\tnormalizedFilename: svelteRequest.normalizedFilename,\\n\\t\\t\\ttimestamp: svelteRequest.timestamp,\\n\\t\\t\\twarnings: handledByDefaultWarn, // allWarnings filtered by warnings where onwarn did not call the default handler\\n\\t\\t\\tallWarnings, // includes warnings filtered by onwarn and our extra vite plugin svelte warnings\\n\\t\\t\\trawWarnings: warnings // raw compiler output\\n\\t\\t};\\n\\t\\tlog.debug(`sending svelte:warnings message for ${svelteRequest.normalizedFilename}`);\\n\\t\\toptions.server?.ws?.send('svelte:warnings', message);\\n\\t}\\n}\\n\\nfunction ignoreCompilerWarning(\\n\\twarning: Warning,\\n\\tisBuild: boolean,\\n\\temitCss: boolean | undefined\\n): boolean {\\n\\treturn (\\n\\t\\t(!emitCss && warning.code === 'css-unused-selector') || // same as rollup-plugin-svelte\\n\\t\\t(!isBuild && isNoScopableElementWarning(warning))\\n\\t);\\n}\\n\\nfunction isNoScopableElementWarning(warning: Warning) {\\n\\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/153\\n\\treturn warning.code === 'css-unused-selector' && warning.message.includes('\\\"*\\\"');\\n}\\n\\nfunction buildExtraWarnings(warnings: Warning[], isBuild: boolean): Warning[] {\\n\\tconst extraWarnings = [];\\n\\tif (!isBuild) {\\n\\t\\tconst noScopableElementWarnings = warnings.filter((w) => isNoScopableElementWarning(w));\\n\\t\\tif (noScopableElementWarnings.length > 0) {\\n\\t\\t\\t// in case there are multiple, use last one as that is the one caused by our *{} rule\\n\\t\\t\\tconst noScopableElementWarning =\\n\\t\\t\\t\\tnoScopableElementWarnings[noScopableElementWarnings.length - 1];\\n\\t\\t\\textraWarnings.push({\\n\\t\\t\\t\\t...noScopableElementWarning,\\n\\t\\t\\t\\tcode: 'vite-plugin-svelte-css-no-scopable-elements',\\n\\t\\t\\t\\tmessage: `No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles.`\\n\\t\\t\\t});\\n\\t\\t}\\n\\t}\\n\\treturn extraWarnings;\\n}\\n\\nfunction warnDev(w: Warning) {\\n\\tlog.info.enabled && log.info(buildExtendedLogMessage(w));\\n}\\n\\nfunction warnBuild(w: Warning) {\\n\\tlog.warn.enabled && log.warn(buildExtendedLogMessage(w), w.frame);\\n}\\n\\nexport function buildExtendedLogMessage(w: Warning) {\\n\\tconst parts = [];\\n\\tif (w.filename) {\\n\\t\\tparts.push(w.filename);\\n\\t}\\n\\tif (w.start) {\\n\\t\\tparts.push(':', w.start.line, ':', w.start.column);\\n\\t}\\n\\tif (w.message) {\\n\\t\\tif (parts.length > 0) {\\n\\t\\t\\tparts.push(' ');\\n\\t\\t}\\n\\t\\tparts.push(w.message);\\n\\t}\\n\\treturn parts.join('');\\n}\\n\",\"import { RollupError } from 'rollup';\\nimport { ResolvedOptions, Warning } from './options';\\nimport { buildExtendedLogMessage } from './log';\\nimport { PartialMessage } from 'esbuild';\\n\\n/**\\n * convert an error thrown by svelte.compile to a RollupError so that vite displays it in a user friendly way\\n * @param error a svelte compiler error, which is a mix of Warning and an error\\n * @returns {RollupError} the converted error\\n */\\nexport function toRollupError(error: Warning & Error, options: ResolvedOptions): RollupError {\\n\\tconst { filename, frame, start, code, name, stack } = error;\\n\\tconst rollupError: RollupError = {\\n\\t\\tname, // needed otherwise sveltekit coalesce_to_error turns it into a string\\n\\t\\tid: filename,\\n\\t\\tmessage: buildExtendedLogMessage(error), // include filename:line:column so that it's clickable\\n\\t\\tframe: formatFrameForVite(frame),\\n\\t\\tcode,\\n\\t\\tstack: options.isBuild || options.isDebug || !frame ? stack : ''\\n\\t};\\n\\tif (start) {\\n\\t\\trollupError.loc = {\\n\\t\\t\\tline: start.line,\\n\\t\\t\\tcolumn: start.column,\\n\\t\\t\\tfile: filename\\n\\t\\t};\\n\\t}\\n\\treturn rollupError;\\n}\\n\\n/**\\n * convert an error thrown by svelte.compile to an esbuild PartialMessage\\n * @param error a svelte compiler error, which is a mix of Warning and an error\\n * @returns {PartialMessage} the converted error\\n */\\nexport function toESBuildError(error: Warning & Error, options: ResolvedOptions): PartialMessage {\\n\\tconst { filename, frame, start, stack } = error;\\n\\tconst partialMessage: PartialMessage = {\\n\\t\\ttext: buildExtendedLogMessage(error)\\n\\t};\\n\\tif (start) {\\n\\t\\tpartialMessage.location = {\\n\\t\\t\\tline: start.line,\\n\\t\\t\\tcolumn: start.column,\\n\\t\\t\\tfile: filename,\\n\\t\\t\\tlineText: lineFromFrame(start.line, frame) // needed to get a meaningful error message on cli\\n\\t\\t};\\n\\t}\\n\\tif (options.isBuild || options.isDebug || !frame) {\\n\\t\\tpartialMessage.detail = stack;\\n\\t}\\n\\treturn partialMessage;\\n}\\n\\n/**\\n * extract line with number from codeframe\\n */\\nfunction lineFromFrame(lineNo: number, frame?: string): string {\\n\\tif (!frame) {\\n\\t\\treturn '';\\n\\t}\\n\\tconst lines = frame.split('\\\\n');\\n\\tconst errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));\\n\\treturn errorLine ? errorLine.substring(errorLine.indexOf(': ') + 3) : '';\\n}\\n\\n/**\\n * vite error overlay expects a specific format to show frames\\n * this reformats svelte frame (colon separated, less whitespace)\\n * to one that vite displays on overlay ( pipe separated, more whitespace)\\n * e.g.\\n * ```\\n * 1: foo\\n * 2: bar;\\n *       ^\\n * 3: baz\\n * ```\\n * to\\n * ```\\n *  1 | foo\\n *  2 | bar;\\n *         ^\\n *  3 | baz\\n * ```\\n * @see https://github.com/vitejs/vite/blob/96591bf9989529de839ba89958755eafe4c445ae/packages/vite/src/client/overlay.ts#L116\\n */\\nfunction formatFrameForVite(frame?: string): string {\\n\\tif (!frame) {\\n\\t\\treturn '';\\n\\t}\\n\\treturn frame\\n\\t\\t.split('\\\\n')\\n\\t\\t.map((line) => (line.match(/^\\\\s+\\\\^/) ? '   ' + line : ' ' + line.replace(':', ' | ')))\\n\\t\\t.join('\\\\n');\\n}\\n\",\"import { ModuleNode, HmrContext } from 'vite';\\nimport { Code, CompileData } from './utils/compile';\\nimport { log, logCompilerWarnings } from './utils/log';\\nimport { SvelteRequest } from './utils/id';\\nimport { VitePluginSvelteCache } from './utils/vite-plugin-svelte-cache';\\nimport { ResolvedOptions } from './utils/options';\\nimport { toRollupError } from './utils/error';\\n\\n/**\\n * Vite-specific HMR handling\\n */\\nexport async function handleHotUpdate(\\n\\tcompileSvelte: Function,\\n\\tctx: HmrContext,\\n\\tsvelteRequest: SvelteRequest,\\n\\tcache: VitePluginSvelteCache,\\n\\toptions: ResolvedOptions\\n): Promise<ModuleNode[] | void> {\\n\\tif (!cache.has(svelteRequest)) {\\n\\t\\t// file hasn't been requested yet (e.g. async component)\\n\\t\\tlog.debug(`handleHotUpdate called before initial transform for ${svelteRequest.id}`);\\n\\t\\treturn;\\n\\t}\\n\\tconst { read, server, modules } = ctx;\\n\\n\\tconst cachedJS = cache.getJS(svelteRequest);\\n\\tconst cachedCss = cache.getCSS(svelteRequest);\\n\\n\\tconst content = await read();\\n\\tlet compileData: CompileData;\\n\\ttry {\\n\\t\\tcompileData = await compileSvelte(svelteRequest, content, options);\\n\\t\\tcache.update(compileData);\\n\\t} catch (e) {\\n\\t\\tcache.setError(svelteRequest, e);\\n\\t\\tthrow toRollupError(e, options);\\n\\t}\\n\\n\\tconst affectedModules = [...modules];\\n\\n\\tconst cssIdx = modules.findIndex((m) => m.id === svelteRequest.cssId);\\n\\tif (cssIdx > -1) {\\n\\t\\tconst cssUpdated = cssChanged(cachedCss, compileData.compiled.css);\\n\\t\\tif (!cssUpdated) {\\n\\t\\t\\tlog.debug(`skipping unchanged css for ${svelteRequest.cssId}`);\\n\\t\\t\\taffectedModules.splice(cssIdx, 1);\\n\\t\\t}\\n\\t}\\n\\tconst jsIdx = modules.findIndex((m) => m.id === svelteRequest.id);\\n\\tif (jsIdx > -1) {\\n\\t\\tconst jsUpdated = jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);\\n\\t\\tif (!jsUpdated) {\\n\\t\\t\\tlog.debug(`skipping unchanged js for ${svelteRequest.id}`);\\n\\t\\t\\taffectedModules.splice(jsIdx, 1);\\n\\t\\t\\t// transform won't be called, log warnings here\\n\\t\\t\\tlogCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\\n\\t\\t}\\n\\t}\\n\\n\\t// TODO is this enough? see also: https://github.com/vitejs/vite/issues/2274\\n\\tconst ssrModulesToInvalidate = affectedModules.filter((m) => !!m.ssrTransformResult);\\n\\tif (ssrModulesToInvalidate.length > 0) {\\n\\t\\tlog.debug(`invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(', ')}`);\\n\\t\\tssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));\\n\\t}\\n\\tif (affectedModules.length > 0) {\\n\\t\\tlog.debug(\\n\\t\\t\\t`handleHotUpdate for ${svelteRequest.id} result: ${affectedModules\\n\\t\\t\\t\\t.map((m) => m.id)\\n\\t\\t\\t\\t.join(', ')}`\\n\\t\\t);\\n\\t}\\n\\treturn affectedModules;\\n}\\n\\nfunction cssChanged(prev?: Code, next?: Code): boolean {\\n\\treturn !isCodeEqual(prev?.code, next?.code);\\n}\\n\\nfunction jsChanged(prev?: Code, next?: Code, filename?: string): boolean {\\n\\tconst prevJs = prev?.code;\\n\\tconst nextJs = next?.code;\\n\\tconst isStrictEqual = isCodeEqual(prevJs, nextJs);\\n\\tif (isStrictEqual) {\\n\\t\\treturn false;\\n\\t}\\n\\tconst isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));\\n\\tif (!isStrictEqual && isLooseEqual) {\\n\\t\\tlog.warn(\\n\\t\\t\\t`ignoring compiler output js change for ${filename} as it is equal to previous output after normalization`\\n\\t\\t);\\n\\t}\\n\\treturn !isLooseEqual;\\n}\\n\\nfunction isCodeEqual(prev?: string, next?: string): boolean {\\n\\tif (!prev && !next) {\\n\\t\\treturn true;\\n\\t}\\n\\tif ((!prev && next) || (prev && !next)) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn prev === next;\\n}\\n\\n/**\\n * remove code that only changes metadata and does not require a js update for the component to keep working\\n *\\n * 1) add_location() calls. These add location metadata to elements, only used by some dev tools\\n * 2) ... maybe more (or less) in the future\\n * @param code\\n */\\nfunction normalizeJsCode(code?: string): string | undefined {\\n\\tif (!code) {\\n\\t\\treturn code;\\n\\t}\\n\\treturn code.replace(/\\\\s*\\\\badd_location\\\\s*\\\\([^)]*\\\\)\\\\s*;?/g, '');\\n}\\n\",\"import { CompileOptions, ResolvedOptions } from './options';\\nimport { compile, preprocess, walk } from 'svelte/compiler';\\n// @ts-ignore\\nimport { createMakeHot } from 'svelte-hmr';\\nimport { SvelteRequest } from './id';\\nimport { safeBase64Hash } from './hash';\\nimport { log } from './log';\\nimport { StatCollection } from './vite-plugin-svelte-stats';\\n//eslint-disable-next-line node/no-missing-import\\nimport type { Processed } from 'svelte/types/compiler/preprocess';\\nimport { createInjectScopeEverythingRulePreprocessorGroup } from './preprocess';\\nimport { mapSourcesToRelative } from './sourcemaps';\\n\\nconst scriptLangRE = /<script [^>]*lang=[\\\"']?([^\\\"' >]+)[\\\"']?[^>]*>/;\\n\\nexport type CompileSvelte = ReturnType<typeof _createCompileSvelte>;\\n\\nconst _createCompileSvelte = (makeHot: Function) => {\\n\\tlet stats: StatCollection | undefined;\\n\\tconst devStylePreprocessor = createInjectScopeEverythingRulePreprocessorGroup();\\n\\treturn async function compileSvelte(\\n\\t\\tsvelteRequest: SvelteRequest,\\n\\t\\tcode: string,\\n\\t\\toptions: Partial<ResolvedOptions>\\n\\t): Promise<CompileData> {\\n\\t\\tconst { filename, normalizedFilename, cssId, ssr, raw } = svelteRequest;\\n\\t\\tconst { emitCss = true } = options;\\n\\t\\tconst dependencies = [];\\n\\n\\t\\tif (options.stats) {\\n\\t\\t\\tif (options.isBuild) {\\n\\t\\t\\t\\tif (!stats) {\\n\\t\\t\\t\\t\\t// build is either completely ssr or csr, create stats collector on first compile\\n\\t\\t\\t\\t\\t// it is then finished in the buildEnd hook.\\n\\t\\t\\t\\t\\tstats = options.stats.startCollection(`${ssr ? 'ssr' : 'dom'} compile`, {\\n\\t\\t\\t\\t\\t\\tlogInProgress: () => false\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// dev time ssr, it's a ssr request and there are no stats, assume new page load and start collecting\\n\\t\\t\\t\\tif (ssr && !stats) {\\n\\t\\t\\t\\t\\tstats = options.stats.startCollection('ssr compile');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// stats are being collected but this isn't an ssr request, assume page loaded and stop collecting\\n\\t\\t\\t\\tif (!ssr && stats) {\\n\\t\\t\\t\\t\\tstats.finish();\\n\\t\\t\\t\\t\\tstats = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// TODO find a way to trace dom compile during dev\\n\\t\\t\\t\\t// problem: we need to call finish at some point but have no way to tell if page load finished\\n\\t\\t\\t\\t// also they for hmr updates too\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst compileOptions: CompileOptions = {\\n\\t\\t\\t...options.compilerOptions,\\n\\t\\t\\tfilename: normalizedFilename, // use normalized here to avoid bleeding absolute fs path\\n\\t\\t\\tgenerate: ssr ? 'ssr' : 'dom',\\n\\t\\t\\tformat: 'esm'\\n\\t\\t};\\n\\t\\tif (options.hot && options.emitCss) {\\n\\t\\t\\tconst hash = `s-${safeBase64Hash(normalizedFilename)}`;\\n\\t\\t\\tlog.debug(`setting cssHash ${hash} for ${normalizedFilename}`);\\n\\t\\t\\tcompileOptions.cssHash = () => hash;\\n\\t\\t}\\n\\t\\tif (ssr && compileOptions.enableSourcemap !== false) {\\n\\t\\t\\tif (typeof compileOptions.enableSourcemap === 'object') {\\n\\t\\t\\t\\tcompileOptions.enableSourcemap.css = false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcompileOptions.enableSourcemap = { js: true, css: false };\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet preprocessed;\\n\\t\\tlet preprocessors = options.preprocess;\\n\\t\\tif (!options.isBuild && options.emitCss && options.hot) {\\n\\t\\t\\t// inject preprocessor that ensures css hmr works better\\n\\t\\t\\tif (!Array.isArray(preprocessors)) {\\n\\t\\t\\t\\tpreprocessors = preprocessors\\n\\t\\t\\t\\t\\t? [preprocessors, devStylePreprocessor]\\n\\t\\t\\t\\t\\t: [devStylePreprocessor];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpreprocessors = preprocessors.concat(devStylePreprocessor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (preprocessors) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tpreprocessed = await preprocess(code, preprocessors, { filename }); // full filename here so postcss works\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\te.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ''}`;\\n\\t\\t\\t\\tthrow e;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (preprocessed.dependencies) dependencies.push(...preprocessed.dependencies);\\n\\t\\t\\tif (preprocessed.map) compileOptions.sourcemap = preprocessed.map;\\n\\t\\t}\\n\\t\\tif (typeof preprocessed?.map === 'object') {\\n\\t\\t\\tmapSourcesToRelative(preprocessed?.map, filename);\\n\\t\\t}\\n\\t\\tif (raw && svelteRequest.query.type === 'preprocessed') {\\n\\t\\t\\t// shortcut\\n\\t\\t\\treturn { preprocessed: preprocessed ?? { code } } as CompileData;\\n\\t\\t}\\n\\t\\tconst finalCode = preprocessed ? preprocessed.code : code;\\n\\t\\tconst dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\\n\\t\\t\\tfilename,\\n\\t\\t\\tcode: finalCode,\\n\\t\\t\\tcompileOptions\\n\\t\\t});\\n\\t\\tif (dynamicCompileOptions && log.debug.enabled) {\\n\\t\\t\\tlog.debug(\\n\\t\\t\\t\\t`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tconst finalCompileOptions = dynamicCompileOptions\\n\\t\\t\\t? {\\n\\t\\t\\t\\t\\t...compileOptions,\\n\\t\\t\\t\\t\\t...dynamicCompileOptions\\n\\t\\t\\t  }\\n\\t\\t\\t: compileOptions;\\n\\n\\t\\tconst endStat = stats?.start(filename);\\n\\t\\tconst compiled = compile(finalCode, finalCompileOptions);\\n\\t\\tif (endStat) {\\n\\t\\t\\tendStat();\\n\\t\\t}\\n\\t\\tmapSourcesToRelative(compiled.js?.map, filename);\\n\\t\\tmapSourcesToRelative(compiled.css?.map, filename);\\n\\t\\tif (!raw) {\\n\\t\\t\\t// wire css import and code for hmr\\n\\t\\t\\tconst hasCss = compiled.css?.code?.trim().length > 0;\\n\\t\\t\\t// compiler might not emit css with mode none or it may be empty\\n\\t\\t\\tif (emitCss && hasCss) {\\n\\t\\t\\t\\t// TODO properly update sourcemap?\\n\\t\\t\\t\\tcompiled.js.code += `\\\\nimport ${JSON.stringify(cssId)};\\\\n`;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// only apply hmr when not in ssr context and hot options are set\\n\\t\\t\\tif (!ssr && makeHot) {\\n\\t\\t\\t\\tcompiled.js.code = makeHot({\\n\\t\\t\\t\\t\\tid: filename,\\n\\t\\t\\t\\t\\tcompiledCode: compiled.js.code,\\n\\t\\t\\t\\t\\t//@ts-expect-error hot isn't a boolean at this point\\n\\t\\t\\t\\t\\thotOptions: { ...options.hot, injectCss: options.hot?.injectCss === true && hasCss },\\n\\t\\t\\t\\t\\tcompiled,\\n\\t\\t\\t\\t\\toriginalCode: code,\\n\\t\\t\\t\\t\\tcompileOptions: finalCompileOptions\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcompiled.js.dependencies = dependencies;\\n\\n\\t\\treturn {\\n\\t\\t\\tfilename,\\n\\t\\t\\tnormalizedFilename,\\n\\t\\t\\tlang: code.match(scriptLangRE)?.[1] || 'js',\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tcompiled,\\n\\t\\t\\tssr,\\n\\t\\t\\tdependencies,\\n\\t\\t\\tpreprocessed: preprocessed ?? { code }\\n\\t\\t};\\n\\t};\\n};\\nfunction buildMakeHot(options: ResolvedOptions) {\\n\\tconst needsMakeHot = options.hot !== false && options.isServe && !options.isProduction;\\n\\tif (needsMakeHot) {\\n\\t\\t// @ts-ignore\\n\\t\\tconst hotApi = options?.hot?.hotApi;\\n\\t\\t// @ts-ignore\\n\\t\\tconst adapter = options?.hot?.adapter;\\n\\t\\treturn createMakeHot({\\n\\t\\t\\twalk,\\n\\t\\t\\thotApi,\\n\\t\\t\\tadapter,\\n\\t\\t\\thotOptions: { noOverlay: true, ...(options.hot as object) }\\n\\t\\t});\\n\\t}\\n}\\n\\nexport function createCompileSvelte(options: ResolvedOptions) {\\n\\tconst makeHot = buildMakeHot(options);\\n\\treturn _createCompileSvelte(makeHot);\\n}\\n\\nexport interface Code {\\n\\tcode: string;\\n\\tmap?: any;\\n\\tdependencies?: any[];\\n}\\n\\nexport interface Compiled {\\n\\tjs: Code;\\n\\tcss: Code;\\n\\tast: any; // TODO type\\n\\twarnings: any[]; // TODO type\\n\\tvars: {\\n\\t\\tname: string;\\n\\t\\texport_name: string;\\n\\t\\tinjected: boolean;\\n\\t\\tmodule: boolean;\\n\\t\\tmutated: boolean;\\n\\t\\treassigned: boolean;\\n\\t\\treferenced: boolean;\\n\\t\\twritable: boolean;\\n\\t\\treferenced_from_script: boolean;\\n\\t}[];\\n\\tstats: {\\n\\t\\ttimings: {\\n\\t\\t\\ttotal: number;\\n\\t\\t};\\n\\t};\\n}\\n\\nexport interface CompileData {\\n\\tfilename: string;\\n\\tnormalizedFilename: string;\\n\\tlang: string;\\n\\tcompiled: Compiled;\\n\\tssr: boolean | undefined;\\n\\tdependencies: string[];\\n\\tpreprocessed: Processed;\\n}\\n\",\"import * as crypto from 'crypto';\\n\\nconst hashes = Object.create(null);\\n\\n//TODO shorter?\\nconst hash_length = 12;\\n\\nexport function safeBase64Hash(input: string) {\\n\\tif (hashes[input]) {\\n\\t\\treturn hashes[input];\\n\\t}\\n\\t//TODO if performance really matters, use a faster one like xx-hash etc.\\n\\t// should be evenly distributed because short input length and similarities in paths could cause collisions otherwise\\n\\t// OR DON'T USE A HASH AT ALL, what about a simple counter?\\n\\tconst md5 = crypto.createHash('md5');\\n\\tmd5.update(input);\\n\\tconst hash = toSafe(md5.digest('base64')).slice(0, hash_length);\\n\\thashes[input] = hash;\\n\\treturn hash;\\n}\\n\\nconst replacements: { [key: string]: string } = {\\n\\t'+': '-',\\n\\t'/': '_',\\n\\t'=': ''\\n};\\n\\nconst replaceRE = new RegExp(`[${Object.keys(replacements).join('')}]`, 'g');\\n\\nfunction toSafe(base64: string) {\\n\\treturn base64.replace(replaceRE, (x) => replacements[x]);\\n}\\n\",\"import type { ResolvedConfig, Plugin } from 'vite';\\nimport MagicString from 'magic-string';\\nimport { PreprocessorGroup, ResolvedOptions } from './options';\\nimport { log } from './log';\\nimport path from 'path';\\n\\n/**\\n * this appends a *{} rule to component styles to force the svelte compiler to add style classes to all nodes\\n * That means adding/removing class rules from <style> node won't trigger js updates as the scope classes are not changed\\n *\\n * only used during dev with enabled css hmr\\n */\\nexport function createInjectScopeEverythingRulePreprocessorGroup(): PreprocessorGroup {\\n\\treturn {\\n\\t\\tstyle({ content, filename }) {\\n\\t\\t\\tconst s = new MagicString(content);\\n\\t\\t\\ts.append(' *{}');\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tcode: s.toString(),\\n\\t\\t\\t\\tmap: s.generateDecodedMap({\\n\\t\\t\\t\\t\\tsource: filename ? path.basename(filename) : undefined,\\n\\t\\t\\t\\t\\thires: true\\n\\t\\t\\t\\t})\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction buildExtraPreprocessors(options: ResolvedOptions, config: ResolvedConfig) {\\n\\tconst prependPreprocessors: PreprocessorGroup[] = [];\\n\\tconst appendPreprocessors: PreprocessorGroup[] = [];\\n\\n\\t// @ts-ignore\\n\\tconst pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p?.sveltePreprocess);\\n\\tif (pluginsWithPreprocessorsDeprecated.length > 0) {\\n\\t\\tlog.warn(\\n\\t\\t\\t`The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated\\n\\t\\t\\t\\t.map((p) => p.name)\\n\\t\\t\\t\\t.join(', ')}`\\n\\t\\t);\\n\\t\\t// patch plugin to avoid breaking\\n\\t\\tpluginsWithPreprocessorsDeprecated.forEach((p) => {\\n\\t\\t\\tif (!p.api) {\\n\\t\\t\\t\\tp.api = {};\\n\\t\\t\\t}\\n\\t\\t\\tif (p.api.sveltePreprocess === undefined) {\\n\\t\\t\\t\\t// @ts-ignore\\n\\t\\t\\t\\tp.api.sveltePreprocess = p.sveltePreprocess;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlog.error(\\n\\t\\t\\t\\t\\t`ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\n\\tconst pluginsWithPreprocessors: Plugin[] = config.plugins.filter((p) => p?.api?.sveltePreprocess);\\n\\tconst ignored: Plugin[] = [],\\n\\t\\tincluded: Plugin[] = [];\\n\\tfor (const p of pluginsWithPreprocessors) {\\n\\t\\tif (\\n\\t\\t\\toptions.ignorePluginPreprocessors === true ||\\n\\t\\t\\t(Array.isArray(options.ignorePluginPreprocessors) &&\\n\\t\\t\\t\\toptions.ignorePluginPreprocessors?.includes(p.name))\\n\\t\\t) {\\n\\t\\t\\tignored.push(p);\\n\\t\\t} else {\\n\\t\\t\\tincluded.push(p);\\n\\t\\t}\\n\\t}\\n\\tif (ignored.length > 0) {\\n\\t\\tlog.debug(\\n\\t\\t\\t`Ignoring svelte preprocessors defined by these vite plugins: ${ignored\\n\\t\\t\\t\\t.map((p) => p.name)\\n\\t\\t\\t\\t.join(', ')}`\\n\\t\\t);\\n\\t}\\n\\tif (included.length > 0) {\\n\\t\\tlog.debug(\\n\\t\\t\\t`Adding svelte preprocessors defined by these vite plugins: ${included\\n\\t\\t\\t\\t.map((p) => p.name)\\n\\t\\t\\t\\t.join(', ')}`\\n\\t\\t);\\n\\t\\tappendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));\\n\\t}\\n\\n\\treturn { prependPreprocessors, appendPreprocessors };\\n}\\n\\nexport function addExtraPreprocessors(options: ResolvedOptions, config: ResolvedConfig) {\\n\\tconst { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);\\n\\tif (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {\\n\\t\\tif (!options.preprocess) {\\n\\t\\t\\toptions.preprocess = [...prependPreprocessors, ...appendPreprocessors];\\n\\t\\t} else if (Array.isArray(options.preprocess)) {\\n\\t\\t\\toptions.preprocess.unshift(...prependPreprocessors);\\n\\t\\t\\toptions.preprocess.push(...appendPreprocessors);\\n\\t\\t} else {\\n\\t\\t\\toptions.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];\\n\\t\\t}\\n\\t}\\n}\\n\",\"import path from 'path';\\n\\n/**\\n * sourcemap sources are relative to the sourcemap itself\\n * assume the sourcemap location is the same as filename and turn absolute paths to relative\\n * to avoid leaking fs information like vite root\\n */\\nexport function mapSourcesToRelative(map: { sources?: string[] }, filename: string) {\\n\\tif (map?.sources) {\\n\\t\\tmap.sources = map.sources.map((s) => {\\n\\t\\t\\tif (path.isAbsolute(s)) {\\n\\t\\t\\t\\tconst relative = path.relative(filename, s);\\n\\t\\t\\t\\t// empty string as a source is not allowed, use simple filename\\n\\t\\t\\t\\treturn relative === '' ? path.basename(filename) : relative;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n}\\n\",\"/* eslint-disable no-unused-vars */\\nimport { createFilter } from 'vite';\\nimport { Arrayable, ResolvedOptions } from './options';\\nimport { normalizePath } from 'vite';\\nimport * as fs from 'fs';\\n//eslint-disable-next-line node/no-missing-import\\nimport { CompileOptions } from 'svelte/types/compiler/interfaces';\\nimport { log } from './log';\\n\\nconst VITE_FS_PREFIX = '/@fs/';\\nconst IS_WINDOWS = process.platform === 'win32';\\n\\nconst SUPPORTED_COMPILER_OPTIONS = [\\n\\t'generate',\\n\\t'dev',\\n\\t'css',\\n\\t'hydratable',\\n\\t'customElement',\\n\\t'immutable',\\n\\t'enableSourcemap'\\n];\\nconst TYPES_WITH_COMPILER_OPTIONS = ['style', 'script', 'all'];\\n\\nexport type SvelteQueryTypes = 'style' | 'script' | 'preprocessed' | 'all';\\n\\nexport interface RequestQuery {\\n\\t// our own\\n\\tsvelte?: boolean;\\n\\ttype?: SvelteQueryTypes;\\n\\tsourcemap?: boolean;\\n\\tcompilerOptions?: Pick<\\n\\t\\tCompileOptions,\\n\\t\\t'generate' | 'dev' | 'css' | 'hydratable' | 'customElement' | 'immutable' | 'enableSourcemap'\\n\\t>;\\n\\t// vite specific\\n\\turl?: boolean;\\n\\traw?: boolean;\\n\\tdirect?: boolean;\\n}\\n\\nexport interface SvelteRequest {\\n\\tid: string;\\n\\tcssId: string;\\n\\tfilename: string;\\n\\tnormalizedFilename: string;\\n\\tquery: RequestQuery;\\n\\ttimestamp: number;\\n\\tssr: boolean;\\n\\traw: boolean;\\n}\\n\\nfunction splitId(id: string) {\\n\\tconst parts = id.split(`?`, 2);\\n\\tconst filename = parts[0];\\n\\tconst rawQuery = parts[1];\\n\\treturn { filename, rawQuery };\\n}\\n\\nfunction parseToSvelteRequest(\\n\\tid: string,\\n\\tfilename: string,\\n\\trawQuery: string,\\n\\troot: string,\\n\\ttimestamp: number,\\n\\tssr: boolean\\n): SvelteRequest | undefined {\\n\\tconst query = parseRequestQuery(rawQuery);\\n\\tconst rawOrDirect = !!(query.raw || query.direct);\\n\\tif (query.url || (!query.svelte && rawOrDirect)) {\\n\\t\\t// skip requests with special vite tags\\n\\t\\treturn;\\n\\t}\\n\\tconst raw = rawOrDirect;\\n\\tconst normalizedFilename = normalize(filename, root);\\n\\tconst cssId = createVirtualImportId(filename, root, 'style');\\n\\n\\treturn {\\n\\t\\tid,\\n\\t\\tfilename,\\n\\t\\tnormalizedFilename,\\n\\t\\tcssId,\\n\\t\\tquery,\\n\\t\\ttimestamp,\\n\\t\\tssr,\\n\\t\\traw\\n\\t};\\n}\\n\\nfunction createVirtualImportId(filename: string, root: string, type: SvelteQueryTypes) {\\n\\tconst parts = ['svelte', `type=${type}`];\\n\\tif (type === 'style') {\\n\\t\\tparts.push('lang.css');\\n\\t}\\n\\tif (existsInRoot(filename, root)) {\\n\\t\\tfilename = root + filename;\\n\\t} else if (filename.startsWith(VITE_FS_PREFIX)) {\\n\\t\\tfilename = IS_WINDOWS\\n\\t\\t\\t? filename.slice(VITE_FS_PREFIX.length) // remove /@fs/ from /@fs/C:/...\\n\\t\\t\\t: filename.slice(VITE_FS_PREFIX.length - 1); // remove /@fs from /@fs/home/user\\n\\t}\\n\\t// return same virtual id format as vite-plugin-vue eg ...App.svelte?svelte&type=style&lang.css\\n\\treturn `${filename}?${parts.join('&')}`;\\n}\\n\\nfunction parseRequestQuery(rawQuery: string): RequestQuery {\\n\\tconst query = Object.fromEntries(new URLSearchParams(rawQuery));\\n\\tfor (const key in query) {\\n\\t\\tif (query[key] === '') {\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tquery[key] = true;\\n\\t\\t}\\n\\t}\\n\\tconst compilerOptions = query.compilerOptions;\\n\\tif (compilerOptions) {\\n\\t\\tif (!((query.raw || query.direct) && TYPES_WITH_COMPILER_OPTIONS.includes(query.type))) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Invalid compilerOptions in query ${rawQuery}. CompilerOptions are only supported for raw or direct queries with type in \\\"${TYPES_WITH_COMPILER_OPTIONS.join(\\n\\t\\t\\t\\t\\t', '\\n\\t\\t\\t\\t)}\\\" e.g. '?svelte&raw&type=script&compilerOptions={\\\"generate\\\":\\\"ssr\\\",\\\"dev\\\":false}`\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\tconst parsed = JSON.parse(compilerOptions);\\n\\t\\t\\tconst invalid = Object.keys(parsed).filter(\\n\\t\\t\\t\\t(key) => !SUPPORTED_COMPILER_OPTIONS.includes(key)\\n\\t\\t\\t);\\n\\t\\t\\tif (invalid.length) {\\n\\t\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t\\t`Invalid compilerOptions in query ${rawQuery}: ${invalid.join(\\n\\t\\t\\t\\t\\t\\t', '\\n\\t\\t\\t\\t\\t)}. Supported: ${SUPPORTED_COMPILER_OPTIONS.join(', ')}`\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tquery.compilerOptions = parsed;\\n\\t\\t} catch (e) {\\n\\t\\t\\tlog.error('failed to parse request query compilerOptions', e);\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t}\\n\\n\\treturn query as RequestQuery;\\n}\\n\\n/**\\n * posixify and remove root at start\\n *\\n * @param filename\\n * @param normalizedRoot\\n */\\nfunction normalize(filename: string, normalizedRoot: string) {\\n\\treturn stripRoot(normalizePath(filename), normalizedRoot);\\n}\\n\\nfunction existsInRoot(filename: string, root: string) {\\n\\tif (filename.startsWith(VITE_FS_PREFIX)) {\\n\\t\\treturn false; // vite already tagged it as out of root\\n\\t}\\n\\treturn fs.existsSync(root + filename);\\n}\\n\\nfunction stripRoot(normalizedFilename: string, normalizedRoot: string) {\\n\\treturn normalizedFilename.startsWith(normalizedRoot + '/')\\n\\t\\t? normalizedFilename.slice(normalizedRoot.length)\\n\\t\\t: normalizedFilename;\\n}\\n\\nfunction buildFilter(\\n\\tinclude: Arrayable<string> | undefined,\\n\\texclude: Arrayable<string> | undefined,\\n\\textensions: string[]\\n): (filename: string) => boolean {\\n\\tconst rollupFilter = createFilter(include, exclude);\\n\\treturn (filename) => rollupFilter(filename) && extensions.some((ext) => filename.endsWith(ext));\\n}\\n\\nexport type IdParser = (id: string, ssr: boolean, timestamp?: number) => SvelteRequest | undefined;\\nexport function buildIdParser(options: ResolvedOptions): IdParser {\\n\\tconst { include, exclude, extensions, root } = options;\\n\\tconst normalizedRoot = normalizePath(root);\\n\\tconst filter = buildFilter(include, exclude, extensions!);\\n\\treturn (id, ssr, timestamp = Date.now()) => {\\n\\t\\tconst { filename, rawQuery } = splitId(id);\\n\\t\\tif (filter(filename)) {\\n\\t\\t\\treturn parseToSvelteRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);\\n\\t\\t}\\n\\t};\\n}\\n\",\"/* eslint-disable no-unused-vars */\\nimport { ConfigEnv, ResolvedConfig, UserConfig, ViteDevServer, normalizePath } from 'vite';\\nimport { log } from './log';\\nimport { loadSvelteConfig } from './load-svelte-config';\\nimport {\\n\\tSVELTE_EXPORT_CONDITIONS,\\n\\tSVELTE_HMR_IMPORTS,\\n\\tSVELTE_IMPORTS,\\n\\tSVELTE_RESOLVE_MAIN_FIELDS,\\n\\tVITE_RESOLVE_MAIN_FIELDS\\n} from './constants';\\n// eslint-disable-next-line node/no-missing-import\\nimport type { CompileOptions, Warning } from 'svelte/types/compiler/interfaces';\\nimport type {\\n\\tMarkupPreprocessor,\\n\\tPreprocessor,\\n\\tPreprocessorGroup,\\n\\tProcessed\\n\\t// eslint-disable-next-line node/no-missing-import\\n} from 'svelte/types/compiler/preprocess';\\n\\nimport path from 'path';\\nimport { esbuildSveltePlugin, facadeEsbuildSveltePluginName } from './esbuild';\\nimport { addExtraPreprocessors } from './preprocess';\\nimport deepmerge from 'deepmerge';\\nimport {\\n\\tcrawlFrameworkPkgs,\\n\\tisDepExcluded,\\n\\tisDepExternaled,\\n\\tisDepIncluded,\\n\\tisDepNoExternaled\\n\\t// eslint-disable-next-line node/no-missing-import\\n} from 'vitefu';\\n\\nimport { isCommonDepWithoutSvelteField } from './dependencies';\\nimport { VitePluginSvelteStats } from './vite-plugin-svelte-stats';\\n\\nconst allowedPluginOptions = new Set([\\n\\t'include',\\n\\t'exclude',\\n\\t'emitCss',\\n\\t'hot',\\n\\t'ignorePluginPreprocessors',\\n\\t'disableDependencyReinclusion',\\n\\t'prebundleSvelteLibraries',\\n\\t'experimental'\\n]);\\n\\nconst knownRootOptions = new Set(['extensions', 'compilerOptions', 'preprocess', 'onwarn']);\\n\\nconst allowedInlineOptions = new Set([\\n\\t'configFile',\\n\\t'kit', // only for internal use by sveltekit\\n\\t...allowedPluginOptions,\\n\\t...knownRootOptions\\n]);\\n\\nexport function validateInlineOptions(inlineOptions?: Partial<Options>) {\\n\\tconst invalidKeys = Object.keys(inlineOptions || {}).filter(\\n\\t\\t(key) => !allowedInlineOptions.has(key)\\n\\t);\\n\\tif (invalidKeys.length) {\\n\\t\\tlog.warn(`invalid plugin options \\\"${invalidKeys.join(', ')}\\\" in inline config`, inlineOptions);\\n\\t}\\n}\\n\\nfunction convertPluginOptions(config?: Partial<SvelteOptions>): Partial<Options> | undefined {\\n\\tif (!config) {\\n\\t\\treturn;\\n\\t}\\n\\tconst invalidRootOptions = Object.keys(config).filter((key) => allowedPluginOptions.has(key));\\n\\tif (invalidRootOptions.length > 0) {\\n\\t\\tthrow new Error(\\n\\t\\t\\t`Invalid options in svelte config. Move the following options into 'vitePlugin:{...}': ${invalidRootOptions.join(\\n\\t\\t\\t\\t', '\\n\\t\\t\\t)}`\\n\\t\\t);\\n\\t}\\n\\tif (!config.vitePlugin) {\\n\\t\\treturn config;\\n\\t}\\n\\tconst pluginOptions = config.vitePlugin;\\n\\tconst pluginOptionKeys = Object.keys(pluginOptions);\\n\\n\\tconst rootOptionsInPluginOptions = pluginOptionKeys.filter((key) => knownRootOptions.has(key));\\n\\tif (rootOptionsInPluginOptions.length > 0) {\\n\\t\\tthrow new Error(\\n\\t\\t\\t`Invalid options in svelte config under vitePlugin:{...}', move them to the config root : ${rootOptionsInPluginOptions.join(\\n\\t\\t\\t\\t', '\\n\\t\\t\\t)}`\\n\\t\\t);\\n\\t}\\n\\tconst duplicateOptions = pluginOptionKeys.filter((key) =>\\n\\t\\tObject.prototype.hasOwnProperty.call(config, key)\\n\\t);\\n\\tif (duplicateOptions.length > 0) {\\n\\t\\tthrow new Error(\\n\\t\\t\\t`Invalid duplicate options in svelte config under vitePlugin:{...}', they are defined in root too and must only exist once: ${duplicateOptions.join(\\n\\t\\t\\t\\t', '\\n\\t\\t\\t)}`\\n\\t\\t);\\n\\t}\\n\\tconst unknownPluginOptions = pluginOptionKeys.filter((key) => !allowedPluginOptions.has(key));\\n\\tif (unknownPluginOptions.length > 0) {\\n\\t\\tlog.warn(\\n\\t\\t\\t`ignoring unknown plugin options in svelte config under vitePlugin:{...}: ${unknownPluginOptions.join(\\n\\t\\t\\t\\t', '\\n\\t\\t\\t)}`\\n\\t\\t);\\n\\t\\tunknownPluginOptions.forEach((unkownOption) => {\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tdelete pluginOptions[unkownOption];\\n\\t\\t});\\n\\t}\\n\\n\\tconst result: Options = {\\n\\t\\t...config,\\n\\t\\t...pluginOptions\\n\\t};\\n\\t// @ts-expect-error it exists\\n\\tdelete result.vitePlugin;\\n\\n\\treturn result;\\n}\\n\\n// used in config phase, merges the default options, svelte config, and inline options\\nexport async function preResolveOptions(\\n\\tinlineOptions: Partial<Options> = {},\\n\\tviteUserConfig: UserConfig,\\n\\tviteEnv: ConfigEnv\\n): Promise<PreResolvedOptions> {\\n\\tconst viteConfigWithResolvedRoot: UserConfig = {\\n\\t\\t...viteUserConfig,\\n\\t\\troot: resolveViteRoot(viteUserConfig)\\n\\t};\\n\\tconst isBuild = viteEnv.command === 'build';\\n\\tconst defaultOptions: Partial<Options> = {\\n\\t\\textensions: ['.svelte'],\\n\\t\\temitCss: true,\\n\\t\\tprebundleSvelteLibraries: !isBuild\\n\\t};\\n\\tconst svelteConfig = convertPluginOptions(\\n\\t\\tawait loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions)\\n\\t);\\n\\n\\tconst extraOptions: Partial<PreResolvedOptions> = {\\n\\t\\troot: viteConfigWithResolvedRoot.root!,\\n\\t\\tisBuild,\\n\\t\\tisServe: viteEnv.command === 'serve',\\n\\t\\tisDebug: process.env.DEBUG != null\\n\\t};\\n\\tconst merged = mergeConfigs<PreResolvedOptions>(\\n\\t\\tdefaultOptions,\\n\\t\\tsvelteConfig,\\n\\t\\tinlineOptions,\\n\\t\\textraOptions\\n\\t);\\n\\t// configFile of svelteConfig contains the absolute path it was loaded from,\\n\\t// prefer it over the possibly relative inline path\\n\\tif (svelteConfig?.configFile) {\\n\\t\\tmerged.configFile = svelteConfig.configFile;\\n\\t}\\n\\treturn merged;\\n}\\n\\nfunction mergeConfigs<T>(...configs: (Partial<T> | undefined)[]): T {\\n\\tlet result: Partial<T> = {};\\n\\tfor (const config of configs.filter((x) => x != null)) {\\n\\t\\tresult = deepmerge<T>(result, config!, {\\n\\t\\t\\t// replace arrays\\n\\t\\t\\tarrayMerge: (target: any[], source: any[]) => source ?? target\\n\\t\\t});\\n\\t}\\n\\treturn result as T;\\n}\\n\\n// used in configResolved phase, merges a contextual default config, pre-resolved options, and some preprocessors.\\n// also validates the final config.\\nexport function resolveOptions(\\n\\tpreResolveOptions: PreResolvedOptions,\\n\\tviteConfig: ResolvedConfig\\n): ResolvedOptions {\\n\\tconst css = preResolveOptions.emitCss ? 'external' : 'injected';\\n\\tconst defaultOptions: Partial<Options> = {\\n\\t\\thot: viteConfig.isProduction\\n\\t\\t\\t? false\\n\\t\\t\\t: {\\n\\t\\t\\t\\t\\tinjectCss: css === 'injected',\\n\\t\\t\\t\\t\\tpartialAccept: !!viteConfig.experimental?.hmrPartialAccept\\n\\t\\t\\t  },\\n\\t\\tcompilerOptions: {\\n\\t\\t\\tcss,\\n\\t\\t\\tdev: !viteConfig.isProduction\\n\\t\\t}\\n\\t};\\n\\tconst extraOptions: Partial<ResolvedOptions> = {\\n\\t\\troot: viteConfig.root,\\n\\t\\tisProduction: viteConfig.isProduction\\n\\t};\\n\\tconst merged = mergeConfigs<ResolvedOptions>(defaultOptions, preResolveOptions, extraOptions);\\n\\n\\tremoveIgnoredOptions(merged);\\n\\thandleDeprecatedOptions(merged);\\n\\taddSvelteKitOptions(merged);\\n\\taddExtraPreprocessors(merged, viteConfig);\\n\\tenforceOptionsForHmr(merged);\\n\\tenforceOptionsForProduction(merged);\\n\\t// mergeConfigs would mangle functions on the stats class, so do this afterwards\\n\\tconst isLogLevelInfo = [undefined, 'info'].includes(viteConfig.logLevel);\\n\\tconst disableCompileStats = merged.experimental?.disableCompileStats;\\n\\tconst statsEnabled =\\n\\t\\tdisableCompileStats !== true && disableCompileStats !== (merged.isBuild ? 'build' : 'dev');\\n\\tif (statsEnabled && isLogLevelInfo) {\\n\\t\\tmerged.stats = new VitePluginSvelteStats();\\n\\t}\\n\\treturn merged;\\n}\\n\\nfunction enforceOptionsForHmr(options: ResolvedOptions) {\\n\\tif (options.hot) {\\n\\t\\tif (!options.compilerOptions.dev) {\\n\\t\\t\\tlog.warn('hmr is enabled but compilerOptions.dev is false, forcing it to true');\\n\\t\\t\\toptions.compilerOptions.dev = true;\\n\\t\\t}\\n\\t\\tif (options.emitCss) {\\n\\t\\t\\tif (options.hot !== true && options.hot.injectCss) {\\n\\t\\t\\t\\tlog.warn('hmr and emitCss are enabled but hot.injectCss is true, forcing it to false');\\n\\t\\t\\t\\toptions.hot.injectCss = false;\\n\\t\\t\\t}\\n\\t\\t\\tconst css = options.compilerOptions.css;\\n\\t\\t\\tif (css === true || css === 'injected') {\\n\\t\\t\\t\\tconst forcedCss = 'external';\\n\\t\\t\\t\\tlog.warn(\\n\\t\\t\\t\\t\\t`hmr and emitCss are enabled but compilerOptions.css is ${css}, forcing it to ${forcedCss}`\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\toptions.compilerOptions.css = forcedCss;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (options.hot === true || !options.hot.injectCss) {\\n\\t\\t\\t\\tlog.warn(\\n\\t\\t\\t\\t\\t'hmr with emitCss disabled requires option hot.injectCss to be enabled, forcing it to true'\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tif (options.hot === true) {\\n\\t\\t\\t\\t\\toptions.hot = { injectCss: true };\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\toptions.hot.injectCss = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tconst css = options.compilerOptions.css;\\n\\t\\t\\tif (!(css === true || css === 'injected')) {\\n\\t\\t\\t\\tconst forcedCss = 'injected';\\n\\t\\t\\t\\tlog.warn(\\n\\t\\t\\t\\t\\t`hmr with emitCss disabled requires compilerOptions.css to be enabled, forcing it to ${forcedCss}`\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\toptions.compilerOptions.css = forcedCss;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction enforceOptionsForProduction(options: ResolvedOptions) {\\n\\tif (options.isProduction) {\\n\\t\\tif (options.hot) {\\n\\t\\t\\tlog.warn('options.hot is enabled but does not work on production build, forcing it to false');\\n\\t\\t\\toptions.hot = false;\\n\\t\\t}\\n\\t\\tif (options.compilerOptions.dev) {\\n\\t\\t\\tlog.warn(\\n\\t\\t\\t\\t'you are building for production but compilerOptions.dev is true, forcing it to false'\\n\\t\\t\\t);\\n\\t\\t\\toptions.compilerOptions.dev = false;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction removeIgnoredOptions(options: ResolvedOptions) {\\n\\tconst ignoredCompilerOptions = ['generate', 'format', 'filename'];\\n\\tif (options.hot && options.emitCss) {\\n\\t\\tignoredCompilerOptions.push('cssHash');\\n\\t}\\n\\tconst passedCompilerOptions = Object.keys(options.compilerOptions || {});\\n\\tconst passedIgnored = passedCompilerOptions.filter((o) => ignoredCompilerOptions.includes(o));\\n\\tif (passedIgnored.length) {\\n\\t\\tlog.warn(\\n\\t\\t\\t`The following Svelte compilerOptions are controlled by vite-plugin-svelte and essential to its functionality. User-specified values are ignored. Please remove them from your configuration: ${passedIgnored.join(\\n\\t\\t\\t\\t', '\\n\\t\\t\\t)}`\\n\\t\\t);\\n\\t\\tpassedIgnored.forEach((ignored) => {\\n\\t\\t\\t// @ts-expect-error string access\\n\\t\\t\\tdelete options.compilerOptions[ignored];\\n\\t\\t});\\n\\t}\\n}\\n\\n// some SvelteKit options need compilerOptions to work, so set them here.\\nfunction addSvelteKitOptions(options: ResolvedOptions) {\\n\\t// @ts-expect-error kit is not typed to avoid dependency on sveltekit\\n\\tif (options?.kit != null && options.compilerOptions.hydratable == null) {\\n\\t\\tlog.debug(`Setting compilerOptions.hydratable = true for SvelteKit`);\\n\\t\\toptions.compilerOptions.hydratable = true;\\n\\t}\\n}\\n\\nfunction handleDeprecatedOptions(options: ResolvedOptions) {\\n\\tif ((options.experimental as any)?.prebundleSvelteLibraries) {\\n\\t\\toptions.prebundleSvelteLibraries = (options.experimental as any)?.prebundleSvelteLibraries;\\n\\t\\tlog.warn(\\n\\t\\t\\t'experimental.prebundleSvelteLibraries is no longer experimental and has moved to prebundleSvelteLibraries'\\n\\t\\t);\\n\\t}\\n\\tif ((options.experimental as any)?.generateMissingPreprocessorSourcemaps) {\\n\\t\\tlog.warn('experimental.generateMissingPreprocessorSourcemaps has been removed.');\\n\\t}\\n}\\n\\n// vite passes unresolved `root`option to config hook but we need the resolved value, so do it here\\n// https://github.com/sveltejs/vite-plugin-svelte/issues/113\\n// https://github.com/vitejs/vite/blob/43c957de8a99bb326afd732c962f42127b0a4d1e/packages/vite/src/node/config.ts#L293\\nfunction resolveViteRoot(viteConfig: UserConfig): string | undefined {\\n\\treturn normalizePath(viteConfig.root ? path.resolve(viteConfig.root) : process.cwd());\\n}\\n\\nexport async function buildExtraViteConfig(\\n\\toptions: PreResolvedOptions,\\n\\tconfig: UserConfig\\n): Promise<Partial<UserConfig>> {\\n\\t// make sure we only readd vite default mainFields when no other plugin has changed the config already\\n\\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/581\\n\\tif (!config.resolve) {\\n\\t\\tconfig.resolve = {};\\n\\t}\\n\\tconfig.resolve.mainFields = [\\n\\t\\t...SVELTE_RESOLVE_MAIN_FIELDS,\\n\\t\\t...(config.resolve.mainFields ?? VITE_RESOLVE_MAIN_FIELDS)\\n\\t];\\n\\n\\tconst extraViteConfig: Partial<UserConfig> = {\\n\\t\\tresolve: {\\n\\t\\t\\tdedupe: [...SVELTE_IMPORTS, ...SVELTE_HMR_IMPORTS],\\n\\t\\t\\tconditions: [...SVELTE_EXPORT_CONDITIONS]\\n\\t\\t}\\n\\t\\t// this option is still awaiting a PR in vite to be supported\\n\\t\\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/60\\n\\t\\t// @ts-ignore\\n\\t\\t// knownJsSrcExtensions: options.extensions\\n\\t};\\n\\n\\tconst extraSvelteConfig = buildExtraConfigForSvelte(config);\\n\\tconst extraDepsConfig = await buildExtraConfigForDependencies(options, config);\\n\\t// merge extra svelte and deps config, but make sure dep values are not contradicting svelte\\n\\textraViteConfig.optimizeDeps = {\\n\\t\\tinclude: [\\n\\t\\t\\t...extraSvelteConfig.optimizeDeps.include,\\n\\t\\t\\t...extraDepsConfig.optimizeDeps.include.filter(\\n\\t\\t\\t\\t(dep) => !isDepExcluded(dep, extraSvelteConfig.optimizeDeps.exclude)\\n\\t\\t\\t)\\n\\t\\t],\\n\\t\\texclude: [\\n\\t\\t\\t...extraSvelteConfig.optimizeDeps.exclude,\\n\\t\\t\\t...extraDepsConfig.optimizeDeps.exclude.filter(\\n\\t\\t\\t\\t(dep) => !isDepIncluded(dep, extraSvelteConfig.optimizeDeps.include)\\n\\t\\t\\t)\\n\\t\\t]\\n\\t};\\n\\n\\textraViteConfig.ssr = {\\n\\t\\texternal: [\\n\\t\\t\\t...extraSvelteConfig.ssr.external,\\n\\t\\t\\t...extraDepsConfig.ssr.external.filter(\\n\\t\\t\\t\\t(dep) => !isDepNoExternaled(dep, extraSvelteConfig.ssr.noExternal)\\n\\t\\t\\t)\\n\\t\\t],\\n\\t\\tnoExternal: [\\n\\t\\t\\t...extraSvelteConfig.ssr.noExternal,\\n\\t\\t\\t...extraDepsConfig.ssr.noExternal.filter(\\n\\t\\t\\t\\t(dep) => !isDepExternaled(dep, extraSvelteConfig.ssr.external)\\n\\t\\t\\t)\\n\\t\\t]\\n\\t};\\n\\n\\t// handle prebundling for svelte files\\n\\tif (options.prebundleSvelteLibraries) {\\n\\t\\textraViteConfig.optimizeDeps = {\\n\\t\\t\\t...extraViteConfig.optimizeDeps,\\n\\t\\t\\t// Experimental Vite API to allow these extensions to be scanned and prebundled\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\textensions: options.extensions ?? ['.svelte'],\\n\\t\\t\\t// Add esbuild plugin to prebundle Svelte files.\\n\\t\\t\\t// Currently a placeholder as more information is needed after Vite config is resolved,\\n\\t\\t\\t// the real Svelte plugin is added in `patchResolvedViteConfig()`\\n\\t\\t\\tesbuildOptions: {\\n\\t\\t\\t\\tplugins: [{ name: facadeEsbuildSveltePluginName, setup: () => {} }]\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// enable hmrPartialAccept if not explicitly disabled\\n\\tif (\\n\\t\\t(options.hot == null ||\\n\\t\\t\\toptions.hot === true ||\\n\\t\\t\\t(options.hot && options.hot.partialAccept !== false)) && // deviate from svelte-hmr, default to true\\n\\t\\tconfig.experimental?.hmrPartialAccept !== false\\n\\t) {\\n\\t\\tlog.debug('enabling \\\"experimental.hmrPartialAccept\\\" in vite config');\\n\\t\\textraViteConfig.experimental = { hmrPartialAccept: true };\\n\\t}\\n\\tvalidateViteConfig(extraViteConfig, config, options);\\n\\treturn extraViteConfig;\\n}\\n\\nfunction validateViteConfig(\\n\\textraViteConfig: Partial<UserConfig>,\\n\\tconfig: UserConfig,\\n\\toptions: PreResolvedOptions\\n) {\\n\\tconst { prebundleSvelteLibraries, isBuild } = options;\\n\\tif (prebundleSvelteLibraries) {\\n\\t\\tconst isEnabled = (option: 'dev' | 'build' | boolean) =>\\n\\t\\t\\toption !== true && option !== (isBuild ? 'build' : 'dev');\\n\\t\\tconst logWarning = (name: string, value: 'dev' | 'build' | boolean, recommendation: string) =>\\n\\t\\t\\tlog.warn.once(\\n\\t\\t\\t\\t`Incompatible options: \\\\`prebundleSvelteLibraries: true\\\\` and vite \\\\`${name}: ${JSON.stringify(\\n\\t\\t\\t\\t\\tvalue\\n\\t\\t\\t\\t)}\\\\` ${isBuild ? 'during build.' : '.'} ${recommendation}`\\n\\t\\t\\t);\\n\\t\\tconst viteOptimizeDepsDisabled = config.optimizeDeps?.disabled ?? 'build'; // fall back to vite default\\n\\t\\tconst isOptimizeDepsEnabled = isEnabled(viteOptimizeDepsDisabled);\\n\\t\\tif (!isBuild && !isOptimizeDepsEnabled) {\\n\\t\\t\\tlogWarning(\\n\\t\\t\\t\\t'optimizeDeps.disabled',\\n\\t\\t\\t\\tviteOptimizeDepsDisabled,\\n\\t\\t\\t\\t'Forcing `optimizeDeps.disabled: \\\"build\\\"`. Disable prebundleSvelteLibraries or update your vite config to enable optimizeDeps during dev.'\\n\\t\\t\\t);\\n\\t\\t\\textraViteConfig.optimizeDeps!.disabled = 'build';\\n\\t\\t} else if (isBuild && isOptimizeDepsEnabled) {\\n\\t\\t\\tlogWarning(\\n\\t\\t\\t\\t'optimizeDeps.disabled',\\n\\t\\t\\t\\tviteOptimizeDepsDisabled,\\n\\t\\t\\t\\t'Disable optimizeDeps or prebundleSvelteLibraries for build if you experience errors.'\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n\\nasync function buildExtraConfigForDependencies(options: PreResolvedOptions, config: UserConfig) {\\n\\t// extra handling for svelte dependencies in the project\\n\\tconst depsConfig = await crawlFrameworkPkgs({\\n\\t\\troot: options.root,\\n\\t\\tisBuild: options.isBuild,\\n\\t\\tviteUserConfig: config,\\n\\t\\tisFrameworkPkgByJson(pkgJson) {\\n\\t\\t\\tlet hasSvelteCondition = false;\\n\\t\\t\\tif (typeof pkgJson.exports === 'object') {\\n\\t\\t\\t\\t// use replacer as a simple way to iterate over nested keys\\n\\t\\t\\t\\tJSON.stringify(pkgJson.exports, (key, value) => {\\n\\t\\t\\t\\t\\tif (SVELTE_EXPORT_CONDITIONS.includes(key)) {\\n\\t\\t\\t\\t\\t\\thasSvelteCondition = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn hasSvelteCondition || !!pkgJson.svelte;\\n\\t\\t},\\n\\t\\tisSemiFrameworkPkgByJson(pkgJson) {\\n\\t\\t\\treturn !!pkgJson.dependencies?.svelte || !!pkgJson.peerDependencies?.svelte;\\n\\t\\t},\\n\\t\\tisFrameworkPkgByName(pkgName) {\\n\\t\\t\\tconst isNotSveltePackage = isCommonDepWithoutSvelteField(pkgName);\\n\\t\\t\\tif (isNotSveltePackage) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\n\\tlog.debug('extra config for dependencies generated by vitefu', depsConfig);\\n\\n\\tif (options.prebundleSvelteLibraries) {\\n\\t\\t// prebundling enabled, so we don't need extra dependency excludes\\n\\t\\tdepsConfig.optimizeDeps.exclude = [];\\n\\t\\t// but keep dependency reinclusions of explicit user excludes\\n\\t\\tconst userExclude = config.optimizeDeps?.exclude;\\n\\t\\tdepsConfig.optimizeDeps.include = !userExclude\\n\\t\\t\\t? []\\n\\t\\t\\t: depsConfig.optimizeDeps.include.filter((dep: string) => {\\n\\t\\t\\t\\t\\t// reincludes look like this: foo > bar > baz\\n\\t\\t\\t\\t\\t// in case foo or bar are excluded, we have to retain the reinclude even with prebundling\\n\\t\\t\\t\\t\\treturn (\\n\\t\\t\\t\\t\\t\\tdep.includes('>') &&\\n\\t\\t\\t\\t\\t\\tdep\\n\\t\\t\\t\\t\\t\\t\\t.split('>')\\n\\t\\t\\t\\t\\t\\t\\t.slice(0, -1)\\n\\t\\t\\t\\t\\t\\t\\t.some((d) => isDepExcluded(d.trim(), userExclude))\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t  });\\n\\t}\\n\\tif (options.disableDependencyReinclusion === true) {\\n\\t\\tdepsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter(\\n\\t\\t\\t(dep) => !dep.includes('>')\\n\\t\\t);\\n\\t} else if (Array.isArray(options.disableDependencyReinclusion)) {\\n\\t\\tconst disabledDeps = options.disableDependencyReinclusion;\\n\\t\\tdepsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter((dep) => {\\n\\t\\t\\tif (!dep.includes('>')) return true;\\n\\t\\t\\tconst trimDep = dep.replace(/\\\\s+/g, '');\\n\\t\\t\\treturn disabledDeps.some((disabled) => trimDep.includes(`${disabled}>`));\\n\\t\\t});\\n\\t}\\n\\n\\tlog.debug('post-processed extra config for dependencies', depsConfig);\\n\\n\\treturn depsConfig;\\n}\\n\\nfunction buildExtraConfigForSvelte(config: UserConfig) {\\n\\t// include svelte imports for optimization unless explicitly excluded\\n\\tconst include: string[] = [];\\n\\tconst exclude: string[] = ['svelte-hmr'];\\n\\tif (!isDepExcluded('svelte', config.optimizeDeps?.exclude ?? [])) {\\n\\t\\tconst svelteImportsToInclude = SVELTE_IMPORTS.filter((x) => x !== 'svelte/ssr'); // not used on clientside\\n\\t\\tlog.debug(\\n\\t\\t\\t`adding bare svelte packages to optimizeDeps.include: ${svelteImportsToInclude.join(', ')} `\\n\\t\\t);\\n\\t\\tinclude.push(...svelteImportsToInclude);\\n\\t} else {\\n\\t\\tlog.debug('\\\"svelte\\\" is excluded in optimizeDeps.exclude, skipped adding it to include.');\\n\\t}\\n\\tconst noExternal: (string | RegExp)[] = [];\\n\\tconst external: string[] = [];\\n\\t// add svelte to ssr.noExternal unless it is present in ssr.external\\n\\t// so we can resolve it with svelte/ssr\\n\\tif (!isDepExternaled('svelte', config.ssr?.external ?? [])) {\\n\\t\\tnoExternal.push('svelte', /^svelte\\\\//);\\n\\t}\\n\\treturn { optimizeDeps: { include, exclude }, ssr: { noExternal, external } };\\n}\\n\\nexport function patchResolvedViteConfig(viteConfig: ResolvedConfig, options: ResolvedOptions) {\\n\\tif (options.preprocess) {\\n\\t\\tfor (const preprocessor of arraify(options.preprocess)) {\\n\\t\\t\\tif (preprocessor.style && '__resolvedConfig' in preprocessor.style) {\\n\\t\\t\\t\\tpreprocessor.style.__resolvedConfig = viteConfig;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// replace facade esbuild plugin with a real one\\n\\tconst facadeEsbuildSveltePlugin = viteConfig.optimizeDeps.esbuildOptions?.plugins?.find(\\n\\t\\t(plugin) => plugin.name === facadeEsbuildSveltePluginName\\n\\t);\\n\\tif (facadeEsbuildSveltePlugin) {\\n\\t\\tObject.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));\\n\\t}\\n}\\n\\nfunction arraify<T>(value: T | T[]): T[] {\\n\\treturn Array.isArray(value) ? value : [value];\\n}\\n\\nexport type Options = Omit<SvelteOptions, 'vitePlugin'> & PluginOptionsInline;\\n\\ninterface PluginOptionsInline extends PluginOptions {\\n\\t/**\\n\\t * Path to a svelte config file, either absolute or relative to Vite root\\n\\t *\\n\\t * set to `false` to ignore the svelte config file\\n\\t *\\n\\t * @see https://vitejs.dev/config/#root\\n\\t */\\n\\tconfigFile?: string | false;\\n}\\n\\nexport interface PluginOptions {\\n\\t/**\\n\\t * A `picomatch` pattern, or array of patterns, which specifies the files the plugin should\\n\\t * operate on. By default, all svelte files are included.\\n\\t *\\n\\t * @see https://github.com/micromatch/picomatch\\n\\t */\\n\\tinclude?: Arrayable<string>;\\n\\n\\t/**\\n\\t * A `picomatch` pattern, or array of patterns, which specifies the files to be ignored by the\\n\\t * plugin. By default, no files are ignored.\\n\\t *\\n\\t * @see https://github.com/micromatch/picomatch\\n\\t */\\n\\texclude?: Arrayable<string>;\\n\\n\\t/**\\n\\t * Emit Svelte styles as virtual CSS files for Vite and other plugins to process\\n\\t *\\n\\t * @default true\\n\\t */\\n\\temitCss?: boolean;\\n\\n\\t/**\\n\\t * Enable or disable Hot Module Replacement.\\n\\t *\\n\\t * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\t *\\n\\t * DO NOT CUSTOMIZE SVELTE-HMR OPTIONS UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING\\n\\t *\\n\\t *                             YOU HAVE BEEN WARNED\\n\\t *\\n\\t * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\t *\\n\\t * Set an object to pass custom options to svelte-hmr\\n\\t *\\n\\t * @see https://github.com/rixo/svelte-hmr#options\\n\\t * @default true for development, always false for production\\n\\t */\\n\\thot?: boolean | { injectCss?: boolean; partialAccept?: boolean; [key: string]: any };\\n\\n\\t/**\\n\\t * Some Vite plugins can contribute additional preprocessors by defining `api.sveltePreprocess`.\\n\\t * If you don't want to use them, set this to true to ignore them all or use an array of strings\\n\\t * with plugin names to specify which.\\n\\t *\\n\\t * @default false\\n\\t */\\n\\tignorePluginPreprocessors?: boolean | string[];\\n\\n\\t/**\\n\\t * vite-plugin-svelte automatically handles excluding svelte libraries and reinclusion of their dependencies\\n\\t * in vite.optimizeDeps.\\n\\t *\\n\\t * `disableDependencyReinclusion: true` disables all reinclusions\\n\\t * `disableDependencyReinclusion: ['foo','bar']` disables reinclusions for dependencies of foo and bar\\n\\t *\\n\\t * This should be used for hybrid packages that contain both node and browser dependencies, eg Routify\\n\\t *\\n\\t * @default false\\n\\t */\\n\\tdisableDependencyReinclusion?: boolean | string[];\\n\\n\\t/**\\n\\t * Enable support for Vite's dependency optimization to prebundle Svelte libraries.\\n\\t *\\n\\t * To disable prebundling for a specific library, add it to `optimizeDeps.exclude`.\\n\\t *\\n\\t * @default true for dev, false for build\\n\\t */\\n\\tprebundleSvelteLibraries?: boolean;\\n\\n\\t/**\\n\\t * These options are considered experimental and breaking changes to them can occur in any release\\n\\t */\\n\\texperimental?: ExperimentalOptions;\\n}\\n\\nexport interface SvelteOptions {\\n\\t/**\\n\\t * A list of file extensions to be compiled by Svelte\\n\\t *\\n\\t * @default ['.svelte']\\n\\t */\\n\\textensions?: string[];\\n\\n\\t/**\\n\\t * An array of preprocessors to transform the Svelte source code before compilation\\n\\t *\\n\\t * @see https://svelte.dev/docs#svelte_preprocess\\n\\t */\\n\\tpreprocess?: Arrayable<PreprocessorGroup>;\\n\\n\\t/**\\n\\t * The options to be passed to the Svelte compiler. A few options are set by default,\\n\\t * including `dev` and `css`. However, some options are non-configurable, like\\n\\t * `filename`, `format`, `generate`, and `cssHash` (in dev).\\n\\t *\\n\\t * @see https://svelte.dev/docs#svelte_compile\\n\\t */\\n\\tcompilerOptions?: Omit<CompileOptions, 'filename' | 'format' | 'generate'>;\\n\\n\\t/**\\n\\t * Handles warning emitted from the Svelte compiler\\n\\t */\\n\\tonwarn?: (warning: Warning, defaultHandler?: (warning: Warning) => void) => void;\\n\\n\\t/**\\n\\t * Options for vite-plugin-svelte\\n\\t */\\n\\tvitePlugin?: PluginOptions;\\n}\\n\\n/**\\n * These options are considered experimental and breaking changes to them can occur in any release\\n */\\nexport interface ExperimentalOptions {\\n\\t/**\\n\\t * A function to update `compilerOptions` before compilation\\n\\t *\\n\\t * `data.filename` - The file to be compiled\\n\\t * `data.code` - The preprocessed Svelte code\\n\\t * `data.compileOptions` - The current compiler options\\n\\t *\\n\\t * To change part of the compiler options, return an object with the changes you need.\\n\\t *\\n\\t * @example\\n\\t * ```\\n\\t * ({ filename, compileOptions }) => {\\n\\t *   // Dynamically set hydration per Svelte file\\n\\t *   if (compileWithHydratable(filename) && !compileOptions.hydratable) {\\n\\t *     return { hydratable: true };\\n\\t *   }\\n\\t * }\\n\\t * ```\\n\\t */\\n\\tdynamicCompileOptions?: (data: {\\n\\t\\tfilename: string;\\n\\t\\tcode: string;\\n\\t\\tcompileOptions: Partial<CompileOptions>;\\n\\t}) => Promise<Partial<CompileOptions> | void> | Partial<CompileOptions> | void;\\n\\n\\t/**\\n\\t * enable svelte inspector\\n\\t */\\n\\tinspector?: InspectorOptions | boolean;\\n\\n\\t/**\\n\\t * send a websocket message with svelte compiler warnings during dev\\n\\t *\\n\\t */\\n\\tsendWarningsToBrowser?: boolean;\\n\\n\\t/**\\n\\t * disable svelte compile statistics\\n\\t *\\n\\t * @default false\\n\\t */\\n\\tdisableCompileStats?: 'dev' | 'build' | boolean;\\n}\\n\\nexport interface InspectorOptions {\\n\\t/**\\n\\t * define a key combo to toggle inspector,\\n\\t * @default 'control-shift' on windows, 'meta-shift' on other os\\n\\t *\\n\\t * any number of modifiers `control` `shift` `alt` `meta` followed by zero or one regular key, separated by -\\n\\t * examples: control-shift, control-o, control-alt-s  meta-x control-meta\\n\\t * Some keys have native behavior (e.g. alt-s opens history menu on firefox).\\n\\t * To avoid conflicts or accidentally typing into inputs, modifier only combinations are recommended.\\n\\t */\\n\\ttoggleKeyCombo?: string;\\n\\n\\t/**\\n\\t * define keys to select elements with via keyboard\\n\\t * @default {parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' }\\n\\t *\\n\\t * improves accessibility and also helps when you want to select elements that do not have a hoverable surface area\\n\\t * due to tight wrapping\\n\\t *\\n\\t * A note for users of screen-readers:\\n\\t * If you are using arrow keys to navigate the page itself, change the navKeys to avoid conflicts.\\n\\t * e.g. navKeys: {parent: 'w', prev: 'a', child: 's', next: 'd'}\\n\\t *\\n\\t *\\n\\t * parent: select closest parent\\n\\t * child: select first child (or grandchild)\\n\\t * next: next sibling (or parent if no next sibling exists)\\n\\t * prev: previous sibling (or parent if no prev sibling exists)\\n\\t */\\n\\tnavKeys?: { parent: string; child: string; next: string; prev: string };\\n\\n\\t/**\\n\\t * define key to open the editor for the currently selected dom node\\n\\t *\\n\\t * @default 'Enter'\\n\\t */\\n\\topenKey?: string;\\n\\n\\t/**\\n\\t * inspector is automatically disabled when releasing toggleKeyCombo after holding it for a longpress\\n\\t * @default false\\n\\t */\\n\\tholdMode?: boolean;\\n\\t/**\\n\\t * when to show the toggle button\\n\\t * @default 'active'\\n\\t */\\n\\tshowToggleButton?: 'always' | 'active' | 'never';\\n\\n\\t/**\\n\\t * where to display the toggle button\\n\\t * @default top-right\\n\\t */\\n\\ttoggleButtonPos?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\\n\\n\\t/**\\n\\t * inject custom styles when inspector is active\\n\\t */\\n\\tcustomStyles?: boolean;\\n\\n\\t/**\\n\\t * append an import to the module id ending with `appendTo` instead of adding a script into body\\n\\t * useful for frameworks that do not support trannsformIndexHtml hook\\n\\t *\\n\\t * WARNING: only set this if you know exactly what it does.\\n\\t * Regular users of vite-plugin-svelte or SvelteKit do not need it\\n\\t */\\n\\tappendTo?: string;\\n}\\n\\nexport interface PreResolvedOptions extends Options {\\n\\t// these options are non-nullable after resolve\\n\\tcompilerOptions: CompileOptions;\\n\\texperimental?: ExperimentalOptions;\\n\\t// extra options\\n\\troot: string;\\n\\tisBuild: boolean;\\n\\tisServe: boolean;\\n\\tisDebug: boolean;\\n}\\n\\nexport interface ResolvedOptions extends PreResolvedOptions {\\n\\tisProduction: boolean;\\n\\tserver?: ViteDevServer;\\n\\tstats?: VitePluginSvelteStats;\\n}\\n\\nexport type {\\n\\tCompileOptions,\\n\\tProcessed,\\n\\tMarkupPreprocessor,\\n\\tPreprocessor,\\n\\tPreprocessorGroup,\\n\\tWarning\\n};\\n\\nexport type ModuleFormat = NonNullable<CompileOptions['format']>;\\n\\nexport type CssHashGetter = NonNullable<CompileOptions['cssHash']>;\\n\\nexport type Arrayable<T> = T | T[];\\n\",\"import { createRequire } from 'module';\\nimport path from 'path';\\nimport fs from 'fs';\\nimport { pathToFileURL } from 'url';\\nimport { log } from './log';\\nimport { Options, SvelteOptions } from './options';\\nimport { UserConfig } from 'vite';\\n\\n// used to require cjs config in esm.\\n// NOTE dynamic import() cjs technically works, but timestamp query cache bust\\n// have no effect, likely because it has another internal cache?\\nlet esmRequire: NodeRequire;\\n\\nexport const knownSvelteConfigNames = [\\n\\t'svelte.config.js',\\n\\t'svelte.config.cjs',\\n\\t'svelte.config.mjs'\\n];\\n\\n// hide dynamic import from ts transform to prevent it turning into a require\\n// see https://github.com/microsoft/TypeScript/issues/43329#issuecomment-811606238\\n// also use timestamp query to avoid caching on reload\\nconst dynamicImportDefault = new Function(\\n\\t'path',\\n\\t'timestamp',\\n\\t'return import(path + \\\"?t=\\\" + timestamp).then(m => m.default)'\\n);\\n\\nexport async function loadSvelteConfig(\\n\\tviteConfig?: UserConfig,\\n\\tinlineOptions?: Partial<Options>\\n): Promise<Partial<SvelteOptions> | undefined> {\\n\\tif (inlineOptions?.configFile === false) {\\n\\t\\treturn;\\n\\t}\\n\\tconst configFile = findConfigToLoad(viteConfig, inlineOptions);\\n\\tif (configFile) {\\n\\t\\tlet err;\\n\\t\\t// try to use dynamic import for svelte.config.js first\\n\\t\\tif (configFile.endsWith('.js') || configFile.endsWith('.mjs')) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst result = await dynamicImportDefault(\\n\\t\\t\\t\\t\\tpathToFileURL(configFile).href,\\n\\t\\t\\t\\t\\tfs.statSync(configFile).mtimeMs\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tif (result != null) {\\n\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t...result,\\n\\t\\t\\t\\t\\t\\tconfigFile\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthrow new Error(`invalid export in ${configFile}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\tlog.error(`failed to import config ${configFile}`, e);\\n\\t\\t\\t\\terr = e;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// cjs or error with dynamic import\\n\\t\\tif (!configFile.endsWith('.mjs')) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\t// identify which require function to use (esm and cjs mode)\\n\\t\\t\\t\\tconst _require = import.meta.url\\n\\t\\t\\t\\t\\t? (esmRequire ??= createRequire(import.meta.url))\\n\\t\\t\\t\\t\\t: require;\\n\\n\\t\\t\\t\\t// avoid loading cached version on reload\\n\\t\\t\\t\\tdelete _require.cache[_require.resolve(configFile)];\\n\\t\\t\\t\\tconst result = _require(configFile);\\n\\t\\t\\t\\tif (result != null) {\\n\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t...result,\\n\\t\\t\\t\\t\\t\\tconfigFile\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthrow new Error(`invalid export in ${configFile}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\tlog.error(`failed to require config ${configFile}`, e);\\n\\t\\t\\t\\tif (!err) {\\n\\t\\t\\t\\t\\terr = e;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// failed to load existing config file\\n\\t\\tthrow err;\\n\\t}\\n}\\n\\nfunction findConfigToLoad(viteConfig?: UserConfig, inlineOptions?: Partial<Options>) {\\n\\tconst root = viteConfig?.root || process.cwd();\\n\\tif (inlineOptions?.configFile) {\\n\\t\\tconst abolutePath = path.isAbsolute(inlineOptions.configFile)\\n\\t\\t\\t? inlineOptions.configFile\\n\\t\\t\\t: path.resolve(root, inlineOptions.configFile);\\n\\t\\tif (!fs.existsSync(abolutePath)) {\\n\\t\\t\\tthrow new Error(`failed to find svelte config file ${abolutePath}.`);\\n\\t\\t}\\n\\t\\treturn abolutePath;\\n\\t} else {\\n\\t\\tconst existingKnownConfigFiles = knownSvelteConfigNames\\n\\t\\t\\t.map((candidate) => path.resolve(root, candidate))\\n\\t\\t\\t.filter((file) => fs.existsSync(file));\\n\\t\\tif (existingKnownConfigFiles.length === 0) {\\n\\t\\t\\tlog.debug(`no svelte config found at ${root}`);\\n\\t\\t\\treturn;\\n\\t\\t} else if (existingKnownConfigFiles.length > 1) {\\n\\t\\t\\tlog.warn(\\n\\t\\t\\t\\t`found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,\\n\\t\\t\\t\\texistingKnownConfigFiles\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn existingKnownConfigFiles[0];\\n\\t}\\n}\\n\",\"export const VITE_RESOLVE_MAIN_FIELDS = ['module', 'jsnext:main', 'jsnext'];\\n\\nexport const SVELTE_RESOLVE_MAIN_FIELDS = ['svelte'];\\n\\nexport const SVELTE_IMPORTS = [\\n\\t'svelte/animate',\\n\\t'svelte/easing',\\n\\t'svelte/internal',\\n\\t'svelte/motion',\\n\\t'svelte/ssr',\\n\\t'svelte/store',\\n\\t'svelte/transition',\\n\\t'svelte'\\n];\\n\\nexport const SVELTE_HMR_IMPORTS = [\\n\\t'svelte-hmr/runtime/hot-api-esm.js',\\n\\t'svelte-hmr/runtime/proxy-adapter-dom.js',\\n\\t'svelte-hmr'\\n];\\n\\nexport const SVELTE_EXPORT_CONDITIONS = ['svelte'];\\n\",\"import { readFileSync } from 'fs';\\nimport { compile, preprocess } from 'svelte/compiler';\\nimport { DepOptimizationOptions } from 'vite';\\nimport { Compiled } from './compile';\\nimport { log } from './log';\\nimport { CompileOptions, ResolvedOptions } from './options';\\nimport { toESBuildError } from './error';\\nimport { StatCollection } from './vite-plugin-svelte-stats';\\n\\ntype EsbuildOptions = NonNullable<DepOptimizationOptions['esbuildOptions']>;\\ntype EsbuildPlugin = NonNullable<EsbuildOptions['plugins']>[number];\\n\\nexport const facadeEsbuildSveltePluginName = 'vite-plugin-svelte:facade';\\n\\nexport function esbuildSveltePlugin(options: ResolvedOptions): EsbuildPlugin {\\n\\treturn {\\n\\t\\tname: 'vite-plugin-svelte:optimize-svelte',\\n\\t\\tsetup(build) {\\n\\t\\t\\t// Skip in scanning phase as Vite already handles scanning Svelte files.\\n\\t\\t\\t// Otherwise this would heavily slow down the scanning phase.\\n\\t\\t\\tif (build.initialOptions.plugins?.some((v) => v.name === 'vite:dep-scan')) return;\\n\\n\\t\\t\\tconst svelteExtensions = (options.extensions ?? ['.svelte']).map((ext) => ext.slice(1));\\n\\t\\t\\tconst svelteFilter = new RegExp(`\\\\\\\\.(` + svelteExtensions.join('|') + `)(\\\\\\\\?.*)?$`);\\n\\t\\t\\tlet statsCollection: StatCollection | undefined;\\n\\t\\t\\tbuild.onStart(() => {\\n\\t\\t\\t\\tstatsCollection = options.stats?.startCollection('prebundle libraries', {\\n\\t\\t\\t\\t\\tlogResult: (c) => c.stats.length > 1\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t\\tbuild.onLoad({ filter: svelteFilter }, async ({ path: filename }) => {\\n\\t\\t\\t\\tconst code = readFileSync(filename, 'utf8');\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tconst contents = await compileSvelte(options, { filename, code }, statsCollection);\\n\\t\\t\\t\\t\\treturn { contents };\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\treturn { errors: [toESBuildError(e, options)] };\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tbuild.onEnd(() => {\\n\\t\\t\\t\\tstatsCollection?.finish();\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n}\\n\\nasync function compileSvelte(\\n\\toptions: ResolvedOptions,\\n\\t{ filename, code }: { filename: string; code: string },\\n\\tstatsCollection?: StatCollection\\n): Promise<string> {\\n\\tlet css = options.compilerOptions.css;\\n\\tif (css !== 'none') {\\n\\t\\t// TODO ideally we'd be able to externalize prebundled styles too, but for now always put them in the js\\n\\t\\tcss = 'injected';\\n\\t}\\n\\tconst compileOptions: CompileOptions = {\\n\\t\\t...options.compilerOptions,\\n\\t\\tcss,\\n\\t\\tfilename,\\n\\t\\tformat: 'esm',\\n\\t\\tgenerate: 'dom'\\n\\t};\\n\\n\\tlet preprocessed;\\n\\n\\tif (options.preprocess) {\\n\\t\\ttry {\\n\\t\\t\\tpreprocessed = await preprocess(code, options.preprocess, { filename });\\n\\t\\t} catch (e) {\\n\\t\\t\\te.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ''}`;\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\tif (preprocessed.map) compileOptions.sourcemap = preprocessed.map;\\n\\t}\\n\\n\\tconst finalCode = preprocessed ? preprocessed.code : code;\\n\\n\\tconst dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\\n\\t\\tfilename,\\n\\t\\tcode: finalCode,\\n\\t\\tcompileOptions\\n\\t});\\n\\n\\tif (dynamicCompileOptions && log.debug.enabled) {\\n\\t\\tlog.debug(`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`);\\n\\t}\\n\\n\\tconst finalCompileOptions = dynamicCompileOptions\\n\\t\\t? {\\n\\t\\t\\t\\t...compileOptions,\\n\\t\\t\\t\\t...dynamicCompileOptions\\n\\t\\t  }\\n\\t\\t: compileOptions;\\n\\tconst endStat = statsCollection?.start(filename);\\n\\tconst compiled = compile(finalCode, finalCompileOptions) as Compiled;\\n\\tif (endStat) {\\n\\t\\tendStat();\\n\\t}\\n\\treturn compiled.js.code + '//# sourceMappingURL=' + compiled.js.map.toUrl();\\n}\\n\",\"import path from 'path';\\nimport fs from 'fs/promises';\\n// eslint-disable-next-line node/no-missing-import\\nimport { findDepPkgJsonPath } from 'vitefu';\\n\\ninterface DependencyData {\\n\\tdir: string;\\n\\tpkg: Record<string, any>;\\n}\\n\\nexport async function resolveDependencyData(\\n\\tdep: string,\\n\\tparent: string\\n): Promise<DependencyData | undefined> {\\n\\tconst depDataPath = await findDepPkgJsonPath(dep, parent);\\n\\tif (!depDataPath) return undefined;\\n\\ttry {\\n\\t\\treturn {\\n\\t\\t\\tdir: path.dirname(depDataPath),\\n\\t\\t\\tpkg: JSON.parse(await fs.readFile(depDataPath, 'utf-8'))\\n\\t\\t};\\n\\t} catch {\\n\\t\\treturn undefined;\\n\\t}\\n}\\n\\nconst COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [\\n\\t'@lukeed/uuid',\\n\\t'@playwright/test',\\n\\t'@sveltejs/vite-plugin-svelte',\\n\\t'@sveltejs/kit',\\n\\t'autoprefixer',\\n\\t'cookie',\\n\\t'dotenv',\\n\\t'esbuild',\\n\\t'eslint',\\n\\t'jest',\\n\\t'mdsvex',\\n\\t'playwright',\\n\\t'postcss',\\n\\t'prettier',\\n\\t'svelte',\\n\\t'svelte-check',\\n\\t'svelte-hmr',\\n\\t'svelte-preprocess',\\n\\t'tslib',\\n\\t'typescript',\\n\\t'vite',\\n\\t'vitest',\\n\\t'__vite-browser-external' // see https://github.com/sveltejs/vite-plugin-svelte/issues/362\\n];\\nconst COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [\\n\\t'@fontsource/',\\n\\t'@postcss-plugins/',\\n\\t'@rollup/',\\n\\t'@sveltejs/adapter-',\\n\\t'@types/',\\n\\t'@typescript-eslint/',\\n\\t'eslint-',\\n\\t'jest-',\\n\\t'postcss-plugin-',\\n\\t'prettier-plugin-',\\n\\t'rollup-plugin-',\\n\\t'vite-plugin-'\\n];\\n\\n/**\\n * Test for common dependency names that tell us it is not a package including a svelte field, eg. eslint + plugins.\\n *\\n * This speeds up the find process as we don't have to try and require the package.json for all of them\\n *\\n * @param dependency {string}\\n * @returns {boolean} true if it is a dependency without a svelte field\\n */\\nexport function isCommonDepWithoutSvelteField(dependency: string): boolean {\\n\\treturn (\\n\\t\\tCOMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) ||\\n\\t\\tCOMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some(\\n\\t\\t\\t(prefix) =>\\n\\t\\t\\t\\tprefix.startsWith('@')\\n\\t\\t\\t\\t\\t? dependency.startsWith(prefix)\\n\\t\\t\\t\\t\\t: dependency.substring(dependency.lastIndexOf('/') + 1).startsWith(prefix) // check prefix omitting @scope/\\n\\t\\t)\\n\\t);\\n}\\n\",\"import { log } from './log';\\n//eslint-disable-next-line node/no-missing-import\\nimport { findClosestPkgJsonPath } from 'vitefu';\\nimport { readFileSync } from 'fs';\\nimport { dirname } from 'path';\\nimport { performance } from 'perf_hooks';\\nimport { normalizePath } from 'vite';\\n\\ninterface Stat {\\n\\tfile: string;\\n\\tpkg?: string;\\n\\tstart: number;\\n\\tend: number;\\n}\\n\\nexport interface StatCollection {\\n\\tname: string;\\n\\toptions: CollectionOptions;\\n\\t//eslint-disable-next-line no-unused-vars\\n\\tstart: (file: string) => () => void;\\n\\tstats: Stat[];\\n\\tpackageStats?: PackageStats[];\\n\\tcollectionStart: number;\\n\\tduration?: number;\\n\\tfinish: () => Promise<void> | void;\\n\\tfinished: boolean;\\n}\\n\\ninterface PackageStats {\\n\\tpkg: string;\\n\\tfiles: number;\\n\\tduration: number;\\n}\\n\\nexport interface CollectionOptions {\\n\\t//eslint-disable-next-line no-unused-vars\\n\\tlogInProgress: (collection: StatCollection, now: number) => boolean;\\n\\t//eslint-disable-next-line no-unused-vars\\n\\tlogResult: (collection: StatCollection) => boolean;\\n}\\n\\nconst defaultCollectionOptions: CollectionOptions = {\\n\\t// log after 500ms and more than one file processed\\n\\tlogInProgress: (c, now) => now - c.collectionStart > 500 && c.stats.length > 1,\\n\\t// always log results\\n\\tlogResult: () => true\\n};\\n\\nfunction humanDuration(n: number) {\\n\\t// 99.9ms  0.10s\\n\\treturn n < 100 ? `${n.toFixed(1)}ms` : `${(n / 1000).toFixed(2)}s`;\\n}\\n\\nfunction formatPackageStats(pkgStats: PackageStats[]) {\\n\\tconst statLines = pkgStats.map((pkgStat) => {\\n\\t\\tconst duration = pkgStat.duration;\\n\\t\\tconst avg = duration / pkgStat.files;\\n\\t\\treturn [pkgStat.pkg, `${pkgStat.files}`, humanDuration(duration), humanDuration(avg)];\\n\\t});\\n\\tstatLines.unshift(['package', 'files', 'time', 'avg']);\\n\\tconst columnWidths = statLines.reduce(\\n\\t\\t(widths: number[], row) => {\\n\\t\\t\\tfor (let i = 0; i < row.length; i++) {\\n\\t\\t\\t\\tconst cell = row[i];\\n\\t\\t\\t\\tif (widths[i] < cell.length) {\\n\\t\\t\\t\\t\\twidths[i] = cell.length;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn widths;\\n\\t\\t},\\n\\t\\tstatLines[0].map(() => 0)\\n\\t);\\n\\n\\tconst table = statLines\\n\\t\\t.map((row: string[]) =>\\n\\t\\t\\trow\\n\\t\\t\\t\\t.map((cell: string, i: number) => {\\n\\t\\t\\t\\t\\tif (i === 0) {\\n\\t\\t\\t\\t\\t\\treturn cell.padEnd(columnWidths[i], ' ');\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn cell.padStart(columnWidths[i], ' ');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.join('\\\\t')\\n\\t\\t)\\n\\t\\t.join('\\\\n');\\n\\treturn table;\\n}\\n\\n/**\\n * utility to get the package name a file belongs to\\n *\\n * @param {string} file to find package for\\n * @returns {path:string,name:string} tuple of path,name where name is the parsed package name and path is the normalized path to it\\n */\\nasync function getClosestNamedPackage(file: string): Promise<{ name: string; path: string }> {\\n\\tlet name = '$unknown';\\n\\tlet path = await findClosestPkgJsonPath(file, (pkgPath) => {\\n\\t\\tconst pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\\n\\t\\tif (pkg.name != null) {\\n\\t\\t\\tname = pkg.name;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t});\\n\\t// return normalized path with appended '/' so .startsWith works for future file checks\\n\\tpath = normalizePath(dirname(path ?? file)) + '/';\\n\\treturn { name, path };\\n}\\n\\nexport class VitePluginSvelteStats {\\n\\t// package directory -> package name\\n\\tprivate _packages: { path: string; name: string }[] = [];\\n\\tprivate _collections: StatCollection[] = [];\\n\\tstartCollection(name: string, opts?: Partial<CollectionOptions>) {\\n\\t\\tconst options = {\\n\\t\\t\\t...defaultCollectionOptions,\\n\\t\\t\\t...opts\\n\\t\\t};\\n\\t\\tconst stats: Stat[] = [];\\n\\t\\tconst collectionStart = performance.now();\\n\\t\\tconst _this = this;\\n\\t\\tlet hasLoggedProgress = false;\\n\\t\\tconst collection: StatCollection = {\\n\\t\\t\\tname,\\n\\t\\t\\toptions,\\n\\t\\t\\tstats,\\n\\t\\t\\tcollectionStart,\\n\\t\\t\\tfinished: false,\\n\\t\\t\\tstart(file) {\\n\\t\\t\\t\\tif (collection.finished) {\\n\\t\\t\\t\\t\\tthrow new Error('called after finish() has been used');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfile = normalizePath(file);\\n\\t\\t\\t\\tconst start = performance.now();\\n\\t\\t\\t\\tconst stat: Stat = { file, start, end: start };\\n\\t\\t\\t\\treturn () => {\\n\\t\\t\\t\\t\\tconst now = performance.now();\\n\\t\\t\\t\\t\\tstat.end = now;\\n\\t\\t\\t\\t\\tstats.push(stat);\\n\\t\\t\\t\\t\\tif (!hasLoggedProgress && options.logInProgress(collection, now)) {\\n\\t\\t\\t\\t\\t\\thasLoggedProgress = true;\\n\\t\\t\\t\\t\\t\\tlog.info(`${name} in progress ...`);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t},\\n\\t\\t\\tasync finish() {\\n\\t\\t\\t\\tawait _this._finish(collection);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t_this._collections.push(collection);\\n\\t\\treturn collection;\\n\\t}\\n\\n\\tpublic async finishAll() {\\n\\t\\tawait Promise.all(this._collections.map((c) => c.finish()));\\n\\t}\\n\\n\\tprivate async _finish(collection: StatCollection) {\\n\\t\\ttry {\\n\\t\\t\\tcollection.finished = true;\\n\\t\\t\\tconst now = performance.now();\\n\\t\\t\\tcollection.duration = now - collection.collectionStart;\\n\\t\\t\\tconst logResult = collection.options.logResult(collection);\\n\\t\\t\\tif (logResult) {\\n\\t\\t\\t\\tawait this._aggregateStatsResult(collection);\\n\\t\\t\\t\\tlog.info(`${collection.name} done.`, formatPackageStats(collection.packageStats!));\\n\\t\\t\\t}\\n\\t\\t\\t// cut some ties to free it for garbage collection\\n\\t\\t\\tconst index = this._collections.indexOf(collection);\\n\\t\\t\\tthis._collections.splice(index, 1);\\n\\t\\t\\tcollection.stats.length = 0;\\n\\t\\t\\tcollection.stats = [];\\n\\t\\t\\tif (collection.packageStats) {\\n\\t\\t\\t\\tcollection.packageStats.length = 0;\\n\\t\\t\\t\\tcollection.packageStats = [];\\n\\t\\t\\t}\\n\\t\\t\\tcollection.start = () => () => {};\\n\\t\\t\\tcollection.finish = () => {};\\n\\t\\t} catch (e) {\\n\\t\\t\\t// this should not happen, but stats taking also should not break the process\\n\\t\\t\\tlog.debug.once(`failed to finish stats for ${collection.name}`, e);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate async _aggregateStatsResult(collection: StatCollection) {\\n\\t\\tconst stats = collection.stats;\\n\\t\\tfor (const stat of stats) {\\n\\t\\t\\tlet pkg = this._packages.find((p) => stat.file.startsWith(p.path));\\n\\t\\t\\tif (!pkg) {\\n\\t\\t\\t\\tpkg = await getClosestNamedPackage(stat.file);\\n\\t\\t\\t\\tthis._packages.push(pkg);\\n\\t\\t\\t}\\n\\t\\t\\tstat.pkg = pkg.name;\\n\\t\\t}\\n\\n\\t\\t// group stats\\n\\t\\tconst grouped: { [key: string]: PackageStats } = {};\\n\\t\\tstats.forEach((stat) => {\\n\\t\\t\\tconst pkg = stat.pkg!;\\n\\t\\t\\tlet group = grouped[pkg];\\n\\t\\t\\tif (!group) {\\n\\t\\t\\t\\tgroup = grouped[pkg] = {\\n\\t\\t\\t\\t\\tfiles: 0,\\n\\t\\t\\t\\t\\tduration: 0,\\n\\t\\t\\t\\t\\tpkg\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tgroup.files += 1;\\n\\t\\t\\tgroup.duration += stat.end - stat.start;\\n\\t\\t});\\n\\n\\t\\tconst groups = Object.values(grouped);\\n\\t\\tgroups.sort((a, b) => b.duration - a.duration);\\n\\t\\tcollection.packageStats = groups;\\n\\t}\\n}\\n\",\"import { VitePluginSvelteCache } from './vite-plugin-svelte-cache';\\nimport fs from 'fs';\\nimport { log } from './log';\\nimport { IdParser } from './id';\\nimport { ResolvedOptions } from './options';\\nimport { knownSvelteConfigNames } from './load-svelte-config';\\nimport path from 'path';\\nimport { FSWatcher } from 'vite';\\n\\nexport function setupWatchers(\\n\\toptions: ResolvedOptions,\\n\\tcache: VitePluginSvelteCache,\\n\\trequestParser: IdParser\\n) {\\n\\tconst { server, configFile: svelteConfigFile } = options;\\n\\tif (!server) {\\n\\t\\treturn;\\n\\t}\\n\\tconst { watcher, ws } = server;\\n\\tconst { root, server: serverConfig } = server.config;\\n\\n\\tconst emitChangeEventOnDependants = (filename: string) => {\\n\\t\\tconst dependants = cache.getDependants(filename);\\n\\t\\tdependants.forEach((dependant) => {\\n\\t\\t\\tif (fs.existsSync(dependant)) {\\n\\t\\t\\t\\tlog.debug(\\n\\t\\t\\t\\t\\t`emitting virtual change event for \\\"${dependant}\\\" because depdendency \\\"${filename}\\\" changed`\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\twatcher.emit('change', dependant);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\n\\tconst removeUnlinkedFromCache = (filename: string) => {\\n\\t\\tconst svelteRequest = requestParser(filename, false);\\n\\t\\tif (svelteRequest) {\\n\\t\\t\\tconst removedFromCache = cache.remove(svelteRequest);\\n\\t\\t\\tif (removedFromCache) {\\n\\t\\t\\t\\tlog.debug(`cleared VitePluginSvelteCache for deleted file ${filename}`);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tconst triggerViteRestart = (filename: string) => {\\n\\t\\tif (serverConfig.middlewareMode) {\\n\\t\\t\\t// in middlewareMode we can't restart the server automatically\\n\\t\\t\\t// show the user an overlay instead\\n\\t\\t\\tconst message =\\n\\t\\t\\t\\t'Svelte config change detected, restart your dev process to apply the changes.';\\n\\t\\t\\tlog.info(message, filename);\\n\\t\\t\\tws.send({\\n\\t\\t\\t\\ttype: 'error',\\n\\t\\t\\t\\terr: { message, stack: '', plugin: 'vite-plugin-svelte', id: filename }\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tlog.info(`svelte config changed: restarting vite server. - file: ${filename}`);\\n\\t\\t\\tserver.restart();\\n\\t\\t}\\n\\t};\\n\\n\\t// collection of watcher listeners by event\\n\\tconst listenerCollection = {\\n\\t\\tadd: [] as Array<Function>,\\n\\t\\tchange: [emitChangeEventOnDependants],\\n\\t\\tunlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]\\n\\t};\\n\\n\\tif (svelteConfigFile !== false) {\\n\\t\\t// configFile false means we ignore the file and external process is responsible\\n\\t\\tconst possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => path.join(root, cfg));\\n\\t\\tconst restartOnConfigAdd = (filename: string) => {\\n\\t\\t\\tif (possibleSvelteConfigs.includes(filename)) {\\n\\t\\t\\t\\ttriggerViteRestart(filename);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tconst restartOnConfigChange = (filename: string) => {\\n\\t\\t\\tif (filename === svelteConfigFile) {\\n\\t\\t\\t\\ttriggerViteRestart(filename);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tif (svelteConfigFile) {\\n\\t\\t\\tlistenerCollection.change.push(restartOnConfigChange);\\n\\t\\t\\tlistenerCollection.unlink.push(restartOnConfigChange);\\n\\t\\t} else {\\n\\t\\t\\tlistenerCollection.add.push(restartOnConfigAdd);\\n\\t\\t}\\n\\t}\\n\\n\\tObject.entries(listenerCollection).forEach(([evt, listeners]) => {\\n\\t\\tif (listeners.length > 0) {\\n\\t\\t\\twatcher.on(evt, (filename) => listeners.forEach((listener) => listener(filename)));\\n\\t\\t}\\n\\t});\\n}\\n// taken from vite utils\\nexport function ensureWatchedFile(watcher: FSWatcher, file: string | null, root: string): void {\\n\\tif (\\n\\t\\tfile &&\\n\\t\\t// only need to watch if out of root\\n\\t\\t!file.startsWith(root + '/') &&\\n\\t\\t// some rollup plugins use null bytes for private resolved Ids\\n\\t\\t!file.includes('\\\\0') &&\\n\\t\\tfs.existsSync(file)\\n\\t) {\\n\\t\\t// resolve file to normalized system path\\n\\t\\twatcher.add(path.resolve(file));\\n\\t}\\n}\\n\",\"import path from 'path';\\nimport { builtinModules } from 'module';\\nimport { resolveDependencyData, isCommonDepWithoutSvelteField } from './dependencies';\\nimport { VitePluginSvelteCache } from './vite-plugin-svelte-cache';\\n\\nexport async function resolveViaPackageJsonSvelte(\\n\\timportee: string,\\n\\timporter: string | undefined,\\n\\tcache: VitePluginSvelteCache\\n): Promise<string | void> {\\n\\tif (\\n\\t\\timporter &&\\n\\t\\tisBareImport(importee) &&\\n\\t\\t!isNodeInternal(importee) &&\\n\\t\\t!isCommonDepWithoutSvelteField(importee)\\n\\t) {\\n\\t\\tconst cached = cache.getResolvedSvelteField(importee, importer);\\n\\t\\tif (cached) {\\n\\t\\t\\treturn cached;\\n\\t\\t}\\n\\t\\tconst pkgData = await resolveDependencyData(importee, importer);\\n\\t\\tif (pkgData) {\\n\\t\\t\\tconst { pkg, dir } = pkgData;\\n\\t\\t\\tif (pkg.svelte) {\\n\\t\\t\\t\\tconst result = path.resolve(dir, pkg.svelte);\\n\\t\\t\\t\\tcache.setResolvedSvelteField(importee, importer, result);\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isNodeInternal(importee: string) {\\n\\treturn importee.startsWith('node:') || builtinModules.includes(importee);\\n}\\n\\nfunction isBareImport(importee: string): boolean {\\n\\tif (\\n\\t\\t!importee ||\\n\\t\\timportee[0] === '.' ||\\n\\t\\timportee[0] === '\\\\0' ||\\n\\t\\timportee.includes(':') ||\\n\\t\\tpath.isAbsolute(importee)\\n\\t) {\\n\\t\\treturn false;\\n\\t}\\n\\tconst parts = importee.split('/');\\n\\tswitch (parts.length) {\\n\\t\\tcase 1:\\n\\t\\t\\treturn true;\\n\\t\\tcase 2:\\n\\t\\t\\treturn parts[0].startsWith('@');\\n\\t\\tdefault:\\n\\t\\t\\treturn false;\\n\\t}\\n}\\n\",\"import { promises as fs } from 'fs';\\nimport path from 'path';\\nimport { ResolvedOptions } from './options';\\n\\n// List of options that changes the prebundling result\\nconst PREBUNDLE_SENSITIVE_OPTIONS: (keyof ResolvedOptions)[] = [\\n\\t'compilerOptions',\\n\\t'configFile',\\n\\t'experimental',\\n\\t'extensions',\\n\\t'ignorePluginPreprocessors',\\n\\t'preprocess'\\n];\\n\\n/**\\n * @returns Whether the Svelte metadata has changed\\n */\\nexport async function saveSvelteMetadata(cacheDir: string, options: ResolvedOptions) {\\n\\tconst svelteMetadata = generateSvelteMetadata(options);\\n\\tconst svelteMetadataPath = path.resolve(cacheDir, '_svelte_metadata.json');\\n\\n\\tconst currentSvelteMetadata = JSON.stringify(svelteMetadata, (_, value) => {\\n\\t\\t// Handle preprocessors\\n\\t\\treturn typeof value === 'function' ? value.toString() : value;\\n\\t});\\n\\n\\tlet existingSvelteMetadata: string | undefined;\\n\\ttry {\\n\\t\\texistingSvelteMetadata = await fs.readFile(svelteMetadataPath, 'utf8');\\n\\t} catch {\\n\\t\\t// ignore\\n\\t}\\n\\n\\tawait fs.mkdir(cacheDir, { recursive: true });\\n\\tawait fs.writeFile(svelteMetadataPath, currentSvelteMetadata);\\n\\treturn currentSvelteMetadata !== existingSvelteMetadata;\\n}\\n\\nfunction generateSvelteMetadata(options: ResolvedOptions) {\\n\\tconst metadata: Record<string, any> = {};\\n\\tfor (const key of PREBUNDLE_SENSITIVE_OPTIONS) {\\n\\t\\tmetadata[key] = options[key];\\n\\t}\\n\\treturn metadata;\\n}\\n\",\"import { Plugin, normalizePath } from 'vite';\\nimport { log } from '../../utils/log';\\nimport { InspectorOptions } from '../../utils/options';\\nimport path from 'path';\\nimport { fileURLToPath } from 'url';\\nimport fs from 'fs';\\nimport { idToFile } from './utils';\\n\\nconst defaultInspectorOptions: InspectorOptions = {\\n\\ttoggleKeyCombo: process.platform === 'win32' ? 'control-shift' : 'meta-shift',\\n\\tnavKeys: { parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' },\\n\\topenKey: 'Enter',\\n\\tholdMode: false,\\n\\tshowToggleButton: 'active',\\n\\ttoggleButtonPos: 'top-right',\\n\\tcustomStyles: true\\n};\\n\\nfunction getInspectorPath() {\\n\\tconst pluginPath = normalizePath(path.dirname(fileURLToPath(import.meta.url)));\\n\\treturn pluginPath.replace(/\\\\/vite-plugin-svelte\\\\/dist$/, '/vite-plugin-svelte/src/ui/inspector/');\\n}\\n\\nexport function svelteInspector(): Plugin {\\n\\tconst inspectorPath = getInspectorPath();\\n\\tlog.debug.enabled && log.debug(`svelte inspector path: ${inspectorPath}`);\\n\\tlet inspectorOptions: InspectorOptions;\\n\\tlet appendTo: string | undefined;\\n\\tlet disabled = false;\\n\\n\\treturn {\\n\\t\\tname: 'vite-plugin-svelte:inspector',\\n\\t\\tapply: 'serve',\\n\\t\\tenforce: 'pre',\\n\\n\\t\\tconfigResolved(config) {\\n\\t\\t\\tconst vps = config.plugins.find((p) => p.name === 'vite-plugin-svelte');\\n\\t\\t\\tconst options = vps?.api?.options?.experimental?.inspector;\\n\\t\\t\\tif (!vps || !options) {\\n\\t\\t\\t\\tlog.debug('inspector disabled, could not find config');\\n\\t\\t\\t\\tdisabled = true;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tinspectorOptions = {\\n\\t\\t\\t\\t...defaultInspectorOptions,\\n\\t\\t\\t\\t...options\\n\\t\\t\\t};\\n\\t\\t\\tconst isSvelteKit = config.plugins.some((p) => p.name.startsWith('vite-plugin-sveltekit'));\\n\\t\\t\\tif (isSvelteKit && !inspectorOptions.appendTo) {\\n\\t\\t\\t\\t// this could append twice if a user had a file that ends with /generated/root.svelte\\n\\t\\t\\t\\t// but that should be rare and inspector doesn't execute twice\\n\\t\\t\\t\\tinspectorOptions.appendTo = `/generated/root.svelte`;\\n\\t\\t\\t}\\n\\t\\t\\tappendTo = inspectorOptions.appendTo;\\n\\t\\t},\\n\\n\\t\\tasync resolveId(importee: string, importer, options) {\\n\\t\\t\\tif (options?.ssr || disabled) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (importee.startsWith('virtual:svelte-inspector-options')) {\\n\\t\\t\\t\\treturn importee;\\n\\t\\t\\t} else if (importee.startsWith('virtual:svelte-inspector-path:')) {\\n\\t\\t\\t\\tconst resolved = importee.replace('virtual:svelte-inspector-path:', inspectorPath);\\n\\t\\t\\t\\tlog.debug.enabled && log.debug(`resolved ${importee} with ${resolved}`);\\n\\t\\t\\t\\treturn resolved;\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tasync load(id, options) {\\n\\t\\t\\tif (options?.ssr || disabled) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (id === 'virtual:svelte-inspector-options') {\\n\\t\\t\\t\\treturn `export default ${JSON.stringify(inspectorOptions ?? {})}`;\\n\\t\\t\\t} else if (id.startsWith(inspectorPath)) {\\n\\t\\t\\t\\t// read file ourselves to avoid getting shut out by vites fs.allow check\\n\\t\\t\\t\\tconst file = idToFile(id);\\n\\t\\t\\t\\tif (fs.existsSync(file)) {\\n\\t\\t\\t\\t\\treturn await fs.promises.readFile(file, 'utf-8');\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlog.error(`failed to find file for svelte-inspector: ${file}, referenced by id ${id}.`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\ttransform(code: string, id: string, options?: { ssr?: boolean }) {\\n\\t\\t\\tif (options?.ssr || disabled || !appendTo) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (id.endsWith(appendTo)) {\\n\\t\\t\\t\\treturn { code: `${code}\\\\nimport 'virtual:svelte-inspector-path:load-inspector.js'` };\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttransformIndexHtml(html) {\\n\\t\\t\\tif (disabled || appendTo) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\treturn {\\n\\t\\t\\t\\thtml,\\n\\t\\t\\t\\ttags: [\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttag: 'script',\\n\\t\\t\\t\\t\\t\\tinjectTo: 'body',\\n\\t\\t\\t\\t\\t\\tattrs: {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'module',\\n\\t\\t\\t\\t\\t\\t\\t// /@id/ is needed, otherwise the virtual: is seen as protocol by browser and cors error happens\\n\\t\\t\\t\\t\\t\\t\\tsrc: '/@id/virtual:svelte-inspector-path:load-inspector.js'\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n}\\n\",\"const FS_PREFIX = `/@fs/`;\\nconst IS_WINDOWS = process.platform === 'win32';\\nconst queryRE = /\\\\?.*$/s;\\nconst hashRE = /#.*$/s;\\n\\nexport function idToFile(id: string): string {\\n\\t// strip /@fs/ but keep leading / on non-windows\\n\\tif (id.startsWith(FS_PREFIX)) {\\n\\t\\tid = id = id.slice(IS_WINDOWS ? FS_PREFIX.length : FS_PREFIX.length - 1);\\n\\t}\\n\\t// strip query and hash\\n\\treturn id.replace(hashRE, '').replace(queryRE, '');\\n}\\n\",\"import { SvelteRequest } from './id';\\nimport { Code, CompileData } from './compile';\\n\\nexport class VitePluginSvelteCache {\\n\\tprivate _css = new Map<string, Code>();\\n\\tprivate _js = new Map<string, Code>();\\n\\tprivate _dependencies = new Map<string, string[]>();\\n\\tprivate _dependants = new Map<string, Set<string>>();\\n\\tprivate _resolvedSvelteFields = new Map<string, string>();\\n\\tprivate _errors = new Map<string, any>();\\n\\n\\tpublic update(compileData: CompileData) {\\n\\t\\tthis._errors.delete(compileData.normalizedFilename);\\n\\t\\tthis.updateCSS(compileData);\\n\\t\\tthis.updateJS(compileData);\\n\\t\\tthis.updateDependencies(compileData);\\n\\t}\\n\\n\\tpublic has(svelteRequest: SvelteRequest) {\\n\\t\\tconst id = svelteRequest.normalizedFilename;\\n\\t\\treturn this._errors.has(id) || this._js.has(id) || this._css.has(id);\\n\\t}\\n\\n\\tpublic setError(svelteRequest: SvelteRequest, error: any) {\\n\\t\\t// keep dependency info, otherwise errors in dependants would not trigger an update after fixing\\n\\t\\t// because they are no longer watched\\n\\t\\tthis.remove(svelteRequest, true);\\n\\t\\tthis._errors.set(svelteRequest.normalizedFilename, error);\\n\\t}\\n\\n\\tprivate updateCSS(compileData: CompileData) {\\n\\t\\tthis._css.set(compileData.normalizedFilename, compileData.compiled.css);\\n\\t}\\n\\n\\tprivate updateJS(compileData: CompileData) {\\n\\t\\tif (!compileData.ssr) {\\n\\t\\t\\t// do not cache SSR js\\n\\t\\t\\tthis._js.set(compileData.normalizedFilename, compileData.compiled.js);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate updateDependencies(compileData: CompileData) {\\n\\t\\tconst id = compileData.normalizedFilename;\\n\\t\\tconst prevDependencies = this._dependencies.get(id) || [];\\n\\t\\tconst dependencies = compileData.dependencies;\\n\\t\\tthis._dependencies.set(id, dependencies);\\n\\t\\tconst removed = prevDependencies.filter((d) => !dependencies.includes(d));\\n\\t\\tconst added = dependencies.filter((d) => !prevDependencies.includes(d));\\n\\t\\tadded.forEach((d) => {\\n\\t\\t\\tif (!this._dependants.has(d)) {\\n\\t\\t\\t\\tthis._dependants.set(d, new Set<string>());\\n\\t\\t\\t}\\n\\t\\t\\tthis._dependants.get(d)!.add(compileData.filename);\\n\\t\\t});\\n\\t\\tremoved.forEach((d) => {\\n\\t\\t\\tthis._dependants.get(d)!.delete(compileData.filename);\\n\\t\\t});\\n\\t}\\n\\n\\tpublic remove(svelteRequest: SvelteRequest, keepDependencies: boolean = false): boolean {\\n\\t\\tconst id = svelteRequest.normalizedFilename;\\n\\t\\tlet removed = false;\\n\\t\\tif (this._errors.delete(id)) {\\n\\t\\t\\tremoved = true;\\n\\t\\t}\\n\\t\\tif (this._js.delete(id)) {\\n\\t\\t\\tremoved = true;\\n\\t\\t}\\n\\t\\tif (this._css.delete(id)) {\\n\\t\\t\\tremoved = true;\\n\\t\\t}\\n\\t\\tif (!keepDependencies) {\\n\\t\\t\\tconst dependencies = this._dependencies.get(id);\\n\\t\\t\\tif (dependencies) {\\n\\t\\t\\t\\tremoved = true;\\n\\t\\t\\t\\tdependencies.forEach((d) => {\\n\\t\\t\\t\\t\\tconst dependants = this._dependants.get(d);\\n\\t\\t\\t\\t\\tif (dependants && dependants.has(svelteRequest.filename)) {\\n\\t\\t\\t\\t\\t\\tdependants.delete(svelteRequest.filename);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tthis._dependencies.delete(id);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn removed;\\n\\t}\\n\\n\\tpublic getCSS(svelteRequest: SvelteRequest) {\\n\\t\\treturn this._css.get(svelteRequest.normalizedFilename);\\n\\t}\\n\\n\\tpublic getJS(svelteRequest: SvelteRequest) {\\n\\t\\tif (!svelteRequest.ssr) {\\n\\t\\t\\t// SSR js isn't cached\\n\\t\\t\\treturn this._js.get(svelteRequest.normalizedFilename);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic getError(svelteRequest: SvelteRequest) {\\n\\t\\treturn this._errors.get(svelteRequest.normalizedFilename);\\n\\t}\\n\\n\\tpublic getDependants(path: string): string[] {\\n\\t\\tconst dependants = this._dependants.get(path);\\n\\t\\treturn dependants ? [...dependants] : [];\\n\\t}\\n\\n\\tpublic getResolvedSvelteField(name: string, importer?: string): string | void {\\n\\t\\treturn this._resolvedSvelteFields.get(this._getResolvedSvelteFieldKey(name, importer));\\n\\t}\\n\\n\\tpublic setResolvedSvelteField(\\n\\t\\timportee: string,\\n\\t\\timporter: string | undefined = undefined,\\n\\t\\tresolvedSvelte: string\\n\\t) {\\n\\t\\tthis._resolvedSvelteFields.set(\\n\\t\\t\\tthis._getResolvedSvelteFieldKey(importee, importer),\\n\\t\\t\\tresolvedSvelte\\n\\t\\t);\\n\\t}\\n\\n\\tprivate _getResolvedSvelteFieldKey(importee: string, importer?: string): string {\\n\\t\\treturn importer ? `${importer} > ${importee}` : importee;\\n\\t}\\n}\\n\",\"import { ResolvedOptions } from './options';\\nimport fs from 'fs';\\nimport { toRollupError } from './error';\\nimport { log } from './log';\\nimport type { SvelteRequest } from './id';\\nimport { type CompileData, CompileSvelte } from './compile';\\n\\n/**\\n * utility function to compile ?raw and ?direct requests in load hook\\n */\\nexport async function loadRaw(\\n\\tsvelteRequest: SvelteRequest,\\n\\tcompileSvelte: CompileSvelte,\\n\\toptions: ResolvedOptions\\n) {\\n\\tconst { id, filename, query } = svelteRequest;\\n\\n\\t// raw svelte subrequest, compile on the fly and return requested subpart\\n\\tlet compileData;\\n\\tconst source = fs.readFileSync(filename, 'utf-8');\\n\\ttry {\\n\\t\\t//avoid compileSvelte doing extra ssr stuff unless requested\\n\\t\\tsvelteRequest.ssr = query.compilerOptions?.generate === 'ssr';\\n\\t\\tconst type = query.type;\\n\\t\\tcompileData = await compileSvelte(svelteRequest, source, {\\n\\t\\t\\t...options,\\n\\t\\t\\t// don't use dynamic vite-plugin-svelte defaults here to ensure stable result between ssr,dev and build\\n\\t\\t\\tcompilerOptions: {\\n\\t\\t\\t\\tdev: false,\\n\\t\\t\\t\\tcss: false,\\n\\t\\t\\t\\thydratable: false,\\n\\t\\t\\t\\tenableSourcemap: query.sourcemap\\n\\t\\t\\t\\t\\t? {\\n\\t\\t\\t\\t\\t\\t\\tjs: type === 'script' || type === 'all',\\n\\t\\t\\t\\t\\t\\t\\tcss: type === 'style' || type === 'all'\\n\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t: false,\\n\\t\\t\\t\\t...svelteRequest.query.compilerOptions\\n\\t\\t\\t},\\n\\t\\t\\thot: false,\\n\\t\\t\\temitCss: true\\n\\t\\t});\\n\\t} catch (e) {\\n\\t\\tthrow toRollupError(e, options);\\n\\t}\\n\\tlet result;\\n\\tif (query.type === 'style') {\\n\\t\\tresult = compileData.compiled.css;\\n\\t} else if (query.type === 'script') {\\n\\t\\tresult = compileData.compiled.js;\\n\\t} else if (query.type === 'preprocessed') {\\n\\t\\tresult = compileData.preprocessed;\\n\\t} else if (query.type === 'all' && query.raw) {\\n\\t\\treturn allToRawExports(compileData, source);\\n\\t} else {\\n\\t\\tthrow new Error(\\n\\t\\t\\t`invalid \\\"type=${query.type}\\\" in ${id}. supported are script, style, preprocessed, all`\\n\\t\\t);\\n\\t}\\n\\tif (query.direct) {\\n\\t\\tconst supportedDirectTypes = ['script', 'style'];\\n\\t\\tif (!supportedDirectTypes.includes(query.type)) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`invalid \\\"type=${\\n\\t\\t\\t\\t\\tquery.type\\n\\t\\t\\t\\t}\\\" combined with direct in ${id}. supported are: ${supportedDirectTypes.join(', ')}`\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tlog.debug(`load returns direct result for ${id}`);\\n\\t\\tlet directOutput = result.code;\\n\\t\\tif (query.sourcemap && result.map?.toUrl) {\\n\\t\\t\\tconst map = `sourceMappingURL=${result.map.toUrl()}`;\\n\\t\\t\\tif (query.type === 'style') {\\n\\t\\t\\t\\tdirectOutput += `\\\\n\\\\n/*# ${map} */\\\\n`;\\n\\t\\t\\t} else if (query.type === 'script') {\\n\\t\\t\\t\\tdirectOutput += `\\\\n\\\\n//# ${map}\\\\n`;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn directOutput;\\n\\t} else if (query.raw) {\\n\\t\\tlog.debug(`load returns raw result for ${id}`);\\n\\t\\treturn toRawExports(result);\\n\\t} else {\\n\\t\\tthrow new Error(`invalid raw mode in ${id}, supported are raw, direct`);\\n\\t}\\n}\\n\\n/**\\n * turn compileData and source into a flat list of raw exports\\n *\\n * @param compileData\\n * @param source\\n */\\nfunction allToRawExports(compileData: CompileData, source: string) {\\n\\t// flatten CompileData\\n\\tconst exports: Partial<CompileData & { source: string }> = {\\n\\t\\t...compileData,\\n\\t\\t...compileData.compiled,\\n\\t\\tsource\\n\\t};\\n\\tdelete exports.compiled;\\n\\tdelete exports.filename; // absolute path, remove to avoid it in output\\n\\treturn toRawExports(exports);\\n}\\n\\n/**\\n * turn object into raw exports.\\n *\\n * every prop is returned as a const export, and if prop 'code' exists it is additionally added as default export\\n *\\n * eg {'foo':'bar','code':'baz'} results in\\n *\\n *  ```js\\n *  export const code='baz'\\n *  export const foo='bar'\\n *  export default code\\n *  ```\\n * @param object\\n */\\nfunction toRawExports(object: object) {\\n\\tlet exports =\\n\\t\\tObject.entries(object)\\n\\t\\t\\t//eslint-disable-next-line no-unused-vars\\n\\t\\t\\t.filter(([key, value]) => typeof value !== 'function') // preprocess output has a toString function that's enumerable\\n\\t\\t\\t.sort(([a], [b]) => (a < b ? -1 : a === b ? 0 : 1))\\n\\t\\t\\t.map(([key, value]) => `export const ${key}=${JSON.stringify(value)}`)\\n\\t\\t\\t.join('\\\\n') + '\\\\n';\\n\\tif (Object.prototype.hasOwnProperty.call(object, 'code')) {\\n\\t\\texports += `export default code\\\\n`;\\n\\t}\\n\\treturn exports;\\n}\\n\",\"import { preprocessCSS, resolveConfig, transformWithEsbuild } from 'vite';\\nimport type { ESBuildOptions, InlineConfig, ResolvedConfig } from 'vite';\\n// eslint-disable-next-line node/no-missing-import\\nimport type { Preprocessor, PreprocessorGroup } from 'svelte/types/compiler/preprocess';\\nimport { mapSourcesToRelative } from './utils/sourcemaps';\\n\\nconst supportedStyleLangs = ['css', 'less', 'sass', 'scss', 'styl', 'stylus', 'postcss', 'sss'];\\nconst supportedScriptLangs = ['ts'];\\n\\nexport function vitePreprocess(opts?: {\\n\\tscript?: boolean;\\n\\tstyle?: boolean | InlineConfig | ResolvedConfig;\\n}) {\\n\\tconst preprocessor: PreprocessorGroup = {};\\n\\tif (opts?.script !== false) {\\n\\t\\tpreprocessor.script = viteScript().script;\\n\\t}\\n\\tif (opts?.style !== false) {\\n\\t\\tconst styleOpts = typeof opts?.style == 'object' ? opts?.style : undefined;\\n\\t\\tpreprocessor.style = viteStyle(styleOpts).style;\\n\\t}\\n\\treturn preprocessor;\\n}\\n\\nfunction viteScript(): { script: Preprocessor } {\\n\\treturn {\\n\\t\\tasync script({ attributes, content, filename = '' }) {\\n\\t\\t\\tconst lang = attributes.lang as string;\\n\\t\\t\\tif (!supportedScriptLangs.includes(lang)) return;\\n\\t\\t\\tconst { code, map } = await transformWithEsbuild(content, filename, {\\n\\t\\t\\t\\tloader: lang as ESBuildOptions['loader'],\\n\\t\\t\\t\\ttarget: 'esnext',\\n\\t\\t\\t\\ttsconfigRaw: {\\n\\t\\t\\t\\t\\tcompilerOptions: {\\n\\t\\t\\t\\t\\t\\t// svelte typescript needs this flag to work with type imports\\n\\t\\t\\t\\t\\t\\timportsNotUsedAsValues: 'preserve',\\n\\t\\t\\t\\t\\t\\tpreserveValueImports: true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tmapSourcesToRelative(map, filename);\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tcode,\\n\\t\\t\\t\\tmap\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction viteStyle(config: InlineConfig | ResolvedConfig = {}): {\\n\\tstyle: Preprocessor;\\n} {\\n\\tlet transform: CssTransform;\\n\\tconst style: Preprocessor = async ({ attributes, content, filename = '' }) => {\\n\\t\\tconst lang = attributes.lang as string;\\n\\t\\tif (!supportedStyleLangs.includes(lang)) return;\\n\\t\\tif (!transform) {\\n\\t\\t\\tlet resolvedConfig: ResolvedConfig;\\n\\t\\t\\t// @ts-expect-error special prop added if running in v-p-s\\n\\t\\t\\tif (style.__resolvedConfig) {\\n\\t\\t\\t\\t// @ts-expect-error\\n\\t\\t\\t\\tresolvedConfig = style.__resolvedConfig;\\n\\t\\t\\t} else if (isResolvedConfig(config)) {\\n\\t\\t\\t\\tresolvedConfig = config;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresolvedConfig = await resolveConfig(\\n\\t\\t\\t\\t\\tconfig,\\n\\t\\t\\t\\t\\tprocess.env.NODE_ENV === 'production' ? 'build' : 'serve'\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\ttransform = getCssTransformFn(resolvedConfig);\\n\\t\\t}\\n\\t\\tconst moduleId = `${filename}.${lang}`;\\n\\t\\tconst { code, map } = await transform(content, moduleId);\\n\\n\\t\\tmapSourcesToRelative(map, moduleId);\\n\\n\\t\\treturn {\\n\\t\\t\\tcode,\\n\\t\\t\\tmap: map ?? undefined\\n\\t\\t};\\n\\t};\\n\\t// @ts-expect-error tag so can be found by v-p-s\\n\\tstyle.__resolvedConfig = null;\\n\\treturn { style };\\n}\\n\\n// eslint-disable-next-line no-unused-vars\\ntype CssTransform = (code: string, filename: string) => Promise<{ code: string; map?: any }>;\\n\\nfunction getCssTransformFn(config: ResolvedConfig): CssTransform {\\n\\treturn async (code, filename) => {\\n\\t\\treturn preprocessCSS(code, filename, config);\\n\\t};\\n}\\n\\nfunction isResolvedConfig(config: any): config is ResolvedConfig {\\n\\treturn !!config.inlineConfig;\\n}\\n\"],\"mappings\":\"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\",\"names\":[\"fs\",\"isDepExcluded\",\"compileSvelte\",\"path\",\"compileSvelte\",\"normalizePath\",\"path\",\"fs\",\"fs\",\"path\",\"path\",\"compile\",\"preprocess\",\"preprocess\",\"compile\",\"path\",\"fs\",\"prefix\",\"readFileSync\",\"normalizePath\",\"path\",\"preResolveOptions\",\"normalizePath\",\"path\",\"fs\",\"path\",\"fs\",\"path\",\"path\",\"fs\",\"path\",\"normalizePath\",\"path\",\"fs\",\"IS_WINDOWS\",\"normalizePath\",\"path\",\"fs\",\"path\",\"fs\",\"compileSvelte\",\"fs\",\"compileSvelte\",\"fs\",\"isDepExcluded\"]}"}}}},"LICENSE":{"file":{"contents":"MIT License\n\nCopyright (c) 2021 [these people](https://github.com/sveltejs/vite-plugin-svelte/graphs/contributors)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"node_modules":{"directory":{"magic-string":{"directory":{"dist":{"directory":{"magic-string.cjs.js":{"file":{"contents":"'use strict';\n\nvar sourcemapCodec = require('@jridgewell/sourcemap-codec');\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa () {\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = sourcemapCodec.encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;\n//# sourceMappingURL=magic-string.cjs.js.map\n"}},"magic-string.cjs.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.cjs.js\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\",\"../src/index-legacy.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t\\tif (typeof properties.x_google_ignoreList !== 'undefined') {\\n\\t\\t\\tthis.x_google_ignoreList = properties.x_google_ignoreList;\\n\\t\\t}\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport Bundle from './Bundle.js';\\nimport SourceMap from './SourceMap.js';\\n\\nMagicString.Bundle = Bundle;\\nMagicString.SourceMap = SourceMap;\\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\\n\\nexport default MagicString;\\n\"],\"names\":[\"encode\"],\"mappings\":\"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\"}"}},"magic-string.es.mjs":{"file":{"contents":"import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa () {\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n"}},"magic-string.es.mjs.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.es.mjs\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t\\tif (typeof properties.x_google_ignoreList !== 'undefined') {\\n\\t\\t\\tthis.x_google_ignoreList = properties.x_google_ignoreList;\\n\\t\\t}\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}"}},"magic-string.umd.js":{"file":{"contents":"(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());\n})(this, (function () { 'use strict';\n\n\tclass BitSet {\n\t\tconstructor(arg) {\n\t\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t\t}\n\n\t\tadd(n) {\n\t\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t\t}\n\n\t\thas(n) {\n\t\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t\t}\n\t}\n\n\tclass Chunk {\n\t\tconstructor(start, end, content) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.original = content;\n\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\n\t\t\tthis.content = content;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\n\t\t\t{\n\t\t\t\tthis.previous = null;\n\t\t\t\tthis.next = null;\n\t\t\t}\n\t\t}\n\n\t\tappendLeft(content) {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tappendRight(content) {\n\t\t\tthis.intro = this.intro + content;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\t\tchunk.intro = this.intro;\n\t\t\tchunk.outro = this.outro;\n\t\t\tchunk.content = this.content;\n\t\t\tchunk.storeName = this.storeName;\n\t\t\tchunk.edited = this.edited;\n\n\t\t\treturn chunk;\n\t\t}\n\n\t\tcontains(index) {\n\t\t\treturn this.start < index && index < this.end;\n\t\t}\n\n\t\teachNext(fn) {\n\t\t\tlet chunk = this;\n\t\t\twhile (chunk) {\n\t\t\t\tfn(chunk);\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\t\t}\n\n\t\teachPrevious(fn) {\n\t\t\tlet chunk = this;\n\t\t\twhile (chunk) {\n\t\t\t\tfn(chunk);\n\t\t\t\tchunk = chunk.previous;\n\t\t\t}\n\t\t}\n\n\t\tedit(content, storeName, contentOnly) {\n\t\t\tthis.content = content;\n\t\t\tif (!contentOnly) {\n\t\t\t\tthis.intro = '';\n\t\t\t\tthis.outro = '';\n\t\t\t}\n\t\t\tthis.storeName = storeName;\n\n\t\t\tthis.edited = true;\n\n\t\t\treturn this;\n\t\t}\n\n\t\tprependLeft(content) {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tprependRight(content) {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tsplit(index) {\n\t\t\tconst sliceIndex = index - this.start;\n\n\t\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\t\tthis.original = originalBefore;\n\n\t\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\t\tnewChunk.outro = this.outro;\n\t\t\tthis.outro = '';\n\n\t\t\tthis.end = index;\n\n\t\t\tif (this.edited) {\n\t\t\t\t// TODO is this block necessary?...\n\t\t\t\tnewChunk.edit('', false);\n\t\t\t\tthis.content = '';\n\t\t\t} else {\n\t\t\t\tthis.content = originalBefore;\n\t\t\t}\n\n\t\t\tnewChunk.next = this.next;\n\t\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\t\tnewChunk.previous = this;\n\t\t\tthis.next = newChunk;\n\n\t\t\treturn newChunk;\n\t\t}\n\n\t\ttoString() {\n\t\t\treturn this.intro + this.content + this.outro;\n\t\t}\n\n\t\ttrimEnd(rx) {\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\n\t\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\t\tif (trimmed.length) {\n\t\t\t\tif (trimmed !== this.content) {\n\t\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.edit('', undefined, true);\n\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tif (this.intro.length) return true;\n\t\t\t}\n\t\t}\n\n\t\ttrimStart(rx) {\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\n\t\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\t\tif (trimmed.length) {\n\t\t\t\tif (trimmed !== this.content) {\n\t\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\t\tthis.edit('', undefined, true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.edit('', undefined, true);\n\n\t\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\t\tif (this.outro.length) return true;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst comma = ','.charCodeAt(0);\n\tconst semicolon = ';'.charCodeAt(0);\n\tconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\tconst intToChar = new Uint8Array(64); // 64 possible chars.\n\tconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\tfor (let i = 0; i < chars.length; i++) {\n\t    const c = chars.charCodeAt(i);\n\t    intToChar[i] = c;\n\t    charToInt[c] = i;\n\t}\n\t// Provide a fallback for older environments.\n\tconst td = typeof TextDecoder !== 'undefined'\n\t    ? /* #__PURE__ */ new TextDecoder()\n\t    : typeof Buffer !== 'undefined'\n\t        ? {\n\t            decode(buf) {\n\t                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n\t                return out.toString();\n\t            },\n\t        }\n\t        : {\n\t            decode(buf) {\n\t                let out = '';\n\t                for (let i = 0; i < buf.length; i++) {\n\t                    out += String.fromCharCode(buf[i]);\n\t                }\n\t                return out;\n\t            },\n\t        };\n\tfunction encode(decoded) {\n\t    const state = new Int32Array(5);\n\t    const bufLength = 1024 * 16;\n\t    const subLength = bufLength - 36;\n\t    const buf = new Uint8Array(bufLength);\n\t    const sub = buf.subarray(0, subLength);\n\t    let pos = 0;\n\t    let out = '';\n\t    for (let i = 0; i < decoded.length; i++) {\n\t        const line = decoded[i];\n\t        if (i > 0) {\n\t            if (pos === bufLength) {\n\t                out += td.decode(buf);\n\t                pos = 0;\n\t            }\n\t            buf[pos++] = semicolon;\n\t        }\n\t        if (line.length === 0)\n\t            continue;\n\t        state[0] = 0;\n\t        for (let j = 0; j < line.length; j++) {\n\t            const segment = line[j];\n\t            // We can push up to 5 ints, each int can take at most 7 chars, and we\n\t            // may push a comma.\n\t            if (pos > subLength) {\n\t                out += td.decode(sub);\n\t                buf.copyWithin(0, subLength, pos);\n\t                pos -= subLength;\n\t            }\n\t            if (j > 0)\n\t                buf[pos++] = comma;\n\t            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\t            if (segment.length === 1)\n\t                continue;\n\t            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n\t            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n\t            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\t            if (segment.length === 4)\n\t                continue;\n\t            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n\t        }\n\t    }\n\t    return out + td.decode(buf.subarray(0, pos));\n\t}\n\tfunction encodeInteger(buf, pos, state, segment, j) {\n\t    const next = segment[j];\n\t    let num = next - state[j];\n\t    state[j] = next;\n\t    num = num < 0 ? (-num << 1) | 1 : num << 1;\n\t    do {\n\t        let clamped = num & 0b011111;\n\t        num >>>= 5;\n\t        if (num > 0)\n\t            clamped |= 0b100000;\n\t        buf[pos++] = intToChar[clamped];\n\t    } while (num > 0);\n\t    return pos;\n\t}\n\n\tfunction getBtoa () {\n\t\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t\t} else if (typeof Buffer === 'function') {\n\t\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t\t} else {\n\t\t\treturn () => {\n\t\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t\t};\n\t\t}\n\t}\n\n\tconst btoa = /*#__PURE__*/ getBtoa();\n\n\tclass SourceMap {\n\t\tconstructor(properties) {\n\t\t\tthis.version = 3;\n\t\t\tthis.file = properties.file;\n\t\t\tthis.sources = properties.sources;\n\t\t\tthis.sourcesContent = properties.sourcesContent;\n\t\t\tthis.names = properties.names;\n\t\t\tthis.mappings = encode(properties.mappings);\n\t\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t\t}\n\t\t}\n\n\t\ttoString() {\n\t\t\treturn JSON.stringify(this);\n\t\t}\n\n\t\ttoUrl() {\n\t\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t\t}\n\t}\n\n\tfunction guessIndent(code) {\n\t\tconst lines = code.split('\\n');\n\n\t\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\t\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\t\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// More lines tabbed than spaced? Assume tabs, and\n\t\t// default to tabs in the case of a tie (or nothing\n\t\t// to go on)\n\t\tif (tabbed.length >= spaced.length) {\n\t\t\treturn '\\t';\n\t\t}\n\n\t\t// Otherwise, we need to guess the multiple\n\t\tconst min = spaced.reduce((previous, current) => {\n\t\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\t\treturn Math.min(numSpaces, previous);\n\t\t}, Infinity);\n\n\t\treturn new Array(min + 1).join(' ');\n\t}\n\n\tfunction getRelativePath(from, to) {\n\t\tconst fromParts = from.split(/[/\\\\]/);\n\t\tconst toParts = to.split(/[/\\\\]/);\n\n\t\tfromParts.pop(); // get dirname\n\n\t\twhile (fromParts[0] === toParts[0]) {\n\t\t\tfromParts.shift();\n\t\t\ttoParts.shift();\n\t\t}\n\n\t\tif (fromParts.length) {\n\t\t\tlet i = fromParts.length;\n\t\t\twhile (i--) fromParts[i] = '..';\n\t\t}\n\n\t\treturn fromParts.concat(toParts).join('/');\n\t}\n\n\tconst toString = Object.prototype.toString;\n\n\tfunction isObject(thing) {\n\t\treturn toString.call(thing) === '[object Object]';\n\t}\n\n\tfunction getLocator(source) {\n\t\tconst originalLines = source.split('\\n');\n\t\tconst lineOffsets = [];\n\n\t\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\t\tlineOffsets.push(pos);\n\t\t\tpos += originalLines[i].length + 1;\n\t\t}\n\n\t\treturn function locate(index) {\n\t\t\tlet i = 0;\n\t\t\tlet j = lineOffsets.length;\n\t\t\twhile (i < j) {\n\t\t\t\tconst m = (i + j) >> 1;\n\t\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\t\tj = m;\n\t\t\t\t} else {\n\t\t\t\t\ti = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst line = i - 1;\n\t\t\tconst column = index - lineOffsets[line];\n\t\t\treturn { line, column };\n\t\t};\n\t}\n\n\tclass Mappings {\n\t\tconstructor(hires) {\n\t\t\tthis.hires = hires;\n\t\t\tthis.generatedCodeLine = 0;\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t\tthis.raw = [];\n\t\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\t\tif (content.length) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t} else if (this.pending) {\n\t\t\t\tthis.rawSegments.push(this.pending);\n\t\t\t}\n\n\t\t\tthis.advance(content);\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\t\tlet originalCharIndex = chunk.start;\n\t\t\tlet first = true;\n\n\t\t\twhile (originalCharIndex < chunk.end) {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t\t}\n\n\t\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\t\tloc.line += 1;\n\t\t\t\t\tloc.column = 0;\n\t\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\t\tfirst = true;\n\t\t\t\t} else {\n\t\t\t\t\tloc.column += 1;\n\t\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\n\t\t\t\toriginalCharIndex += 1;\n\t\t\t}\n\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\tadvance(str) {\n\t\t\tif (!str) return;\n\n\t\t\tconst lines = str.split('\\n');\n\n\t\t\tif (lines.length > 1) {\n\t\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\t}\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t}\n\n\t\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t\t}\n\t}\n\n\tconst n = '\\n';\n\n\tconst warned = {\n\t\tinsertLeft: false,\n\t\tinsertRight: false,\n\t\tstoreName: false,\n\t};\n\n\tclass MagicString {\n\t\tconstructor(string, options = {}) {\n\t\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\toriginal: { writable: true, value: string },\n\t\t\t\toutro: { writable: true, value: '' },\n\t\t\t\tintro: { writable: true, value: '' },\n\t\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\t\tbyStart: { writable: true, value: {} },\n\t\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\t});\n\n\t\t\tthis.byStart[0] = chunk;\n\t\t\tthis.byEnd[string.length] = chunk;\n\t\t}\n\n\t\taddSourcemapLocation(char) {\n\t\t\tthis.sourcemapLocations.add(char);\n\t\t}\n\n\t\tappend(content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\t\tthis.outro += content;\n\t\t\treturn this;\n\t\t}\n\n\t\tappendLeft(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byEnd[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.appendLeft(content);\n\t\t\t} else {\n\t\t\t\tthis.intro += content;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tappendRight(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byStart[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.appendRight(content);\n\t\t\t} else {\n\t\t\t\tthis.outro += content;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\t\tlet originalChunk = this.firstChunk;\n\t\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\t\twhile (originalChunk) {\n\t\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\t\tif (nextClonedChunk) {\n\t\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t\t}\n\n\t\t\t\toriginalChunk = nextOriginalChunk;\n\t\t\t}\n\n\t\t\tcloned.lastChunk = clonedChunk;\n\n\t\t\tif (this.indentExclusionRanges) {\n\t\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t\t}\n\n\t\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\t\tcloned.intro = this.intro;\n\t\t\tcloned.outro = this.outro;\n\n\t\t\treturn cloned;\n\t\t}\n\n\t\tgenerateDecodedMap(options) {\n\t\t\toptions = options || {};\n\n\t\t\tconst sourceIndex = 0;\n\t\t\tconst names = Object.keys(this.storedNames);\n\t\t\tconst mappings = new Mappings(options.hires);\n\n\t\t\tconst locate = getLocator(this.original);\n\n\t\t\tif (this.intro) {\n\t\t\t\tmappings.advance(this.intro);\n\t\t\t}\n\n\t\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (chunk.edited) {\n\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\tloc,\n\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\t\tnames,\n\t\t\t\tmappings: mappings.raw,\n\t\t\t};\n\t\t}\n\n\t\tgenerateMap(options) {\n\t\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t\t}\n\n\t\t_ensureindentStr() {\n\t\t\tif (this.indentStr === undefined) {\n\t\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t\t}\n\t\t}\n\n\t\t_getRawIndentString() {\n\t\t\tthis._ensureindentStr();\n\t\t\treturn this.indentStr;\n\t\t}\n\n\t\tgetIndentString() {\n\t\t\tthis._ensureindentStr();\n\t\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t\t}\n\n\t\tindent(indentStr, options) {\n\t\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\t\tif (isObject(indentStr)) {\n\t\t\t\toptions = indentStr;\n\t\t\t\tindentStr = undefined;\n\t\t\t}\n\n\t\t\tif (indentStr === undefined) {\n\t\t\t\tthis._ensureindentStr();\n\t\t\t\tindentStr = this.indentStr || '\\t';\n\t\t\t}\n\n\t\t\tif (indentStr === '') return this; // noop\n\n\t\t\toptions = options || {};\n\n\t\t\t// Process exclusion ranges\n\t\t\tconst isExcluded = {};\n\n\t\t\tif (options.exclude) {\n\t\t\t\tconst exclusions =\n\t\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\t\tconst replacer = (match) => {\n\t\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\treturn match;\n\t\t\t};\n\n\t\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\t\tlet charIndex = 0;\n\t\t\tlet chunk = this.firstChunk;\n\n\t\t\twhile (chunk) {\n\t\t\t\tconst end = chunk.end;\n\n\t\t\t\tif (chunk.edited) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcharIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharIndex = chunk.end;\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tinsert() {\n\t\t\tthrow new Error(\n\t\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t\t);\n\t\t}\n\n\t\tinsertLeft(index, content) {\n\t\t\tif (!warned.insertLeft) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.insertLeft = true;\n\t\t\t}\n\n\t\t\treturn this.appendLeft(index, content);\n\t\t}\n\n\t\tinsertRight(index, content) {\n\t\t\tif (!warned.insertRight) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.insertRight = true;\n\t\t\t}\n\n\t\t\treturn this.prependRight(index, content);\n\t\t}\n\n\t\tmove(start, end, index) {\n\t\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\t\t\tthis._split(index);\n\n\t\t\tconst first = this.byStart[start];\n\t\t\tconst last = this.byEnd[end];\n\n\t\t\tconst oldLeft = first.previous;\n\t\t\tconst oldRight = last.next;\n\n\t\t\tconst newRight = this.byStart[index];\n\t\t\tif (!newRight && last === this.lastChunk) return this;\n\t\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\t\tif (newLeft) newLeft.next = first;\n\t\t\tif (newRight) newRight.previous = last;\n\n\t\t\tif (!first.previous) this.firstChunk = last.next;\n\t\t\tif (!last.next) {\n\t\t\t\tthis.lastChunk = first.previous;\n\t\t\t\tthis.lastChunk.next = null;\n\t\t\t}\n\n\t\t\tfirst.previous = newLeft;\n\t\t\tlast.next = newRight || null;\n\n\t\t\tif (!newLeft) this.firstChunk = first;\n\t\t\tif (!newRight) this.lastChunk = last;\n\t\t\treturn this;\n\t\t}\n\n\t\toverwrite(start, end, content, options) {\n\t\t\toptions = options || {};\n\t\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t\t}\n\n\t\tupdate(start, end, content, options) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\t\tif (start === end)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t\t);\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\n\t\t\tif (options === true) {\n\t\t\t\tif (!warned.storeName) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\t\twarned.storeName = true;\n\t\t\t\t}\n\n\t\t\t\toptions = { storeName: true };\n\t\t\t}\n\t\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\t\tif (storeName) {\n\t\t\t\tconst original = this.original.slice(start, end);\n\t\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst first = this.byStart[start];\n\t\t\tconst last = this.byEnd[end];\n\n\t\t\tif (first) {\n\t\t\t\tlet chunk = first;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t\t}\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t}\n\n\t\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t\t} else {\n\t\t\t\t// must be inserting at the end\n\t\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\t\tlast.next = newChunk;\n\t\t\t\tnewChunk.previous = last;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tprepend(content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\t\tthis.intro = content + this.intro;\n\t\t\treturn this;\n\t\t}\n\n\t\tprependLeft(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byEnd[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.prependLeft(content);\n\t\t\t} else {\n\t\t\t\tthis.intro = content + this.intro;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tprependRight(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byStart[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.prependRight(content);\n\t\t\t} else {\n\t\t\t\tthis.outro = content + this.outro;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tremove(start, end) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tif (start === end) return this;\n\n\t\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\n\t\t\tlet chunk = this.byStart[start];\n\n\t\t\twhile (chunk) {\n\t\t\t\tchunk.intro = '';\n\t\t\t\tchunk.outro = '';\n\t\t\t\tchunk.edit('');\n\n\t\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tlastChar() {\n\t\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\t\tlet chunk = this.lastChunk;\n\t\t\tdo {\n\t\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t\t} while ((chunk = chunk.previous));\n\t\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\t\treturn '';\n\t\t}\n\n\t\tlastLine() {\n\t\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\t\tlet lineStr = this.outro;\n\t\t\tlet chunk = this.lastChunk;\n\t\t\tdo {\n\t\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t\t}\n\n\t\t\t\tif (chunk.content.length > 0) {\n\t\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t\t}\n\n\t\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t\t}\n\t\t\t} while ((chunk = chunk.previous));\n\t\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\t\treturn this.intro + lineStr;\n\t\t}\n\n\t\tslice(start = 0, end = this.original.length) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tlet result = '';\n\n\t\t\t// find start chunk\n\t\t\tlet chunk = this.firstChunk;\n\t\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t\t// found end chunk before start\n\t\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\t\tconst startChunk = chunk;\n\t\t\twhile (chunk) {\n\t\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\t\tresult += chunk.intro;\n\t\t\t\t}\n\n\t\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\t\tresult += chunk.outro;\n\t\t\t\t}\n\n\t\t\t\tif (containsEnd) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// TODO deprecate this? not really very useful\n\t\tsnip(start, end) {\n\t\t\tconst clone = this.clone();\n\t\t\tclone.remove(0, start);\n\t\t\tclone.remove(end, clone.original.length);\n\n\t\t\treturn clone;\n\t\t}\n\n\t\t_split(index) {\n\t\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\t\tlet chunk = this.lastSearchedChunk;\n\t\t\tconst searchForward = index > chunk.end;\n\n\t\t\twhile (chunk) {\n\t\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t\t}\n\t\t}\n\n\t\t_splitChunk(chunk, index) {\n\t\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst newChunk = chunk.split(index);\n\n\t\t\tthis.byEnd[index] = chunk;\n\t\t\tthis.byStart[index] = newChunk;\n\t\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\t\tthis.lastSearchedChunk = chunk;\n\t\t\treturn true;\n\t\t}\n\n\t\ttoString() {\n\t\t\tlet str = this.intro;\n\n\t\t\tlet chunk = this.firstChunk;\n\t\t\twhile (chunk) {\n\t\t\t\tstr += chunk.toString();\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\treturn str + this.outro;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\tlet chunk = this.firstChunk;\n\t\t\tdo {\n\t\t\t\tif (\n\t\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t\t)\n\t\t\t\t\treturn false;\n\t\t\t} while ((chunk = chunk.next));\n\t\t\treturn true;\n\t\t}\n\n\t\tlength() {\n\t\t\tlet chunk = this.firstChunk;\n\t\t\tlet length = 0;\n\t\t\tdo {\n\t\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t\t} while ((chunk = chunk.next));\n\t\t\treturn length;\n\t\t}\n\n\t\ttrimLines() {\n\t\t\treturn this.trim('[\\\\r\\\\n]');\n\t\t}\n\n\t\ttrim(charType) {\n\t\t\treturn this.trimStart(charType).trimEnd(charType);\n\t\t}\n\n\t\ttrimEndAborted(charType) {\n\t\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\n\t\t\tlet chunk = this.lastChunk;\n\n\t\t\tdo {\n\t\t\t\tconst end = chunk.end;\n\t\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\t\tif (chunk.end !== end) {\n\t\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tif (aborted) return true;\n\t\t\t\tchunk = chunk.previous;\n\t\t\t} while (chunk);\n\n\t\t\treturn false;\n\t\t}\n\n\t\ttrimEnd(charType) {\n\t\t\tthis.trimEndAborted(charType);\n\t\t\treturn this;\n\t\t}\n\t\ttrimStartAborted(charType) {\n\t\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\n\t\t\tlet chunk = this.firstChunk;\n\n\t\t\tdo {\n\t\t\t\tconst end = chunk.end;\n\t\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\t\tif (chunk.end !== end) {\n\t\t\t\t\t// special case...\n\t\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tif (aborted) return true;\n\t\t\t\tchunk = chunk.next;\n\t\t\t} while (chunk);\n\n\t\t\treturn false;\n\t\t}\n\n\t\ttrimStart(charType) {\n\t\t\tthis.trimStartAborted(charType);\n\t\t\treturn this;\n\t\t}\n\n\t\thasChanged() {\n\t\t\treturn this.original !== this.toString();\n\t\t}\n\n\t\t_replaceRegexp(searchValue, replacement) {\n\t\t\tfunction getReplacement(match, str) {\n\t\t\t\tif (typeof replacement === 'string') {\n\t\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\t\tconst num = +i;\n\t\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\t\treturn `$${i}`;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction matchAll(re, str) {\n\t\t\t\tlet match;\n\t\t\t\tconst matches = [];\n\t\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\t\tmatches.push(match);\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t\tif (searchValue.global) {\n\t\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\t\tmatches.forEach((match) => {\n\t\t\t\t\tif (match.index != null)\n\t\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst match = this.original.match(searchValue);\n\t\t\t\tif (match && match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t_replaceString(string, replacement) {\n\t\t\tconst { original } = this;\n\t\t\tconst index = original.indexOf(string);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\treplace(searchValue, replacement) {\n\t\t\tif (typeof searchValue === 'string') {\n\t\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t\t}\n\n\t\t\treturn this._replaceRegexp(searchValue, replacement);\n\t\t}\n\n\t\t_replaceAllString(string, replacement) {\n\t\t\tconst { original } = this;\n\t\t\tconst stringLength = string.length;\n\t\t\tfor (\n\t\t\t\tlet index = original.indexOf(string);\n\t\t\t\tindex !== -1;\n\t\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t\t) {\n\t\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\treplaceAll(searchValue, replacement) {\n\t\t\tif (typeof searchValue === 'string') {\n\t\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t\t}\n\n\t\t\tif (!searchValue.global) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this._replaceRegexp(searchValue, replacement);\n\t\t}\n\t}\n\n\tconst hasOwnProp = Object.prototype.hasOwnProperty;\n\n\tclass Bundle {\n\t\tconstructor(options = {}) {\n\t\t\tthis.intro = options.intro || '';\n\t\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\t\tthis.sources = [];\n\t\t\tthis.uniqueSources = [];\n\t\t\tthis.uniqueSourceIndexByFilename = {};\n\t\t}\n\n\t\taddSource(source) {\n\t\t\tif (source instanceof MagicString) {\n\t\t\t\treturn this.addSource({\n\t\t\t\t\tcontent: source,\n\t\t\t\t\tfilename: source.filename,\n\t\t\t\t\tseparator: this.separator,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!isObject(source) || !source.content) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t\t});\n\n\t\t\tif (source.separator === undefined) {\n\t\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\t\tsource.separator = this.separator;\n\t\t\t}\n\n\t\t\tif (source.filename) {\n\t\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t\t} else {\n\t\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.sources.push(source);\n\t\t\treturn this;\n\t\t}\n\n\t\tappend(str, options) {\n\t\t\tthis.addSource({\n\t\t\t\tcontent: new MagicString(str),\n\t\t\t\tseparator: (options && options.separator) || '',\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst bundle = new Bundle({\n\t\t\t\tintro: this.intro,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tbundle.addSource({\n\t\t\t\t\tfilename: source.filename,\n\t\t\t\t\tcontent: source.content.clone(),\n\t\t\t\t\tseparator: source.separator,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn bundle;\n\t\t}\n\n\t\tgenerateDecodedMap(options = {}) {\n\t\t\tconst names = [];\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tconst mappings = new Mappings(options.hires);\n\n\t\t\tif (this.intro) {\n\t\t\t\tmappings.advance(this.intro);\n\t\t\t}\n\n\t\t\tthis.sources.forEach((source, i) => {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tmappings.advance(this.separator);\n\t\t\t\t}\n\n\t\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\t\tconst magicString = source.content;\n\t\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\t\tif (magicString.intro) {\n\t\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t\t}\n\n\t\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\t\tif (source.filename) {\n\t\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t\t});\n\n\t\t\t\tif (magicString.outro) {\n\t\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t\t}),\n\t\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t\t}),\n\t\t\t\tnames,\n\t\t\t\tmappings: mappings.raw,\n\t\t\t};\n\t\t}\n\n\t\tgenerateMap(options) {\n\t\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t\t}\n\n\t\tgetIndentString() {\n\t\t\tconst indentStringCounts = {};\n\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\t\tif (indentStr === null) return;\n\n\t\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\t\tindentStringCounts[indentStr] += 1;\n\t\t\t});\n\n\t\t\treturn (\n\t\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t\t})[0] || '\\t'\n\t\t\t);\n\t\t}\n\n\t\tindent(indentStr) {\n\t\t\tif (!arguments.length) {\n\t\t\t\tindentStr = this.getIndentString();\n\t\t\t}\n\n\t\t\tif (indentStr === '') return this; // noop\n\n\t\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\t\tthis.sources.forEach((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\t\tsource.content.indent(indentStr, {\n\t\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t\t});\n\n\t\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t\t});\n\n\t\t\tif (this.intro) {\n\t\t\t\tthis.intro =\n\t\t\t\t\tindentStr +\n\t\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tprepend(str) {\n\t\t\tthis.intro = str + this.intro;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoString() {\n\t\t\tconst body = this.sources\n\t\t\t\t.map((source, i) => {\n\t\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\t\treturn str;\n\t\t\t\t})\n\t\t\t\t.join('');\n\n\t\t\treturn this.intro + body;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn this.sources.reduce(\n\t\t\t\t(length, source) => length + source.content.length(),\n\t\t\t\tthis.intro.length\n\t\t\t);\n\t\t}\n\n\t\ttrimLines() {\n\t\t\treturn this.trim('[\\\\r\\\\n]');\n\t\t}\n\n\t\ttrim(charType) {\n\t\t\treturn this.trimStart(charType).trimEnd(charType);\n\t\t}\n\n\t\ttrimStart(charType) {\n\t\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\t\tif (!this.intro) {\n\t\t\t\tlet source;\n\t\t\t\tlet i = 0;\n\n\t\t\t\tdo {\n\t\t\t\t\tsource = this.sources[i++];\n\t\t\t\t\tif (!source) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttrimEnd(charType) {\n\t\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\t\tlet source;\n\t\t\tlet i = this.sources.length - 1;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i--];\n\t\t\t\tif (!source) {\n\t\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tMagicString.Bundle = Bundle;\n\tMagicString.SourceMap = SourceMap;\n\tMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\n\treturn MagicString;\n\n}));\n//# sourceMappingURL=magic-string.umd.js.map\n"}},"magic-string.umd.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.umd.js\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\",\"../src/index-legacy.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"const comma = ','.charCodeAt(0);\\nconst semicolon = ';'.charCodeAt(0);\\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\nconst intToChar = new Uint8Array(64); // 64 possible chars.\\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\\nfor (let i = 0; i < chars.length; i++) {\\n    const c = chars.charCodeAt(i);\\n    intToChar[i] = c;\\n    charToInt[c] = i;\\n}\\n// Provide a fallback for older environments.\\nconst td = typeof TextDecoder !== 'undefined'\\n    ? /* #__PURE__ */ new TextDecoder()\\n    : typeof Buffer !== 'undefined'\\n        ? {\\n            decode(buf) {\\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\\n                return out.toString();\\n            },\\n        }\\n        : {\\n            decode(buf) {\\n                let out = '';\\n                for (let i = 0; i < buf.length; i++) {\\n                    out += String.fromCharCode(buf[i]);\\n                }\\n                return out;\\n            },\\n        };\\nfunction decode(mappings) {\\n    const state = new Int32Array(5);\\n    const decoded = [];\\n    let index = 0;\\n    do {\\n        const semi = indexOf(mappings, index);\\n        const line = [];\\n        let sorted = true;\\n        let lastCol = 0;\\n        state[0] = 0;\\n        for (let i = index; i < semi; i++) {\\n            let seg;\\n            i = decodeInteger(mappings, i, state, 0); // genColumn\\n            const col = state[0];\\n            if (col < lastCol)\\n                sorted = false;\\n            lastCol = col;\\n            if (hasMoreVlq(mappings, i, semi)) {\\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\\n                if (hasMoreVlq(mappings, i, semi)) {\\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\\n                    seg = [col, state[1], state[2], state[3], state[4]];\\n                }\\n                else {\\n                    seg = [col, state[1], state[2], state[3]];\\n                }\\n            }\\n            else {\\n                seg = [col];\\n            }\\n            line.push(seg);\\n        }\\n        if (!sorted)\\n            sort(line);\\n        decoded.push(line);\\n        index = semi + 1;\\n    } while (index <= mappings.length);\\n    return decoded;\\n}\\nfunction indexOf(mappings, index) {\\n    const idx = mappings.indexOf(';', index);\\n    return idx === -1 ? mappings.length : idx;\\n}\\nfunction decodeInteger(mappings, pos, state, j) {\\n    let value = 0;\\n    let shift = 0;\\n    let integer = 0;\\n    do {\\n        const c = mappings.charCodeAt(pos++);\\n        integer = charToInt[c];\\n        value |= (integer & 31) << shift;\\n        shift += 5;\\n    } while (integer & 32);\\n    const shouldNegate = value & 1;\\n    value >>>= 1;\\n    if (shouldNegate) {\\n        value = -0x80000000 | -value;\\n    }\\n    state[j] += value;\\n    return pos;\\n}\\nfunction hasMoreVlq(mappings, i, length) {\\n    if (i >= length)\\n        return false;\\n    return mappings.charCodeAt(i) !== comma;\\n}\\nfunction sort(line) {\\n    line.sort(sortComparator);\\n}\\nfunction sortComparator(a, b) {\\n    return a[0] - b[0];\\n}\\nfunction encode(decoded) {\\n    const state = new Int32Array(5);\\n    const bufLength = 1024 * 16;\\n    const subLength = bufLength - 36;\\n    const buf = new Uint8Array(bufLength);\\n    const sub = buf.subarray(0, subLength);\\n    let pos = 0;\\n    let out = '';\\n    for (let i = 0; i < decoded.length; i++) {\\n        const line = decoded[i];\\n        if (i > 0) {\\n            if (pos === bufLength) {\\n                out += td.decode(buf);\\n                pos = 0;\\n            }\\n            buf[pos++] = semicolon;\\n        }\\n        if (line.length === 0)\\n            continue;\\n        state[0] = 0;\\n        for (let j = 0; j < line.length; j++) {\\n            const segment = line[j];\\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\\n            // may push a comma.\\n            if (pos > subLength) {\\n                out += td.decode(sub);\\n                buf.copyWithin(0, subLength, pos);\\n                pos -= subLength;\\n            }\\n            if (j > 0)\\n                buf[pos++] = comma;\\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\\n            if (segment.length === 1)\\n                continue;\\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\\n            if (segment.length === 4)\\n                continue;\\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\\n        }\\n    }\\n    return out + td.decode(buf.subarray(0, pos));\\n}\\nfunction encodeInteger(buf, pos, state, segment, j) {\\n    const next = segment[j];\\n    let num = next - state[j];\\n    state[j] = next;\\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\\n    do {\\n        let clamped = num & 0b011111;\\n        num >>>= 5;\\n        if (num > 0)\\n            clamped |= 0b100000;\\n        buf[pos++] = intToChar[clamped];\\n    } while (num > 0);\\n    return pos;\\n}\\n\\nexport { decode, encode };\\n//# sourceMappingURL=sourcemap-codec.mjs.map\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t\\tif (typeof properties.x_google_ignoreList !== 'undefined') {\\n\\t\\t\\tthis.x_google_ignoreList = properties.x_google_ignoreList;\\n\\t\\t}\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport Bundle from './Bundle.js';\\nimport SourceMap from './SourceMap.js';\\n\\nMagicString.Bundle = Bundle;\\nMagicString.SourceMap = SourceMap;\\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\\n\\nexport default MagicString;\\n\"],\"names\":[],\"mappings\":\";;;;;;CAAe,MAAM,MAAM,CAAC;CAC5B,CAAC,WAAW,CAAC,GAAG,EAAE;CAClB,EAAE,IAAI,CAAC,IAAI,GAAG,GAAG,YAAY,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC;CAC5D,EAAE;AACF;CACA,CAAC,GAAG,CAAC,CAAC,EAAE;CACR,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;CACrC,EAAE;AACF;CACA,CAAC,GAAG,CAAC,CAAC,EAAE;CACR,EAAE,OAAO,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;CACjD,EAAE;CACF;;CCZe,MAAM,KAAK,CAAC;CAC3B,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE;CAClC,EAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;CACrB,EAAE,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;CACjB,EAAE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;AAC1B;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;CAClB,EAAE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AAClB;CACA,EAAE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;CACzB,EAAE,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;CACzB,EAAE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;AACtB;CACA,EAMS;CACT,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;CACxB,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;CACpB,GAAG;CACH,EAAE;AACF;CACA,CAAC,UAAU,CAAC,OAAO,EAAE;CACrB,EAAE,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC;CACxB,EAAE;AACF;CACA,CAAC,WAAW,CAAC,OAAO,EAAE;CACtB,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;CACpC,EAAE;AACF;CACA,CAAC,KAAK,GAAG;CACT,EAAE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC/D;CACA,EAAE,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CAC3B,EAAE,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CAC3B,EAAE,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;CAC/B,EAAE,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;CACnC,EAAE,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AAC7B;CACA,EAAE,OAAO,KAAK,CAAC;CACf,EAAE;AACF;CACA,CAAC,QAAQ,CAAC,KAAK,EAAE;CACjB,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC;CAChD,EAAE;AACF;CACA,CAAC,QAAQ,CAAC,EAAE,EAAE;CACd,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC;CACnB,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;CACb,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG;CACH,EAAE;AACF;CACA,CAAC,YAAY,CAAC,EAAE,EAAE;CAClB,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC;CACnB,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC;CACb,GAAG,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC;CAC1B,GAAG;CACH,EAAE;AACF;CACA,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE;CACvC,EAAE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;CACzB,EAAE,IAAI,CAAC,WAAW,EAAE;CACpB,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;CACnB,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;CACnB,GAAG;CACH,EAAE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;AAC7B;CACA,EAAE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;AACrB;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,WAAW,CAAC,OAAO,EAAE;CACtB,EAAE,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CACpC,EAAE;AACF;CACA,CAAC,YAAY,CAAC,OAAO,EAAE;CACvB,EAAE,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CACpC,EAAE;AACF;CACA,CAAC,KAAK,CAAC,KAAK,EAAE;CACd,EAAE,MAAM,UAAU,GAAG,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AACxC;CACA,EAAE,MAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;CAC5D,EAAE,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AACxD;CACA,EAAE,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC;AACjC;CACA,EAAE,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,aAAa,CAAC,CAAC;CAC7D,EAAE,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CAC9B,EAAE,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AAClB;CACA,EAAE,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;AACnB;CACA,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE;CACnB;CACA,GAAG,QAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;CAC5B,GAAG,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;CACrB,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,OAAO,GAAG,cAAc,CAAC;CACjC,GAAG;AACH;CACA,EAAE,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;CAC5B,EAAE,IAAI,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;CACvD,EAAE,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;CAC3B,EAAE,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;AACvB;CACA,EAAE,OAAO,QAAQ,CAAC;CAClB,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CAChD,EAAE;AACF;CACA,CAAC,OAAO,CAAC,EAAE,EAAE;CACb,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC1C,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AACrC;CACA,EAAE,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC/C;CACA,EAAE,IAAI,OAAO,CAAC,MAAM,EAAE;CACtB,GAAG,IAAI,OAAO,KAAK,IAAI,CAAC,OAAO,EAAE;CACjC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;CACtE,IAAI;CACJ,GAAG,OAAO,IAAI,CAAC;CACf,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;AAClC;CACA,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC3C,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;CACtC,GAAG;CACH,EAAE;AACF;CACA,CAAC,SAAS,CAAC,EAAE,EAAE;CACf,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC1C,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AACrC;CACA,EAAE,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC/C;CACA,EAAE,IAAI,OAAO,CAAC,MAAM,EAAE;CACtB,GAAG,IAAI,OAAO,KAAK,IAAI,CAAC,OAAO,EAAE;CACjC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;CAC1C,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;CACnC,IAAI;CACJ,GAAG,OAAO,IAAI,CAAC;CACf,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;AAClC;CACA,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC3C,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;CACtC,GAAG;CACH,EAAE;CACF;;CC9JA,MAAM,KAAK,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;CAChC,MAAM,SAAS,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;CACpC,MAAM,KAAK,GAAG,kEAAkE,CAAC;CACjF,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;CACrC,MAAM,SAAS,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;CACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;CACvC,IAAI,MAAM,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;CAClC,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;CACrB,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;CACrB,CAAC;CACD;CACA,MAAM,EAAE,GAAG,OAAO,WAAW,KAAK,WAAW;CAC7C,sBAAsB,IAAI,WAAW,EAAE;CACvC,MAAM,OAAO,MAAM,KAAK,WAAW;CACnC,UAAU;CACV,YAAY,MAAM,CAAC,GAAG,EAAE;CACxB,gBAAgB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;CACpF,gBAAgB,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;CACtC,aAAa;CACb,SAAS;CACT,UAAU;CACV,YAAY,MAAM,CAAC,GAAG,EAAE;CACxB,gBAAgB,IAAI,GAAG,GAAG,EAAE,CAAC;CAC7B,gBAAgB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;CACrD,oBAAoB,GAAG,IAAI,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;CACvD,iBAAiB;CACjB,gBAAgB,OAAO,GAAG,CAAC;CAC3B,aAAa;CACb,SAAS,CAAC;CA2EV,SAAS,MAAM,CAAC,OAAO,EAAE;CACzB,IAAI,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;CACpC,IAAI,MAAM,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;CAChC,IAAI,MAAM,SAAS,GAAG,SAAS,GAAG,EAAE,CAAC;CACrC,IAAI,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;CAC1C,IAAI,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;CAC3C,IAAI,IAAI,GAAG,GAAG,CAAC,CAAC;CAChB,IAAI,IAAI,GAAG,GAAG,EAAE,CAAC;CACjB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;CAC7C,QAAQ,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;CAChC,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE;CACnB,YAAY,IAAI,GAAG,KAAK,SAAS,EAAE;CACnC,gBAAgB,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;CACtC,gBAAgB,GAAG,GAAG,CAAC,CAAC;CACxB,aAAa;CACb,YAAY,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC;CACnC,SAAS;CACT,QAAQ,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;CAC7B,YAAY,SAAS;CACrB,QAAQ,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;CACrB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;CAC9C,YAAY,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;CACpC;CACA;CACA,YAAY,IAAI,GAAG,GAAG,SAAS,EAAE;CACjC,gBAAgB,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;CACtC,gBAAgB,GAAG,CAAC,UAAU,CAAC,CAAC,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;CAClD,gBAAgB,GAAG,IAAI,SAAS,CAAC;CACjC,aAAa;CACb,YAAY,IAAI,CAAC,GAAG,CAAC;CACrB,gBAAgB,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,KAAK,CAAC;CACnC,YAAY,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;CAC7D,YAAY,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;CACpC,gBAAgB,SAAS;CACzB,YAAY,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;CAC7D,YAAY,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;CAC7D,YAAY,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;CAC7D,YAAY,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;CACpC,gBAAgB,SAAS;CACzB,YAAY,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;CAC7D,SAAS;CACT,KAAK;CACL,IAAI,OAAO,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;CACjD,CAAC;CACD,SAAS,aAAa,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,EAAE;CACpD,IAAI,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;CAC5B,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;CAC9B,IAAI,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;CACpB,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;CAC/C,IAAI,GAAG;CACP,QAAQ,IAAI,OAAO,GAAG,GAAG,GAAG,QAAQ,CAAC;CACrC,QAAQ,GAAG,MAAM,CAAC,CAAC;CACnB,QAAQ,IAAI,GAAG,GAAG,CAAC;CACnB,YAAY,OAAO,IAAI,QAAQ,CAAC;CAChC,QAAQ,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;CACxC,KAAK,QAAQ,GAAG,GAAG,CAAC,EAAE;CACtB,IAAI,OAAO,GAAG,CAAC;CACf;;CC9JA,SAAS,OAAO,IAAI;CACpB,CAAC,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE;CACzE,EAAE,OAAO,CAAC,GAAG,KAAK,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;CACjE,EAAE,MAAM,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;CAC1C,EAAE,OAAO,CAAC,GAAG,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;CAC/D,EAAE,MAAM;CACR,EAAE,OAAO,MAAM;CACf,GAAG,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC,CAAC;CAC9F,GAAG,CAAC;CACJ,EAAE;CACF,CAAC;AACD;CACA,MAAM,IAAI,iBAAiB,OAAO,EAAE,CAAC;AACrC;CACe,MAAM,SAAS,CAAC;CAC/B,CAAC,WAAW,CAAC,UAAU,EAAE;CACzB,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;CACnB,EAAE,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;CAC9B,EAAE,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,OAAO,CAAC;CACpC,EAAE,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC,cAAc,CAAC;CAClD,EAAE,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;CAChC,EAAE,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;CAC9C,EAAE,IAAI,OAAO,UAAU,CAAC,mBAAmB,KAAK,WAAW,EAAE;CAC7D,GAAG,IAAI,CAAC,mBAAmB,GAAG,UAAU,CAAC,mBAAmB,CAAC;CAC7D,GAAG;CACH,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;CAC9B,EAAE;AACF;CACA,CAAC,KAAK,GAAG;CACT,EAAE,OAAO,6CAA6C,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;CAC/E,EAAE;CACF;;CCpCe,SAAS,WAAW,CAAC,IAAI,EAAE;CAC1C,CAAC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAChC;CACA,CAAC,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;CAC1D,CAAC,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5D;CACA,CAAC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;CACjD,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA;CACA;CACA;CACA,CAAC,IAAI,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,EAAE;CACrC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA;CACA,CAAC,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,OAAO,KAAK;CAClD,EAAE,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;CAClD,EAAE,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;CACvC,EAAE,EAAE,QAAQ,CAAC,CAAC;AACd;CACA,CAAC,OAAO,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;CACrC;;CCxBe,SAAS,eAAe,CAAC,IAAI,EAAE,EAAE,EAAE;CAClD,CAAC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;CACvC,CAAC,MAAM,OAAO,GAAG,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;AACnC;CACA,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC;AACjB;CACA,CAAC,OAAO,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE;CACrC,EAAE,SAAS,CAAC,KAAK,EAAE,CAAC;CACpB,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC;CAClB,EAAE;AACF;CACA,CAAC,IAAI,SAAS,CAAC,MAAM,EAAE;CACvB,EAAE,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC;CAC3B,EAAE,OAAO,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;CAClC,EAAE;AACF;CACA,CAAC,OAAO,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;CAC5C;;CCjBA,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAC3C;CACe,SAAS,QAAQ,CAAC,KAAK,EAAE;CACxC,CAAC,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,iBAAiB,CAAC;CACnD;;CCJe,SAAS,UAAU,CAAC,MAAM,EAAE;CAC3C,CAAC,MAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;CAC1C,CAAC,MAAM,WAAW,GAAG,EAAE,CAAC;AACxB;CACA,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;CACzD,EAAE,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;CACxB,EAAE,GAAG,IAAI,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;CACrC,EAAE;AACF;CACA,CAAC,OAAO,SAAS,MAAM,CAAC,KAAK,EAAE;CAC/B,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;CACZ,EAAE,IAAI,CAAC,GAAG,WAAW,CAAC,MAAM,CAAC;CAC7B,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE;CAChB,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;CAC1B,GAAG,IAAI,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,EAAE;CAC/B,IAAI,CAAC,GAAG,CAAC,CAAC;CACV,IAAI,MAAM;CACV,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;CACd,IAAI;CACJ,GAAG;CACH,EAAE,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;CACrB,EAAE,MAAM,MAAM,GAAG,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;CAC3C,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;CAC1B,EAAE,CAAC;CACH;;CCxBe,MAAM,QAAQ,CAAC;CAC9B,CAAC,WAAW,CAAC,KAAK,EAAE;CACpB,EAAE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;CACrB,EAAE,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;CAC7B,EAAE,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;CAC/B,EAAE,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;CAChB,EAAE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC;CAC3D,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;CACtB,EAAE;AACF;CACA,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE;CAC/C,EAAE,IAAI,OAAO,CAAC,MAAM,EAAE;CACtB,GAAG,MAAM,OAAO,GAAG,CAAC,IAAI,CAAC,mBAAmB,EAAE,WAAW,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;CACjF,GAAG,IAAI,SAAS,IAAI,CAAC,EAAE;CACvB,IAAI,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;CAC5B,IAAI;CACJ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;CAClC,GAAG,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;CAC3B,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;CACvC,GAAG;AACH;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;CACxB,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;CACtB,EAAE;AACF;CACA,CAAC,gBAAgB,CAAC,WAAW,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,EAAE,kBAAkB,EAAE;CACzE,EAAE,IAAI,iBAAiB,GAAG,KAAK,CAAC,KAAK,CAAC;CACtC,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC;AACnB;CACA,EAAE,OAAO,iBAAiB,GAAG,KAAK,CAAC,GAAG,EAAE;CACxC,GAAG,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,IAAI,kBAAkB,CAAC,GAAG,CAAC,iBAAiB,CAAC,EAAE;CACzE,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,WAAW,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;CACzF,IAAI;AACJ;CACA,GAAG,IAAI,QAAQ,CAAC,iBAAiB,CAAC,KAAK,IAAI,EAAE;CAC7C,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC;CAClB,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;CACnB,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,CAAC;CAChC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;CAC7D,IAAI,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;CACjC,IAAI,KAAK,GAAG,IAAI,CAAC;CACjB,IAAI,MAAM;CACV,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC;CACpB,IAAI,IAAI,CAAC,mBAAmB,IAAI,CAAC,CAAC;CAClC,IAAI,KAAK,GAAG,KAAK,CAAC;CAClB,IAAI;AACJ;CACA,GAAG,iBAAiB,IAAI,CAAC,CAAC;CAC1B,GAAG;AACH;CACA,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;CACtB,EAAE;AACF;CACA,CAAC,OAAO,CAAC,GAAG,EAAE;CACd,EAAE,IAAI,CAAC,GAAG,EAAE,OAAO;AACnB;CACA,EAAE,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAChC;CACA,EAAE,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;CACxB,GAAG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;CAC9C,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;CAC7B,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;CAC7D,IAAI;CACJ,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;CAChC,GAAG;AACH;CACA,EAAE,IAAI,CAAC,mBAAmB,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC;CAC7D,EAAE;CACF;;CC1DA,MAAM,CAAC,GAAG,IAAI,CAAC;AACf;CACA,MAAM,MAAM,GAAG;CACf,CAAC,UAAU,EAAE,KAAK;CAClB,CAAC,WAAW,EAAE,KAAK;CACnB,CAAC,SAAS,EAAE,KAAK;CACjB,CAAC,CAAC;AACF;CACe,MAAM,WAAW,CAAC;CACjC,CAAC,WAAW,CAAC,MAAM,EAAE,OAAO,GAAG,EAAE,EAAE;CACnC,EAAE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AACpD;CACA,EAAE,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE;CAChC,GAAG,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE;CAC9C,GAAG,KAAK,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;CACvC,GAAG,KAAK,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;CACvC,GAAG,UAAU,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;CAC/C,GAAG,SAAS,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;CAC9C,GAAG,iBAAiB,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;CACtD,GAAG,OAAO,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;CACzC,GAAG,KAAK,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;CACvC,GAAG,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,QAAQ,EAAE;CACxD,GAAG,qBAAqB,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC,qBAAqB,EAAE;CAClF,GAAG,kBAAkB,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,MAAM,EAAE,EAAE;CAC9D,GAAG,WAAW,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;CAC7C,GAAG,SAAS,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE;CAClD,GAAG,CAAC,CAAC;AAKL;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;CAC1B,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC;CACpC,EAAE;AACF;CACA,CAAC,oBAAoB,CAAC,IAAI,EAAE;CAC5B,EAAE,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;CACpC,EAAE;AACF;CACA,CAAC,MAAM,CAAC,OAAO,EAAE;CACjB,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AACzF;CACA,EAAE,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC;CACxB,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,EAAE;CAC5B,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;AAG5F;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClC;CACA,EAAE,IAAI,KAAK,EAAE;CACb,GAAG,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;CAC7B,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC;CACzB,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE;CAC7B,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;AAG5F;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACpC;CACA,EAAE,IAAI,KAAK,EAAE;CACb,GAAG,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;CAC9B,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC;CACzB,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,KAAK,GAAG;CACT,EAAE,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC7E;CACA,EAAE,IAAI,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC;CACtC,EAAE,IAAI,WAAW,IAAI,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,iBAAiB,GAAG,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;AAC3F;CACA,EAAE,OAAO,aAAa,EAAE;CACxB,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC;CACnD,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC;AAC/C;CACA,GAAG,MAAM,iBAAiB,GAAG,aAAa,CAAC,IAAI,CAAC;CAChD,GAAG,MAAM,eAAe,GAAG,iBAAiB,IAAI,iBAAiB,CAAC,KAAK,EAAE,CAAC;AAC1E;CACA,GAAG,IAAI,eAAe,EAAE;CACxB,IAAI,WAAW,CAAC,IAAI,GAAG,eAAe,CAAC;CACvC,IAAI,eAAe,CAAC,QAAQ,GAAG,WAAW,CAAC;AAC3C;CACA,IAAI,WAAW,GAAG,eAAe,CAAC;CAClC,IAAI;AACJ;CACA,GAAG,aAAa,GAAG,iBAAiB,CAAC;CACrC,GAAG;AACH;CACA,EAAE,MAAM,CAAC,SAAS,GAAG,WAAW,CAAC;AACjC;CACA,EAAE,IAAI,IAAI,CAAC,qBAAqB,EAAE;CAClC,GAAG,MAAM,CAAC,qBAAqB,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,EAAE,CAAC;CACrE,GAAG;AACH;CACA,EAAE,MAAM,CAAC,kBAAkB,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;AAClE;CACA,EAAE,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;CAC5B,EAAE,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;AAC5B;CACA,EAAE,OAAO,MAAM,CAAC;CAChB,EAAE;AACF;CACA,CAAC,kBAAkB,CAAC,OAAO,EAAE;CAC7B,EAAE,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AAC1B;CACA,EAAE,MAAM,WAAW,GAAG,CAAC,CAAC;CACxB,EAAE,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;CAC9C,EAAE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC/C;CACA,EAAE,MAAM,MAAM,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC3C;CACA,EAAE,IAAI,IAAI,CAAC,KAAK,EAAE;CAClB,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;CAChC,GAAG;AACH;CACA,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK;CACtC,GAAG,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACnC;CACA,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACzD;CACA,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE;CACrB,IAAI,QAAQ,CAAC,OAAO;CACpB,KAAK,WAAW;CAChB,KAAK,KAAK,CAAC,OAAO;CAClB,KAAK,GAAG;CACR,KAAK,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;CACzD,KAAK,CAAC;CACN,IAAI,MAAM;CACV,IAAI,QAAQ,CAAC,gBAAgB,CAAC,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC;CAC/F,IAAI;AACJ;CACA,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;CACzD,GAAG,CAAC,CAAC;AACL;CACA,EAAE,OAAO;CACT,GAAG,IAAI,EAAE,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,IAAI;CAChE,GAAG,OAAO,EAAE,CAAC,OAAO,CAAC,MAAM,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;CACzF,GAAG,cAAc,EAAE,OAAO,CAAC,cAAc,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC;CACpE,GAAG,KAAK;CACR,GAAG,QAAQ,EAAE,QAAQ,CAAC,GAAG;CACzB,GAAG,CAAC;CACJ,EAAE;AACF;CACA,CAAC,WAAW,CAAC,OAAO,EAAE;CACtB,EAAE,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC;CACzD,EAAE;AACF;CACA,CAAC,gBAAgB,GAAG;CACpB,EAAE,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;CACpC,GAAG,IAAI,CAAC,SAAS,GAAG,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;CAC/C,GAAG;CACH,EAAE;AACF;CACA,CAAC,mBAAmB,GAAG;CACvB,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC;CAC1B,EAAE,OAAO,IAAI,CAAC,SAAS,CAAC;CACxB,EAAE;AACF;CACA,CAAC,eAAe,GAAG;CACnB,EAAE,IAAI,CAAC,gBAAgB,EAAE,CAAC;CAC1B,EAAE,OAAO,IAAI,CAAC,SAAS,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;CACzD,EAAE;AACF;CACA,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE;CAC5B,EAAE,MAAM,OAAO,GAAG,YAAY,CAAC;AAC/B;CACA,EAAE,IAAI,QAAQ,CAAC,SAAS,CAAC,EAAE;CAC3B,GAAG,OAAO,GAAG,SAAS,CAAC;CACvB,GAAG,SAAS,GAAG,SAAS,CAAC;CACzB,GAAG;AACH;CACA,EAAE,IAAI,SAAS,KAAK,SAAS,EAAE;CAC/B,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;CAC3B,GAAG,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC;CACtC,GAAG;AACH;CACA,EAAE,IAAI,SAAS,KAAK,EAAE,EAAE,OAAO,IAAI,CAAC;AACpC;CACA,EAAE,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AAC1B;CACA;CACA,EAAE,MAAM,UAAU,GAAG,EAAE,CAAC;AACxB;CACA,EAAE,IAAI,OAAO,CAAC,OAAO,EAAE;CACvB,GAAG,MAAM,UAAU;CACnB,IAAI,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC;CACjF,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,KAAK;CACrC,IAAI,KAAK,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;CACzD,KAAK,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;CAC1B,KAAK;CACL,IAAI,CAAC,CAAC;CACN,GAAG;AACH;CACA,EAAE,IAAI,yBAAyB,GAAG,OAAO,CAAC,WAAW,KAAK,KAAK,CAAC;CAChE,EAAE,MAAM,QAAQ,GAAG,CAAC,KAAK,KAAK;CAC9B,GAAG,IAAI,yBAAyB,EAAE,OAAO,CAAC,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;CAChE,GAAG,yBAAyB,GAAG,IAAI,CAAC;CACpC,GAAG,OAAO,KAAK,CAAC;CAChB,GAAG,CAAC;AACJ;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACrD;CACA,EAAE,IAAI,SAAS,GAAG,CAAC,CAAC;CACpB,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;AAC9B;CACA,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;AACzB;CACA,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE;CACrB,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;CAChC,KAAK,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AAC9D;CACA,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE;CAC/B,MAAM,yBAAyB,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC;CACnF,MAAM;CACN,KAAK;CACL,IAAI,MAAM;CACV,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC;AAC5B;CACA,IAAI,OAAO,SAAS,GAAG,GAAG,EAAE;CAC5B,KAAK,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;CACjC,MAAM,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AAC5C;CACA,MAAM,IAAI,IAAI,KAAK,IAAI,EAAE;CACzB,OAAO,yBAAyB,GAAG,IAAI,CAAC;CACxC,OAAO,MAAM,IAAI,IAAI,KAAK,IAAI,IAAI,yBAAyB,EAAE;CAC7D,OAAO,yBAAyB,GAAG,KAAK,CAAC;AACzC;CACA,OAAO,IAAI,SAAS,KAAK,KAAK,CAAC,KAAK,EAAE;CACtC,QAAQ,KAAK,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;CACtC,QAAQ,MAAM;CACd,QAAQ,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;CAC3C,QAAQ,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CAC3B,QAAQ,KAAK,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;CACtC,QAAQ;CACR,OAAO;CACP,MAAM;AACN;CACA,KAAK,SAAS,IAAI,CAAC,CAAC;CACpB,KAAK;CACL,IAAI;AACJ;CACA,GAAG,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC;CACzB,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG;AACH;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AACrD;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,MAAM,GAAG;CACV,EAAE,MAAM,IAAI,KAAK;CACjB,GAAG,iFAAiF;CACpF,GAAG,CAAC;CACJ,EAAE;AACF;CACA,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,EAAE;CAC5B,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;CAC1B,GAAG,OAAO,CAAC,IAAI;CACf,IAAI,oFAAoF;CACxF,IAAI,CAAC;CACL,GAAG,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC;CAC5B,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;CACzC,EAAE;AACF;CACA,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE;CAC7B,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;CAC3B,GAAG,OAAO,CAAC,IAAI;CACf,IAAI,uFAAuF;CAC3F,IAAI,CAAC;CACL,GAAG,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC;CAC7B,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;CAC3C,EAAE;AACF;CACA,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE;CACzB,EAAE,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;AAG/F;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;CACrB,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;CACnB,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;CACpC,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC/B;CACA,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,QAAQ,CAAC;CACjC,EAAE,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;AAC7B;CACA,EAAE,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;CACvC,EAAE,IAAI,CAAC,QAAQ,IAAI,IAAI,KAAK,IAAI,CAAC,SAAS,EAAE,OAAO,IAAI,CAAC;CACxD,EAAE,MAAM,OAAO,GAAG,QAAQ,GAAG,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;AAChE;CACA,EAAE,IAAI,OAAO,EAAE,OAAO,CAAC,IAAI,GAAG,QAAQ,CAAC;CACvC,EAAE,IAAI,QAAQ,EAAE,QAAQ,CAAC,QAAQ,GAAG,OAAO,CAAC;AAC5C;CACA,EAAE,IAAI,OAAO,EAAE,OAAO,CAAC,IAAI,GAAG,KAAK,CAAC;CACpC,EAAE,IAAI,QAAQ,EAAE,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;AACzC;CACA,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC;CACnD,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;CAClB,GAAG,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC;CACnC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC;CAC9B,GAAG;AACH;CACA,EAAE,KAAK,CAAC,QAAQ,GAAG,OAAO,CAAC;CAC3B,EAAE,IAAI,CAAC,IAAI,GAAG,QAAQ,IAAI,IAAI,CAAC;AAC/B;CACA,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;CACxC,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;CAGvC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE;CACzC,EAAE,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;CAC1B,EAAE,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,GAAG,OAAO,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;CAC3F,EAAE;AACF;CACA,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE;CACtC,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,sCAAsC,CAAC,CAAC;AAC/F;CACA,EAAE,OAAO,KAAK,GAAG,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;CAClD,EAAE,OAAO,GAAG,GAAG,CAAC,EAAE,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AAC9C;CACA,EAAE,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;CAC1E,EAAE,IAAI,KAAK,KAAK,GAAG;CACnB,GAAG,MAAM,IAAI,KAAK;CAClB,IAAI,+EAA+E;CACnF,IAAI,CAAC;AAGL;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;CACrB,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACnB;CACA,EAAE,IAAI,OAAO,KAAK,IAAI,EAAE;CACxB,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;CAC1B,IAAI,OAAO,CAAC,IAAI;CAChB,KAAK,+HAA+H;CACpI,KAAK,CAAC;CACN,IAAI,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC;CAC5B,IAAI;AACJ;CACA,GAAG,OAAO,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;CACjC,GAAG;CACH,EAAE,MAAM,SAAS,GAAG,OAAO,KAAK,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC;CACtE,EAAE,MAAM,SAAS,GAAG,OAAO,KAAK,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC;AACtE;CACA,EAAE,IAAI,SAAS,EAAE;CACjB,GAAG,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;CACpD,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,EAAE;CACrD,IAAI,QAAQ,EAAE,IAAI;CAClB,IAAI,KAAK,EAAE,IAAI;CACf,IAAI,UAAU,EAAE,IAAI;CACpB,IAAI,CAAC,CAAC;CACN,GAAG;AACH;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;CACpC,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC/B;CACA,EAAE,IAAI,KAAK,EAAE;CACb,GAAG,IAAI,KAAK,GAAG,KAAK,CAAC;CACrB,GAAG,OAAO,KAAK,KAAK,IAAI,EAAE;CAC1B,IAAI,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;CAChD,KAAK,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;CAC9D,KAAK;CACL,IAAI,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACvB,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;CAC1B,IAAI;AACJ;CACA,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC;CAC9C,GAAG,MAAM;CACT;CACA,GAAG,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AACvE;CACA;CACA,GAAG,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;CACxB,GAAG,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;CAC5B,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,OAAO,CAAC,OAAO,EAAE;CAClB,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AACzF;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CACpC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE;CAC7B,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;AAG5F;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAClC;CACA,EAAE,IAAI,KAAK,EAAE;CACb,GAAG,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;CAC9B,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CACrC,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,YAAY,CAAC,KAAK,EAAE,OAAO,EAAE;CAC9B,EAAE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,IAAI,SAAS,CAAC,mCAAmC,CAAC,CAAC;AAG5F;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AACrB;CACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACpC;CACA,EAAE,IAAI,KAAK,EAAE;CACb,GAAG,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;CAC/B,GAAG,MAAM;CACT,GAAG,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CACrC,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,MAAM,CAAC,KAAK,EAAE,GAAG,EAAE;CACpB,EAAE,OAAO,KAAK,GAAG,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;CAClD,EAAE,OAAO,GAAG,GAAG,CAAC,EAAE,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AAC9C;CACA,EAAE,IAAI,KAAK,KAAK,GAAG,EAAE,OAAO,IAAI,CAAC;AACjC;CACA,EAAE,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;CAC7F,EAAE,IAAI,KAAK,GAAG,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;AAGrE;CACA,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;CACrB,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACnB;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAClC;CACA,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC;CACpB,GAAG,KAAK,CAAC,KAAK,GAAG,EAAE,CAAC;CACpB,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AAClB;CACA,GAAG,KAAK,GAAG,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;CAC5D,GAAG;CAGH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;CAClE,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;CAC7B,EAAE,GAAG;CACL,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;CACtE,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;CAC5E,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;CACtE,GAAG,SAAS,KAAK,GAAG,KAAK,CAAC,QAAQ,GAAG;CACrC,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;CAClE,EAAE,OAAO,EAAE,CAAC;CACZ,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;CAC5C,EAAE,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;CAChE,EAAE,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;CAC3B,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;CAC7B,EAAE,GAAG;CACL,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;CAC/B,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;CAC3C,IAAI,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC;CAC7E,IAAI,OAAO,GAAG,KAAK,CAAC,KAAK,GAAG,OAAO,CAAC;CACpC,IAAI;AACJ;CACA,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;CACjC,IAAI,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;CAC7C,IAAI,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC;CAC/E,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC;CACtC,IAAI;AACJ;CACA,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;CAC/B,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;CAC3C,IAAI,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC;CAC7E,IAAI,OAAO,GAAG,KAAK,CAAC,KAAK,GAAG,OAAO,CAAC;CACpC,IAAI;CACJ,GAAG,SAAS,KAAK,GAAG,KAAK,CAAC,QAAQ,GAAG;CACrC,EAAE,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;CACxC,EAAE,IAAI,SAAS,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC;CAC1E,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;CAC9B,EAAE;AACF;CACA,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;CAC9C,EAAE,OAAO,KAAK,GAAG,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;CAClD,EAAE,OAAO,GAAG,GAAG,CAAC,EAAE,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;AAC9C;CACA,EAAE,IAAI,MAAM,GAAG,EAAE,CAAC;AAClB;CACA;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;CAC9B,EAAE,OAAO,KAAK,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,GAAG,IAAI,KAAK,CAAC,EAAE;CAC/D;CACA,GAAG,IAAI,KAAK,CAAC,KAAK,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE;CAC9C,IAAI,OAAO,MAAM,CAAC;CAClB,IAAI;AACJ;CACA,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG;AACH;CACA,EAAE,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK;CACpD,GAAG,MAAM,IAAI,KAAK,CAAC,CAAC,8BAA8B,EAAE,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAC;AACpF;CACA,EAAE,MAAM,UAAU,GAAG,KAAK,CAAC;CAC3B,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,IAAI,KAAK,CAAC,KAAK,KAAK,UAAU,KAAK,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,EAAE;CACvE,IAAI,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC;CAC1B,IAAI;AACJ;CACA,GAAG,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,GAAG,GAAG,IAAI,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC;CAC7D,GAAG,IAAI,WAAW,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,KAAK,GAAG;CACvD,IAAI,MAAM,IAAI,KAAK,CAAC,CAAC,8BAA8B,EAAE,GAAG,CAAC,qBAAqB,CAAC,CAAC,CAAC;AACjF;CACA,GAAG,MAAM,UAAU,GAAG,UAAU,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;CACrE,GAAG,MAAM,QAAQ,GAAG,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC;AAChG;CACA,GAAG,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AACvD;CACA,GAAG,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE;CAC3D,IAAI,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC;CAC1B,IAAI;AACJ;CACA,GAAG,IAAI,WAAW,EAAE;CACpB,IAAI,MAAM;CACV,IAAI;AACJ;CACA,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG;AACH;CACA,EAAE,OAAO,MAAM,CAAC;CAChB,EAAE;AACF;CACA;CACA,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE;CAClB,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;CAC7B,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;CACzB,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;AAC3C;CACA,EAAE,OAAO,KAAK,CAAC;CACf,EAAE;AACF;CACA,CAAC,MAAM,CAAC,KAAK,EAAE;CACf,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,OAAO;AAGvD;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,iBAAiB,CAAC;CACrC,EAAE,MAAM,aAAa,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC;AAC1C;CACA,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACpE;CACA,GAAG,KAAK,GAAG,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;CAC7E,GAAG;CACH,EAAE;AACF;CACA,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE;CAC3B,EAAE,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE;CAC5C;CACA,GAAG,MAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,CAAC;CAChD,GAAG,MAAM,IAAI,KAAK;CAClB,IAAI,CAAC,mDAAmD,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;CACzG,IAAI,CAAC;CACL,GAAG;AACH;CACA,EAAE,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACtC;CACA,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;CAC5B,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;CACjC,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;AACtC;CACA,EAAE,IAAI,KAAK,KAAK,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;AAC1D;CACA,EAAE,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;CAEjC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,IAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;AACvB;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;CAC9B,EAAE,OAAO,KAAK,EAAE;CAChB,GAAG,GAAG,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;CAC3B,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG;AACH;CACA,EAAE,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;CAC1B,EAAE;AACF;CACA,CAAC,OAAO,GAAG;CACX,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;CAC9B,EAAE,GAAG;CACL,GAAG;CACH,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE;CAC7C,KAAK,KAAK,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;CAClD,KAAK,KAAK,CAAC,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;CAC9C;CACA,IAAI,OAAO,KAAK,CAAC;CACjB,GAAG,SAAS,KAAK,GAAG,KAAK,CAAC,IAAI,GAAG;CACjC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,MAAM,GAAG;CACV,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;CAC9B,EAAE,IAAI,MAAM,GAAG,CAAC,CAAC;CACjB,EAAE,GAAG;CACL,GAAG,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC;CAC5E,GAAG,SAAS,KAAK,GAAG,KAAK,CAAC,IAAI,GAAG;CACjC,EAAE,OAAO,MAAM,CAAC;CAChB,EAAE;AACF;CACA,CAAC,SAAS,GAAG;CACb,EAAE,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;CAC/B,EAAE;AACF;CACA,CAAC,IAAI,CAAC,QAAQ,EAAE;CAChB,EAAE,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;CACpD,EAAE;AACF;CACA,CAAC,cAAc,CAAC,QAAQ,EAAE;CAC1B,EAAE,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,CAAC,QAAQ,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC;AACpD;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC1C,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AACrC;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;AAC7B;CACA,EAAE,GAAG;CACL,GAAG,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;CACzB,GAAG,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AACrC;CACA;CACA,GAAG,IAAI,KAAK,CAAC,GAAG,KAAK,GAAG,EAAE;CAC1B,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;CAClC,KAAK,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC;CACjC,KAAK;AACL;CACA,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;CAClC,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;CAChD,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;CAC5C,IAAI;AACJ;CACA,GAAG,IAAI,OAAO,EAAE,OAAO,IAAI,CAAC;CAC5B,GAAG,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC;CAC1B,GAAG,QAAQ,KAAK,EAAE;AAClB;CACA,EAAE,OAAO,KAAK,CAAC;CACf,EAAE;AACF;CACA,CAAC,OAAO,CAAC,QAAQ,EAAE;CACnB,EAAE,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;CAChC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;CACF,CAAC,gBAAgB,CAAC,QAAQ,EAAE;CAC5B,EAAE,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,QAAQ,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;AACzD;CACA,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC1C,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC;AACrC;CACA,EAAE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;AAC9B;CACA,EAAE,GAAG;CACL,GAAG,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;CACzB,GAAG,MAAM,OAAO,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;AACvC;CACA,GAAG,IAAI,KAAK,CAAC,GAAG,KAAK,GAAG,EAAE;CAC1B;CACA,IAAI,IAAI,KAAK,KAAK,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC;AAC9D;CACA,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;CAClC,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;CAChD,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;CAC5C,IAAI;AACJ;CACA,GAAG,IAAI,OAAO,EAAE,OAAO,IAAI,CAAC;CAC5B,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;CACtB,GAAG,QAAQ,KAAK,EAAE;AAClB;CACA,EAAE,OAAO,KAAK,CAAC;CACf,EAAE;AACF;CACA,CAAC,SAAS,CAAC,QAAQ,EAAE;CACrB,EAAE,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;CAClC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,UAAU,GAAG;CACd,EAAE,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC;CAC3C,EAAE;AACF;CACA,CAAC,cAAc,CAAC,WAAW,EAAE,WAAW,EAAE;CAC1C,EAAE,SAAS,cAAc,CAAC,KAAK,EAAE,GAAG,EAAE;CACtC,GAAG,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE;CACxC,IAAI,OAAO,WAAW,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK;CAC1D;CACA,KAAK,IAAI,CAAC,KAAK,GAAG,EAAE,OAAO,GAAG,CAAC;CAC/B,KAAK,IAAI,CAAC,KAAK,GAAG,EAAE,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;CACpC,KAAK,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC;CACpB,KAAK,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;CAC9C,KAAK,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;CACpB,KAAK,CAAC,CAAC;CACP,IAAI,MAAM;CACV,IAAI,OAAO,WAAW,CAAC,GAAG,KAAK,EAAE,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;CACjE,IAAI;CACJ,GAAG;CACH,EAAE,SAAS,QAAQ,CAAC,EAAE,EAAE,GAAG,EAAE;CAC7B,GAAG,IAAI,KAAK,CAAC;CACb,GAAG,MAAM,OAAO,GAAG,EAAE,CAAC;CACtB,GAAG,QAAQ,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;CAClC,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;CACxB,IAAI;CACJ,GAAG,OAAO,OAAO,CAAC;CAClB,GAAG;CACH,EAAE,IAAI,WAAW,CAAC,MAAM,EAAE;CAC1B,GAAG,MAAM,OAAO,GAAG,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;CACxD,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK;CAC9B,IAAI,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI;CAC3B,KAAK,IAAI,CAAC,SAAS;CACnB,MAAM,KAAK,CAAC,KAAK;CACjB,MAAM,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM;CACnC,MAAM,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC;CAC1C,MAAM,CAAC;CACP,IAAI,CAAC,CAAC;CACN,GAAG,MAAM;CACT,GAAG,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;CAClD,GAAG,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI;CACnC,IAAI,IAAI,CAAC,SAAS;CAClB,KAAK,KAAK,CAAC,KAAK;CAChB,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM;CAClC,KAAK,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC;CACzC,KAAK,CAAC;CACN,GAAG;CACH,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,cAAc,CAAC,MAAM,EAAE,WAAW,EAAE;CACrC,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;CAC5B,EAAE,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AACzC;CACA,EAAE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;CACpB,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;CAC7D,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,OAAO,CAAC,WAAW,EAAE,WAAW,EAAE;CACnC,EAAE,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE;CACvC,GAAG,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;CACxD,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;CACvD,EAAE;AACF;CACA,CAAC,iBAAiB,CAAC,MAAM,EAAE,WAAW,EAAE;CACxC,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;CAC5B,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC;CACrC,EAAE;CACF,GAAG,IAAI,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC;CACvC,GAAG,KAAK,KAAK,CAAC,CAAC;CACf,GAAG,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,GAAG,YAAY,CAAC;CACzD,IAAI;CACJ,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,GAAG,YAAY,EAAE,WAAW,CAAC,CAAC;CAC5D,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,UAAU,CAAC,WAAW,EAAE,WAAW,EAAE;CACtC,EAAE,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE;CACvC,GAAG,OAAO,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;CAC3D,GAAG;AACH;CACA,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;CAC3B,GAAG,MAAM,IAAI,SAAS;CACtB,IAAI,2EAA2E;CAC/E,IAAI,CAAC;CACL,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;CACvD,EAAE;CACF;;CC3zBA,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;AACnD;CACe,MAAM,MAAM,CAAC;CAC5B,CAAC,WAAW,CAAC,OAAO,GAAG,EAAE,EAAE;CAC3B,EAAE,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC;CACnC,EAAE,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,KAAK,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;CAC9E,EAAE,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;CACpB,EAAE,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;CAC1B,EAAE,IAAI,CAAC,2BAA2B,GAAG,EAAE,CAAC;CACxC,EAAE;AACF;CACA,CAAC,SAAS,CAAC,MAAM,EAAE;CACnB,EAAE,IAAI,MAAM,YAAY,WAAW,EAAE;CACrC,GAAG,OAAO,IAAI,CAAC,SAAS,CAAC;CACzB,IAAI,OAAO,EAAE,MAAM;CACnB,IAAI,QAAQ,EAAE,MAAM,CAAC,QAAQ;CAC7B,IAAI,SAAS,EAAE,IAAI,CAAC,SAAS;CAC7B,IAAI,CAAC,CAAC;CACN,GAAG;AACH;CACA,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;CAC5C,GAAG,MAAM,IAAI,KAAK;CAClB,IAAI,sIAAsI;CAC1I,IAAI,CAAC;CACL,GAAG;AACH;CACA,EAAE,CAAC,UAAU,EAAE,uBAAuB,EAAE,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK;CACzE,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;CACjF,GAAG,CAAC,CAAC;AACL;CACA,EAAE,IAAI,MAAM,CAAC,SAAS,KAAK,SAAS,EAAE;CACtC;CACA,GAAG,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;CACrC,GAAG;AACH;CACA,EAAE,IAAI,MAAM,CAAC,QAAQ,EAAE;CACvB,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,2BAA2B,EAAE,MAAM,CAAC,QAAQ,CAAC,EAAE;CAC5E,IAAI,IAAI,CAAC,2BAA2B,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;CAClF,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;CAC7F,IAAI,MAAM;CACV,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,2BAA2B,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC/F,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,QAAQ,KAAK,YAAY,CAAC,OAAO,EAAE;CAC1D,KAAK,MAAM,IAAI,KAAK,CAAC,CAAC,+BAA+B,EAAE,MAAM,CAAC,QAAQ,CAAC,qBAAqB,CAAC,CAAC,CAAC;CAC/F,KAAK;CACL,IAAI;CACJ,GAAG;AACH;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;CAC5B,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,EAAE;CACtB,EAAE,IAAI,CAAC,SAAS,CAAC;CACjB,GAAG,OAAO,EAAE,IAAI,WAAW,CAAC,GAAG,CAAC;CAChC,GAAG,SAAS,EAAE,CAAC,OAAO,IAAI,OAAO,CAAC,SAAS,KAAK,EAAE;CAClD,GAAG,CAAC,CAAC;AACL;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,KAAK,GAAG;CACT,EAAE,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC;CAC5B,GAAG,KAAK,EAAE,IAAI,CAAC,KAAK;CACpB,GAAG,SAAS,EAAE,IAAI,CAAC,SAAS;CAC5B,GAAG,CAAC,CAAC;AACL;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK;CACnC,GAAG,MAAM,CAAC,SAAS,CAAC;CACpB,IAAI,QAAQ,EAAE,MAAM,CAAC,QAAQ;CAC7B,IAAI,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE;CACnC,IAAI,SAAS,EAAE,MAAM,CAAC,SAAS;CAC/B,IAAI,CAAC,CAAC;CACN,GAAG,CAAC,CAAC;AACL;CACA,EAAE,OAAO,MAAM,CAAC;CAChB,EAAE;AACF;CACA,CAAC,kBAAkB,CAAC,OAAO,GAAG,EAAE,EAAE;CAClC,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC;CACnB,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK;CACnC,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK;CAC7D,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;CAChD,IAAI,CAAC,CAAC;CACN,GAAG,CAAC,CAAC;AACL;CACA,EAAE,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC/C;CACA,EAAE,IAAI,IAAI,CAAC,KAAK,EAAE;CAClB,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;CAChC,GAAG;AACH;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK;CACtC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE;CACd,IAAI,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;CACrC,IAAI;AACJ;CACA,GAAG,MAAM,WAAW,GAAG,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;CAChG,GAAG,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;CACtC,GAAG,MAAM,MAAM,GAAG,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;AACnD;CACA,GAAG,IAAI,WAAW,CAAC,KAAK,EAAE;CAC1B,IAAI,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;CACxC,IAAI;AACJ;CACA,GAAG,WAAW,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,KAAK,KAAK;CAC9C,IAAI,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACpC;CACA,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AAC1D;CACA,IAAI,IAAI,MAAM,CAAC,QAAQ,EAAE;CACzB,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;CACvB,MAAM,QAAQ,CAAC,OAAO;CACtB,OAAO,WAAW;CAClB,OAAO,KAAK,CAAC,OAAO;CACpB,OAAO,GAAG;CACV,OAAO,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;CAC3D,OAAO,CAAC;CACR,MAAM,MAAM;CACZ,MAAM,QAAQ,CAAC,gBAAgB;CAC/B,OAAO,WAAW;CAClB,OAAO,KAAK;CACZ,OAAO,WAAW,CAAC,QAAQ;CAC3B,OAAO,GAAG;CACV,OAAO,WAAW,CAAC,kBAAkB;CACrC,OAAO,CAAC;CACR,MAAM;CACN,KAAK,MAAM;CACX,KAAK,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;CACrC,KAAK;AACL;CACA,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;CAC1D,IAAI,CAAC,CAAC;AACN;CACA,GAAG,IAAI,WAAW,CAAC,KAAK,EAAE;CAC1B,IAAI,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;CACxC,IAAI;CACJ,GAAG,CAAC,CAAC;AACL;CACA,EAAE,OAAO;CACT,GAAG,IAAI,EAAE,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,IAAI;CAChE,GAAG,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK;CAC/C,IAAI,OAAO,OAAO,CAAC,IAAI,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC;CAC3F,IAAI,CAAC;CACL,GAAG,cAAc,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK;CACtD,IAAI,OAAO,OAAO,CAAC,cAAc,GAAG,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC;CAC1D,IAAI,CAAC;CACL,GAAG,KAAK;CACR,GAAG,QAAQ,EAAE,QAAQ,CAAC,GAAG;CACzB,GAAG,CAAC;CACJ,EAAE;AACF;CACA,CAAC,WAAW,CAAC,OAAO,EAAE;CACtB,EAAE,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,CAAC;CACzD,EAAE;AACF;CACA,CAAC,eAAe,GAAG;CACnB,EAAE,MAAM,kBAAkB,GAAG,EAAE,CAAC;AAChC;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK;CACnC,GAAG,MAAM,SAAS,GAAG,MAAM,CAAC,OAAO,CAAC,mBAAmB,EAAE,CAAC;AAC1D;CACA,GAAG,IAAI,SAAS,KAAK,IAAI,EAAE,OAAO;AAClC;CACA,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,kBAAkB,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;CACzE,GAAG,kBAAkB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;CACtC,GAAG,CAAC,CAAC;AACL;CACA,EAAE;CACF,GAAG,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK;CAClD,IAAI,OAAO,kBAAkB,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;CACzD,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;CAChB,IAAI;CACJ,EAAE;AACF;CACA,CAAC,MAAM,CAAC,SAAS,EAAE;CACnB,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;CACzB,GAAG,SAAS,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;CACtC,GAAG;AACH;CACA,EAAE,IAAI,SAAS,KAAK,EAAE,EAAE,OAAO,IAAI,CAAC;AACpC;CACA,EAAE,IAAI,eAAe,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC;AACrE;CACA,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK;CACtC,GAAG,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,KAAK,SAAS,GAAG,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;CACxF,GAAG,MAAM,WAAW,GAAG,eAAe,KAAK,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;AAC9E;CACA,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE;CACpC,IAAI,OAAO,EAAE,MAAM,CAAC,qBAAqB;CACzC,IAAI,WAAW;CACf,IAAI,CAAC,CAAC;AACN;CACA,GAAG,eAAe,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,KAAK,IAAI,CAAC;CACxD,GAAG,CAAC,CAAC;AACL;CACA,EAAE,IAAI,IAAI,CAAC,KAAK,EAAE;CAClB,GAAG,IAAI,CAAC,KAAK;CACb,IAAI,SAAS;CACb,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK;CACrD,KAAK,OAAO,KAAK,GAAG,CAAC,GAAG,SAAS,GAAG,KAAK,GAAG,KAAK,CAAC;CAClD,KAAK,CAAC,CAAC;CACP,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,OAAO,CAAC,GAAG,EAAE;CACd,EAAE,IAAI,CAAC,KAAK,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;CAChC,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,QAAQ,GAAG;CACZ,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO;CAC3B,IAAI,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK;CACvB,IAAI,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,KAAK,SAAS,GAAG,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;CACzF,IAAI,MAAM,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,SAAS,GAAG,EAAE,IAAI,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;AACrE;CACA,IAAI,OAAO,GAAG,CAAC;CACf,IAAI,CAAC;CACL,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC;AACb;CACA,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;CAC3B,EAAE;AACF;CACA,CAAC,OAAO,GAAG;CACX,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,OAAO,KAAK,CAAC;CAC3D,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,EAAE,OAAO,KAAK,CAAC;CAC7E,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,MAAM,GAAG;CACV,EAAE,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM;CAC5B,GAAG,CAAC,MAAM,EAAE,MAAM,KAAK,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,EAAE;CACvD,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM;CACpB,GAAG,CAAC;CACJ,EAAE;AACF;CACA,CAAC,SAAS,GAAG;CACb,EAAE,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;CAC/B,EAAE;AACF;CACA,CAAC,IAAI,CAAC,QAAQ,EAAE;CAChB,EAAE,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;CACpD,EAAE;AACF;CACA,CAAC,SAAS,CAAC,QAAQ,EAAE;CACrB,EAAE,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,GAAG,IAAI,QAAQ,IAAI,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC;CACzD,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC1C;CACA,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;CACnB,GAAG,IAAI,MAAM,CAAC;CACd,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AACb;CACA,GAAG,GAAG;CACN,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;CAC/B,IAAI,IAAI,CAAC,MAAM,EAAE;CACjB,KAAK,MAAM;CACX,KAAK;CACL,IAAI,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;CACxD,GAAG;AACH;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;AACF;CACA,CAAC,OAAO,CAAC,QAAQ,EAAE;CACnB,EAAE,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,CAAC,QAAQ,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC;AACpD;CACA,EAAE,IAAI,MAAM,CAAC;CACb,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;AAClC;CACA,EAAE,GAAG;CACL,GAAG,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;CAC9B,GAAG,IAAI,CAAC,MAAM,EAAE;CAChB,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CAC5C,IAAI,MAAM;CACV,IAAI;CACJ,GAAG,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;AACrD;CACA,EAAE,OAAO,IAAI,CAAC;CACd,EAAE;CACF;;CC3RA,WAAW,CAAC,MAAM,GAAG,MAAM,CAAC;CAC5B,WAAW,CAAC,SAAS,GAAG,SAAS,CAAC;CAClC,WAAW,CAAC,OAAO,GAAG,WAAW,CAAC;;;;;;;;\"}"}}}},"index.d.ts":{"file":{"contents":"export interface BundleOptions {\n  intro?: string;\n  separator?: string;\n}\n\nexport interface SourceMapOptions {\n  /**\n   * Whether the mapping should be high-resolution.\n   * Hi-res mappings map every single character, meaning (for example) your devtools will always\n   * be able to pinpoint the exact location of function calls and so on.\n   * With lo-res mappings, devtools may only be able to identify the correct\n   * line - but they're quicker to generate and less bulky.\n   * If sourcemap locations have been specified with s.addSourceMapLocation(), they will be used here.\n   */\n  hires?: boolean;\n  /**\n   * The filename where you plan to write the sourcemap.\n   */\n  file?: string;\n  /**\n   * The filename of the file containing the original source.\n   */\n  source?: string;\n  /**\n   * Whether to include the original content in the map's sourcesContent array.\n   */\n  includeContent?: boolean;\n}\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\n\nexport interface DecodedSourceMap {\n  file: string;\n  sources: string[];\n  sourcesContent: (string | null)[];\n  names: string[];\n  mappings: SourceMapSegment[][];\n  x_google_ignoreList?: number[];\n}\n\nexport class SourceMap {\n  constructor(properties: DecodedSourceMap);\n\n  version: number;\n  file: string;\n  sources: string[];\n  sourcesContent: (string | null)[];\n  names: string[];\n  mappings: string;\n  x_google_ignoreList?: number[];\n\n  /**\n   * Returns the equivalent of `JSON.stringify(map)`\n   */\n  toString(): string;\n  /**\n   * Returns a DataURI containing the sourcemap. Useful for doing this sort of thing:\n   * `generateMap(options?: SourceMapOptions): SourceMap;`\n   */\n  toUrl(): string;\n}\n\nexport class Bundle {\n  constructor(options?: BundleOptions);\n  addSource(source: MagicString | { filename?: string, content: MagicString }): Bundle;\n  append(str: string, options?: BundleOptions): Bundle;\n  clone(): Bundle;\n  generateMap(options?: SourceMapOptions): SourceMap;\n  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;\n  getIndentString(): string;\n  indent(indentStr?: string): Bundle;\n  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;\n  prepend(str: string): Bundle;\n  toString(): string;\n  trimLines(): Bundle;\n  trim(charType?: string): Bundle;\n  trimStart(charType?: string): Bundle;\n  trimEnd(charType?: string): Bundle;\n  isEmpty(): boolean;\n  length(): number;\n}\n\nexport type ExclusionRange = [ number, number ];\n\nexport interface MagicStringOptions {\n  filename?: string,\n  indentExclusionRanges?: ExclusionRange | Array<ExclusionRange>;\n}\n\nexport interface IndentOptions {\n  exclude?: ExclusionRange | Array<ExclusionRange>;\n  indentStart?: boolean;\n}\n\nexport interface OverwriteOptions {\n  storeName?: boolean;\n  contentOnly?: boolean;\n}\n\nexport interface UpdateOptions {\n  storeName?: boolean;\n  overwrite?: boolean;\n}\n\nexport default class MagicString {\n  constructor(str: string, options?: MagicStringOptions);\n  /**\n   * Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is false.\n   */\n  addSourcemapLocation(char: number): void;\n  /**\n   * Appends the specified content to the end of the string.\n   */\n  append(content: string): MagicString;\n  /**\n   * Appends the specified content at the index in the original string.\n   * If a range *ending* with index is subsequently moved, the insert will be moved with it. \n   * See also `s.prependLeft(...)`.\n   */\n  appendLeft(index: number, content: string): MagicString;\n  /**\n   * Appends the specified content at the index in the original string.\n   * If a range *starting* with index is subsequently moved, the insert will be moved with it.\n   * See also `s.prependRight(...)`.\n   */\n  appendRight(index: number, content: string): MagicString;\n  /**\n   * Does what you'd expect.\n   */\n  clone(): MagicString;\n  /**\n   * Generates a version 3 sourcemap.\n   */\n  generateMap(options?: SourceMapOptions): SourceMap;\n  /**\n   * Generates a sourcemap object with raw mappings in array form, rather than encoded as a string.\n   * Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.\n   */\n  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;\n  getIndentString(): string;\n\n  /**\n   * Prefixes each line of the string with prefix.\n   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.\n   */\n  indent(options?: IndentOptions): MagicString;\n  /**\n   * Prefixes each line of the string with prefix.\n   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.\n   *\n   * The options argument can have an exclude property, which is an array of [start, end] character ranges.\n   * These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.\n   */\n  indent(indentStr?: string, options?: IndentOptions): MagicString;\n  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;\n\n  /**\n   * Moves the characters from `start and `end` to `index`.\n   */\n  move(start: number, end: number, index: number): MagicString;\n  /**\n   * Replaces the characters from `start` to `end` with `content`, along with the appended/prepended content in \n   * that range. The same restrictions as `s.remove()` apply.\n   *\n   * The fourth argument is optional. It can have a storeName property — if true, the original name will be stored\n   * for later inclusion in a sourcemap's names array — and a contentOnly property which determines whether only\n   * the content is overwritten, or anything that was appended/prepended to the range as well.\n   * \n   * It may be preferred to use `s.update(...)` instead if you wish to avoid overwriting the appended/prepended content.\n   */\n  overwrite(start: number, end: number, content: string, options?: boolean | OverwriteOptions): MagicString;\n  /**\n   * Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply.\n   *\n   * The fourth argument is optional. It can have a storeName property — if true, the original name will be stored\n   * for later inclusion in a sourcemap's names array — and an overwrite property which determines whether only\n   * the content is overwritten, or anything that was appended/prepended to the range as well.\n   */\n  update(start: number, end: number, content: string, options?: boolean | UpdateOptions): MagicString;\n  /**\n   * Prepends the string with the specified content. \n   */\n  prepend(content: string): MagicString;\n  /**\n   * Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at index\n   */\n  prependLeft(index: number, content: string): MagicString;\n  /**\n   * Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n   */\n  prependRight(index: number, content: string): MagicString;\n  /**\n   * Removes the characters from `start` to `end` (of the original string, **not** the generated string).\n   * Removing the same content twice, or making removals that partially overlap, will cause an error.\n   */\n  remove(start: number, end: number): MagicString;\n  /**\n   * Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string.\n   * Throws error if the indices are for characters that were already removed.\n   */\n  slice(start: number, end: number): string;\n  /**\n   * Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.\n   */\n  snip(start: number, end: number): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start and end.\n   */\n  trim(charType?: string): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start.\n   */\n  trimStart(charType?: string): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the end.\n   */\n  trimEnd(charType?: string): MagicString;\n  /**\n   * Removes empty lines from the start and end.\n   */\n  trimLines(): MagicString;\n  /**\n   * String replacement with RegExp or string.\n   */\n  replace(regex: RegExp | string, replacement: string | ((substring: string, ...args: any[]) => string)): MagicString;\n  /**\n   * Same as `s.replace`, but replace all matched strings instead of just one.\n   */\n  replaceAll(regex: RegExp | string, replacement: string | ((substring: string, ...args: any[]) => string)): MagicString;\n\n  lastChar(): string;\n  lastLine(): string;\n  /**\n   * Returns true if the resulting source is empty (disregarding white space).\n   */\n  isEmpty(): boolean;\n  length(): number;\n\n  /**\n   * Indicates if the string has been changed.\n   */\n  hasChanged(): boolean;\n\n  original: string;\n  /**\n   * Returns the generated string.\n   */\n  toString(): string;\n}\n"}},"LICENSE":{"file":{"contents":"Copyright 2018 Rich Harris\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"magic-string\",\n  \"version\": \"0.29.0\",\n  \"description\": \"Modify strings, generate sourcemaps\",\n  \"keywords\": [\n    \"string\",\n    \"string manipulation\",\n    \"sourcemap\",\n    \"templating\",\n    \"transpilation\"\n  ],\n  \"repository\": \"https://github.com/rich-harris/magic-string\",\n  \"license\": \"MIT\",\n  \"author\": \"Rich Harris\",\n  \"main\": \"./dist/magic-string.cjs.js\",\n  \"module\": \"./dist/magic-string.es.mjs\",\n  \"jsnext:main\": \"./dist/magic-string.es.mjs\",\n  \"types\": \"./index.d.ts\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"import\": \"./dist/magic-string.es.mjs\",\n      \"require\": \"./dist/magic-string.cjs.js\"\n    }\n  },\n  \"files\": [\n    \"dist/*\",\n    \"index.d.ts\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"rollup -c\",\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s\",\n    \"format\": \"prettier --single-quote --print-width 100 --use-tabs --write src/*.js src/**/*.js\",\n    \"lint\": \"eslint src test && publint\",\n    \"prepare\": \"npm run build\",\n    \"prepublishOnly\": \"npm run lint && rm -rf dist && npm test\",\n    \"release\": \"bumpp -x \\\"npm run changelog\\\" --all --commit --tag --push && npm publish\",\n    \"pretest\": \"npm run build\",\n    \"test\": \"mocha\",\n    \"bench\": \"npm run build && node benchmark/index.mjs\",\n    \"watch\": \"rollup -cw\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-node-resolve\": \"^14.1.0\",\n    \"@rollup/plugin-replace\": \"^4.0.0\",\n    \"benchmark\": \"^2.1.4\",\n    \"bumpp\": \"^8.2.1\",\n    \"conventional-changelog-cli\": \"^2.2.2\",\n    \"eslint\": \"^8.23.1\",\n    \"mocha\": \"^10.0.0\",\n    \"prettier\": \"^2.7.1\",\n    \"publint\": \"^0.1.7\",\n    \"rollup\": \"^2.79.1\",\n    \"source-map-js\": \"^1.0.2\",\n    \"source-map-support\": \"^0.5.21\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"dependencies\": {\n    \"@jridgewell/sourcemap-codec\": \"^1.4.13\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# magic-string\n\n<a href=\"https://travis-ci.org/Rich-Harris/magic-string\">\n  <img src=\"http://img.shields.io/travis/Rich-Harris/magic-string.svg\"\n       alt=\"build status\">\n</a>\n<a href=\"https://npmjs.org/package/magic-string\">\n  <img src=\"https://img.shields.io/npm/v/magic-string.svg\"\n       alt=\"npm version\">\n</a>\n<a href=\"https://github.com/Rich-Harris/magic-string/blob/master/LICENSE.md\">\n  <img src=\"https://img.shields.io/npm/l/magic-string.svg\"\n       alt=\"license\">\n</a>\n\nSuppose you have some source code. You want to make some light modifications to it - replacing a few characters here and there, wrapping it with a header and footer, etc - and ideally you'd like to generate a [source map](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/) at the end of it. You've thought about using something like [recast](https://github.com/benjamn/recast) (which allows you to generate an AST from some JavaScript, manipulate it, and reprint it with a sourcemap without losing your comments and formatting), but it seems like overkill for your needs (or maybe the source code isn't JavaScript).\n\nYour requirements are, frankly, rather niche. But they're requirements that I also have, and for which I made magic-string. It's a small, fast utility for manipulating strings and generating sourcemaps.\n\n## Installation\n\nmagic-string works in both node.js and browser environments. For node, install with npm:\n\n```bash\nnpm i magic-string\n```\n\nTo use in browser, grab the [magic-string.umd.js](https://unpkg.com/magic-string/dist/magic-string.umd.js) file and add it to your page:\n\n```html\n<script src='magic-string.umd.js'></script>\n```\n\n(It also works with various module systems, if you prefer that sort of thing - it has a dependency on [vlq](https://github.com/Rich-Harris/vlq).)\n\n## Usage\n\nThese examples assume you're in node.js, or something similar:\n\n```js\nimport MagicString from 'magic-string';\nimport fs from 'fs'\n\nconst s = new MagicString('problems = 99');\n\ns.update(0, 8, 'answer');\ns.toString(); // 'answer = 99'\n\ns.update(11, 13, '42'); // character indices always refer to the original string\ns.toString(); // 'answer = 42'\n\ns.prepend('var ').append(';'); // most methods are chainable\ns.toString(); // 'var answer = 42;'\n\nconst map = s.generateMap({\n  source: 'source.js',\n  file: 'converted.js.map',\n  includeContent: true\n}); // generates a v3 sourcemap\n\nfs.writeFileSync('converted.js', s.toString());\nfs.writeFileSync('converted.js.map', map.toString());\n```\n\nYou can pass an options argument:\n\n```js\nconst s = new MagicString(someCode, {\n  // both these options will be used if you later\n  // call `bundle.addSource( s )` - see below\n  filename: 'foo.js',\n  indentExclusionRanges: [/*...*/]\n});\n```\n\n## Methods\n\n### s.addSourcemapLocation( index )\n\nAdds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is `false` (see below).\n\n### s.append( content )\n\nAppends the specified content to the end of the string. Returns `this`.\n\n### s.appendLeft( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *ending* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependLeft(...)`.\n\n### s.appendRight( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *starting* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependRight(...)`.\n\n### s.clone()\n\nDoes what you'd expect.\n\n### s.generateDecodedMap( options )\n\nGenerates a sourcemap object with raw mappings in array form, rather than encoded as a string. See `generateMap` documentation below for options details. Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.\n\n### s.generateMap( options )\n\nGenerates a [version 3 sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit). All options are, well, optional:\n\n* `file` - the filename where you plan to write the sourcemap\n* `source` - the filename of the file containing the original source\n* `includeContent` - whether to include the original content in the map's `sourcesContent` array\n* `hires` - whether the mapping should be high-resolution. Hi-res mappings map every single character, meaning (for example) your devtools will always be able to pinpoint the exact location of function calls and so on. With lo-res mappings, devtools may only be able to identify the correct line - but they're quicker to generate and less bulky. If sourcemap locations have been specified with `s.addSourceMapLocation()`, they will be used here.\n\nThe returned sourcemap has two (non-enumerable) methods attached for convenience:\n\n* `toString` - returns the equivalent of `JSON.stringify(map)`\n* `toUrl` - returns a DataURI containing the sourcemap. Useful for doing this sort of thing:\n\n```js\ncode += '\\n//# sourceMappingURL=' + map.toUrl();\n```\n\n### s.hasChanged()\n\nIndicates if the string has been changed.\n\n### s.indent( prefix[, options] )\n\nPrefixes each line of the string with `prefix`. If `prefix` is not supplied, the indentation will be guessed from the original content, falling back to a single tab character. Returns `this`.\n\nThe `options` argument can have an `exclude` property, which is an array of `[start, end]` character ranges. These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.\n\n### s.insertLeft( index, content )\n\n**DEPRECATED** since 0.17 – use `s.appendLeft(...)` instead\n\n### s.insertRight( index, content )\n\n**DEPRECATED** since 0.17 – use `s.prependRight(...)` instead\n\n### s.isEmpty()\n\nReturns true if the resulting source is empty (disregarding white space).\n\n### s.locate( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.locateOrigin( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.move( start, end, index )\n\nMoves the characters from `start` and `end` to `index`. Returns `this`.\n\n### s.overwrite( start, end, content[, options] )\n\nReplaces the characters from `start` to `end` with `content`, along with the appended/prepended content in that range. The same restrictions as `s.remove()` apply. Returns `this`.\n\nThe fourth argument is optional. It can have a `storeName` property — if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array — and a `contentOnly` property which determines whether only the content is overwritten, or anything that was appended/prepended to the range as well.\n\nIt may be preferred to use `s.update(...)` instead if you wish to avoid overwriting the appended/prepended content.\n\n### s.prepend( content )\n\nPrepends the string with the specified content. Returns `this`.\n\n### s.prependLeft ( index, content )\n\nSame as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.prependRight ( index, content )\n\nSame as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.replace( regexpOrString, substitution )\n\nString replacement with RegExp or string. When using a RegExp, replacer function is also supported. Returns `this`.\n\n```ts\nimport MagicString from 'magic-string'\n\nconst s = new MagicString(source)\n\ns.replace('foo', 'bar')\ns.replace(/foo/g, 'bar')\ns.replace(/(\\w)(\\d+)/g, (_, $1, $2) => $1.toUpperCase() + $2)\n```\n\nThe differences from [`String.replace`]((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)):\n- It will always match against the **original string**\n- It mutates the magic string state (use `.clone()` to be immutable)\n\n### s.replaceAll( regexpOrString, substitution )\n\nSame as `s.replace`, but replace all matched strings instead of just one.\nIf `substitution` is a regex, then it must have the global (`g`) flag set, or a `TypeError` is thrown. Matches the behavior of the bultin [`String.property.replaceAll`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll).\n\n### s.remove( start, end )\n\nRemoves the characters from `start` to `end` (of the original string, **not** the generated string). Removing the same content twice, or making removals that partially overlap, will cause an error. Returns `this`.\n\n### s.slice( start, end )\n\nReturns the content of the generated string that corresponds to the slice between `start` and `end` of the original string. Throws error if the indices are for characters that were already removed.\n\n### s.snip( start, end )\n\nReturns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.\n\n### s.toString()\n\nReturns the generated string.\n\n### s.trim([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start and end. Returns `this`.\n\n### s.trimStart([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start. Returns `this`.\n\n### s.trimEnd([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the end. Returns `this`.\n\n### s.trimLines()\n\nRemoves empty lines from the start and end. Returns `this`.\n\n### s.update( start, end, content[, options] )\n\nReplaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply. Returns `this`.\n\nThe fourth argument is optional. It can have a `storeName` property — if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array — and an `overwrite` property which defaults to `false` and determines whether anything that was appended/prepended to the range will be overwritten along with the original content.\n\n`s.update(start, end, content)` is equivalent to `s.overwrite(start, end, content, { contentOnly: true })`.\n\n## Bundling\n\nTo concatenate several sources, use `MagicString.Bundle`:\n\n```js\nconst bundle = new MagicString.Bundle();\n\nbundle.addSource({\n  filename: 'foo.js',\n  content: new MagicString('var answer = 42;')\n});\n\nbundle.addSource({\n  filename: 'bar.js',\n  content: new MagicString('console.log( answer )')\n});\n\n// Advanced: a source can include an `indentExclusionRanges` property\n// alongside `filename` and `content`. This will be passed to `s.indent()`\n// - see documentation above\n\nbundle.indent() // optionally, pass an indent string, otherwise it will be guessed\n  .prepend('(function () {\\n')\n  .append('}());');\n\nbundle.toString();\n// (function () {\n//   var answer = 42;\n//   console.log( answer );\n// }());\n\n// options are as per `s.generateMap()` above\nconst map = bundle.generateMap({\n  file: 'bundle.js',\n  includeContent: true,\n  hires: true\n});\n```\n\nAs an alternative syntax, if you a) don't have `filename` or `indentExclusionRanges` options, or b) passed those in when you used `new MagicString(...)`, you can simply pass the `MagicString` instance itself:\n\n```js\nconst bundle = new MagicString.Bundle();\nconst source = new MagicString(someCode, {\n  filename: 'foo.js'\n});\n\nbundle.addSource(source);\n```\n\n## License\n\nMIT\n"}}}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"@sveltejs/vite-plugin-svelte\",\n  \"version\": \"2.0.3\",\n  \"license\": \"MIT\",\n  \"author\": \"dominikg\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"*.d.ts\"\n  ],\n  \"type\": \"module\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    },\n    \"./package.json\": \"./package.json\",\n    \"./src/ui/*\": \"./src/ui/*\"\n  },\n  \"engines\": {\n    \"node\": \"^14.18.0 || >= 16\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/sveltejs/vite-plugin-svelte.git\",\n    \"directory\": \"packages/vite-plugin-svelte\"\n  },\n  \"keywords\": [\n    \"vite-plugin\",\n    \"vite plugin\",\n    \"vite\",\n    \"svelte\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/sveltejs/vite-plugin-svelte/issues\"\n  },\n  \"homepage\": \"https://github.com/sveltejs/vite-plugin-svelte#readme\",\n  \"dependencies\": {\n    \"debug\": \"^4.3.4\",\n    \"deepmerge\": \"^4.3.0\",\n    \"kleur\": \"^4.1.5\",\n    \"magic-string\": \"^0.29.0\",\n    \"svelte-hmr\": \"^0.15.1\",\n    \"vitefu\": \"^0.2.4\"\n  },\n  \"peerDependencies\": {\n    \"svelte\": \"^3.54.0\",\n    \"vite\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/debug\": \"^4.1.7\",\n    \"esbuild\": \"^0.17.9\",\n    \"rollup\": \"^2.79.1\",\n    \"svelte\": \"^3.55.1\",\n    \"tsup\": \"^6.6.3\",\n    \"vite\": \"^4.1.4\"\n  },\n  \"scripts\": {\n    \"dev\": \"pnpm build:ci --sourcemap --watch src\",\n    \"build:ci\": \"rimraf dist && tsup-node src/index.ts --format esm\",\n    \"build\": \"pnpm build:ci --dts --sourcemap\"\n  }\n}"}},"README.md":{"file":{"contents":"# @sveltejs/vite-plugin-svelte\n\nThe official [Svelte](https://svelte.dev) plugin for [Vite](https://vitejs.dev).\n\n## Usage\n\n```js\n// vite.config.js\nimport { defineConfig } from 'vite';\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\n\nexport default defineConfig({\n  plugins: [\n    svelte({\n      /* plugin options */\n    })\n  ]\n});\n```\n\n## Documentation\n\n- [Plugin options](../../docs/config.md)\n- [FAQ](../../docs/faq.md)\n\n## License\n\n[MIT](./LICENSE)\n"}},"src":{"directory":{"handle-hot-update.ts":{"file":{"contents":"import { ModuleNode, HmrContext } from 'vite';\nimport { Code, CompileData } from './utils/compile';\nimport { log, logCompilerWarnings } from './utils/log';\nimport { SvelteRequest } from './utils/id';\nimport { VitePluginSvelteCache } from './utils/vite-plugin-svelte-cache';\nimport { ResolvedOptions } from './utils/options';\nimport { toRollupError } from './utils/error';\n\n/**\n * Vite-specific HMR handling\n */\nexport async function handleHotUpdate(\n\tcompileSvelte: Function,\n\tctx: HmrContext,\n\tsvelteRequest: SvelteRequest,\n\tcache: VitePluginSvelteCache,\n\toptions: ResolvedOptions\n): Promise<ModuleNode[] | void> {\n\tif (!cache.has(svelteRequest)) {\n\t\t// file hasn't been requested yet (e.g. async component)\n\t\tlog.debug(`handleHotUpdate called before initial transform for ${svelteRequest.id}`);\n\t\treturn;\n\t}\n\tconst { read, server, modules } = ctx;\n\n\tconst cachedJS = cache.getJS(svelteRequest);\n\tconst cachedCss = cache.getCSS(svelteRequest);\n\n\tconst content = await read();\n\tlet compileData: CompileData;\n\ttry {\n\t\tcompileData = await compileSvelte(svelteRequest, content, options);\n\t\tcache.update(compileData);\n\t} catch (e) {\n\t\tcache.setError(svelteRequest, e);\n\t\tthrow toRollupError(e, options);\n\t}\n\n\tconst affectedModules = [...modules];\n\n\tconst cssIdx = modules.findIndex((m) => m.id === svelteRequest.cssId);\n\tif (cssIdx > -1) {\n\t\tconst cssUpdated = cssChanged(cachedCss, compileData.compiled.css);\n\t\tif (!cssUpdated) {\n\t\t\tlog.debug(`skipping unchanged css for ${svelteRequest.cssId}`);\n\t\t\taffectedModules.splice(cssIdx, 1);\n\t\t}\n\t}\n\tconst jsIdx = modules.findIndex((m) => m.id === svelteRequest.id);\n\tif (jsIdx > -1) {\n\t\tconst jsUpdated = jsChanged(cachedJS, compileData.compiled.js, svelteRequest.filename);\n\t\tif (!jsUpdated) {\n\t\t\tlog.debug(`skipping unchanged js for ${svelteRequest.id}`);\n\t\t\taffectedModules.splice(jsIdx, 1);\n\t\t\t// transform won't be called, log warnings here\n\t\t\tlogCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\n\t\t}\n\t}\n\n\t// TODO is this enough? see also: https://github.com/vitejs/vite/issues/2274\n\tconst ssrModulesToInvalidate = affectedModules.filter((m) => !!m.ssrTransformResult);\n\tif (ssrModulesToInvalidate.length > 0) {\n\t\tlog.debug(`invalidating modules ${ssrModulesToInvalidate.map((m) => m.id).join(', ')}`);\n\t\tssrModulesToInvalidate.forEach((moduleNode) => server.moduleGraph.invalidateModule(moduleNode));\n\t}\n\tif (affectedModules.length > 0) {\n\t\tlog.debug(\n\t\t\t`handleHotUpdate for ${svelteRequest.id} result: ${affectedModules\n\t\t\t\t.map((m) => m.id)\n\t\t\t\t.join(', ')}`\n\t\t);\n\t}\n\treturn affectedModules;\n}\n\nfunction cssChanged(prev?: Code, next?: Code): boolean {\n\treturn !isCodeEqual(prev?.code, next?.code);\n}\n\nfunction jsChanged(prev?: Code, next?: Code, filename?: string): boolean {\n\tconst prevJs = prev?.code;\n\tconst nextJs = next?.code;\n\tconst isStrictEqual = isCodeEqual(prevJs, nextJs);\n\tif (isStrictEqual) {\n\t\treturn false;\n\t}\n\tconst isLooseEqual = isCodeEqual(normalizeJsCode(prevJs), normalizeJsCode(nextJs));\n\tif (!isStrictEqual && isLooseEqual) {\n\t\tlog.warn(\n\t\t\t`ignoring compiler output js change for ${filename} as it is equal to previous output after normalization`\n\t\t);\n\t}\n\treturn !isLooseEqual;\n}\n\nfunction isCodeEqual(prev?: string, next?: string): boolean {\n\tif (!prev && !next) {\n\t\treturn true;\n\t}\n\tif ((!prev && next) || (prev && !next)) {\n\t\treturn false;\n\t}\n\treturn prev === next;\n}\n\n/**\n * remove code that only changes metadata and does not require a js update for the component to keep working\n *\n * 1) add_location() calls. These add location metadata to elements, only used by some dev tools\n * 2) ... maybe more (or less) in the future\n * @param code\n */\nfunction normalizeJsCode(code?: string): string | undefined {\n\tif (!code) {\n\t\treturn code;\n\t}\n\treturn code.replace(/\\s*\\badd_location\\s*\\([^)]*\\)\\s*;?/g, '');\n}\n"}},"index.ts":{"file":{"contents":"import fs from 'fs';\nimport { HmrContext, ModuleNode, Plugin, ResolvedConfig, UserConfig } from 'vite';\n// eslint-disable-next-line node/no-missing-import\nimport { isDepExcluded } from 'vitefu';\nimport { handleHotUpdate } from './handle-hot-update';\nimport { log, logCompilerWarnings } from './utils/log';\nimport { type CompileSvelte, createCompileSvelte } from './utils/compile';\nimport { buildIdParser, IdParser } from './utils/id';\nimport {\n\tbuildExtraViteConfig,\n\tvalidateInlineOptions,\n\tOptions,\n\tResolvedOptions,\n\tresolveOptions,\n\tpatchResolvedViteConfig,\n\tpreResolveOptions\n} from './utils/options';\n\nimport { ensureWatchedFile, setupWatchers } from './utils/watch';\nimport { resolveViaPackageJsonSvelte } from './utils/resolve';\nimport { PartialResolvedId } from 'rollup';\nimport { toRollupError } from './utils/error';\nimport { saveSvelteMetadata } from './utils/optimizer';\nimport { svelteInspector } from './ui/inspector/plugin';\nimport { VitePluginSvelteCache } from './utils/vite-plugin-svelte-cache';\nimport { loadRaw } from './utils/load-raw';\n\ninterface PluginAPI {\n\t/**\n\t * must not be modified, should not be used outside of vite-plugin-svelte repo\n\t * @internal\n\t * @experimental\n\t */\n\toptions?: ResolvedOptions;\n\t// TODO expose compile cache here so other utility plugins can use it\n}\n\nexport function svelte(inlineOptions?: Partial<Options>): Plugin[] {\n\tif (process.env.DEBUG != null) {\n\t\tlog.setLevel('debug');\n\t}\n\tvalidateInlineOptions(inlineOptions);\n\tconst cache = new VitePluginSvelteCache();\n\t// updated in configResolved hook\n\tlet requestParser: IdParser;\n\tlet options: ResolvedOptions;\n\tlet viteConfig: ResolvedConfig;\n\t/* eslint-disable no-unused-vars */\n\tlet compileSvelte: CompileSvelte;\n\t/* eslint-enable no-unused-vars */\n\n\tlet resolvedSvelteSSR: Promise<PartialResolvedId | null>;\n\tconst api: PluginAPI = {};\n\tconst plugins: Plugin[] = [\n\t\t{\n\t\t\tname: 'vite-plugin-svelte',\n\t\t\t// make sure our resolver runs before vite internal resolver to resolve svelte field correctly\n\t\t\tenforce: 'pre',\n\t\t\tapi,\n\t\t\tasync config(config, configEnv): Promise<Partial<UserConfig>> {\n\t\t\t\t// setup logger\n\t\t\t\tif (process.env.DEBUG) {\n\t\t\t\t\tlog.setLevel('debug');\n\t\t\t\t} else if (config.logLevel) {\n\t\t\t\t\tlog.setLevel(config.logLevel);\n\t\t\t\t}\n\t\t\t\t// @ts-expect-error temporarily lend the options variable until fixed in configResolved\n\t\t\t\toptions = await preResolveOptions(inlineOptions, config, configEnv);\n\t\t\t\t// extra vite config\n\t\t\t\tconst extraViteConfig = await buildExtraViteConfig(options, config);\n\t\t\t\tlog.debug('additional vite config', extraViteConfig);\n\t\t\t\treturn extraViteConfig;\n\t\t\t},\n\n\t\t\tasync configResolved(config) {\n\t\t\t\toptions = resolveOptions(options, config);\n\t\t\t\tpatchResolvedViteConfig(config, options);\n\t\t\t\trequestParser = buildIdParser(options);\n\t\t\t\tcompileSvelte = createCompileSvelte(options);\n\t\t\t\tviteConfig = config;\n\t\t\t\t// TODO deep clone to avoid mutability from outside?\n\t\t\t\tapi.options = options;\n\t\t\t\tlog.debug('resolved options', options);\n\t\t\t},\n\n\t\t\tasync buildStart() {\n\t\t\t\tif (!options.prebundleSvelteLibraries) return;\n\t\t\t\tconst isSvelteMetadataChanged = await saveSvelteMetadata(viteConfig.cacheDir, options);\n\t\t\t\tif (isSvelteMetadataChanged) {\n\t\t\t\t\t// Force Vite to optimize again. Although we mutate the config here, it works because\n\t\t\t\t\t// Vite's optimizer runs after `buildStart()`.\n\t\t\t\t\tviteConfig.optimizeDeps.force = true;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tconfigureServer(server) {\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\toptions.server = server;\n\t\t\t\tsetupWatchers(options, cache, requestParser);\n\t\t\t},\n\n\t\t\tasync load(id, opts) {\n\t\t\t\tconst ssr = !!opts?.ssr;\n\t\t\t\tconst svelteRequest = requestParser(id, !!ssr);\n\t\t\t\tif (svelteRequest) {\n\t\t\t\t\tconst { filename, query, raw } = svelteRequest;\n\t\t\t\t\tif (raw) {\n\t\t\t\t\t\treturn loadRaw(svelteRequest, compileSvelte, options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (query.svelte && query.type === 'style') {\n\t\t\t\t\t\t\tconst css = cache.getCSS(svelteRequest);\n\t\t\t\t\t\t\tif (css) {\n\t\t\t\t\t\t\t\tlog.debug(`load returns css for ${filename}`);\n\t\t\t\t\t\t\t\treturn css;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// prevent vite asset plugin from loading files as url that should be compiled in transform\n\t\t\t\t\t\tif (viteConfig.assetsInclude(filename)) {\n\t\t\t\t\t\t\tlog.debug(`load returns raw content for ${filename}`);\n\t\t\t\t\t\t\treturn fs.readFileSync(filename, 'utf-8');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync resolveId(importee, importer, opts) {\n\t\t\t\tconst ssr = !!opts?.ssr;\n\t\t\t\tconst svelteRequest = requestParser(importee, ssr);\n\t\t\t\tif (svelteRequest?.query.svelte) {\n\t\t\t\t\tif (svelteRequest.query.type === 'style' && !svelteRequest.raw) {\n\t\t\t\t\t\t// return cssId with root prefix so postcss pipeline of vite finds the directory correctly\n\t\t\t\t\t\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/14\n\t\t\t\t\t\tlog.debug(`resolveId resolved virtual css module ${svelteRequest.cssId}`);\n\t\t\t\t\t\treturn svelteRequest.cssId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ssr && importee === 'svelte') {\n\t\t\t\t\tif (!resolvedSvelteSSR) {\n\t\t\t\t\t\tresolvedSvelteSSR = this.resolve('svelte/ssr', undefined, { skipSelf: true }).then(\n\t\t\t\t\t\t\t(svelteSSR) => {\n\t\t\t\t\t\t\t\tlog.debug('resolved svelte to svelte/ssr');\n\t\t\t\t\t\t\t\treturn svelteSSR;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t\t'failed to resolve svelte to svelte/ssr. Update svelte to a version that exports it',\n\t\t\t\t\t\t\t\t\terr\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn null; // returning null here leads to svelte getting resolved regularly\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolvedSvelteSSR;\n\t\t\t\t}\n\t\t\t\t//@ts-expect-error scan\n\t\t\t\tconst scan = !!opts?.scan; // scanner phase of optimizeDeps\n\t\t\t\tconst isPrebundled =\n\t\t\t\t\toptions.prebundleSvelteLibraries &&\n\t\t\t\t\tviteConfig.optimizeDeps?.disabled !== true &&\n\t\t\t\t\tviteConfig.optimizeDeps?.disabled !== (options.isBuild ? 'build' : 'dev') &&\n\t\t\t\t\t!isDepExcluded(importee, viteConfig.optimizeDeps?.exclude ?? []);\n\t\t\t\t// for prebundled libraries we let vite resolve the prebundling result\n\t\t\t\t// for ssr, during scanning and non-prebundled, we do it\n\t\t\t\tif (ssr || scan || !isPrebundled) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst resolved = await resolveViaPackageJsonSvelte(importee, importer, cache);\n\t\t\t\t\t\tif (resolved) {\n\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t`resolveId resolved ${resolved} via package.json svelte field of ${importee}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn resolved;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlog.debug.once(\n\t\t\t\t\t\t\t`error trying to resolve ${importee} from ${importer} via package.json svelte field `,\n\t\t\t\t\t\t\te\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// this error most likely happens due to non-svelte related importee/importers so swallow it here\n\t\t\t\t\t\t// in case it really way a svelte library, users will notice anyway. (lib not working due to failed resolve)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tasync transform(code, id, opts) {\n\t\t\t\tconst ssr = !!opts?.ssr;\n\t\t\t\tconst svelteRequest = requestParser(id, ssr);\n\t\t\t\tif (!svelteRequest || svelteRequest.query.type === 'style' || svelteRequest.raw) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet compileData;\n\t\t\t\ttry {\n\t\t\t\t\tcompileData = await compileSvelte(svelteRequest, code, options);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcache.setError(svelteRequest, e);\n\t\t\t\t\tthrow toRollupError(e, options);\n\t\t\t\t}\n\t\t\t\tlogCompilerWarnings(svelteRequest, compileData.compiled.warnings, options);\n\t\t\t\tcache.update(compileData);\n\t\t\t\tif (compileData.dependencies?.length && options.server) {\n\t\t\t\t\tcompileData.dependencies.forEach((d) => {\n\t\t\t\t\t\tensureWatchedFile(options.server!.watcher, d, options.root);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tlog.debug(`transform returns compiled js for ${svelteRequest.filename}`);\n\t\t\t\treturn {\n\t\t\t\t\t...compileData.compiled.js,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tvite: {\n\t\t\t\t\t\t\tlang: compileData.lang\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\thandleHotUpdate(ctx: HmrContext): void | Promise<Array<ModuleNode> | void> {\n\t\t\t\tif (!options.hot || !options.emitCss) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst svelteRequest = requestParser(ctx.file, false, ctx.timestamp);\n\t\t\t\tif (svelteRequest) {\n\t\t\t\t\treturn handleHotUpdate(compileSvelte, ctx, svelteRequest, cache, options);\n\t\t\t\t}\n\t\t\t},\n\t\t\tasync buildEnd() {\n\t\t\t\tawait options.stats?.finishAll();\n\t\t\t}\n\t\t}\n\t];\n\tplugins.push(svelteInspector());\n\treturn plugins.filter(Boolean);\n}\n\nexport { vitePreprocess } from './preprocess';\nexport { loadSvelteConfig } from './utils/load-svelte-config';\n\nexport {\n\tOptions,\n\tPluginOptions,\n\tSvelteOptions,\n\tPreprocessor,\n\tPreprocessorGroup,\n\tCompileOptions,\n\tCssHashGetter,\n\tArrayable,\n\tMarkupPreprocessor,\n\tModuleFormat,\n\tProcessed,\n\tWarning\n} from './utils/options';\n\nexport { SvelteWarningsMessage } from './utils/log';\n"}},"preprocess.ts":{"file":{"contents":"import { preprocessCSS, resolveConfig, transformWithEsbuild } from 'vite';\nimport type { ESBuildOptions, InlineConfig, ResolvedConfig } from 'vite';\n// eslint-disable-next-line node/no-missing-import\nimport type { Preprocessor, PreprocessorGroup } from 'svelte/types/compiler/preprocess';\nimport { mapSourcesToRelative } from './utils/sourcemaps';\n\nconst supportedStyleLangs = ['css', 'less', 'sass', 'scss', 'styl', 'stylus', 'postcss', 'sss'];\nconst supportedScriptLangs = ['ts'];\n\nexport function vitePreprocess(opts?: {\n\tscript?: boolean;\n\tstyle?: boolean | InlineConfig | ResolvedConfig;\n}) {\n\tconst preprocessor: PreprocessorGroup = {};\n\tif (opts?.script !== false) {\n\t\tpreprocessor.script = viteScript().script;\n\t}\n\tif (opts?.style !== false) {\n\t\tconst styleOpts = typeof opts?.style == 'object' ? opts?.style : undefined;\n\t\tpreprocessor.style = viteStyle(styleOpts).style;\n\t}\n\treturn preprocessor;\n}\n\nfunction viteScript(): { script: Preprocessor } {\n\treturn {\n\t\tasync script({ attributes, content, filename = '' }) {\n\t\t\tconst lang = attributes.lang as string;\n\t\t\tif (!supportedScriptLangs.includes(lang)) return;\n\t\t\tconst { code, map } = await transformWithEsbuild(content, filename, {\n\t\t\t\tloader: lang as ESBuildOptions['loader'],\n\t\t\t\ttarget: 'esnext',\n\t\t\t\ttsconfigRaw: {\n\t\t\t\t\tcompilerOptions: {\n\t\t\t\t\t\t// svelte typescript needs this flag to work with type imports\n\t\t\t\t\t\timportsNotUsedAsValues: 'preserve',\n\t\t\t\t\t\tpreserveValueImports: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmapSourcesToRelative(map, filename);\n\n\t\t\treturn {\n\t\t\t\tcode,\n\t\t\t\tmap\n\t\t\t};\n\t\t}\n\t};\n}\n\nfunction viteStyle(config: InlineConfig | ResolvedConfig = {}): {\n\tstyle: Preprocessor;\n} {\n\tlet transform: CssTransform;\n\tconst style: Preprocessor = async ({ attributes, content, filename = '' }) => {\n\t\tconst lang = attributes.lang as string;\n\t\tif (!supportedStyleLangs.includes(lang)) return;\n\t\tif (!transform) {\n\t\t\tlet resolvedConfig: ResolvedConfig;\n\t\t\t// @ts-expect-error special prop added if running in v-p-s\n\t\t\tif (style.__resolvedConfig) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tresolvedConfig = style.__resolvedConfig;\n\t\t\t} else if (isResolvedConfig(config)) {\n\t\t\t\tresolvedConfig = config;\n\t\t\t} else {\n\t\t\t\tresolvedConfig = await resolveConfig(\n\t\t\t\t\tconfig,\n\t\t\t\t\tprocess.env.NODE_ENV === 'production' ? 'build' : 'serve'\n\t\t\t\t);\n\t\t\t}\n\t\t\ttransform = getCssTransformFn(resolvedConfig);\n\t\t}\n\t\tconst moduleId = `${filename}.${lang}`;\n\t\tconst { code, map } = await transform(content, moduleId);\n\n\t\tmapSourcesToRelative(map, moduleId);\n\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap: map ?? undefined\n\t\t};\n\t};\n\t// @ts-expect-error tag so can be found by v-p-s\n\tstyle.__resolvedConfig = null;\n\treturn { style };\n}\n\n// eslint-disable-next-line no-unused-vars\ntype CssTransform = (code: string, filename: string) => Promise<{ code: string; map?: any }>;\n\nfunction getCssTransformFn(config: ResolvedConfig): CssTransform {\n\treturn async (code, filename) => {\n\t\treturn preprocessCSS(code, filename, config);\n\t};\n}\n\nfunction isResolvedConfig(config: any): config is ResolvedConfig {\n\treturn !!config.inlineConfig;\n}\n"}},"ui":{"directory":{"inspector":{"directory":{"Inspector.svelte":{"file":{"contents":"<script>\n\t// do not use TS here so that this component works in non-ts projects too\n\timport { onMount } from 'svelte';\n\t// eslint-disable-next-line node/no-missing-import\n\timport options from 'virtual:svelte-inspector-options';\n\tconst toggle_combo = options.toggleKeyCombo?.toLowerCase().split('-');\n\tconst nav_keys = Object.values(options.navKeys).map((k) => k.toLowerCase());\n\tlet enabled = false;\n\n\tconst icon = `data:image/svg+xml;base64,${btoa(\n\t\t`\n<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"21\" height=\"25\" viewBox=\"0 0 107 128\">\n  <title>svelte-inspector-logo</title>\n  <path d=\"M94.1566,22.8189c-10.4-14.8851-30.94-19.2971-45.7914-9.8348L22.2825,29.6078A29.9234,29.9234,0,0,0,8.7639,49.6506a31.5136,31.5136,0,0,0,3.1076,20.2318A30.0061,30.0061,0,0,0,7.3953,81.0653a31.8886,31.8886,0,0,0,5.4473,24.1157c10.4022,14.8865,30.9423,19.2966,45.7914,9.8348L84.7167,98.3921A29.9177,29.9177,0,0,0,98.2353,78.3493,31.5263,31.5263,0,0,0,95.13,58.117a30,30,0,0,0,4.4743-11.1824,31.88,31.88,0,0,0-5.4473-24.1157\" style=\"fill:#ff3e00\"/><path d=\"M45.8171,106.5815A20.7182,20.7182,0,0,1,23.58,98.3389a19.1739,19.1739,0,0,1-3.2766-14.5025,18.1886,18.1886,0,0,1,.6233-2.4357l.4912-1.4978,1.3363.9815a33.6443,33.6443,0,0,0,10.203,5.0978l.9694.2941-.0893.9675a5.8474,5.8474,0,0,0,1.052,3.8781,6.2389,6.2389,0,0,0,6.6952,2.485,5.7449,5.7449,0,0,0,1.6021-.7041L69.27,76.281a5.4306,5.4306,0,0,0,2.4506-3.631,5.7948,5.7948,0,0,0-.9875-4.3712,6.2436,6.2436,0,0,0-6.6978-2.4864,5.7427,5.7427,0,0,0-1.6.7036l-9.9532,6.3449a19.0329,19.0329,0,0,1-5.2965,2.3259,20.7181,20.7181,0,0,1-22.2368-8.2427,19.1725,19.1725,0,0,1-3.2766-14.5024,17.9885,17.9885,0,0,1,8.13-12.0513L55.8833,23.7472a19.0038,19.0038,0,0,1,5.3-2.3287A20.7182,20.7182,0,0,1,83.42,29.6611a19.1739,19.1739,0,0,1,3.2766,14.5025,18.4,18.4,0,0,1-.6233,2.4357l-.4912,1.4978-1.3356-.98a33.6175,33.6175,0,0,0-10.2037-5.1l-.9694-.2942.0893-.9675a5.8588,5.8588,0,0,0-1.052-3.878,6.2389,6.2389,0,0,0-6.6952-2.485,5.7449,5.7449,0,0,0-1.6021.7041L37.73,51.719a5.4218,5.4218,0,0,0-2.4487,3.63,5.7862,5.7862,0,0,0,.9856,4.3717,6.2437,6.2437,0,0,0,6.6978,2.4864,5.7652,5.7652,0,0,0,1.602-.7041l9.9519-6.3425a18.978,18.978,0,0,1,5.2959-2.3278,20.7181,20.7181,0,0,1,22.2368,8.2427,19.1725,19.1725,0,0,1,3.2766,14.5024,17.9977,17.9977,0,0,1-8.13,12.0532L51.1167,104.2528a19.0038,19.0038,0,0,1-5.3,2.3287\" style=\"fill:#fff\"/>\n  <polygon points=\"0,0 15,40 40,20\" stroke=\"#ff3e00\" fill=\"#ff3e00\"></polygon>\n</svg>\n`\n\t\t\t.replace(/[\\n\\r\\t\\s]+/g, ' ')\n\t\t\t.trim()\n\t)}`;\n\n\t// location of code in file\n\tlet file_loc;\n\t// cursor pos and width for file_loc overlay positioning\n\tlet x, y, w;\n\n\tlet active_el;\n\n\tlet enabled_ts;\n\n\t$: show_toggle =\n\t\toptions.showToggleButton === 'always' || (options.showToggleButton === 'active' && enabled);\n\n\tfunction mousemove(event) {\n\t\tx = event.x;\n\t\ty = event.y;\n\t}\n\n\tfunction find_selectable_parent(el, include_self = false) {\n\t\tif (!include_self) {\n\t\t\tel = el.parentNode;\n\t\t}\n\t\twhile (el) {\n\t\t\tif (is_selectable(el)) {\n\t\t\t\treturn el;\n\t\t\t}\n\t\t\tel = el.parentNode;\n\t\t}\n\t}\n\n\tfunction find_selectable_child(el) {\n\t\treturn [...el.querySelectorAll('*')].find(is_selectable);\n\t}\n\n\tfunction find_selectable_sibling(el, prev = false) {\n\t\tdo {\n\t\t\tel = prev ? el.previousElementSibling : el.nextElementSibling;\n\t\t\tif (is_selectable(el)) {\n\t\t\t\treturn el;\n\t\t\t}\n\t\t} while (el);\n\t}\n\n\tfunction find_selectable_for_nav(key) {\n\t\tconst el = active_el;\n\t\tif (!el) {\n\t\t\treturn find_selectable_child(document?.body);\n\t\t}\n\t\tswitch (key) {\n\t\t\tcase options.navKeys.parent:\n\t\t\t\treturn find_selectable_parent(el);\n\t\t\tcase options.navKeys.child:\n\t\t\t\treturn find_selectable_child(el);\n\t\t\tcase options.navKeys.next:\n\t\t\t\treturn find_selectable_sibling(el) || find_selectable_parent(el);\n\t\t\tcase options.navKeys.prev:\n\t\t\t\treturn find_selectable_sibling(el, true) || find_selectable_parent(el);\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction is_selectable(el) {\n\t\tconst file = el?.__svelte_meta?.loc?.file;\n\t\tif (!file || file.includes('node_modules/')) {\n\t\t\treturn false; // no file or 3rd party\n\t\t}\n\t\tconst id = el.getAttribute('id');\n\t\tif (id === 'svelte-announcer' || id?.startsWith('svelte-inspector-')) {\n\t\t\treturn false; // ignore some elements by id that would be selectable from keyboard nav otherwise\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mouseover({ target }) {\n\t\tconst el = find_selectable_parent(target, true);\n\t\tactivate(el, false);\n\t}\n\n\tfunction activate(el, set_bubble_pos = true) {\n\t\tif (options.customStyles && el !== active_el) {\n\t\t\tif (active_el) {\n\t\t\t\tactive_el.classList.remove('svelte-inspector-active-target');\n\t\t\t}\n\t\t\tif (el) {\n\t\t\t\tel.classList.add('svelte-inspector-active-target');\n\t\t\t}\n\t\t}\n\t\tif (el) {\n\t\t\tconst { file, line, column } = el.__svelte_meta.loc;\n\t\t\tfile_loc = `${file}:${line + 1}:${column + 1}`;\n\t\t} else {\n\t\t\tfile_loc = null;\n\t\t}\n\t\tactive_el = el;\n\t\tif (set_bubble_pos) {\n\t\t\tconst pos = el.getBoundingClientRect();\n\t\t\tx = Math.ceil(pos.left);\n\t\t\ty = Math.ceil(pos.bottom - 20);\n\t\t}\n\t}\n\n\tfunction open_editor(event) {\n\t\tif (file_loc) {\n\t\t\tstop(event);\n\t\t\tfetch(`/__open-in-editor?file=${encodeURIComponent(file_loc)}`);\n\t\t\tif (options.holdMode && is_holding()) {\n\t\t\t\tdisable();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction is_key_active(key, event) {\n\t\tswitch (key) {\n\t\t\tcase 'shift':\n\t\t\tcase 'control':\n\t\t\tcase 'alt':\n\t\t\tcase 'meta':\n\t\t\t\treturn event.getModifierState(key.charAt(0).toUpperCase() + key.slice(1));\n\t\t\tdefault:\n\t\t\t\treturn key === event.key.toLowerCase();\n\t\t}\n\t}\n\n\tfunction is_combo(event) {\n\t\treturn toggle_combo?.every((key) => is_key_active(key, event));\n\t}\n\n\tfunction is_nav(event) {\n\t\treturn nav_keys?.some((key) => is_key_active(key, event));\n\t}\n\n\tfunction is_open(event) {\n\t\treturn options.openKey && options.openKey.toLowerCase() === event.key.toLowerCase();\n\t}\n\n\tfunction is_holding() {\n\t\treturn enabled_ts && Date.now() - enabled_ts > 250;\n\t}\n\n\tfunction stop(event) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tevent.stopImmediatePropagation();\n\t}\n\n\tfunction keydown(event) {\n\t\tif (event.repeat || event.key == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_combo(event)) {\n\t\t\ttoggle();\n\t\t\tif (options.holdMode && enabled) {\n\t\t\t\tenabled_ts = Date.now();\n\t\t\t}\n\t\t} else if (enabled) {\n\t\t\tif (is_nav(event)) {\n\t\t\t\tconst el = find_selectable_for_nav(event.key);\n\t\t\t\tif (el) {\n\t\t\t\t\tactivate(el);\n\t\t\t\t\tstop(event);\n\t\t\t\t}\n\t\t\t} else if (is_open(event)) {\n\t\t\t\topen_editor(event);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction keyup(event) {\n\t\tif (event.repeat || event.key == null) {\n\t\t\treturn;\n\t\t}\n\t\tconst k = event.key.toLowerCase();\n\t\tif (enabled && is_holding() && toggle_combo.includes(k)) {\n\t\t\tdisable();\n\t\t} else {\n\t\t\tenabled_ts = null;\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\tenabled ? disable() : enable();\n\t}\n\n\tfunction listeners(body, enabled) {\n\t\tconst l = enabled ? body.addEventListener : body.removeEventListener;\n\t\tl('mousemove', mousemove);\n\t\tl('mouseover', mouseover);\n\t\tl('click', open_editor, true);\n\t}\n\n\tfunction enable() {\n\t\tenabled = true;\n\t\tconst b = document.body;\n\t\tif (options.customStyles) {\n\t\t\tb.classList.add('svelte-inspector-enabled');\n\t\t}\n\t\tlisteners(b, enabled);\n\t\tactivate_initial_el();\n\t}\n\n\tfunction activate_initial_el() {\n\t\tconst hov = innermost_hover_el();\n\t\tlet el = find_selectable_parent(hov, true);\n\t\tif (!el) {\n\t\t\tconst act = document.activeElement;\n\t\t\tel = find_selectable_parent(act, true);\n\t\t}\n\t\tif (!el) {\n\t\t\tel = find_selectable_child(document.body);\n\t\t}\n\t\tif (el) {\n\t\t\tactivate(el);\n\t\t}\n\t}\n\n\tfunction innermost_hover_el() {\n\t\tlet e = document.body.querySelector(':hover');\n\t\tlet result;\n\t\twhile (e) {\n\t\t\tresult = e;\n\t\t\te = e.querySelector(':hover');\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction disable() {\n\t\tenabled = false;\n\t\tenabled_ts = null;\n\t\tconst b = document.body;\n\t\tlisteners(b, enabled);\n\t\tif (options.customStyles) {\n\t\t\tb.classList.remove('svelte-inspector-enabled');\n\t\t\tactive_el?.classList.remove('svelte-inspector-active-target');\n\t\t}\n\t\tactive_el = null;\n\t}\n\n\tonMount(() => {\n\t\tconst s = document.createElement('style');\n\t\ts.setAttribute('type', 'text/css');\n\t\ts.setAttribute('id', 'svelte-inspector-style');\n\t\ts.textContent = `:root { --svelte-inspector-icon: url(${icon})};`;\n\t\tdocument.head.append(s);\n\t\tif (toggle_combo) {\n\t\t\tdocument.body.addEventListener('keydown', keydown);\n\t\t\tif (options.holdMode) {\n\t\t\t\tdocument.body.addEventListener('keyup', keyup);\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\t// make sure we get rid of everything\n\t\t\tdisable();\n\t\t\tconst s = document.head.querySelector('#svelte-inspector-style');\n\t\t\tif (s) {\n\t\t\t\tdocument.head.removeChild(s);\n\t\t\t}\n\t\t\tif (toggle_combo) {\n\t\t\t\tdocument.body.removeEventListener('keydown', keydown);\n\t\t\t\tif (options.holdMode) {\n\t\t\t\t\tdocument.body.addEventListener('keyup', keyup);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n</script>\n\n{#if show_toggle}\n\t<button\n\t\tid=\"svelte-inspector-toggle\"\n\t\tclass:enabled\n\t\tstyle={`background-image: var(--svelte-inspector-icon);${options.toggleButtonPos\n\t\t\t.split('-')\n\t\t\t.map((p) => `${p}: 8px;`)\n\t\t\t.join('')}`}\n\t\ton:click={() => toggle()}\n\t\taria-label={`${enabled ? 'disable' : 'enable'} svelte-inspector`}\n\t/>\n{/if}\n{#if enabled && active_el && file_loc}\n\t{@const loc = active_el.__svelte_meta.loc}\n\t<div\n\t\tid=\"svelte-inspector-overlay\"\n\t\tstyle:left=\"{Math.min(x + 3, document.documentElement.clientWidth - w - 10)}px\"\n\t\tstyle:top=\"{document.documentElement.clientHeight < y + 50 ? y - 30 : y + 30}px\"\n\t\tbind:offsetWidth={w}\n\t>\n\t\t&lt;{active_el.tagName.toLowerCase()}&gt;&nbsp;{file_loc}\n\t</div>\n\t<div id=\"svelte-inspector-announcer\" aria-live=\"assertive\" aria-atomic=\"true\">\n\t\t{active_el.tagName.toLowerCase()} in file {loc.file} on line {loc.line} column {loc.column}\n\t</div>\n{/if}\n\n<style>\n\t:global(body.svelte-inspector-enabled *) {\n\t\tcursor: var(--svelte-inspector-icon), crosshair !important;\n\t}\n\t:global(.svelte-inspector-active-target) {\n\t\toutline: 2px dashed #ff3e00 !important;\n\t}\n\n\t#svelte-inspector-overlay {\n\t\tposition: fixed;\n\t\tbackground-color: rgba(0, 0, 0, 0.8);\n\t\tcolor: #fff;\n\t\tpadding: 2px 4px;\n\t\tborder-radius: 5px;\n\t\tz-index: 999999;\n\t\tpointer-events: none;\n\t}\n\n\t#svelte-inspector-toggle {\n\t\tall: unset;\n\t\tborder: 1px solid #ff3e00;\n\t\tborder-radius: 8px;\n\t\tposition: fixed;\n\t\theight: 32px;\n\t\twidth: 32px;\n\t\tbackground-color: white;\n\t\tbackground-position: center;\n\t\tbackground-repeat: no-repeat;\n\t\tcursor: pointer;\n\t}\n\n\t#svelte-inspector-announcer {\n\t\tposition: absolute;\n\t\tleft: 0px;\n\t\ttop: 0px;\n\t\tclip: rect(0px, 0px, 0px, 0px);\n\t\tclip-path: inset(50%);\n\t\toverflow: hidden;\n\t\twhite-space: nowrap;\n\t\twidth: 1px;\n\t\theight: 1px;\n\t}\n\n\t#svelte-inspector-toggle:not(.enabled) {\n\t\tfilter: grayscale(1);\n\t}\n\t#svelte-inspector-toggle:hover {\n\t\tbackground-color: #facece;\n\t}\n</style>\n"}},"load-inspector.js":{"file":{"contents":"// eslint-disable-next-line node/no-missing-import\nimport Inspector from 'virtual:svelte-inspector-path:Inspector.svelte';\n\nfunction create_inspector_host() {\n\tconst id = 'svelte-inspector-host';\n\tif (document.getElementById(id) != null) {\n\t\tthrow new Error('svelte-inspector-host element already exists');\n\t}\n\tconst el = document.createElement('div');\n\tel.setAttribute('id', id);\n\tdocument.getElementsByTagName('body')[0].appendChild(el);\n\treturn el;\n}\n\nnew Inspector({ target: create_inspector_host() });\n"}},"plugin.ts":{"file":{"contents":"import { Plugin, normalizePath } from 'vite';\nimport { log } from '../../utils/log';\nimport { InspectorOptions } from '../../utils/options';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport fs from 'fs';\nimport { idToFile } from './utils';\n\nconst defaultInspectorOptions: InspectorOptions = {\n\ttoggleKeyCombo: process.platform === 'win32' ? 'control-shift' : 'meta-shift',\n\tnavKeys: { parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' },\n\topenKey: 'Enter',\n\tholdMode: false,\n\tshowToggleButton: 'active',\n\ttoggleButtonPos: 'top-right',\n\tcustomStyles: true\n};\n\nfunction getInspectorPath() {\n\tconst pluginPath = normalizePath(path.dirname(fileURLToPath(import.meta.url)));\n\treturn pluginPath.replace(/\\/vite-plugin-svelte\\/dist$/, '/vite-plugin-svelte/src/ui/inspector/');\n}\n\nexport function svelteInspector(): Plugin {\n\tconst inspectorPath = getInspectorPath();\n\tlog.debug.enabled && log.debug(`svelte inspector path: ${inspectorPath}`);\n\tlet inspectorOptions: InspectorOptions;\n\tlet appendTo: string | undefined;\n\tlet disabled = false;\n\n\treturn {\n\t\tname: 'vite-plugin-svelte:inspector',\n\t\tapply: 'serve',\n\t\tenforce: 'pre',\n\n\t\tconfigResolved(config) {\n\t\t\tconst vps = config.plugins.find((p) => p.name === 'vite-plugin-svelte');\n\t\t\tconst options = vps?.api?.options?.experimental?.inspector;\n\t\t\tif (!vps || !options) {\n\t\t\t\tlog.debug('inspector disabled, could not find config');\n\t\t\t\tdisabled = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinspectorOptions = {\n\t\t\t\t...defaultInspectorOptions,\n\t\t\t\t...options\n\t\t\t};\n\t\t\tconst isSvelteKit = config.plugins.some((p) => p.name.startsWith('vite-plugin-sveltekit'));\n\t\t\tif (isSvelteKit && !inspectorOptions.appendTo) {\n\t\t\t\t// this could append twice if a user had a file that ends with /generated/root.svelte\n\t\t\t\t// but that should be rare and inspector doesn't execute twice\n\t\t\t\tinspectorOptions.appendTo = `/generated/root.svelte`;\n\t\t\t}\n\t\t\tappendTo = inspectorOptions.appendTo;\n\t\t},\n\n\t\tasync resolveId(importee: string, importer, options) {\n\t\t\tif (options?.ssr || disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (importee.startsWith('virtual:svelte-inspector-options')) {\n\t\t\t\treturn importee;\n\t\t\t} else if (importee.startsWith('virtual:svelte-inspector-path:')) {\n\t\t\t\tconst resolved = importee.replace('virtual:svelte-inspector-path:', inspectorPath);\n\t\t\t\tlog.debug.enabled && log.debug(`resolved ${importee} with ${resolved}`);\n\t\t\t\treturn resolved;\n\t\t\t}\n\t\t},\n\n\t\tasync load(id, options) {\n\t\t\tif (options?.ssr || disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (id === 'virtual:svelte-inspector-options') {\n\t\t\t\treturn `export default ${JSON.stringify(inspectorOptions ?? {})}`;\n\t\t\t} else if (id.startsWith(inspectorPath)) {\n\t\t\t\t// read file ourselves to avoid getting shut out by vites fs.allow check\n\t\t\t\tconst file = idToFile(id);\n\t\t\t\tif (fs.existsSync(file)) {\n\t\t\t\t\treturn await fs.promises.readFile(file, 'utf-8');\n\t\t\t\t} else {\n\t\t\t\t\tlog.error(`failed to find file for svelte-inspector: ${file}, referenced by id ${id}.`);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\ttransform(code: string, id: string, options?: { ssr?: boolean }) {\n\t\t\tif (options?.ssr || disabled || !appendTo) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (id.endsWith(appendTo)) {\n\t\t\t\treturn { code: `${code}\\nimport 'virtual:svelte-inspector-path:load-inspector.js'` };\n\t\t\t}\n\t\t},\n\t\ttransformIndexHtml(html) {\n\t\t\tif (disabled || appendTo) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\ttags: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttag: 'script',\n\t\t\t\t\t\tinjectTo: 'body',\n\t\t\t\t\t\tattrs: {\n\t\t\t\t\t\t\ttype: 'module',\n\t\t\t\t\t\t\t// /@id/ is needed, otherwise the virtual: is seen as protocol by browser and cors error happens\n\t\t\t\t\t\t\tsrc: '/@id/virtual:svelte-inspector-path:load-inspector.js'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t};\n}\n"}},"utils.ts":{"file":{"contents":"const FS_PREFIX = `/@fs/`;\nconst IS_WINDOWS = process.platform === 'win32';\nconst queryRE = /\\?.*$/s;\nconst hashRE = /#.*$/s;\n\nexport function idToFile(id: string): string {\n\t// strip /@fs/ but keep leading / on non-windows\n\tif (id.startsWith(FS_PREFIX)) {\n\t\tid = id = id.slice(IS_WINDOWS ? FS_PREFIX.length : FS_PREFIX.length - 1);\n\t}\n\t// strip query and hash\n\treturn id.replace(hashRE, '').replace(queryRE, '');\n}\n"}}}}}},"utils":{"directory":{"compile.ts":{"file":{"contents":"import { CompileOptions, ResolvedOptions } from './options';\nimport { compile, preprocess, walk } from 'svelte/compiler';\n// @ts-ignore\nimport { createMakeHot } from 'svelte-hmr';\nimport { SvelteRequest } from './id';\nimport { safeBase64Hash } from './hash';\nimport { log } from './log';\nimport { StatCollection } from './vite-plugin-svelte-stats';\n//eslint-disable-next-line node/no-missing-import\nimport type { Processed } from 'svelte/types/compiler/preprocess';\nimport { createInjectScopeEverythingRulePreprocessorGroup } from './preprocess';\nimport { mapSourcesToRelative } from './sourcemaps';\n\nconst scriptLangRE = /<script [^>]*lang=[\"']?([^\"' >]+)[\"']?[^>]*>/;\n\nexport type CompileSvelte = ReturnType<typeof _createCompileSvelte>;\n\nconst _createCompileSvelte = (makeHot: Function) => {\n\tlet stats: StatCollection | undefined;\n\tconst devStylePreprocessor = createInjectScopeEverythingRulePreprocessorGroup();\n\treturn async function compileSvelte(\n\t\tsvelteRequest: SvelteRequest,\n\t\tcode: string,\n\t\toptions: Partial<ResolvedOptions>\n\t): Promise<CompileData> {\n\t\tconst { filename, normalizedFilename, cssId, ssr, raw } = svelteRequest;\n\t\tconst { emitCss = true } = options;\n\t\tconst dependencies = [];\n\n\t\tif (options.stats) {\n\t\t\tif (options.isBuild) {\n\t\t\t\tif (!stats) {\n\t\t\t\t\t// build is either completely ssr or csr, create stats collector on first compile\n\t\t\t\t\t// it is then finished in the buildEnd hook.\n\t\t\t\t\tstats = options.stats.startCollection(`${ssr ? 'ssr' : 'dom'} compile`, {\n\t\t\t\t\t\tlogInProgress: () => false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// dev time ssr, it's a ssr request and there are no stats, assume new page load and start collecting\n\t\t\t\tif (ssr && !stats) {\n\t\t\t\t\tstats = options.stats.startCollection('ssr compile');\n\t\t\t\t}\n\t\t\t\t// stats are being collected but this isn't an ssr request, assume page loaded and stop collecting\n\t\t\t\tif (!ssr && stats) {\n\t\t\t\t\tstats.finish();\n\t\t\t\t\tstats = undefined;\n\t\t\t\t}\n\t\t\t\t// TODO find a way to trace dom compile during dev\n\t\t\t\t// problem: we need to call finish at some point but have no way to tell if page load finished\n\t\t\t\t// also they for hmr updates too\n\t\t\t}\n\t\t}\n\n\t\tconst compileOptions: CompileOptions = {\n\t\t\t...options.compilerOptions,\n\t\t\tfilename: normalizedFilename, // use normalized here to avoid bleeding absolute fs path\n\t\t\tgenerate: ssr ? 'ssr' : 'dom',\n\t\t\tformat: 'esm'\n\t\t};\n\t\tif (options.hot && options.emitCss) {\n\t\t\tconst hash = `s-${safeBase64Hash(normalizedFilename)}`;\n\t\t\tlog.debug(`setting cssHash ${hash} for ${normalizedFilename}`);\n\t\t\tcompileOptions.cssHash = () => hash;\n\t\t}\n\t\tif (ssr && compileOptions.enableSourcemap !== false) {\n\t\t\tif (typeof compileOptions.enableSourcemap === 'object') {\n\t\t\t\tcompileOptions.enableSourcemap.css = false;\n\t\t\t} else {\n\t\t\t\tcompileOptions.enableSourcemap = { js: true, css: false };\n\t\t\t}\n\t\t}\n\n\t\tlet preprocessed;\n\t\tlet preprocessors = options.preprocess;\n\t\tif (!options.isBuild && options.emitCss && options.hot) {\n\t\t\t// inject preprocessor that ensures css hmr works better\n\t\t\tif (!Array.isArray(preprocessors)) {\n\t\t\t\tpreprocessors = preprocessors\n\t\t\t\t\t? [preprocessors, devStylePreprocessor]\n\t\t\t\t\t: [devStylePreprocessor];\n\t\t\t} else {\n\t\t\t\tpreprocessors = preprocessors.concat(devStylePreprocessor);\n\t\t\t}\n\t\t}\n\t\tif (preprocessors) {\n\t\t\ttry {\n\t\t\t\tpreprocessed = await preprocess(code, preprocessors, { filename }); // full filename here so postcss works\n\t\t\t} catch (e) {\n\t\t\t\te.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ''}`;\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (preprocessed.dependencies) dependencies.push(...preprocessed.dependencies);\n\t\t\tif (preprocessed.map) compileOptions.sourcemap = preprocessed.map;\n\t\t}\n\t\tif (typeof preprocessed?.map === 'object') {\n\t\t\tmapSourcesToRelative(preprocessed?.map, filename);\n\t\t}\n\t\tif (raw && svelteRequest.query.type === 'preprocessed') {\n\t\t\t// shortcut\n\t\t\treturn { preprocessed: preprocessed ?? { code } } as CompileData;\n\t\t}\n\t\tconst finalCode = preprocessed ? preprocessed.code : code;\n\t\tconst dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\n\t\t\tfilename,\n\t\t\tcode: finalCode,\n\t\t\tcompileOptions\n\t\t});\n\t\tif (dynamicCompileOptions && log.debug.enabled) {\n\t\t\tlog.debug(\n\t\t\t\t`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`\n\t\t\t);\n\t\t}\n\t\tconst finalCompileOptions = dynamicCompileOptions\n\t\t\t? {\n\t\t\t\t\t...compileOptions,\n\t\t\t\t\t...dynamicCompileOptions\n\t\t\t  }\n\t\t\t: compileOptions;\n\n\t\tconst endStat = stats?.start(filename);\n\t\tconst compiled = compile(finalCode, finalCompileOptions);\n\t\tif (endStat) {\n\t\t\tendStat();\n\t\t}\n\t\tmapSourcesToRelative(compiled.js?.map, filename);\n\t\tmapSourcesToRelative(compiled.css?.map, filename);\n\t\tif (!raw) {\n\t\t\t// wire css import and code for hmr\n\t\t\tconst hasCss = compiled.css?.code?.trim().length > 0;\n\t\t\t// compiler might not emit css with mode none or it may be empty\n\t\t\tif (emitCss && hasCss) {\n\t\t\t\t// TODO properly update sourcemap?\n\t\t\t\tcompiled.js.code += `\\nimport ${JSON.stringify(cssId)};\\n`;\n\t\t\t}\n\n\t\t\t// only apply hmr when not in ssr context and hot options are set\n\t\t\tif (!ssr && makeHot) {\n\t\t\t\tcompiled.js.code = makeHot({\n\t\t\t\t\tid: filename,\n\t\t\t\t\tcompiledCode: compiled.js.code,\n\t\t\t\t\t//@ts-expect-error hot isn't a boolean at this point\n\t\t\t\t\thotOptions: { ...options.hot, injectCss: options.hot?.injectCss === true && hasCss },\n\t\t\t\t\tcompiled,\n\t\t\t\t\toriginalCode: code,\n\t\t\t\t\tcompileOptions: finalCompileOptions\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tcompiled.js.dependencies = dependencies;\n\n\t\treturn {\n\t\t\tfilename,\n\t\t\tnormalizedFilename,\n\t\t\tlang: code.match(scriptLangRE)?.[1] || 'js',\n\t\t\t// @ts-ignore\n\t\t\tcompiled,\n\t\t\tssr,\n\t\t\tdependencies,\n\t\t\tpreprocessed: preprocessed ?? { code }\n\t\t};\n\t};\n};\nfunction buildMakeHot(options: ResolvedOptions) {\n\tconst needsMakeHot = options.hot !== false && options.isServe && !options.isProduction;\n\tif (needsMakeHot) {\n\t\t// @ts-ignore\n\t\tconst hotApi = options?.hot?.hotApi;\n\t\t// @ts-ignore\n\t\tconst adapter = options?.hot?.adapter;\n\t\treturn createMakeHot({\n\t\t\twalk,\n\t\t\thotApi,\n\t\t\tadapter,\n\t\t\thotOptions: { noOverlay: true, ...(options.hot as object) }\n\t\t});\n\t}\n}\n\nexport function createCompileSvelte(options: ResolvedOptions) {\n\tconst makeHot = buildMakeHot(options);\n\treturn _createCompileSvelte(makeHot);\n}\n\nexport interface Code {\n\tcode: string;\n\tmap?: any;\n\tdependencies?: any[];\n}\n\nexport interface Compiled {\n\tjs: Code;\n\tcss: Code;\n\tast: any; // TODO type\n\twarnings: any[]; // TODO type\n\tvars: {\n\t\tname: string;\n\t\texport_name: string;\n\t\tinjected: boolean;\n\t\tmodule: boolean;\n\t\tmutated: boolean;\n\t\treassigned: boolean;\n\t\treferenced: boolean;\n\t\twritable: boolean;\n\t\treferenced_from_script: boolean;\n\t}[];\n\tstats: {\n\t\ttimings: {\n\t\t\ttotal: number;\n\t\t};\n\t};\n}\n\nexport interface CompileData {\n\tfilename: string;\n\tnormalizedFilename: string;\n\tlang: string;\n\tcompiled: Compiled;\n\tssr: boolean | undefined;\n\tdependencies: string[];\n\tpreprocessed: Processed;\n}\n"}},"constants.ts":{"file":{"contents":"export const VITE_RESOLVE_MAIN_FIELDS = ['module', 'jsnext:main', 'jsnext'];\n\nexport const SVELTE_RESOLVE_MAIN_FIELDS = ['svelte'];\n\nexport const SVELTE_IMPORTS = [\n\t'svelte/animate',\n\t'svelte/easing',\n\t'svelte/internal',\n\t'svelte/motion',\n\t'svelte/ssr',\n\t'svelte/store',\n\t'svelte/transition',\n\t'svelte'\n];\n\nexport const SVELTE_HMR_IMPORTS = [\n\t'svelte-hmr/runtime/hot-api-esm.js',\n\t'svelte-hmr/runtime/proxy-adapter-dom.js',\n\t'svelte-hmr'\n];\n\nexport const SVELTE_EXPORT_CONDITIONS = ['svelte'];\n"}},"dependencies.ts":{"file":{"contents":"import path from 'path';\nimport fs from 'fs/promises';\n// eslint-disable-next-line node/no-missing-import\nimport { findDepPkgJsonPath } from 'vitefu';\n\ninterface DependencyData {\n\tdir: string;\n\tpkg: Record<string, any>;\n}\n\nexport async function resolveDependencyData(\n\tdep: string,\n\tparent: string\n): Promise<DependencyData | undefined> {\n\tconst depDataPath = await findDepPkgJsonPath(dep, parent);\n\tif (!depDataPath) return undefined;\n\ttry {\n\t\treturn {\n\t\t\tdir: path.dirname(depDataPath),\n\t\t\tpkg: JSON.parse(await fs.readFile(depDataPath, 'utf-8'))\n\t\t};\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n\nconst COMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD = [\n\t'@lukeed/uuid',\n\t'@playwright/test',\n\t'@sveltejs/vite-plugin-svelte',\n\t'@sveltejs/kit',\n\t'autoprefixer',\n\t'cookie',\n\t'dotenv',\n\t'esbuild',\n\t'eslint',\n\t'jest',\n\t'mdsvex',\n\t'playwright',\n\t'postcss',\n\t'prettier',\n\t'svelte',\n\t'svelte-check',\n\t'svelte-hmr',\n\t'svelte-preprocess',\n\t'tslib',\n\t'typescript',\n\t'vite',\n\t'vitest',\n\t'__vite-browser-external' // see https://github.com/sveltejs/vite-plugin-svelte/issues/362\n];\nconst COMMON_PREFIXES_WITHOUT_SVELTE_FIELD = [\n\t'@fontsource/',\n\t'@postcss-plugins/',\n\t'@rollup/',\n\t'@sveltejs/adapter-',\n\t'@types/',\n\t'@typescript-eslint/',\n\t'eslint-',\n\t'jest-',\n\t'postcss-plugin-',\n\t'prettier-plugin-',\n\t'rollup-plugin-',\n\t'vite-plugin-'\n];\n\n/**\n * Test for common dependency names that tell us it is not a package including a svelte field, eg. eslint + plugins.\n *\n * This speeds up the find process as we don't have to try and require the package.json for all of them\n *\n * @param dependency {string}\n * @returns {boolean} true if it is a dependency without a svelte field\n */\nexport function isCommonDepWithoutSvelteField(dependency: string): boolean {\n\treturn (\n\t\tCOMMON_DEPENDENCIES_WITHOUT_SVELTE_FIELD.includes(dependency) ||\n\t\tCOMMON_PREFIXES_WITHOUT_SVELTE_FIELD.some(\n\t\t\t(prefix) =>\n\t\t\t\tprefix.startsWith('@')\n\t\t\t\t\t? dependency.startsWith(prefix)\n\t\t\t\t\t: dependency.substring(dependency.lastIndexOf('/') + 1).startsWith(prefix) // check prefix omitting @scope/\n\t\t)\n\t);\n}\n"}},"error.ts":{"file":{"contents":"import { RollupError } from 'rollup';\nimport { ResolvedOptions, Warning } from './options';\nimport { buildExtendedLogMessage } from './log';\nimport { PartialMessage } from 'esbuild';\n\n/**\n * convert an error thrown by svelte.compile to a RollupError so that vite displays it in a user friendly way\n * @param error a svelte compiler error, which is a mix of Warning and an error\n * @returns {RollupError} the converted error\n */\nexport function toRollupError(error: Warning & Error, options: ResolvedOptions): RollupError {\n\tconst { filename, frame, start, code, name, stack } = error;\n\tconst rollupError: RollupError = {\n\t\tname, // needed otherwise sveltekit coalesce_to_error turns it into a string\n\t\tid: filename,\n\t\tmessage: buildExtendedLogMessage(error), // include filename:line:column so that it's clickable\n\t\tframe: formatFrameForVite(frame),\n\t\tcode,\n\t\tstack: options.isBuild || options.isDebug || !frame ? stack : ''\n\t};\n\tif (start) {\n\t\trollupError.loc = {\n\t\t\tline: start.line,\n\t\t\tcolumn: start.column,\n\t\t\tfile: filename\n\t\t};\n\t}\n\treturn rollupError;\n}\n\n/**\n * convert an error thrown by svelte.compile to an esbuild PartialMessage\n * @param error a svelte compiler error, which is a mix of Warning and an error\n * @returns {PartialMessage} the converted error\n */\nexport function toESBuildError(error: Warning & Error, options: ResolvedOptions): PartialMessage {\n\tconst { filename, frame, start, stack } = error;\n\tconst partialMessage: PartialMessage = {\n\t\ttext: buildExtendedLogMessage(error)\n\t};\n\tif (start) {\n\t\tpartialMessage.location = {\n\t\t\tline: start.line,\n\t\t\tcolumn: start.column,\n\t\t\tfile: filename,\n\t\t\tlineText: lineFromFrame(start.line, frame) // needed to get a meaningful error message on cli\n\t\t};\n\t}\n\tif (options.isBuild || options.isDebug || !frame) {\n\t\tpartialMessage.detail = stack;\n\t}\n\treturn partialMessage;\n}\n\n/**\n * extract line with number from codeframe\n */\nfunction lineFromFrame(lineNo: number, frame?: string): string {\n\tif (!frame) {\n\t\treturn '';\n\t}\n\tconst lines = frame.split('\\n');\n\tconst errorLine = lines.find((line) => line.trimStart().startsWith(`${lineNo}: `));\n\treturn errorLine ? errorLine.substring(errorLine.indexOf(': ') + 3) : '';\n}\n\n/**\n * vite error overlay expects a specific format to show frames\n * this reformats svelte frame (colon separated, less whitespace)\n * to one that vite displays on overlay ( pipe separated, more whitespace)\n * e.g.\n * ```\n * 1: foo\n * 2: bar;\n *       ^\n * 3: baz\n * ```\n * to\n * ```\n *  1 | foo\n *  2 | bar;\n *         ^\n *  3 | baz\n * ```\n * @see https://github.com/vitejs/vite/blob/96591bf9989529de839ba89958755eafe4c445ae/packages/vite/src/client/overlay.ts#L116\n */\nfunction formatFrameForVite(frame?: string): string {\n\tif (!frame) {\n\t\treturn '';\n\t}\n\treturn frame\n\t\t.split('\\n')\n\t\t.map((line) => (line.match(/^\\s+\\^/) ? '   ' + line : ' ' + line.replace(':', ' | ')))\n\t\t.join('\\n');\n}\n"}},"esbuild.ts":{"file":{"contents":"import { readFileSync } from 'fs';\nimport { compile, preprocess } from 'svelte/compiler';\nimport { DepOptimizationOptions } from 'vite';\nimport { Compiled } from './compile';\nimport { log } from './log';\nimport { CompileOptions, ResolvedOptions } from './options';\nimport { toESBuildError } from './error';\nimport { StatCollection } from './vite-plugin-svelte-stats';\n\ntype EsbuildOptions = NonNullable<DepOptimizationOptions['esbuildOptions']>;\ntype EsbuildPlugin = NonNullable<EsbuildOptions['plugins']>[number];\n\nexport const facadeEsbuildSveltePluginName = 'vite-plugin-svelte:facade';\n\nexport function esbuildSveltePlugin(options: ResolvedOptions): EsbuildPlugin {\n\treturn {\n\t\tname: 'vite-plugin-svelte:optimize-svelte',\n\t\tsetup(build) {\n\t\t\t// Skip in scanning phase as Vite already handles scanning Svelte files.\n\t\t\t// Otherwise this would heavily slow down the scanning phase.\n\t\t\tif (build.initialOptions.plugins?.some((v) => v.name === 'vite:dep-scan')) return;\n\n\t\t\tconst svelteExtensions = (options.extensions ?? ['.svelte']).map((ext) => ext.slice(1));\n\t\t\tconst svelteFilter = new RegExp(`\\\\.(` + svelteExtensions.join('|') + `)(\\\\?.*)?$`);\n\t\t\tlet statsCollection: StatCollection | undefined;\n\t\t\tbuild.onStart(() => {\n\t\t\t\tstatsCollection = options.stats?.startCollection('prebundle libraries', {\n\t\t\t\t\tlogResult: (c) => c.stats.length > 1\n\t\t\t\t});\n\t\t\t});\n\t\t\tbuild.onLoad({ filter: svelteFilter }, async ({ path: filename }) => {\n\t\t\t\tconst code = readFileSync(filename, 'utf8');\n\t\t\t\ttry {\n\t\t\t\t\tconst contents = await compileSvelte(options, { filename, code }, statsCollection);\n\t\t\t\t\treturn { contents };\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { errors: [toESBuildError(e, options)] };\n\t\t\t\t}\n\t\t\t});\n\t\t\tbuild.onEnd(() => {\n\t\t\t\tstatsCollection?.finish();\n\t\t\t});\n\t\t}\n\t};\n}\n\nasync function compileSvelte(\n\toptions: ResolvedOptions,\n\t{ filename, code }: { filename: string; code: string },\n\tstatsCollection?: StatCollection\n): Promise<string> {\n\tlet css = options.compilerOptions.css;\n\tif (css !== 'none') {\n\t\t// TODO ideally we'd be able to externalize prebundled styles too, but for now always put them in the js\n\t\tcss = 'injected';\n\t}\n\tconst compileOptions: CompileOptions = {\n\t\t...options.compilerOptions,\n\t\tcss,\n\t\tfilename,\n\t\tformat: 'esm',\n\t\tgenerate: 'dom'\n\t};\n\n\tlet preprocessed;\n\n\tif (options.preprocess) {\n\t\ttry {\n\t\t\tpreprocessed = await preprocess(code, options.preprocess, { filename });\n\t\t} catch (e) {\n\t\t\te.message = `Error while preprocessing ${filename}${e.message ? ` - ${e.message}` : ''}`;\n\t\t\tthrow e;\n\t\t}\n\t\tif (preprocessed.map) compileOptions.sourcemap = preprocessed.map;\n\t}\n\n\tconst finalCode = preprocessed ? preprocessed.code : code;\n\n\tconst dynamicCompileOptions = await options.experimental?.dynamicCompileOptions?.({\n\t\tfilename,\n\t\tcode: finalCode,\n\t\tcompileOptions\n\t});\n\n\tif (dynamicCompileOptions && log.debug.enabled) {\n\t\tlog.debug(`dynamic compile options for  ${filename}: ${JSON.stringify(dynamicCompileOptions)}`);\n\t}\n\n\tconst finalCompileOptions = dynamicCompileOptions\n\t\t? {\n\t\t\t\t...compileOptions,\n\t\t\t\t...dynamicCompileOptions\n\t\t  }\n\t\t: compileOptions;\n\tconst endStat = statsCollection?.start(filename);\n\tconst compiled = compile(finalCode, finalCompileOptions) as Compiled;\n\tif (endStat) {\n\t\tendStat();\n\t}\n\treturn compiled.js.code + '//# sourceMappingURL=' + compiled.js.map.toUrl();\n}\n"}},"hash.ts":{"file":{"contents":"import * as crypto from 'crypto';\n\nconst hashes = Object.create(null);\n\n//TODO shorter?\nconst hash_length = 12;\n\nexport function safeBase64Hash(input: string) {\n\tif (hashes[input]) {\n\t\treturn hashes[input];\n\t}\n\t//TODO if performance really matters, use a faster one like xx-hash etc.\n\t// should be evenly distributed because short input length and similarities in paths could cause collisions otherwise\n\t// OR DON'T USE A HASH AT ALL, what about a simple counter?\n\tconst md5 = crypto.createHash('md5');\n\tmd5.update(input);\n\tconst hash = toSafe(md5.digest('base64')).slice(0, hash_length);\n\thashes[input] = hash;\n\treturn hash;\n}\n\nconst replacements: { [key: string]: string } = {\n\t'+': '-',\n\t'/': '_',\n\t'=': ''\n};\n\nconst replaceRE = new RegExp(`[${Object.keys(replacements).join('')}]`, 'g');\n\nfunction toSafe(base64: string) {\n\treturn base64.replace(replaceRE, (x) => replacements[x]);\n}\n"}},"id.ts":{"file":{"contents":"/* eslint-disable no-unused-vars */\nimport { createFilter } from 'vite';\nimport { Arrayable, ResolvedOptions } from './options';\nimport { normalizePath } from 'vite';\nimport * as fs from 'fs';\n//eslint-disable-next-line node/no-missing-import\nimport { CompileOptions } from 'svelte/types/compiler/interfaces';\nimport { log } from './log';\n\nconst VITE_FS_PREFIX = '/@fs/';\nconst IS_WINDOWS = process.platform === 'win32';\n\nconst SUPPORTED_COMPILER_OPTIONS = [\n\t'generate',\n\t'dev',\n\t'css',\n\t'hydratable',\n\t'customElement',\n\t'immutable',\n\t'enableSourcemap'\n];\nconst TYPES_WITH_COMPILER_OPTIONS = ['style', 'script', 'all'];\n\nexport type SvelteQueryTypes = 'style' | 'script' | 'preprocessed' | 'all';\n\nexport interface RequestQuery {\n\t// our own\n\tsvelte?: boolean;\n\ttype?: SvelteQueryTypes;\n\tsourcemap?: boolean;\n\tcompilerOptions?: Pick<\n\t\tCompileOptions,\n\t\t'generate' | 'dev' | 'css' | 'hydratable' | 'customElement' | 'immutable' | 'enableSourcemap'\n\t>;\n\t// vite specific\n\turl?: boolean;\n\traw?: boolean;\n\tdirect?: boolean;\n}\n\nexport interface SvelteRequest {\n\tid: string;\n\tcssId: string;\n\tfilename: string;\n\tnormalizedFilename: string;\n\tquery: RequestQuery;\n\ttimestamp: number;\n\tssr: boolean;\n\traw: boolean;\n}\n\nfunction splitId(id: string) {\n\tconst parts = id.split(`?`, 2);\n\tconst filename = parts[0];\n\tconst rawQuery = parts[1];\n\treturn { filename, rawQuery };\n}\n\nfunction parseToSvelteRequest(\n\tid: string,\n\tfilename: string,\n\trawQuery: string,\n\troot: string,\n\ttimestamp: number,\n\tssr: boolean\n): SvelteRequest | undefined {\n\tconst query = parseRequestQuery(rawQuery);\n\tconst rawOrDirect = !!(query.raw || query.direct);\n\tif (query.url || (!query.svelte && rawOrDirect)) {\n\t\t// skip requests with special vite tags\n\t\treturn;\n\t}\n\tconst raw = rawOrDirect;\n\tconst normalizedFilename = normalize(filename, root);\n\tconst cssId = createVirtualImportId(filename, root, 'style');\n\n\treturn {\n\t\tid,\n\t\tfilename,\n\t\tnormalizedFilename,\n\t\tcssId,\n\t\tquery,\n\t\ttimestamp,\n\t\tssr,\n\t\traw\n\t};\n}\n\nfunction createVirtualImportId(filename: string, root: string, type: SvelteQueryTypes) {\n\tconst parts = ['svelte', `type=${type}`];\n\tif (type === 'style') {\n\t\tparts.push('lang.css');\n\t}\n\tif (existsInRoot(filename, root)) {\n\t\tfilename = root + filename;\n\t} else if (filename.startsWith(VITE_FS_PREFIX)) {\n\t\tfilename = IS_WINDOWS\n\t\t\t? filename.slice(VITE_FS_PREFIX.length) // remove /@fs/ from /@fs/C:/...\n\t\t\t: filename.slice(VITE_FS_PREFIX.length - 1); // remove /@fs from /@fs/home/user\n\t}\n\t// return same virtual id format as vite-plugin-vue eg ...App.svelte?svelte&type=style&lang.css\n\treturn `${filename}?${parts.join('&')}`;\n}\n\nfunction parseRequestQuery(rawQuery: string): RequestQuery {\n\tconst query = Object.fromEntries(new URLSearchParams(rawQuery));\n\tfor (const key in query) {\n\t\tif (query[key] === '') {\n\t\t\t// @ts-ignore\n\t\t\tquery[key] = true;\n\t\t}\n\t}\n\tconst compilerOptions = query.compilerOptions;\n\tif (compilerOptions) {\n\t\tif (!((query.raw || query.direct) && TYPES_WITH_COMPILER_OPTIONS.includes(query.type))) {\n\t\t\tthrow new Error(\n\t\t\t\t`Invalid compilerOptions in query ${rawQuery}. CompilerOptions are only supported for raw or direct queries with type in \"${TYPES_WITH_COMPILER_OPTIONS.join(\n\t\t\t\t\t', '\n\t\t\t\t)}\" e.g. '?svelte&raw&type=script&compilerOptions={\"generate\":\"ssr\",\"dev\":false}`\n\t\t\t);\n\t\t}\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(compilerOptions);\n\t\t\tconst invalid = Object.keys(parsed).filter(\n\t\t\t\t(key) => !SUPPORTED_COMPILER_OPTIONS.includes(key)\n\t\t\t);\n\t\t\tif (invalid.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid compilerOptions in query ${rawQuery}: ${invalid.join(\n\t\t\t\t\t\t', '\n\t\t\t\t\t)}. Supported: ${SUPPORTED_COMPILER_OPTIONS.join(', ')}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tquery.compilerOptions = parsed;\n\t\t} catch (e) {\n\t\t\tlog.error('failed to parse request query compilerOptions', e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treturn query as RequestQuery;\n}\n\n/**\n * posixify and remove root at start\n *\n * @param filename\n * @param normalizedRoot\n */\nfunction normalize(filename: string, normalizedRoot: string) {\n\treturn stripRoot(normalizePath(filename), normalizedRoot);\n}\n\nfunction existsInRoot(filename: string, root: string) {\n\tif (filename.startsWith(VITE_FS_PREFIX)) {\n\t\treturn false; // vite already tagged it as out of root\n\t}\n\treturn fs.existsSync(root + filename);\n}\n\nfunction stripRoot(normalizedFilename: string, normalizedRoot: string) {\n\treturn normalizedFilename.startsWith(normalizedRoot + '/')\n\t\t? normalizedFilename.slice(normalizedRoot.length)\n\t\t: normalizedFilename;\n}\n\nfunction buildFilter(\n\tinclude: Arrayable<string> | undefined,\n\texclude: Arrayable<string> | undefined,\n\textensions: string[]\n): (filename: string) => boolean {\n\tconst rollupFilter = createFilter(include, exclude);\n\treturn (filename) => rollupFilter(filename) && extensions.some((ext) => filename.endsWith(ext));\n}\n\nexport type IdParser = (id: string, ssr: boolean, timestamp?: number) => SvelteRequest | undefined;\nexport function buildIdParser(options: ResolvedOptions): IdParser {\n\tconst { include, exclude, extensions, root } = options;\n\tconst normalizedRoot = normalizePath(root);\n\tconst filter = buildFilter(include, exclude, extensions!);\n\treturn (id, ssr, timestamp = Date.now()) => {\n\t\tconst { filename, rawQuery } = splitId(id);\n\t\tif (filter(filename)) {\n\t\t\treturn parseToSvelteRequest(id, filename, rawQuery, normalizedRoot, timestamp, ssr);\n\t\t}\n\t};\n}\n"}},"load-raw.ts":{"file":{"contents":"import { ResolvedOptions } from './options';\nimport fs from 'fs';\nimport { toRollupError } from './error';\nimport { log } from './log';\nimport type { SvelteRequest } from './id';\nimport { type CompileData, CompileSvelte } from './compile';\n\n/**\n * utility function to compile ?raw and ?direct requests in load hook\n */\nexport async function loadRaw(\n\tsvelteRequest: SvelteRequest,\n\tcompileSvelte: CompileSvelte,\n\toptions: ResolvedOptions\n) {\n\tconst { id, filename, query } = svelteRequest;\n\n\t// raw svelte subrequest, compile on the fly and return requested subpart\n\tlet compileData;\n\tconst source = fs.readFileSync(filename, 'utf-8');\n\ttry {\n\t\t//avoid compileSvelte doing extra ssr stuff unless requested\n\t\tsvelteRequest.ssr = query.compilerOptions?.generate === 'ssr';\n\t\tconst type = query.type;\n\t\tcompileData = await compileSvelte(svelteRequest, source, {\n\t\t\t...options,\n\t\t\t// don't use dynamic vite-plugin-svelte defaults here to ensure stable result between ssr,dev and build\n\t\t\tcompilerOptions: {\n\t\t\t\tdev: false,\n\t\t\t\tcss: false,\n\t\t\t\thydratable: false,\n\t\t\t\tenableSourcemap: query.sourcemap\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tjs: type === 'script' || type === 'all',\n\t\t\t\t\t\t\tcss: type === 'style' || type === 'all'\n\t\t\t\t\t  }\n\t\t\t\t\t: false,\n\t\t\t\t...svelteRequest.query.compilerOptions\n\t\t\t},\n\t\t\thot: false,\n\t\t\temitCss: true\n\t\t});\n\t} catch (e) {\n\t\tthrow toRollupError(e, options);\n\t}\n\tlet result;\n\tif (query.type === 'style') {\n\t\tresult = compileData.compiled.css;\n\t} else if (query.type === 'script') {\n\t\tresult = compileData.compiled.js;\n\t} else if (query.type === 'preprocessed') {\n\t\tresult = compileData.preprocessed;\n\t} else if (query.type === 'all' && query.raw) {\n\t\treturn allToRawExports(compileData, source);\n\t} else {\n\t\tthrow new Error(\n\t\t\t`invalid \"type=${query.type}\" in ${id}. supported are script, style, preprocessed, all`\n\t\t);\n\t}\n\tif (query.direct) {\n\t\tconst supportedDirectTypes = ['script', 'style'];\n\t\tif (!supportedDirectTypes.includes(query.type)) {\n\t\t\tthrow new Error(\n\t\t\t\t`invalid \"type=${\n\t\t\t\t\tquery.type\n\t\t\t\t}\" combined with direct in ${id}. supported are: ${supportedDirectTypes.join(', ')}`\n\t\t\t);\n\t\t}\n\t\tlog.debug(`load returns direct result for ${id}`);\n\t\tlet directOutput = result.code;\n\t\tif (query.sourcemap && result.map?.toUrl) {\n\t\t\tconst map = `sourceMappingURL=${result.map.toUrl()}`;\n\t\t\tif (query.type === 'style') {\n\t\t\t\tdirectOutput += `\\n\\n/*# ${map} */\\n`;\n\t\t\t} else if (query.type === 'script') {\n\t\t\t\tdirectOutput += `\\n\\n//# ${map}\\n`;\n\t\t\t}\n\t\t}\n\t\treturn directOutput;\n\t} else if (query.raw) {\n\t\tlog.debug(`load returns raw result for ${id}`);\n\t\treturn toRawExports(result);\n\t} else {\n\t\tthrow new Error(`invalid raw mode in ${id}, supported are raw, direct`);\n\t}\n}\n\n/**\n * turn compileData and source into a flat list of raw exports\n *\n * @param compileData\n * @param source\n */\nfunction allToRawExports(compileData: CompileData, source: string) {\n\t// flatten CompileData\n\tconst exports: Partial<CompileData & { source: string }> = {\n\t\t...compileData,\n\t\t...compileData.compiled,\n\t\tsource\n\t};\n\tdelete exports.compiled;\n\tdelete exports.filename; // absolute path, remove to avoid it in output\n\treturn toRawExports(exports);\n}\n\n/**\n * turn object into raw exports.\n *\n * every prop is returned as a const export, and if prop 'code' exists it is additionally added as default export\n *\n * eg {'foo':'bar','code':'baz'} results in\n *\n *  ```js\n *  export const code='baz'\n *  export const foo='bar'\n *  export default code\n *  ```\n * @param object\n */\nfunction toRawExports(object: object) {\n\tlet exports =\n\t\tObject.entries(object)\n\t\t\t//eslint-disable-next-line no-unused-vars\n\t\t\t.filter(([key, value]) => typeof value !== 'function') // preprocess output has a toString function that's enumerable\n\t\t\t.sort(([a], [b]) => (a < b ? -1 : a === b ? 0 : 1))\n\t\t\t.map(([key, value]) => `export const ${key}=${JSON.stringify(value)}`)\n\t\t\t.join('\\n') + '\\n';\n\tif (Object.prototype.hasOwnProperty.call(object, 'code')) {\n\t\texports += `export default code\\n`;\n\t}\n\treturn exports;\n}\n"}},"load-svelte-config.ts":{"file":{"contents":"import { createRequire } from 'module';\nimport path from 'path';\nimport fs from 'fs';\nimport { pathToFileURL } from 'url';\nimport { log } from './log';\nimport { Options, SvelteOptions } from './options';\nimport { UserConfig } from 'vite';\n\n// used to require cjs config in esm.\n// NOTE dynamic import() cjs technically works, but timestamp query cache bust\n// have no effect, likely because it has another internal cache?\nlet esmRequire: NodeRequire;\n\nexport const knownSvelteConfigNames = [\n\t'svelte.config.js',\n\t'svelte.config.cjs',\n\t'svelte.config.mjs'\n];\n\n// hide dynamic import from ts transform to prevent it turning into a require\n// see https://github.com/microsoft/TypeScript/issues/43329#issuecomment-811606238\n// also use timestamp query to avoid caching on reload\nconst dynamicImportDefault = new Function(\n\t'path',\n\t'timestamp',\n\t'return import(path + \"?t=\" + timestamp).then(m => m.default)'\n);\n\nexport async function loadSvelteConfig(\n\tviteConfig?: UserConfig,\n\tinlineOptions?: Partial<Options>\n): Promise<Partial<SvelteOptions> | undefined> {\n\tif (inlineOptions?.configFile === false) {\n\t\treturn;\n\t}\n\tconst configFile = findConfigToLoad(viteConfig, inlineOptions);\n\tif (configFile) {\n\t\tlet err;\n\t\t// try to use dynamic import for svelte.config.js first\n\t\tif (configFile.endsWith('.js') || configFile.endsWith('.mjs')) {\n\t\t\ttry {\n\t\t\t\tconst result = await dynamicImportDefault(\n\t\t\t\t\tpathToFileURL(configFile).href,\n\t\t\t\t\tfs.statSync(configFile).mtimeMs\n\t\t\t\t);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tconfigFile\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`invalid export in ${configFile}`);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlog.error(`failed to import config ${configFile}`, e);\n\t\t\t\terr = e;\n\t\t\t}\n\t\t}\n\t\t// cjs or error with dynamic import\n\t\tif (!configFile.endsWith('.mjs')) {\n\t\t\ttry {\n\t\t\t\t// identify which require function to use (esm and cjs mode)\n\t\t\t\tconst _require = import.meta.url\n\t\t\t\t\t? (esmRequire ??= createRequire(import.meta.url))\n\t\t\t\t\t: require;\n\n\t\t\t\t// avoid loading cached version on reload\n\t\t\t\tdelete _require.cache[_require.resolve(configFile)];\n\t\t\t\tconst result = _require(configFile);\n\t\t\t\tif (result != null) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tconfigFile\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`invalid export in ${configFile}`);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tlog.error(`failed to require config ${configFile}`, e);\n\t\t\t\tif (!err) {\n\t\t\t\t\terr = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// failed to load existing config file\n\t\tthrow err;\n\t}\n}\n\nfunction findConfigToLoad(viteConfig?: UserConfig, inlineOptions?: Partial<Options>) {\n\tconst root = viteConfig?.root || process.cwd();\n\tif (inlineOptions?.configFile) {\n\t\tconst abolutePath = path.isAbsolute(inlineOptions.configFile)\n\t\t\t? inlineOptions.configFile\n\t\t\t: path.resolve(root, inlineOptions.configFile);\n\t\tif (!fs.existsSync(abolutePath)) {\n\t\t\tthrow new Error(`failed to find svelte config file ${abolutePath}.`);\n\t\t}\n\t\treturn abolutePath;\n\t} else {\n\t\tconst existingKnownConfigFiles = knownSvelteConfigNames\n\t\t\t.map((candidate) => path.resolve(root, candidate))\n\t\t\t.filter((file) => fs.existsSync(file));\n\t\tif (existingKnownConfigFiles.length === 0) {\n\t\t\tlog.debug(`no svelte config found at ${root}`);\n\t\t\treturn;\n\t\t} else if (existingKnownConfigFiles.length > 1) {\n\t\t\tlog.warn(\n\t\t\t\t`found more than one svelte config file, using ${existingKnownConfigFiles[0]}. you should only have one!`,\n\t\t\t\texistingKnownConfigFiles\n\t\t\t);\n\t\t}\n\t\treturn existingKnownConfigFiles[0];\n\t}\n}\n"}},"log.ts":{"file":{"contents":"/* eslint-disable no-unused-vars,no-console */\nimport { cyan, yellow, red } from 'kleur/colors';\nimport debug from 'debug';\nimport { ResolvedOptions, Warning } from './options';\nimport { SvelteRequest } from './id';\n\nconst levels: string[] = ['debug', 'info', 'warn', 'error', 'silent'];\nconst prefix = 'vite-plugin-svelte';\nconst loggers: { [key: string]: any } = {\n\tdebug: {\n\t\tlog: debug(`vite:${prefix}`),\n\t\tenabled: false,\n\t\tisDebug: true\n\t},\n\tinfo: {\n\t\tcolor: cyan,\n\t\tlog: console.log,\n\t\tenabled: true\n\t},\n\twarn: {\n\t\tcolor: yellow,\n\t\tlog: console.warn,\n\t\tenabled: true\n\t},\n\terror: {\n\t\tcolor: red,\n\t\tlog: console.error,\n\t\tenabled: true\n\t},\n\tsilent: {\n\t\tenabled: false\n\t}\n};\n\nlet _level: string = 'info';\nfunction setLevel(level: string) {\n\tif (level === _level) {\n\t\treturn;\n\t}\n\tconst levelIndex = levels.indexOf(level);\n\tif (levelIndex > -1) {\n\t\t_level = level;\n\t\tfor (let i = 0; i < levels.length; i++) {\n\t\t\tloggers[levels[i]].enabled = i >= levelIndex;\n\t\t}\n\t} else {\n\t\t_log(loggers.error, `invalid log level: ${level} `);\n\t}\n}\n\nfunction _log(logger: any, message: string, payload?: any) {\n\tif (!logger.enabled) {\n\t\treturn;\n\t}\n\tif (logger.isDebug) {\n\t\tpayload !== undefined ? logger.log(message, payload) : logger.log(message);\n\t} else {\n\t\tlogger.log(logger.color(`${new Date().toLocaleTimeString()} [${prefix}] ${message}`));\n\t\tif (payload) {\n\t\t\tlogger.log(payload);\n\t\t}\n\t}\n}\n\nexport interface LogFn {\n\t(message: string, payload?: any): void;\n\tenabled: boolean;\n\tonce: (message: string, payload?: any) => void;\n}\n\nfunction createLogger(level: string): LogFn {\n\tconst logger = loggers[level];\n\tconst logFn: LogFn = _log.bind(null, logger) as LogFn;\n\tconst logged = new Set<String>();\n\tconst once = function (message: string, payload?: any) {\n\t\tif (logged.has(message)) {\n\t\t\treturn;\n\t\t}\n\t\tlogged.add(message);\n\t\tlogFn.apply(null, [message, payload]);\n\t};\n\tObject.defineProperty(logFn, 'enabled', {\n\t\tget() {\n\t\t\treturn logger.enabled;\n\t\t}\n\t});\n\tObject.defineProperty(logFn, 'once', {\n\t\tget() {\n\t\t\treturn once;\n\t\t}\n\t});\n\treturn logFn;\n}\n\nexport const log = {\n\tdebug: createLogger('debug'),\n\tinfo: createLogger('info'),\n\twarn: createLogger('warn'),\n\terror: createLogger('error'),\n\tsetLevel\n};\n\nexport type SvelteWarningsMessage = {\n\tid: string;\n\tfilename: string;\n\tnormalizedFilename: string;\n\ttimestamp: number;\n\twarnings: Warning[]; // allWarnings filtered by warnings where onwarn did not call the default handler\n\tallWarnings: Warning[]; // includes warnings filtered by onwarn and our extra vite plugin svelte warnings\n\trawWarnings: Warning[]; // raw compiler output\n};\n\nexport function logCompilerWarnings(\n\tsvelteRequest: SvelteRequest,\n\twarnings: Warning[],\n\toptions: ResolvedOptions\n) {\n\tconst { emitCss, onwarn, isBuild } = options;\n\tconst sendViaWS = !isBuild && options.experimental?.sendWarningsToBrowser;\n\tlet warn = isBuild ? warnBuild : warnDev;\n\tconst handledByDefaultWarn: Warning[] = [];\n\tconst notIgnored = warnings?.filter((w) => !ignoreCompilerWarning(w, isBuild, emitCss));\n\tconst extra = buildExtraWarnings(warnings, isBuild);\n\tconst allWarnings = [...notIgnored, ...extra];\n\tif (sendViaWS) {\n\t\tconst _warn = warn;\n\t\twarn = (w: Warning) => {\n\t\t\thandledByDefaultWarn.push(w);\n\t\t\t_warn(w);\n\t\t};\n\t}\n\tallWarnings.forEach((warning) => {\n\t\tif (onwarn) {\n\t\t\tonwarn(warning, warn);\n\t\t} else {\n\t\t\twarn(warning);\n\t\t}\n\t});\n\tif (sendViaWS) {\n\t\tconst message: SvelteWarningsMessage = {\n\t\t\tid: svelteRequest.id,\n\t\t\tfilename: svelteRequest.filename,\n\t\t\tnormalizedFilename: svelteRequest.normalizedFilename,\n\t\t\ttimestamp: svelteRequest.timestamp,\n\t\t\twarnings: handledByDefaultWarn, // allWarnings filtered by warnings where onwarn did not call the default handler\n\t\t\tallWarnings, // includes warnings filtered by onwarn and our extra vite plugin svelte warnings\n\t\t\trawWarnings: warnings // raw compiler output\n\t\t};\n\t\tlog.debug(`sending svelte:warnings message for ${svelteRequest.normalizedFilename}`);\n\t\toptions.server?.ws?.send('svelte:warnings', message);\n\t}\n}\n\nfunction ignoreCompilerWarning(\n\twarning: Warning,\n\tisBuild: boolean,\n\temitCss: boolean | undefined\n): boolean {\n\treturn (\n\t\t(!emitCss && warning.code === 'css-unused-selector') || // same as rollup-plugin-svelte\n\t\t(!isBuild && isNoScopableElementWarning(warning))\n\t);\n}\n\nfunction isNoScopableElementWarning(warning: Warning) {\n\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/153\n\treturn warning.code === 'css-unused-selector' && warning.message.includes('\"*\"');\n}\n\nfunction buildExtraWarnings(warnings: Warning[], isBuild: boolean): Warning[] {\n\tconst extraWarnings = [];\n\tif (!isBuild) {\n\t\tconst noScopableElementWarnings = warnings.filter((w) => isNoScopableElementWarning(w));\n\t\tif (noScopableElementWarnings.length > 0) {\n\t\t\t// in case there are multiple, use last one as that is the one caused by our *{} rule\n\t\t\tconst noScopableElementWarning =\n\t\t\t\tnoScopableElementWarnings[noScopableElementWarnings.length - 1];\n\t\t\textraWarnings.push({\n\t\t\t\t...noScopableElementWarning,\n\t\t\t\tcode: 'vite-plugin-svelte-css-no-scopable-elements',\n\t\t\t\tmessage: `No scopable elements found in template. If you're using global styles in the style tag, you should move it into an external stylesheet file and import it in JS. See https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#where-should-i-put-my-global-styles.`\n\t\t\t});\n\t\t}\n\t}\n\treturn extraWarnings;\n}\n\nfunction warnDev(w: Warning) {\n\tlog.info.enabled && log.info(buildExtendedLogMessage(w));\n}\n\nfunction warnBuild(w: Warning) {\n\tlog.warn.enabled && log.warn(buildExtendedLogMessage(w), w.frame);\n}\n\nexport function buildExtendedLogMessage(w: Warning) {\n\tconst parts = [];\n\tif (w.filename) {\n\t\tparts.push(w.filename);\n\t}\n\tif (w.start) {\n\t\tparts.push(':', w.start.line, ':', w.start.column);\n\t}\n\tif (w.message) {\n\t\tif (parts.length > 0) {\n\t\t\tparts.push(' ');\n\t\t}\n\t\tparts.push(w.message);\n\t}\n\treturn parts.join('');\n}\n"}},"optimizer.ts":{"file":{"contents":"import { promises as fs } from 'fs';\nimport path from 'path';\nimport { ResolvedOptions } from './options';\n\n// List of options that changes the prebundling result\nconst PREBUNDLE_SENSITIVE_OPTIONS: (keyof ResolvedOptions)[] = [\n\t'compilerOptions',\n\t'configFile',\n\t'experimental',\n\t'extensions',\n\t'ignorePluginPreprocessors',\n\t'preprocess'\n];\n\n/**\n * @returns Whether the Svelte metadata has changed\n */\nexport async function saveSvelteMetadata(cacheDir: string, options: ResolvedOptions) {\n\tconst svelteMetadata = generateSvelteMetadata(options);\n\tconst svelteMetadataPath = path.resolve(cacheDir, '_svelte_metadata.json');\n\n\tconst currentSvelteMetadata = JSON.stringify(svelteMetadata, (_, value) => {\n\t\t// Handle preprocessors\n\t\treturn typeof value === 'function' ? value.toString() : value;\n\t});\n\n\tlet existingSvelteMetadata: string | undefined;\n\ttry {\n\t\texistingSvelteMetadata = await fs.readFile(svelteMetadataPath, 'utf8');\n\t} catch {\n\t\t// ignore\n\t}\n\n\tawait fs.mkdir(cacheDir, { recursive: true });\n\tawait fs.writeFile(svelteMetadataPath, currentSvelteMetadata);\n\treturn currentSvelteMetadata !== existingSvelteMetadata;\n}\n\nfunction generateSvelteMetadata(options: ResolvedOptions) {\n\tconst metadata: Record<string, any> = {};\n\tfor (const key of PREBUNDLE_SENSITIVE_OPTIONS) {\n\t\tmetadata[key] = options[key];\n\t}\n\treturn metadata;\n}\n"}},"options.ts":{"file":{"contents":"/* eslint-disable no-unused-vars */\nimport { ConfigEnv, ResolvedConfig, UserConfig, ViteDevServer, normalizePath } from 'vite';\nimport { log } from './log';\nimport { loadSvelteConfig } from './load-svelte-config';\nimport {\n\tSVELTE_EXPORT_CONDITIONS,\n\tSVELTE_HMR_IMPORTS,\n\tSVELTE_IMPORTS,\n\tSVELTE_RESOLVE_MAIN_FIELDS,\n\tVITE_RESOLVE_MAIN_FIELDS\n} from './constants';\n// eslint-disable-next-line node/no-missing-import\nimport type { CompileOptions, Warning } from 'svelte/types/compiler/interfaces';\nimport type {\n\tMarkupPreprocessor,\n\tPreprocessor,\n\tPreprocessorGroup,\n\tProcessed\n\t// eslint-disable-next-line node/no-missing-import\n} from 'svelte/types/compiler/preprocess';\n\nimport path from 'path';\nimport { esbuildSveltePlugin, facadeEsbuildSveltePluginName } from './esbuild';\nimport { addExtraPreprocessors } from './preprocess';\nimport deepmerge from 'deepmerge';\nimport {\n\tcrawlFrameworkPkgs,\n\tisDepExcluded,\n\tisDepExternaled,\n\tisDepIncluded,\n\tisDepNoExternaled\n\t// eslint-disable-next-line node/no-missing-import\n} from 'vitefu';\n\nimport { isCommonDepWithoutSvelteField } from './dependencies';\nimport { VitePluginSvelteStats } from './vite-plugin-svelte-stats';\n\nconst allowedPluginOptions = new Set([\n\t'include',\n\t'exclude',\n\t'emitCss',\n\t'hot',\n\t'ignorePluginPreprocessors',\n\t'disableDependencyReinclusion',\n\t'prebundleSvelteLibraries',\n\t'experimental'\n]);\n\nconst knownRootOptions = new Set(['extensions', 'compilerOptions', 'preprocess', 'onwarn']);\n\nconst allowedInlineOptions = new Set([\n\t'configFile',\n\t'kit', // only for internal use by sveltekit\n\t...allowedPluginOptions,\n\t...knownRootOptions\n]);\n\nexport function validateInlineOptions(inlineOptions?: Partial<Options>) {\n\tconst invalidKeys = Object.keys(inlineOptions || {}).filter(\n\t\t(key) => !allowedInlineOptions.has(key)\n\t);\n\tif (invalidKeys.length) {\n\t\tlog.warn(`invalid plugin options \"${invalidKeys.join(', ')}\" in inline config`, inlineOptions);\n\t}\n}\n\nfunction convertPluginOptions(config?: Partial<SvelteOptions>): Partial<Options> | undefined {\n\tif (!config) {\n\t\treturn;\n\t}\n\tconst invalidRootOptions = Object.keys(config).filter((key) => allowedPluginOptions.has(key));\n\tif (invalidRootOptions.length > 0) {\n\t\tthrow new Error(\n\t\t\t`Invalid options in svelte config. Move the following options into 'vitePlugin:{...}': ${invalidRootOptions.join(\n\t\t\t\t', '\n\t\t\t)}`\n\t\t);\n\t}\n\tif (!config.vitePlugin) {\n\t\treturn config;\n\t}\n\tconst pluginOptions = config.vitePlugin;\n\tconst pluginOptionKeys = Object.keys(pluginOptions);\n\n\tconst rootOptionsInPluginOptions = pluginOptionKeys.filter((key) => knownRootOptions.has(key));\n\tif (rootOptionsInPluginOptions.length > 0) {\n\t\tthrow new Error(\n\t\t\t`Invalid options in svelte config under vitePlugin:{...}', move them to the config root : ${rootOptionsInPluginOptions.join(\n\t\t\t\t', '\n\t\t\t)}`\n\t\t);\n\t}\n\tconst duplicateOptions = pluginOptionKeys.filter((key) =>\n\t\tObject.prototype.hasOwnProperty.call(config, key)\n\t);\n\tif (duplicateOptions.length > 0) {\n\t\tthrow new Error(\n\t\t\t`Invalid duplicate options in svelte config under vitePlugin:{...}', they are defined in root too and must only exist once: ${duplicateOptions.join(\n\t\t\t\t', '\n\t\t\t)}`\n\t\t);\n\t}\n\tconst unknownPluginOptions = pluginOptionKeys.filter((key) => !allowedPluginOptions.has(key));\n\tif (unknownPluginOptions.length > 0) {\n\t\tlog.warn(\n\t\t\t`ignoring unknown plugin options in svelte config under vitePlugin:{...}: ${unknownPluginOptions.join(\n\t\t\t\t', '\n\t\t\t)}`\n\t\t);\n\t\tunknownPluginOptions.forEach((unkownOption) => {\n\t\t\t// @ts-ignore\n\t\t\tdelete pluginOptions[unkownOption];\n\t\t});\n\t}\n\n\tconst result: Options = {\n\t\t...config,\n\t\t...pluginOptions\n\t};\n\t// @ts-expect-error it exists\n\tdelete result.vitePlugin;\n\n\treturn result;\n}\n\n// used in config phase, merges the default options, svelte config, and inline options\nexport async function preResolveOptions(\n\tinlineOptions: Partial<Options> = {},\n\tviteUserConfig: UserConfig,\n\tviteEnv: ConfigEnv\n): Promise<PreResolvedOptions> {\n\tconst viteConfigWithResolvedRoot: UserConfig = {\n\t\t...viteUserConfig,\n\t\troot: resolveViteRoot(viteUserConfig)\n\t};\n\tconst isBuild = viteEnv.command === 'build';\n\tconst defaultOptions: Partial<Options> = {\n\t\textensions: ['.svelte'],\n\t\temitCss: true,\n\t\tprebundleSvelteLibraries: !isBuild\n\t};\n\tconst svelteConfig = convertPluginOptions(\n\t\tawait loadSvelteConfig(viteConfigWithResolvedRoot, inlineOptions)\n\t);\n\n\tconst extraOptions: Partial<PreResolvedOptions> = {\n\t\troot: viteConfigWithResolvedRoot.root!,\n\t\tisBuild,\n\t\tisServe: viteEnv.command === 'serve',\n\t\tisDebug: process.env.DEBUG != null\n\t};\n\tconst merged = mergeConfigs<PreResolvedOptions>(\n\t\tdefaultOptions,\n\t\tsvelteConfig,\n\t\tinlineOptions,\n\t\textraOptions\n\t);\n\t// configFile of svelteConfig contains the absolute path it was loaded from,\n\t// prefer it over the possibly relative inline path\n\tif (svelteConfig?.configFile) {\n\t\tmerged.configFile = svelteConfig.configFile;\n\t}\n\treturn merged;\n}\n\nfunction mergeConfigs<T>(...configs: (Partial<T> | undefined)[]): T {\n\tlet result: Partial<T> = {};\n\tfor (const config of configs.filter((x) => x != null)) {\n\t\tresult = deepmerge<T>(result, config!, {\n\t\t\t// replace arrays\n\t\t\tarrayMerge: (target: any[], source: any[]) => source ?? target\n\t\t});\n\t}\n\treturn result as T;\n}\n\n// used in configResolved phase, merges a contextual default config, pre-resolved options, and some preprocessors.\n// also validates the final config.\nexport function resolveOptions(\n\tpreResolveOptions: PreResolvedOptions,\n\tviteConfig: ResolvedConfig\n): ResolvedOptions {\n\tconst css = preResolveOptions.emitCss ? 'external' : 'injected';\n\tconst defaultOptions: Partial<Options> = {\n\t\thot: viteConfig.isProduction\n\t\t\t? false\n\t\t\t: {\n\t\t\t\t\tinjectCss: css === 'injected',\n\t\t\t\t\tpartialAccept: !!viteConfig.experimental?.hmrPartialAccept\n\t\t\t  },\n\t\tcompilerOptions: {\n\t\t\tcss,\n\t\t\tdev: !viteConfig.isProduction\n\t\t}\n\t};\n\tconst extraOptions: Partial<ResolvedOptions> = {\n\t\troot: viteConfig.root,\n\t\tisProduction: viteConfig.isProduction\n\t};\n\tconst merged = mergeConfigs<ResolvedOptions>(defaultOptions, preResolveOptions, extraOptions);\n\n\tremoveIgnoredOptions(merged);\n\thandleDeprecatedOptions(merged);\n\taddSvelteKitOptions(merged);\n\taddExtraPreprocessors(merged, viteConfig);\n\tenforceOptionsForHmr(merged);\n\tenforceOptionsForProduction(merged);\n\t// mergeConfigs would mangle functions on the stats class, so do this afterwards\n\tconst isLogLevelInfo = [undefined, 'info'].includes(viteConfig.logLevel);\n\tconst disableCompileStats = merged.experimental?.disableCompileStats;\n\tconst statsEnabled =\n\t\tdisableCompileStats !== true && disableCompileStats !== (merged.isBuild ? 'build' : 'dev');\n\tif (statsEnabled && isLogLevelInfo) {\n\t\tmerged.stats = new VitePluginSvelteStats();\n\t}\n\treturn merged;\n}\n\nfunction enforceOptionsForHmr(options: ResolvedOptions) {\n\tif (options.hot) {\n\t\tif (!options.compilerOptions.dev) {\n\t\t\tlog.warn('hmr is enabled but compilerOptions.dev is false, forcing it to true');\n\t\t\toptions.compilerOptions.dev = true;\n\t\t}\n\t\tif (options.emitCss) {\n\t\t\tif (options.hot !== true && options.hot.injectCss) {\n\t\t\t\tlog.warn('hmr and emitCss are enabled but hot.injectCss is true, forcing it to false');\n\t\t\t\toptions.hot.injectCss = false;\n\t\t\t}\n\t\t\tconst css = options.compilerOptions.css;\n\t\t\tif (css === true || css === 'injected') {\n\t\t\t\tconst forcedCss = 'external';\n\t\t\t\tlog.warn(\n\t\t\t\t\t`hmr and emitCss are enabled but compilerOptions.css is ${css}, forcing it to ${forcedCss}`\n\t\t\t\t);\n\t\t\t\toptions.compilerOptions.css = forcedCss;\n\t\t\t}\n\t\t} else {\n\t\t\tif (options.hot === true || !options.hot.injectCss) {\n\t\t\t\tlog.warn(\n\t\t\t\t\t'hmr with emitCss disabled requires option hot.injectCss to be enabled, forcing it to true'\n\t\t\t\t);\n\t\t\t\tif (options.hot === true) {\n\t\t\t\t\toptions.hot = { injectCss: true };\n\t\t\t\t} else {\n\t\t\t\t\toptions.hot.injectCss = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst css = options.compilerOptions.css;\n\t\t\tif (!(css === true || css === 'injected')) {\n\t\t\t\tconst forcedCss = 'injected';\n\t\t\t\tlog.warn(\n\t\t\t\t\t`hmr with emitCss disabled requires compilerOptions.css to be enabled, forcing it to ${forcedCss}`\n\t\t\t\t);\n\t\t\t\toptions.compilerOptions.css = forcedCss;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction enforceOptionsForProduction(options: ResolvedOptions) {\n\tif (options.isProduction) {\n\t\tif (options.hot) {\n\t\t\tlog.warn('options.hot is enabled but does not work on production build, forcing it to false');\n\t\t\toptions.hot = false;\n\t\t}\n\t\tif (options.compilerOptions.dev) {\n\t\t\tlog.warn(\n\t\t\t\t'you are building for production but compilerOptions.dev is true, forcing it to false'\n\t\t\t);\n\t\t\toptions.compilerOptions.dev = false;\n\t\t}\n\t}\n}\n\nfunction removeIgnoredOptions(options: ResolvedOptions) {\n\tconst ignoredCompilerOptions = ['generate', 'format', 'filename'];\n\tif (options.hot && options.emitCss) {\n\t\tignoredCompilerOptions.push('cssHash');\n\t}\n\tconst passedCompilerOptions = Object.keys(options.compilerOptions || {});\n\tconst passedIgnored = passedCompilerOptions.filter((o) => ignoredCompilerOptions.includes(o));\n\tif (passedIgnored.length) {\n\t\tlog.warn(\n\t\t\t`The following Svelte compilerOptions are controlled by vite-plugin-svelte and essential to its functionality. User-specified values are ignored. Please remove them from your configuration: ${passedIgnored.join(\n\t\t\t\t', '\n\t\t\t)}`\n\t\t);\n\t\tpassedIgnored.forEach((ignored) => {\n\t\t\t// @ts-expect-error string access\n\t\t\tdelete options.compilerOptions[ignored];\n\t\t});\n\t}\n}\n\n// some SvelteKit options need compilerOptions to work, so set them here.\nfunction addSvelteKitOptions(options: ResolvedOptions) {\n\t// @ts-expect-error kit is not typed to avoid dependency on sveltekit\n\tif (options?.kit != null && options.compilerOptions.hydratable == null) {\n\t\tlog.debug(`Setting compilerOptions.hydratable = true for SvelteKit`);\n\t\toptions.compilerOptions.hydratable = true;\n\t}\n}\n\nfunction handleDeprecatedOptions(options: ResolvedOptions) {\n\tif ((options.experimental as any)?.prebundleSvelteLibraries) {\n\t\toptions.prebundleSvelteLibraries = (options.experimental as any)?.prebundleSvelteLibraries;\n\t\tlog.warn(\n\t\t\t'experimental.prebundleSvelteLibraries is no longer experimental and has moved to prebundleSvelteLibraries'\n\t\t);\n\t}\n\tif ((options.experimental as any)?.generateMissingPreprocessorSourcemaps) {\n\t\tlog.warn('experimental.generateMissingPreprocessorSourcemaps has been removed.');\n\t}\n}\n\n// vite passes unresolved `root`option to config hook but we need the resolved value, so do it here\n// https://github.com/sveltejs/vite-plugin-svelte/issues/113\n// https://github.com/vitejs/vite/blob/43c957de8a99bb326afd732c962f42127b0a4d1e/packages/vite/src/node/config.ts#L293\nfunction resolveViteRoot(viteConfig: UserConfig): string | undefined {\n\treturn normalizePath(viteConfig.root ? path.resolve(viteConfig.root) : process.cwd());\n}\n\nexport async function buildExtraViteConfig(\n\toptions: PreResolvedOptions,\n\tconfig: UserConfig\n): Promise<Partial<UserConfig>> {\n\t// make sure we only readd vite default mainFields when no other plugin has changed the config already\n\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/581\n\tif (!config.resolve) {\n\t\tconfig.resolve = {};\n\t}\n\tconfig.resolve.mainFields = [\n\t\t...SVELTE_RESOLVE_MAIN_FIELDS,\n\t\t...(config.resolve.mainFields ?? VITE_RESOLVE_MAIN_FIELDS)\n\t];\n\n\tconst extraViteConfig: Partial<UserConfig> = {\n\t\tresolve: {\n\t\t\tdedupe: [...SVELTE_IMPORTS, ...SVELTE_HMR_IMPORTS],\n\t\t\tconditions: [...SVELTE_EXPORT_CONDITIONS]\n\t\t}\n\t\t// this option is still awaiting a PR in vite to be supported\n\t\t// see https://github.com/sveltejs/vite-plugin-svelte/issues/60\n\t\t// @ts-ignore\n\t\t// knownJsSrcExtensions: options.extensions\n\t};\n\n\tconst extraSvelteConfig = buildExtraConfigForSvelte(config);\n\tconst extraDepsConfig = await buildExtraConfigForDependencies(options, config);\n\t// merge extra svelte and deps config, but make sure dep values are not contradicting svelte\n\textraViteConfig.optimizeDeps = {\n\t\tinclude: [\n\t\t\t...extraSvelteConfig.optimizeDeps.include,\n\t\t\t...extraDepsConfig.optimizeDeps.include.filter(\n\t\t\t\t(dep) => !isDepExcluded(dep, extraSvelteConfig.optimizeDeps.exclude)\n\t\t\t)\n\t\t],\n\t\texclude: [\n\t\t\t...extraSvelteConfig.optimizeDeps.exclude,\n\t\t\t...extraDepsConfig.optimizeDeps.exclude.filter(\n\t\t\t\t(dep) => !isDepIncluded(dep, extraSvelteConfig.optimizeDeps.include)\n\t\t\t)\n\t\t]\n\t};\n\n\textraViteConfig.ssr = {\n\t\texternal: [\n\t\t\t...extraSvelteConfig.ssr.external,\n\t\t\t...extraDepsConfig.ssr.external.filter(\n\t\t\t\t(dep) => !isDepNoExternaled(dep, extraSvelteConfig.ssr.noExternal)\n\t\t\t)\n\t\t],\n\t\tnoExternal: [\n\t\t\t...extraSvelteConfig.ssr.noExternal,\n\t\t\t...extraDepsConfig.ssr.noExternal.filter(\n\t\t\t\t(dep) => !isDepExternaled(dep, extraSvelteConfig.ssr.external)\n\t\t\t)\n\t\t]\n\t};\n\n\t// handle prebundling for svelte files\n\tif (options.prebundleSvelteLibraries) {\n\t\textraViteConfig.optimizeDeps = {\n\t\t\t...extraViteConfig.optimizeDeps,\n\t\t\t// Experimental Vite API to allow these extensions to be scanned and prebundled\n\t\t\t// @ts-ignore\n\t\t\textensions: options.extensions ?? ['.svelte'],\n\t\t\t// Add esbuild plugin to prebundle Svelte files.\n\t\t\t// Currently a placeholder as more information is needed after Vite config is resolved,\n\t\t\t// the real Svelte plugin is added in `patchResolvedViteConfig()`\n\t\t\tesbuildOptions: {\n\t\t\t\tplugins: [{ name: facadeEsbuildSveltePluginName, setup: () => {} }]\n\t\t\t}\n\t\t};\n\t}\n\n\t// enable hmrPartialAccept if not explicitly disabled\n\tif (\n\t\t(options.hot == null ||\n\t\t\toptions.hot === true ||\n\t\t\t(options.hot && options.hot.partialAccept !== false)) && // deviate from svelte-hmr, default to true\n\t\tconfig.experimental?.hmrPartialAccept !== false\n\t) {\n\t\tlog.debug('enabling \"experimental.hmrPartialAccept\" in vite config');\n\t\textraViteConfig.experimental = { hmrPartialAccept: true };\n\t}\n\tvalidateViteConfig(extraViteConfig, config, options);\n\treturn extraViteConfig;\n}\n\nfunction validateViteConfig(\n\textraViteConfig: Partial<UserConfig>,\n\tconfig: UserConfig,\n\toptions: PreResolvedOptions\n) {\n\tconst { prebundleSvelteLibraries, isBuild } = options;\n\tif (prebundleSvelteLibraries) {\n\t\tconst isEnabled = (option: 'dev' | 'build' | boolean) =>\n\t\t\toption !== true && option !== (isBuild ? 'build' : 'dev');\n\t\tconst logWarning = (name: string, value: 'dev' | 'build' | boolean, recommendation: string) =>\n\t\t\tlog.warn.once(\n\t\t\t\t`Incompatible options: \\`prebundleSvelteLibraries: true\\` and vite \\`${name}: ${JSON.stringify(\n\t\t\t\t\tvalue\n\t\t\t\t)}\\` ${isBuild ? 'during build.' : '.'} ${recommendation}`\n\t\t\t);\n\t\tconst viteOptimizeDepsDisabled = config.optimizeDeps?.disabled ?? 'build'; // fall back to vite default\n\t\tconst isOptimizeDepsEnabled = isEnabled(viteOptimizeDepsDisabled);\n\t\tif (!isBuild && !isOptimizeDepsEnabled) {\n\t\t\tlogWarning(\n\t\t\t\t'optimizeDeps.disabled',\n\t\t\t\tviteOptimizeDepsDisabled,\n\t\t\t\t'Forcing `optimizeDeps.disabled: \"build\"`. Disable prebundleSvelteLibraries or update your vite config to enable optimizeDeps during dev.'\n\t\t\t);\n\t\t\textraViteConfig.optimizeDeps!.disabled = 'build';\n\t\t} else if (isBuild && isOptimizeDepsEnabled) {\n\t\t\tlogWarning(\n\t\t\t\t'optimizeDeps.disabled',\n\t\t\t\tviteOptimizeDepsDisabled,\n\t\t\t\t'Disable optimizeDeps or prebundleSvelteLibraries for build if you experience errors.'\n\t\t\t);\n\t\t}\n\t}\n}\n\nasync function buildExtraConfigForDependencies(options: PreResolvedOptions, config: UserConfig) {\n\t// extra handling for svelte dependencies in the project\n\tconst depsConfig = await crawlFrameworkPkgs({\n\t\troot: options.root,\n\t\tisBuild: options.isBuild,\n\t\tviteUserConfig: config,\n\t\tisFrameworkPkgByJson(pkgJson) {\n\t\t\tlet hasSvelteCondition = false;\n\t\t\tif (typeof pkgJson.exports === 'object') {\n\t\t\t\t// use replacer as a simple way to iterate over nested keys\n\t\t\t\tJSON.stringify(pkgJson.exports, (key, value) => {\n\t\t\t\t\tif (SVELTE_EXPORT_CONDITIONS.includes(key)) {\n\t\t\t\t\t\thasSvelteCondition = true;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn hasSvelteCondition || !!pkgJson.svelte;\n\t\t},\n\t\tisSemiFrameworkPkgByJson(pkgJson) {\n\t\t\treturn !!pkgJson.dependencies?.svelte || !!pkgJson.peerDependencies?.svelte;\n\t\t},\n\t\tisFrameworkPkgByName(pkgName) {\n\t\t\tconst isNotSveltePackage = isCommonDepWithoutSvelteField(pkgName);\n\t\t\tif (isNotSveltePackage) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t});\n\n\tlog.debug('extra config for dependencies generated by vitefu', depsConfig);\n\n\tif (options.prebundleSvelteLibraries) {\n\t\t// prebundling enabled, so we don't need extra dependency excludes\n\t\tdepsConfig.optimizeDeps.exclude = [];\n\t\t// but keep dependency reinclusions of explicit user excludes\n\t\tconst userExclude = config.optimizeDeps?.exclude;\n\t\tdepsConfig.optimizeDeps.include = !userExclude\n\t\t\t? []\n\t\t\t: depsConfig.optimizeDeps.include.filter((dep: string) => {\n\t\t\t\t\t// reincludes look like this: foo > bar > baz\n\t\t\t\t\t// in case foo or bar are excluded, we have to retain the reinclude even with prebundling\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdep.includes('>') &&\n\t\t\t\t\t\tdep\n\t\t\t\t\t\t\t.split('>')\n\t\t\t\t\t\t\t.slice(0, -1)\n\t\t\t\t\t\t\t.some((d) => isDepExcluded(d.trim(), userExclude))\n\t\t\t\t\t);\n\t\t\t  });\n\t}\n\tif (options.disableDependencyReinclusion === true) {\n\t\tdepsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter(\n\t\t\t(dep) => !dep.includes('>')\n\t\t);\n\t} else if (Array.isArray(options.disableDependencyReinclusion)) {\n\t\tconst disabledDeps = options.disableDependencyReinclusion;\n\t\tdepsConfig.optimizeDeps.include = depsConfig.optimizeDeps.include.filter((dep) => {\n\t\t\tif (!dep.includes('>')) return true;\n\t\t\tconst trimDep = dep.replace(/\\s+/g, '');\n\t\t\treturn disabledDeps.some((disabled) => trimDep.includes(`${disabled}>`));\n\t\t});\n\t}\n\n\tlog.debug('post-processed extra config for dependencies', depsConfig);\n\n\treturn depsConfig;\n}\n\nfunction buildExtraConfigForSvelte(config: UserConfig) {\n\t// include svelte imports for optimization unless explicitly excluded\n\tconst include: string[] = [];\n\tconst exclude: string[] = ['svelte-hmr'];\n\tif (!isDepExcluded('svelte', config.optimizeDeps?.exclude ?? [])) {\n\t\tconst svelteImportsToInclude = SVELTE_IMPORTS.filter((x) => x !== 'svelte/ssr'); // not used on clientside\n\t\tlog.debug(\n\t\t\t`adding bare svelte packages to optimizeDeps.include: ${svelteImportsToInclude.join(', ')} `\n\t\t);\n\t\tinclude.push(...svelteImportsToInclude);\n\t} else {\n\t\tlog.debug('\"svelte\" is excluded in optimizeDeps.exclude, skipped adding it to include.');\n\t}\n\tconst noExternal: (string | RegExp)[] = [];\n\tconst external: string[] = [];\n\t// add svelte to ssr.noExternal unless it is present in ssr.external\n\t// so we can resolve it with svelte/ssr\n\tif (!isDepExternaled('svelte', config.ssr?.external ?? [])) {\n\t\tnoExternal.push('svelte', /^svelte\\//);\n\t}\n\treturn { optimizeDeps: { include, exclude }, ssr: { noExternal, external } };\n}\n\nexport function patchResolvedViteConfig(viteConfig: ResolvedConfig, options: ResolvedOptions) {\n\tif (options.preprocess) {\n\t\tfor (const preprocessor of arraify(options.preprocess)) {\n\t\t\tif (preprocessor.style && '__resolvedConfig' in preprocessor.style) {\n\t\t\t\tpreprocessor.style.__resolvedConfig = viteConfig;\n\t\t\t}\n\t\t}\n\t}\n\n\t// replace facade esbuild plugin with a real one\n\tconst facadeEsbuildSveltePlugin = viteConfig.optimizeDeps.esbuildOptions?.plugins?.find(\n\t\t(plugin) => plugin.name === facadeEsbuildSveltePluginName\n\t);\n\tif (facadeEsbuildSveltePlugin) {\n\t\tObject.assign(facadeEsbuildSveltePlugin, esbuildSveltePlugin(options));\n\t}\n}\n\nfunction arraify<T>(value: T | T[]): T[] {\n\treturn Array.isArray(value) ? value : [value];\n}\n\nexport type Options = Omit<SvelteOptions, 'vitePlugin'> & PluginOptionsInline;\n\ninterface PluginOptionsInline extends PluginOptions {\n\t/**\n\t * Path to a svelte config file, either absolute or relative to Vite root\n\t *\n\t * set to `false` to ignore the svelte config file\n\t *\n\t * @see https://vitejs.dev/config/#root\n\t */\n\tconfigFile?: string | false;\n}\n\nexport interface PluginOptions {\n\t/**\n\t * A `picomatch` pattern, or array of patterns, which specifies the files the plugin should\n\t * operate on. By default, all svelte files are included.\n\t *\n\t * @see https://github.com/micromatch/picomatch\n\t */\n\tinclude?: Arrayable<string>;\n\n\t/**\n\t * A `picomatch` pattern, or array of patterns, which specifies the files to be ignored by the\n\t * plugin. By default, no files are ignored.\n\t *\n\t * @see https://github.com/micromatch/picomatch\n\t */\n\texclude?: Arrayable<string>;\n\n\t/**\n\t * Emit Svelte styles as virtual CSS files for Vite and other plugins to process\n\t *\n\t * @default true\n\t */\n\temitCss?: boolean;\n\n\t/**\n\t * Enable or disable Hot Module Replacement.\n\t *\n\t * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t *\n\t * DO NOT CUSTOMIZE SVELTE-HMR OPTIONS UNLESS YOU KNOW EXACTLY WHAT YOU ARE DOING\n\t *\n\t *                             YOU HAVE BEEN WARNED\n\t *\n\t * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t *\n\t * Set an object to pass custom options to svelte-hmr\n\t *\n\t * @see https://github.com/rixo/svelte-hmr#options\n\t * @default true for development, always false for production\n\t */\n\thot?: boolean | { injectCss?: boolean; partialAccept?: boolean; [key: string]: any };\n\n\t/**\n\t * Some Vite plugins can contribute additional preprocessors by defining `api.sveltePreprocess`.\n\t * If you don't want to use them, set this to true to ignore them all or use an array of strings\n\t * with plugin names to specify which.\n\t *\n\t * @default false\n\t */\n\tignorePluginPreprocessors?: boolean | string[];\n\n\t/**\n\t * vite-plugin-svelte automatically handles excluding svelte libraries and reinclusion of their dependencies\n\t * in vite.optimizeDeps.\n\t *\n\t * `disableDependencyReinclusion: true` disables all reinclusions\n\t * `disableDependencyReinclusion: ['foo','bar']` disables reinclusions for dependencies of foo and bar\n\t *\n\t * This should be used for hybrid packages that contain both node and browser dependencies, eg Routify\n\t *\n\t * @default false\n\t */\n\tdisableDependencyReinclusion?: boolean | string[];\n\n\t/**\n\t * Enable support for Vite's dependency optimization to prebundle Svelte libraries.\n\t *\n\t * To disable prebundling for a specific library, add it to `optimizeDeps.exclude`.\n\t *\n\t * @default true for dev, false for build\n\t */\n\tprebundleSvelteLibraries?: boolean;\n\n\t/**\n\t * These options are considered experimental and breaking changes to them can occur in any release\n\t */\n\texperimental?: ExperimentalOptions;\n}\n\nexport interface SvelteOptions {\n\t/**\n\t * A list of file extensions to be compiled by Svelte\n\t *\n\t * @default ['.svelte']\n\t */\n\textensions?: string[];\n\n\t/**\n\t * An array of preprocessors to transform the Svelte source code before compilation\n\t *\n\t * @see https://svelte.dev/docs#svelte_preprocess\n\t */\n\tpreprocess?: Arrayable<PreprocessorGroup>;\n\n\t/**\n\t * The options to be passed to the Svelte compiler. A few options are set by default,\n\t * including `dev` and `css`. However, some options are non-configurable, like\n\t * `filename`, `format`, `generate`, and `cssHash` (in dev).\n\t *\n\t * @see https://svelte.dev/docs#svelte_compile\n\t */\n\tcompilerOptions?: Omit<CompileOptions, 'filename' | 'format' | 'generate'>;\n\n\t/**\n\t * Handles warning emitted from the Svelte compiler\n\t */\n\tonwarn?: (warning: Warning, defaultHandler?: (warning: Warning) => void) => void;\n\n\t/**\n\t * Options for vite-plugin-svelte\n\t */\n\tvitePlugin?: PluginOptions;\n}\n\n/**\n * These options are considered experimental and breaking changes to them can occur in any release\n */\nexport interface ExperimentalOptions {\n\t/**\n\t * A function to update `compilerOptions` before compilation\n\t *\n\t * `data.filename` - The file to be compiled\n\t * `data.code` - The preprocessed Svelte code\n\t * `data.compileOptions` - The current compiler options\n\t *\n\t * To change part of the compiler options, return an object with the changes you need.\n\t *\n\t * @example\n\t * ```\n\t * ({ filename, compileOptions }) => {\n\t *   // Dynamically set hydration per Svelte file\n\t *   if (compileWithHydratable(filename) && !compileOptions.hydratable) {\n\t *     return { hydratable: true };\n\t *   }\n\t * }\n\t * ```\n\t */\n\tdynamicCompileOptions?: (data: {\n\t\tfilename: string;\n\t\tcode: string;\n\t\tcompileOptions: Partial<CompileOptions>;\n\t}) => Promise<Partial<CompileOptions> | void> | Partial<CompileOptions> | void;\n\n\t/**\n\t * enable svelte inspector\n\t */\n\tinspector?: InspectorOptions | boolean;\n\n\t/**\n\t * send a websocket message with svelte compiler warnings during dev\n\t *\n\t */\n\tsendWarningsToBrowser?: boolean;\n\n\t/**\n\t * disable svelte compile statistics\n\t *\n\t * @default false\n\t */\n\tdisableCompileStats?: 'dev' | 'build' | boolean;\n}\n\nexport interface InspectorOptions {\n\t/**\n\t * define a key combo to toggle inspector,\n\t * @default 'control-shift' on windows, 'meta-shift' on other os\n\t *\n\t * any number of modifiers `control` `shift` `alt` `meta` followed by zero or one regular key, separated by -\n\t * examples: control-shift, control-o, control-alt-s  meta-x control-meta\n\t * Some keys have native behavior (e.g. alt-s opens history menu on firefox).\n\t * To avoid conflicts or accidentally typing into inputs, modifier only combinations are recommended.\n\t */\n\ttoggleKeyCombo?: string;\n\n\t/**\n\t * define keys to select elements with via keyboard\n\t * @default {parent: 'ArrowUp', child: 'ArrowDown', next: 'ArrowRight', prev: 'ArrowLeft' }\n\t *\n\t * improves accessibility and also helps when you want to select elements that do not have a hoverable surface area\n\t * due to tight wrapping\n\t *\n\t * A note for users of screen-readers:\n\t * If you are using arrow keys to navigate the page itself, change the navKeys to avoid conflicts.\n\t * e.g. navKeys: {parent: 'w', prev: 'a', child: 's', next: 'd'}\n\t *\n\t *\n\t * parent: select closest parent\n\t * child: select first child (or grandchild)\n\t * next: next sibling (or parent if no next sibling exists)\n\t * prev: previous sibling (or parent if no prev sibling exists)\n\t */\n\tnavKeys?: { parent: string; child: string; next: string; prev: string };\n\n\t/**\n\t * define key to open the editor for the currently selected dom node\n\t *\n\t * @default 'Enter'\n\t */\n\topenKey?: string;\n\n\t/**\n\t * inspector is automatically disabled when releasing toggleKeyCombo after holding it for a longpress\n\t * @default false\n\t */\n\tholdMode?: boolean;\n\t/**\n\t * when to show the toggle button\n\t * @default 'active'\n\t */\n\tshowToggleButton?: 'always' | 'active' | 'never';\n\n\t/**\n\t * where to display the toggle button\n\t * @default top-right\n\t */\n\ttoggleButtonPos?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\n\n\t/**\n\t * inject custom styles when inspector is active\n\t */\n\tcustomStyles?: boolean;\n\n\t/**\n\t * append an import to the module id ending with `appendTo` instead of adding a script into body\n\t * useful for frameworks that do not support trannsformIndexHtml hook\n\t *\n\t * WARNING: only set this if you know exactly what it does.\n\t * Regular users of vite-plugin-svelte or SvelteKit do not need it\n\t */\n\tappendTo?: string;\n}\n\nexport interface PreResolvedOptions extends Options {\n\t// these options are non-nullable after resolve\n\tcompilerOptions: CompileOptions;\n\texperimental?: ExperimentalOptions;\n\t// extra options\n\troot: string;\n\tisBuild: boolean;\n\tisServe: boolean;\n\tisDebug: boolean;\n}\n\nexport interface ResolvedOptions extends PreResolvedOptions {\n\tisProduction: boolean;\n\tserver?: ViteDevServer;\n\tstats?: VitePluginSvelteStats;\n}\n\nexport type {\n\tCompileOptions,\n\tProcessed,\n\tMarkupPreprocessor,\n\tPreprocessor,\n\tPreprocessorGroup,\n\tWarning\n};\n\nexport type ModuleFormat = NonNullable<CompileOptions['format']>;\n\nexport type CssHashGetter = NonNullable<CompileOptions['cssHash']>;\n\nexport type Arrayable<T> = T | T[];\n"}},"preprocess.ts":{"file":{"contents":"import type { ResolvedConfig, Plugin } from 'vite';\nimport MagicString from 'magic-string';\nimport { PreprocessorGroup, ResolvedOptions } from './options';\nimport { log } from './log';\nimport path from 'path';\n\n/**\n * this appends a *{} rule to component styles to force the svelte compiler to add style classes to all nodes\n * That means adding/removing class rules from <style> node won't trigger js updates as the scope classes are not changed\n *\n * only used during dev with enabled css hmr\n */\nexport function createInjectScopeEverythingRulePreprocessorGroup(): PreprocessorGroup {\n\treturn {\n\t\tstyle({ content, filename }) {\n\t\t\tconst s = new MagicString(content);\n\t\t\ts.append(' *{}');\n\t\t\treturn {\n\t\t\t\tcode: s.toString(),\n\t\t\t\tmap: s.generateDecodedMap({\n\t\t\t\t\tsource: filename ? path.basename(filename) : undefined,\n\t\t\t\t\thires: true\n\t\t\t\t})\n\t\t\t};\n\t\t}\n\t};\n}\n\nfunction buildExtraPreprocessors(options: ResolvedOptions, config: ResolvedConfig) {\n\tconst prependPreprocessors: PreprocessorGroup[] = [];\n\tconst appendPreprocessors: PreprocessorGroup[] = [];\n\n\t// @ts-ignore\n\tconst pluginsWithPreprocessorsDeprecated = config.plugins.filter((p) => p?.sveltePreprocess);\n\tif (pluginsWithPreprocessorsDeprecated.length > 0) {\n\t\tlog.warn(\n\t\t\t`The following plugins use the deprecated 'plugin.sveltePreprocess' field. Please contact their maintainers and ask them to move it to 'plugin.api.sveltePreprocess': ${pluginsWithPreprocessorsDeprecated\n\t\t\t\t.map((p) => p.name)\n\t\t\t\t.join(', ')}`\n\t\t);\n\t\t// patch plugin to avoid breaking\n\t\tpluginsWithPreprocessorsDeprecated.forEach((p) => {\n\t\t\tif (!p.api) {\n\t\t\t\tp.api = {};\n\t\t\t}\n\t\t\tif (p.api.sveltePreprocess === undefined) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tp.api.sveltePreprocess = p.sveltePreprocess;\n\t\t\t} else {\n\t\t\t\tlog.error(\n\t\t\t\t\t`ignoring plugin.sveltePreprocess of ${p.name} because it already defined plugin.api.sveltePreprocess.`\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tconst pluginsWithPreprocessors: Plugin[] = config.plugins.filter((p) => p?.api?.sveltePreprocess);\n\tconst ignored: Plugin[] = [],\n\t\tincluded: Plugin[] = [];\n\tfor (const p of pluginsWithPreprocessors) {\n\t\tif (\n\t\t\toptions.ignorePluginPreprocessors === true ||\n\t\t\t(Array.isArray(options.ignorePluginPreprocessors) &&\n\t\t\t\toptions.ignorePluginPreprocessors?.includes(p.name))\n\t\t) {\n\t\t\tignored.push(p);\n\t\t} else {\n\t\t\tincluded.push(p);\n\t\t}\n\t}\n\tif (ignored.length > 0) {\n\t\tlog.debug(\n\t\t\t`Ignoring svelte preprocessors defined by these vite plugins: ${ignored\n\t\t\t\t.map((p) => p.name)\n\t\t\t\t.join(', ')}`\n\t\t);\n\t}\n\tif (included.length > 0) {\n\t\tlog.debug(\n\t\t\t`Adding svelte preprocessors defined by these vite plugins: ${included\n\t\t\t\t.map((p) => p.name)\n\t\t\t\t.join(', ')}`\n\t\t);\n\t\tappendPreprocessors.push(...pluginsWithPreprocessors.map((p) => p.api.sveltePreprocess));\n\t}\n\n\treturn { prependPreprocessors, appendPreprocessors };\n}\n\nexport function addExtraPreprocessors(options: ResolvedOptions, config: ResolvedConfig) {\n\tconst { prependPreprocessors, appendPreprocessors } = buildExtraPreprocessors(options, config);\n\tif (prependPreprocessors.length > 0 || appendPreprocessors.length > 0) {\n\t\tif (!options.preprocess) {\n\t\t\toptions.preprocess = [...prependPreprocessors, ...appendPreprocessors];\n\t\t} else if (Array.isArray(options.preprocess)) {\n\t\t\toptions.preprocess.unshift(...prependPreprocessors);\n\t\t\toptions.preprocess.push(...appendPreprocessors);\n\t\t} else {\n\t\t\toptions.preprocess = [...prependPreprocessors, options.preprocess, ...appendPreprocessors];\n\t\t}\n\t}\n}\n"}},"resolve.ts":{"file":{"contents":"import path from 'path';\nimport { builtinModules } from 'module';\nimport { resolveDependencyData, isCommonDepWithoutSvelteField } from './dependencies';\nimport { VitePluginSvelteCache } from './vite-plugin-svelte-cache';\n\nexport async function resolveViaPackageJsonSvelte(\n\timportee: string,\n\timporter: string | undefined,\n\tcache: VitePluginSvelteCache\n): Promise<string | void> {\n\tif (\n\t\timporter &&\n\t\tisBareImport(importee) &&\n\t\t!isNodeInternal(importee) &&\n\t\t!isCommonDepWithoutSvelteField(importee)\n\t) {\n\t\tconst cached = cache.getResolvedSvelteField(importee, importer);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\t\tconst pkgData = await resolveDependencyData(importee, importer);\n\t\tif (pkgData) {\n\t\t\tconst { pkg, dir } = pkgData;\n\t\t\tif (pkg.svelte) {\n\t\t\t\tconst result = path.resolve(dir, pkg.svelte);\n\t\t\t\tcache.setResolvedSvelteField(importee, importer, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction isNodeInternal(importee: string) {\n\treturn importee.startsWith('node:') || builtinModules.includes(importee);\n}\n\nfunction isBareImport(importee: string): boolean {\n\tif (\n\t\t!importee ||\n\t\timportee[0] === '.' ||\n\t\timportee[0] === '\\0' ||\n\t\timportee.includes(':') ||\n\t\tpath.isAbsolute(importee)\n\t) {\n\t\treturn false;\n\t}\n\tconst parts = importee.split('/');\n\tswitch (parts.length) {\n\t\tcase 1:\n\t\t\treturn true;\n\t\tcase 2:\n\t\t\treturn parts[0].startsWith('@');\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n"}},"sourcemaps.ts":{"file":{"contents":"import path from 'path';\n\n/**\n * sourcemap sources are relative to the sourcemap itself\n * assume the sourcemap location is the same as filename and turn absolute paths to relative\n * to avoid leaking fs information like vite root\n */\nexport function mapSourcesToRelative(map: { sources?: string[] }, filename: string) {\n\tif (map?.sources) {\n\t\tmap.sources = map.sources.map((s) => {\n\t\t\tif (path.isAbsolute(s)) {\n\t\t\t\tconst relative = path.relative(filename, s);\n\t\t\t\t// empty string as a source is not allowed, use simple filename\n\t\t\t\treturn relative === '' ? path.basename(filename) : relative;\n\t\t\t} else {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t});\n\t}\n}\n"}},"svelte-version.ts":{"file":{"contents":"import { VERSION } from 'svelte/compiler';\nconst svelteVersion = parseVersion(VERSION);\n\nexport function parseVersion(version: string): number[] {\n\tconst segments = version.split('.', 3).map((s) => parseInt(s, 10));\n\twhile (segments.length < 3) {\n\t\tsegments.push(0);\n\t}\n\treturn segments;\n}\n\n/**\n * compare version with current svelte, only takes major.minor.patch into account.\n * If you don't pass all three, values will be filled with 0, ie `3` is equal to `3.0.0`\n * @param version\n * @returns 1 if passed version is larger than current, 0 if it is equal and -1 if it is lower\n */\nexport function compareToSvelte(version: string): 1 | 0 | -1 {\n\tconst parsedVersion = parseVersion(version);\n\tfor (let i = 0; i < svelteVersion.length; i++) {\n\t\tconst a = parsedVersion[i];\n\t\tconst b = svelteVersion[i];\n\t\tif (a === b) {\n\t\t\tcontinue;\n\t\t} else if (a > b) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nexport function atLeastSvelte(version: string) {\n\tconst result = compareToSvelte(version) <= 0;\n\treturn result;\n}\n"}},"vite-plugin-svelte-cache.ts":{"file":{"contents":"import { SvelteRequest } from './id';\nimport { Code, CompileData } from './compile';\n\nexport class VitePluginSvelteCache {\n\tprivate _css = new Map<string, Code>();\n\tprivate _js = new Map<string, Code>();\n\tprivate _dependencies = new Map<string, string[]>();\n\tprivate _dependants = new Map<string, Set<string>>();\n\tprivate _resolvedSvelteFields = new Map<string, string>();\n\tprivate _errors = new Map<string, any>();\n\n\tpublic update(compileData: CompileData) {\n\t\tthis._errors.delete(compileData.normalizedFilename);\n\t\tthis.updateCSS(compileData);\n\t\tthis.updateJS(compileData);\n\t\tthis.updateDependencies(compileData);\n\t}\n\n\tpublic has(svelteRequest: SvelteRequest) {\n\t\tconst id = svelteRequest.normalizedFilename;\n\t\treturn this._errors.has(id) || this._js.has(id) || this._css.has(id);\n\t}\n\n\tpublic setError(svelteRequest: SvelteRequest, error: any) {\n\t\t// keep dependency info, otherwise errors in dependants would not trigger an update after fixing\n\t\t// because they are no longer watched\n\t\tthis.remove(svelteRequest, true);\n\t\tthis._errors.set(svelteRequest.normalizedFilename, error);\n\t}\n\n\tprivate updateCSS(compileData: CompileData) {\n\t\tthis._css.set(compileData.normalizedFilename, compileData.compiled.css);\n\t}\n\n\tprivate updateJS(compileData: CompileData) {\n\t\tif (!compileData.ssr) {\n\t\t\t// do not cache SSR js\n\t\t\tthis._js.set(compileData.normalizedFilename, compileData.compiled.js);\n\t\t}\n\t}\n\n\tprivate updateDependencies(compileData: CompileData) {\n\t\tconst id = compileData.normalizedFilename;\n\t\tconst prevDependencies = this._dependencies.get(id) || [];\n\t\tconst dependencies = compileData.dependencies;\n\t\tthis._dependencies.set(id, dependencies);\n\t\tconst removed = prevDependencies.filter((d) => !dependencies.includes(d));\n\t\tconst added = dependencies.filter((d) => !prevDependencies.includes(d));\n\t\tadded.forEach((d) => {\n\t\t\tif (!this._dependants.has(d)) {\n\t\t\t\tthis._dependants.set(d, new Set<string>());\n\t\t\t}\n\t\t\tthis._dependants.get(d)!.add(compileData.filename);\n\t\t});\n\t\tremoved.forEach((d) => {\n\t\t\tthis._dependants.get(d)!.delete(compileData.filename);\n\t\t});\n\t}\n\n\tpublic remove(svelteRequest: SvelteRequest, keepDependencies: boolean = false): boolean {\n\t\tconst id = svelteRequest.normalizedFilename;\n\t\tlet removed = false;\n\t\tif (this._errors.delete(id)) {\n\t\t\tremoved = true;\n\t\t}\n\t\tif (this._js.delete(id)) {\n\t\t\tremoved = true;\n\t\t}\n\t\tif (this._css.delete(id)) {\n\t\t\tremoved = true;\n\t\t}\n\t\tif (!keepDependencies) {\n\t\t\tconst dependencies = this._dependencies.get(id);\n\t\t\tif (dependencies) {\n\t\t\t\tremoved = true;\n\t\t\t\tdependencies.forEach((d) => {\n\t\t\t\t\tconst dependants = this._dependants.get(d);\n\t\t\t\t\tif (dependants && dependants.has(svelteRequest.filename)) {\n\t\t\t\t\t\tdependants.delete(svelteRequest.filename);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis._dependencies.delete(id);\n\t\t\t}\n\t\t}\n\n\t\treturn removed;\n\t}\n\n\tpublic getCSS(svelteRequest: SvelteRequest) {\n\t\treturn this._css.get(svelteRequest.normalizedFilename);\n\t}\n\n\tpublic getJS(svelteRequest: SvelteRequest) {\n\t\tif (!svelteRequest.ssr) {\n\t\t\t// SSR js isn't cached\n\t\t\treturn this._js.get(svelteRequest.normalizedFilename);\n\t\t}\n\t}\n\n\tpublic getError(svelteRequest: SvelteRequest) {\n\t\treturn this._errors.get(svelteRequest.normalizedFilename);\n\t}\n\n\tpublic getDependants(path: string): string[] {\n\t\tconst dependants = this._dependants.get(path);\n\t\treturn dependants ? [...dependants] : [];\n\t}\n\n\tpublic getResolvedSvelteField(name: string, importer?: string): string | void {\n\t\treturn this._resolvedSvelteFields.get(this._getResolvedSvelteFieldKey(name, importer));\n\t}\n\n\tpublic setResolvedSvelteField(\n\t\timportee: string,\n\t\timporter: string | undefined = undefined,\n\t\tresolvedSvelte: string\n\t) {\n\t\tthis._resolvedSvelteFields.set(\n\t\t\tthis._getResolvedSvelteFieldKey(importee, importer),\n\t\t\tresolvedSvelte\n\t\t);\n\t}\n\n\tprivate _getResolvedSvelteFieldKey(importee: string, importer?: string): string {\n\t\treturn importer ? `${importer} > ${importee}` : importee;\n\t}\n}\n"}},"vite-plugin-svelte-stats.ts":{"file":{"contents":"import { log } from './log';\n//eslint-disable-next-line node/no-missing-import\nimport { findClosestPkgJsonPath } from 'vitefu';\nimport { readFileSync } from 'fs';\nimport { dirname } from 'path';\nimport { performance } from 'perf_hooks';\nimport { normalizePath } from 'vite';\n\ninterface Stat {\n\tfile: string;\n\tpkg?: string;\n\tstart: number;\n\tend: number;\n}\n\nexport interface StatCollection {\n\tname: string;\n\toptions: CollectionOptions;\n\t//eslint-disable-next-line no-unused-vars\n\tstart: (file: string) => () => void;\n\tstats: Stat[];\n\tpackageStats?: PackageStats[];\n\tcollectionStart: number;\n\tduration?: number;\n\tfinish: () => Promise<void> | void;\n\tfinished: boolean;\n}\n\ninterface PackageStats {\n\tpkg: string;\n\tfiles: number;\n\tduration: number;\n}\n\nexport interface CollectionOptions {\n\t//eslint-disable-next-line no-unused-vars\n\tlogInProgress: (collection: StatCollection, now: number) => boolean;\n\t//eslint-disable-next-line no-unused-vars\n\tlogResult: (collection: StatCollection) => boolean;\n}\n\nconst defaultCollectionOptions: CollectionOptions = {\n\t// log after 500ms and more than one file processed\n\tlogInProgress: (c, now) => now - c.collectionStart > 500 && c.stats.length > 1,\n\t// always log results\n\tlogResult: () => true\n};\n\nfunction humanDuration(n: number) {\n\t// 99.9ms  0.10s\n\treturn n < 100 ? `${n.toFixed(1)}ms` : `${(n / 1000).toFixed(2)}s`;\n}\n\nfunction formatPackageStats(pkgStats: PackageStats[]) {\n\tconst statLines = pkgStats.map((pkgStat) => {\n\t\tconst duration = pkgStat.duration;\n\t\tconst avg = duration / pkgStat.files;\n\t\treturn [pkgStat.pkg, `${pkgStat.files}`, humanDuration(duration), humanDuration(avg)];\n\t});\n\tstatLines.unshift(['package', 'files', 'time', 'avg']);\n\tconst columnWidths = statLines.reduce(\n\t\t(widths: number[], row) => {\n\t\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\t\tconst cell = row[i];\n\t\t\t\tif (widths[i] < cell.length) {\n\t\t\t\t\twidths[i] = cell.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn widths;\n\t\t},\n\t\tstatLines[0].map(() => 0)\n\t);\n\n\tconst table = statLines\n\t\t.map((row: string[]) =>\n\t\t\trow\n\t\t\t\t.map((cell: string, i: number) => {\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\treturn cell.padEnd(columnWidths[i], ' ');\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn cell.padStart(columnWidths[i], ' ');\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join('\\t')\n\t\t)\n\t\t.join('\\n');\n\treturn table;\n}\n\n/**\n * utility to get the package name a file belongs to\n *\n * @param {string} file to find package for\n * @returns {path:string,name:string} tuple of path,name where name is the parsed package name and path is the normalized path to it\n */\nasync function getClosestNamedPackage(file: string): Promise<{ name: string; path: string }> {\n\tlet name = '$unknown';\n\tlet path = await findClosestPkgJsonPath(file, (pkgPath) => {\n\t\tconst pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n\t\tif (pkg.name != null) {\n\t\t\tname = pkg.name;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\t// return normalized path with appended '/' so .startsWith works for future file checks\n\tpath = normalizePath(dirname(path ?? file)) + '/';\n\treturn { name, path };\n}\n\nexport class VitePluginSvelteStats {\n\t// package directory -> package name\n\tprivate _packages: { path: string; name: string }[] = [];\n\tprivate _collections: StatCollection[] = [];\n\tstartCollection(name: string, opts?: Partial<CollectionOptions>) {\n\t\tconst options = {\n\t\t\t...defaultCollectionOptions,\n\t\t\t...opts\n\t\t};\n\t\tconst stats: Stat[] = [];\n\t\tconst collectionStart = performance.now();\n\t\tconst _this = this;\n\t\tlet hasLoggedProgress = false;\n\t\tconst collection: StatCollection = {\n\t\t\tname,\n\t\t\toptions,\n\t\t\tstats,\n\t\t\tcollectionStart,\n\t\t\tfinished: false,\n\t\t\tstart(file) {\n\t\t\t\tif (collection.finished) {\n\t\t\t\t\tthrow new Error('called after finish() has been used');\n\t\t\t\t}\n\t\t\t\tfile = normalizePath(file);\n\t\t\t\tconst start = performance.now();\n\t\t\t\tconst stat: Stat = { file, start, end: start };\n\t\t\t\treturn () => {\n\t\t\t\t\tconst now = performance.now();\n\t\t\t\t\tstat.end = now;\n\t\t\t\t\tstats.push(stat);\n\t\t\t\t\tif (!hasLoggedProgress && options.logInProgress(collection, now)) {\n\t\t\t\t\t\thasLoggedProgress = true;\n\t\t\t\t\t\tlog.info(`${name} in progress ...`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\tasync finish() {\n\t\t\t\tawait _this._finish(collection);\n\t\t\t}\n\t\t};\n\t\t_this._collections.push(collection);\n\t\treturn collection;\n\t}\n\n\tpublic async finishAll() {\n\t\tawait Promise.all(this._collections.map((c) => c.finish()));\n\t}\n\n\tprivate async _finish(collection: StatCollection) {\n\t\ttry {\n\t\t\tcollection.finished = true;\n\t\t\tconst now = performance.now();\n\t\t\tcollection.duration = now - collection.collectionStart;\n\t\t\tconst logResult = collection.options.logResult(collection);\n\t\t\tif (logResult) {\n\t\t\t\tawait this._aggregateStatsResult(collection);\n\t\t\t\tlog.info(`${collection.name} done.`, formatPackageStats(collection.packageStats!));\n\t\t\t}\n\t\t\t// cut some ties to free it for garbage collection\n\t\t\tconst index = this._collections.indexOf(collection);\n\t\t\tthis._collections.splice(index, 1);\n\t\t\tcollection.stats.length = 0;\n\t\t\tcollection.stats = [];\n\t\t\tif (collection.packageStats) {\n\t\t\t\tcollection.packageStats.length = 0;\n\t\t\t\tcollection.packageStats = [];\n\t\t\t}\n\t\t\tcollection.start = () => () => {};\n\t\t\tcollection.finish = () => {};\n\t\t} catch (e) {\n\t\t\t// this should not happen, but stats taking also should not break the process\n\t\t\tlog.debug.once(`failed to finish stats for ${collection.name}`, e);\n\t\t}\n\t}\n\n\tprivate async _aggregateStatsResult(collection: StatCollection) {\n\t\tconst stats = collection.stats;\n\t\tfor (const stat of stats) {\n\t\t\tlet pkg = this._packages.find((p) => stat.file.startsWith(p.path));\n\t\t\tif (!pkg) {\n\t\t\t\tpkg = await getClosestNamedPackage(stat.file);\n\t\t\t\tthis._packages.push(pkg);\n\t\t\t}\n\t\t\tstat.pkg = pkg.name;\n\t\t}\n\n\t\t// group stats\n\t\tconst grouped: { [key: string]: PackageStats } = {};\n\t\tstats.forEach((stat) => {\n\t\t\tconst pkg = stat.pkg!;\n\t\t\tlet group = grouped[pkg];\n\t\t\tif (!group) {\n\t\t\t\tgroup = grouped[pkg] = {\n\t\t\t\t\tfiles: 0,\n\t\t\t\t\tduration: 0,\n\t\t\t\t\tpkg\n\t\t\t\t};\n\t\t\t}\n\t\t\tgroup.files += 1;\n\t\t\tgroup.duration += stat.end - stat.start;\n\t\t});\n\n\t\tconst groups = Object.values(grouped);\n\t\tgroups.sort((a, b) => b.duration - a.duration);\n\t\tcollection.packageStats = groups;\n\t}\n}\n"}},"watch.ts":{"file":{"contents":"import { VitePluginSvelteCache } from './vite-plugin-svelte-cache';\nimport fs from 'fs';\nimport { log } from './log';\nimport { IdParser } from './id';\nimport { ResolvedOptions } from './options';\nimport { knownSvelteConfigNames } from './load-svelte-config';\nimport path from 'path';\nimport { FSWatcher } from 'vite';\n\nexport function setupWatchers(\n\toptions: ResolvedOptions,\n\tcache: VitePluginSvelteCache,\n\trequestParser: IdParser\n) {\n\tconst { server, configFile: svelteConfigFile } = options;\n\tif (!server) {\n\t\treturn;\n\t}\n\tconst { watcher, ws } = server;\n\tconst { root, server: serverConfig } = server.config;\n\n\tconst emitChangeEventOnDependants = (filename: string) => {\n\t\tconst dependants = cache.getDependants(filename);\n\t\tdependants.forEach((dependant) => {\n\t\t\tif (fs.existsSync(dependant)) {\n\t\t\t\tlog.debug(\n\t\t\t\t\t`emitting virtual change event for \"${dependant}\" because depdendency \"${filename}\" changed`\n\t\t\t\t);\n\t\t\t\twatcher.emit('change', dependant);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst removeUnlinkedFromCache = (filename: string) => {\n\t\tconst svelteRequest = requestParser(filename, false);\n\t\tif (svelteRequest) {\n\t\t\tconst removedFromCache = cache.remove(svelteRequest);\n\t\t\tif (removedFromCache) {\n\t\t\t\tlog.debug(`cleared VitePluginSvelteCache for deleted file ${filename}`);\n\t\t\t}\n\t\t}\n\t};\n\n\tconst triggerViteRestart = (filename: string) => {\n\t\tif (serverConfig.middlewareMode) {\n\t\t\t// in middlewareMode we can't restart the server automatically\n\t\t\t// show the user an overlay instead\n\t\t\tconst message =\n\t\t\t\t'Svelte config change detected, restart your dev process to apply the changes.';\n\t\t\tlog.info(message, filename);\n\t\t\tws.send({\n\t\t\t\ttype: 'error',\n\t\t\t\terr: { message, stack: '', plugin: 'vite-plugin-svelte', id: filename }\n\t\t\t});\n\t\t} else {\n\t\t\tlog.info(`svelte config changed: restarting vite server. - file: ${filename}`);\n\t\t\tserver.restart();\n\t\t}\n\t};\n\n\t// collection of watcher listeners by event\n\tconst listenerCollection = {\n\t\tadd: [] as Array<Function>,\n\t\tchange: [emitChangeEventOnDependants],\n\t\tunlink: [removeUnlinkedFromCache, emitChangeEventOnDependants]\n\t};\n\n\tif (svelteConfigFile !== false) {\n\t\t// configFile false means we ignore the file and external process is responsible\n\t\tconst possibleSvelteConfigs = knownSvelteConfigNames.map((cfg) => path.join(root, cfg));\n\t\tconst restartOnConfigAdd = (filename: string) => {\n\t\t\tif (possibleSvelteConfigs.includes(filename)) {\n\t\t\t\ttriggerViteRestart(filename);\n\t\t\t}\n\t\t};\n\n\t\tconst restartOnConfigChange = (filename: string) => {\n\t\t\tif (filename === svelteConfigFile) {\n\t\t\t\ttriggerViteRestart(filename);\n\t\t\t}\n\t\t};\n\n\t\tif (svelteConfigFile) {\n\t\t\tlistenerCollection.change.push(restartOnConfigChange);\n\t\t\tlistenerCollection.unlink.push(restartOnConfigChange);\n\t\t} else {\n\t\t\tlistenerCollection.add.push(restartOnConfigAdd);\n\t\t}\n\t}\n\n\tObject.entries(listenerCollection).forEach(([evt, listeners]) => {\n\t\tif (listeners.length > 0) {\n\t\t\twatcher.on(evt, (filename) => listeners.forEach((listener) => listener(filename)));\n\t\t}\n\t});\n}\n// taken from vite utils\nexport function ensureWatchedFile(watcher: FSWatcher, file: string | null, root: string): void {\n\tif (\n\t\tfile &&\n\t\t// only need to watch if out of root\n\t\t!file.startsWith(root + '/') &&\n\t\t// some rollup plugins use null bytes for private resolved Ids\n\t\t!file.includes('\\0') &&\n\t\tfs.existsSync(file)\n\t) {\n\t\t// resolve file to normalized system path\n\t\twatcher.add(path.resolve(file));\n\t}\n}\n"}},"__tests__":{"directory":{"svelte-version.spec.ts":{"file":{"contents":"import { describe, it, expect } from 'vitest';\nimport { compareToSvelte, atLeastSvelte, parseVersion } from '../svelte-version';\nimport { VERSION } from 'svelte/compiler';\nconst svelteVersion = parseVersion(VERSION);\ndescribe('svelte-version', () => {\n\tdescribe('parseVersion', () => {\n\t\tit('should fill major,minor,patch', () => {\n\t\t\texpect(parseVersion('3')).toEqual([3, 0, 0]);\n\t\t\texpect(parseVersion('3.1')).toEqual([3, 1, 0]);\n\t\t});\n\t\tit('should ignore additional segments', () => {\n\t\t\texpect(parseVersion('1.2.3.4')).toEqual([1, 2, 3]);\n\t\t});\n\t});\n\tdescribe('compareToSvelte', () => {\n\t\tit('should return 0 for current', async () => {\n\t\t\texpect(compareToSvelte(VERSION)).toBe(0);\n\t\t});\n\n\t\tit('should return 1 for patch bump', async () => {\n\t\t\tconst patch = svelteVersion.concat();\n\t\t\tpatch[2] += 1;\n\t\t\tconst patchBump = patch.join('.');\n\t\t\texpect(compareToSvelte(patchBump)).toBe(1);\n\t\t});\n\t\tit('should return 1 for minor bump', async () => {\n\t\t\tconst minor = svelteVersion.concat();\n\t\t\tminor[1] += 1;\n\t\t\tconst minorBump = minor.join('.');\n\t\t\texpect(compareToSvelte(minorBump)).toBe(1);\n\t\t});\n\t\tit('should return 1 for major bump', async () => {\n\t\t\tconst major = svelteVersion.concat();\n\t\t\tmajor[0] += 1;\n\t\t\tconst majorBump = major.join('.');\n\t\t\texpect(compareToSvelte(majorBump)).toBe(1);\n\t\t});\n\n\t\tit('should return -1 for lower patch', async () => {\n\t\t\tconst patch = svelteVersion.concat();\n\t\t\tpatch[2] -= 1;\n\t\t\tconst lowerPatch = patch.join('.');\n\t\t\texpect(compareToSvelte(lowerPatch)).toBe(-1);\n\t\t});\n\t\tit('should return -1 for lower minor', async () => {\n\t\t\tconst minor = svelteVersion.concat();\n\t\t\tminor[1] -= 1;\n\t\t\tconst lowerMinor = minor.join('.');\n\t\t\texpect(compareToSvelte(lowerMinor)).toBe(-1);\n\t\t});\n\t\tit('should return -1 for lower major', async () => {\n\t\t\tconst major = svelteVersion.concat();\n\t\t\tmajor[0] -= 1;\n\t\t\tconst lowerMajor = major.join('.');\n\t\t\texpect(compareToSvelte(lowerMajor)).toBe(-1);\n\t\t});\n\t});\n\n\tdescribe('atLeastSvelte', () => {\n\t\tit('should return true for current', async () => {\n\t\t\texpect(atLeastSvelte(VERSION)).toBe(true);\n\t\t});\n\n\t\tit('should return false for higher patch', async () => {\n\t\t\tconst patch = svelteVersion.concat();\n\t\t\tpatch[2] += 1;\n\t\t\tconst patchBump = patch.join('.');\n\t\t\texpect(atLeastSvelte(patchBump)).toBe(false);\n\t\t});\n\t\tit('should return false for higher minor', async () => {\n\t\t\tconst minor = svelteVersion.concat();\n\t\t\tminor[1] += 1;\n\t\t\tconst minorBump = minor.join('.');\n\t\t\texpect(atLeastSvelte(minorBump)).toBe(false);\n\t\t});\n\t\tit('should return false for higher major', async () => {\n\t\t\tconst major = svelteVersion.concat();\n\t\t\tmajor[0] += 1;\n\t\t\tconst majorBump = major.join('.');\n\t\t\texpect(atLeastSvelte(majorBump)).toBe(false);\n\t\t});\n\n\t\tit('should return true for lower patch', async () => {\n\t\t\tconst patch = svelteVersion.concat();\n\t\t\tpatch[2] -= 1;\n\t\t\tconst lowerPatch = patch.join('.');\n\t\t\texpect(atLeastSvelte(lowerPatch)).toBe(true);\n\t\t});\n\t\tit('should return true for lower minor', async () => {\n\t\t\tconst minor = svelteVersion.concat();\n\t\t\tminor[1] -= 1;\n\t\t\tconst lowerMinor = minor.join('.');\n\t\t\texpect(atLeastSvelte(lowerMinor)).toBe(true);\n\t\t});\n\t\tit('should return true for lower major', async () => {\n\t\t\tconst major = svelteVersion.concat();\n\t\t\tmajor[0] -= 1;\n\t\t\tconst lowerMajor = major.join('.');\n\t\t\texpect(atLeastSvelte(lowerMajor)).toBe(true);\n\t\t});\n\t});\n});\n"}}}}}}}}}}}}