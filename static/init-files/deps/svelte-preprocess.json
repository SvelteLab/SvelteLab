{"directory":{"dist":{"directory":{"autoProcess.d.ts":{"file":{"contents":"import type { AutoPreprocessGroup, AutoPreprocessOptions, Processed, TransformerArgs, TransformerOptions } from './types';\r\nexport declare const transform: (name: string | null | undefined, options: TransformerOptions, { content, markup, map, filename, attributes }: TransformerArgs<any>) => Promise<Processed>;\r\nexport declare function sveltePreprocess({ aliases, markupTagName, preserve, sourceMap, ...rest }?: AutoPreprocessOptions): AutoPreprocessGroup;\r\n"}},"autoProcess.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sveltePreprocess = exports.transform = void 0;\r\nconst utils_1 = require(\"./modules/utils\");\r\nconst tagInfo_1 = require(\"./modules/tagInfo\");\r\nconst language_1 = require(\"./modules/language\");\r\nconst prepareContent_1 = require(\"./modules/prepareContent\");\r\nconst markup_1 = require(\"./modules/markup\");\r\nconst TARGET_LANGUAGES = Object.freeze({\r\n    markup: 'html',\r\n    style: 'css',\r\n    script: 'javascript',\r\n});\r\nconst transform = async (name, options, { content, markup, map, filename, attributes }) => {\r\n    var _a;\r\n    if (name == null || options === false) {\r\n        return { code: content };\r\n    }\r\n    if (typeof options === 'function') {\r\n        return options({ content, map, filename, attributes });\r\n    }\r\n    // todo: maybe add a try-catch here looking for module-not-found errors\r\n    const { transformer } = await (_a = `./transformers/${name}`, Promise.resolve().then(() => __importStar(require(_a))));\r\n    return transformer({\r\n        content,\r\n        markup,\r\n        filename,\r\n        map,\r\n        attributes,\r\n        options: typeof options === 'boolean' ? null : options,\r\n    });\r\n};\r\nexports.transform = transform;\r\nfunction sveltePreprocess(_a) {\r\n    var _b, _c;\r\n    var { aliases, markupTagName = 'template', preserve = [], sourceMap = (_c = ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.NODE_ENV) === 'development') !== null && _c !== void 0 ? _c : false, ...rest } = _a === void 0 ? {} : _a;\r\n    const transformers = rest;\r\n    if (aliases === null || aliases === void 0 ? void 0 : aliases.length) {\r\n        (0, language_1.addLanguageAlias)(aliases);\r\n    }\r\n    function resolveLanguageArgs(lang, alias) {\r\n        const langOpts = transformers[lang];\r\n        const aliasOpts = alias ? transformers[alias] : undefined;\r\n        const opts = {};\r\n        if (typeof langOpts === 'object') {\r\n            Object.assign(opts, langOpts);\r\n        }\r\n        Object.assign(opts, (0, language_1.getLanguageDefaults)(lang), (0, language_1.getLanguageDefaults)(alias));\r\n        if (lang !== alias && typeof aliasOpts === 'object') {\r\n            Object.assign(opts, aliasOpts);\r\n        }\r\n        if (sourceMap && lang in language_1.SOURCE_MAP_PROP_MAP) {\r\n            const [path, value] = language_1.SOURCE_MAP_PROP_MAP[lang];\r\n            (0, utils_1.setProp)(opts, path, value);\r\n        }\r\n        return opts;\r\n    }\r\n    function getTransformerOptions(lang, alias, { ignoreAliasOverride } = {}) {\r\n        if (lang == null)\r\n            return null;\r\n        const langOpts = transformers[lang];\r\n        const aliasOpts = alias ? transformers[alias] : undefined;\r\n        if (!ignoreAliasOverride && typeof aliasOpts === 'function') {\r\n            return aliasOpts;\r\n        }\r\n        if (typeof langOpts === 'function')\r\n            return langOpts;\r\n        if (aliasOpts === false || langOpts === false)\r\n            return false;\r\n        return resolveLanguageArgs(lang, alias);\r\n    }\r\n    const getTransformerTo = (type, targetLanguage) => async (svelteFile) => {\r\n        let { content, markup, filename, lang, alias, dependencies, attributes } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (lang == null || alias == null) {\r\n            alias = TARGET_LANGUAGES[type];\r\n            lang = (0, language_1.getLanguageFromAlias)(alias);\r\n        }\r\n        if ((lang && preserve.includes(lang)) || preserve.includes(alias)) {\r\n            return { code: content };\r\n        }\r\n        const transformerOptions = getTransformerOptions(lang, alias);\r\n        content = (0, prepareContent_1.prepareContent)({\r\n            options: transformerOptions,\r\n            content,\r\n        });\r\n        if (lang === targetLanguage) {\r\n            // has override method for alias\r\n            // example: sugarss override should work apart from postcss\r\n            if (typeof transformerOptions === 'function' && alias !== lang) {\r\n                return transformerOptions({ content, filename, attributes });\r\n            }\r\n            // otherwise, we're done here\r\n            return { code: content, dependencies };\r\n        }\r\n        const transformed = await (0, exports.transform)(lang, transformerOptions, {\r\n            content,\r\n            markup,\r\n            filename,\r\n            attributes,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    };\r\n    const scriptTransformer = getTransformerTo('script', 'javascript');\r\n    const cssTransformer = getTransformerTo('style', 'css');\r\n    const markupTransformer = getTransformerTo('markup', 'html');\r\n    const markup = async ({ content, filename }) => {\r\n        if (transformers.replace) {\r\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\r\n                content,\r\n                markup: content,\r\n                filename,\r\n            });\r\n            content = transformed.code;\r\n        }\r\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\r\n            // we only pass the markupTagName because the rest of options\r\n            // is fetched internally by the `markupTransformer`\r\n            markupTagName,\r\n        });\r\n    };\r\n    const script = async ({ content, attributes, markup: fullMarkup, filename, }) => {\r\n        const transformResult = await scriptTransformer({\r\n            content,\r\n            attributes,\r\n            markup: fullMarkup,\r\n            filename,\r\n        });\r\n        let { code, map, dependencies, diagnostics } = transformResult;\r\n        if (transformers.babel) {\r\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\r\n            code = transformed.code;\r\n            map = transformed.map;\r\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\r\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\r\n        }\r\n        return { code, map, dependencies, diagnostics };\r\n    };\r\n    const style = async ({ content, attributes, markup: fullMarkup, filename, }) => {\r\n        const transformResult = await cssTransformer({\r\n            content,\r\n            attributes,\r\n            markup: fullMarkup,\r\n            filename,\r\n        });\r\n        let { code, map, dependencies } = transformResult;\r\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\r\n        // istanbul ignore else\r\n        if (hasPostcss) {\r\n            if (transformers.postcss) {\r\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\r\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \r\n                // todo: this seems wrong and ugly\r\n                { ignoreAliasOverride: true });\r\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\r\n                    content: code,\r\n                    markup: fullMarkup,\r\n                    map,\r\n                    filename,\r\n                    attributes,\r\n                });\r\n                code = transformed.code;\r\n                map = transformed.map;\r\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\r\n            }\r\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\r\n            code = transformed.code;\r\n            map = transformed.map;\r\n        }\r\n        else if ('global' in attributes) {\r\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\r\n        }\r\n        return { code, map, dependencies };\r\n    };\r\n    return {\r\n        markup,\r\n        script,\r\n        style,\r\n    };\r\n}\r\nexports.sveltePreprocess = sveltePreprocess;\r\n"}},"index.d.ts":{"file":{"contents":"import { sveltePreprocess } from './autoProcess';\r\ndeclare const _default: typeof sveltePreprocess;\r\nexport default _default;\r\nexport { default as pug } from './processors/pug';\r\nexport { default as coffeescript } from './processors/coffeescript';\r\nexport { default as typescript } from './processors/typescript';\r\nexport { default as less } from './processors/less';\r\nexport { default as scss, default as sass } from './processors/scss';\r\nexport { default as stylus } from './processors/stylus';\r\nexport { default as postcss } from './processors/postcss';\r\nexport { default as globalStyle } from './processors/globalStyle';\r\nexport { default as babel } from './processors/babel';\r\nexport { default as replace } from './processors/replace';\r\n"}},"index.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.replace = exports.babel = exports.globalStyle = exports.postcss = exports.stylus = exports.sass = exports.scss = exports.less = exports.typescript = exports.coffeescript = exports.pug = void 0;\r\nconst autoProcess_1 = require(\"./autoProcess\");\r\n// default auto processor\r\n// crazy es6/cjs export mix for backward compatibility\r\n// eslint-disable-next-line no-multi-assign\r\nexports.default = exports = module.exports = autoProcess_1.sveltePreprocess;\r\n// stand-alone processors to be included manually */\r\nvar pug_1 = require(\"./processors/pug\");\r\nObject.defineProperty(exports, \"pug\", { enumerable: true, get: function () { return __importDefault(pug_1).default; } });\r\nvar coffeescript_1 = require(\"./processors/coffeescript\");\r\nObject.defineProperty(exports, \"coffeescript\", { enumerable: true, get: function () { return __importDefault(coffeescript_1).default; } });\r\nvar typescript_1 = require(\"./processors/typescript\");\r\nObject.defineProperty(exports, \"typescript\", { enumerable: true, get: function () { return __importDefault(typescript_1).default; } });\r\nvar less_1 = require(\"./processors/less\");\r\nObject.defineProperty(exports, \"less\", { enumerable: true, get: function () { return __importDefault(less_1).default; } });\r\nvar scss_1 = require(\"./processors/scss\");\r\nObject.defineProperty(exports, \"scss\", { enumerable: true, get: function () { return __importDefault(scss_1).default; } });\r\nObject.defineProperty(exports, \"sass\", { enumerable: true, get: function () { return __importDefault(scss_1).default; } });\r\nvar stylus_1 = require(\"./processors/stylus\");\r\nObject.defineProperty(exports, \"stylus\", { enumerable: true, get: function () { return __importDefault(stylus_1).default; } });\r\nvar postcss_1 = require(\"./processors/postcss\");\r\nObject.defineProperty(exports, \"postcss\", { enumerable: true, get: function () { return __importDefault(postcss_1).default; } });\r\nvar globalStyle_1 = require(\"./processors/globalStyle\");\r\nObject.defineProperty(exports, \"globalStyle\", { enumerable: true, get: function () { return __importDefault(globalStyle_1).default; } });\r\nvar babel_1 = require(\"./processors/babel\");\r\nObject.defineProperty(exports, \"babel\", { enumerable: true, get: function () { return __importDefault(babel_1).default; } });\r\nvar replace_1 = require(\"./processors/replace\");\r\nObject.defineProperty(exports, \"replace\", { enumerable: true, get: function () { return __importDefault(replace_1).default; } });\r\n"}},"modules":{"directory":{"errors.d.ts":{"file":{"contents":"export declare const throwError: (msg: string) => never;\r\nexport declare const throwTypescriptError: () => void;\r\n"}},"errors.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.throwTypescriptError = exports.throwError = void 0;\r\nconst throwError = (msg) => {\r\n    throw new Error(`[svelte-preprocess] ${msg}`);\r\n};\r\nexports.throwError = throwError;\r\nconst throwTypescriptError = () => {\r\n    (0, exports.throwError)(`Encountered type error`);\r\n};\r\nexports.throwTypescriptError = throwTypescriptError;\r\n"}},"globalifySelector.d.ts":{"file":{"contents":"export declare function globalifySelector(selector: string): string;\r\n"}},"globalifySelector.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.globalifySelector = void 0;\r\n/* eslint-disable line-comment-position */\r\n/*\r\n * Split a selector string (ex: div > foo ~ .potato) by\r\n * separators: space, >, +, ~ and comma (maybe not needed)\r\n * We use a negative lookbehind assertion to prevent matching\r\n * escaped combinators like `\\~`.\r\n */\r\n// TODO: maybe replace this ugly pattern with an actual selector parser? (https://github.com/leaverou/parsel, 2kb)\r\nconst combinatorPattern = /(?<!\\\\)(?:\\\\\\\\)*([ >+~,]\\s*)(?![^[]+\\]|\\d)/g;\r\nfunction globalifySelector(selector) {\r\n    const parts = selector.trim().split(combinatorPattern);\r\n    const newSelector = [];\r\n    for (let i = 0; i < parts.length; i++) {\r\n        const part = parts[i];\r\n        // if this is a separator or a :global\r\n        if (i % 2 !== 0 || part === '' || part.startsWith(':global')) {\r\n            newSelector.push(part);\r\n            continue;\r\n        }\r\n        // :local() with scope\r\n        if (part.startsWith(':local(')) {\r\n            newSelector.push(part.replace(/:local\\((.+?)\\)/g, '$1'));\r\n            continue;\r\n        }\r\n        // :local inlined in a selector\r\n        if (part.startsWith(':local')) {\r\n            // + 2 to ignore the :local and space combinator\r\n            const startIndex = i + 2;\r\n            let endIndex = parts.findIndex((p, idx) => idx > startIndex && p.startsWith(':global'));\r\n            endIndex = endIndex === -1 ? parts.length - 1 : endIndex;\r\n            newSelector.push(...parts.slice(startIndex, endIndex + 1));\r\n            i = endIndex;\r\n            continue;\r\n        }\r\n        newSelector.push(`:global(${part})`);\r\n    }\r\n    return newSelector.join('');\r\n}\r\nexports.globalifySelector = globalifySelector;\r\n"}},"language.d.ts":{"file":{"contents":"import type { PreprocessorArgs } from '../types';\r\nexport declare const ALIAS_MAP: Map<string, string>;\r\nexport declare const SOURCE_MAP_PROP_MAP: Record<string, [string[], any]>;\r\nexport declare function getLanguageDefaults(lang?: string | null): null | Record<string, any>;\r\nexport declare function addLanguageAlias(entries: Array<[string, string]>): void;\r\nexport declare function getLanguageFromAlias(alias?: string | null): string | null | undefined;\r\nexport declare function isAliasOf(alias?: string | null, lang?: string | null): boolean;\r\nexport declare const getLanguage: (attributes: PreprocessorArgs['attributes']) => {\r\n    lang: string | null | undefined;\r\n    alias: string | null;\r\n};\r\n"}},"language.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getLanguage = exports.isAliasOf = exports.getLanguageFromAlias = exports.addLanguageAlias = exports.getLanguageDefaults = exports.SOURCE_MAP_PROP_MAP = exports.ALIAS_MAP = void 0;\r\nconst path_1 = require(\"path\");\r\nconst utils_1 = require(\"./utils\");\r\nconst LANGUAGE_DEFAULTS = {\r\n    sass: {\r\n        indentedSyntax: true,\r\n        stripIndent: true,\r\n    },\r\n    pug: {\r\n        stripIndent: true,\r\n    },\r\n    coffeescript: {\r\n        stripIndent: true,\r\n    },\r\n    stylus: {\r\n        stripIndent: true,\r\n    },\r\n    // We need to defer this require to make sugarss an optional dependency.\r\n    sugarss: () => ({\r\n        stripIndent: true,\r\n        // eslint-disable-next-line @typescript-eslint/no-require-imports, node/global-require\r\n        parser: require('sugarss'),\r\n    }),\r\n};\r\nexports.ALIAS_MAP = new Map([\r\n    ['pcss', 'css'],\r\n    ['postcss', 'css'],\r\n    ['sugarss', 'css'],\r\n    ['sss', 'css'],\r\n    ['sass', 'scss'],\r\n    ['styl', 'stylus'],\r\n    ['js', 'javascript'],\r\n    ['coffee', 'coffeescript'],\r\n    ['ts', 'typescript'],\r\n]);\r\nexports.SOURCE_MAP_PROP_MAP = {\r\n    babel: [['sourceMaps'], true],\r\n    typescript: [['compilerOptions', 'sourceMap'], true],\r\n    scss: [['sourceMap'], true],\r\n    less: [['sourceMap'], {}],\r\n    stylus: [['sourcemap'], true],\r\n    postcss: [['map'], true],\r\n    coffeescript: [['sourceMap'], true],\r\n    globalStyle: [['sourceMap'], true],\r\n};\r\nfunction getLanguageDefaults(lang) {\r\n    if (lang == null)\r\n        return null;\r\n    const defaults = LANGUAGE_DEFAULTS[lang];\r\n    if (!defaults)\r\n        return null;\r\n    if (typeof defaults === 'function') {\r\n        return defaults();\r\n    }\r\n    return defaults;\r\n}\r\nexports.getLanguageDefaults = getLanguageDefaults;\r\nfunction addLanguageAlias(entries) {\r\n    return entries.forEach((entry) => exports.ALIAS_MAP.set(...entry));\r\n}\r\nexports.addLanguageAlias = addLanguageAlias;\r\nfunction getLanguageFromAlias(alias) {\r\n    var _a;\r\n    return alias == null ? alias : (_a = exports.ALIAS_MAP.get(alias)) !== null && _a !== void 0 ? _a : alias;\r\n}\r\nexports.getLanguageFromAlias = getLanguageFromAlias;\r\nfunction isAliasOf(alias, lang) {\r\n    return lang !== alias && getLanguageFromAlias(alias) === lang;\r\n}\r\nexports.isAliasOf = isAliasOf;\r\nconst getLanguage = (attributes) => {\r\n    let alias = null;\r\n    if (attributes.lang) {\r\n        // istanbul ignore if\r\n        if (typeof attributes.lang !== 'string') {\r\n            throw new Error('lang attribute must be string');\r\n        }\r\n        alias = attributes.lang;\r\n    }\r\n    else if (typeof attributes.src === 'string' &&\r\n        (0, utils_1.isValidLocalPath)(attributes.src)) {\r\n        const parts = (0, path_1.basename)(attributes.src).split('.');\r\n        if (parts.length > 1) {\r\n            alias = parts.pop();\r\n        }\r\n    }\r\n    return {\r\n        lang: getLanguageFromAlias(alias),\r\n        alias,\r\n    };\r\n};\r\nexports.getLanguage = getLanguage;\r\n"}},"markup.d.ts":{"file":{"contents":"import type { Transformer, Preprocessor } from '../types';\r\n/** Create a tag matching regexp. */\r\nexport declare function createTagRegex(tagName: string, flags?: string): RegExp;\r\n/** Strip script and style tags from markup. */\r\nexport declare function stripTags(markup: string): string;\r\n/** Transform an attribute string into a key-value object */\r\nexport declare function parseAttributes(attributesStr: string): Record<string, any>;\r\nexport declare function transformMarkup({ content, filename }: {\r\n    content: string;\r\n    filename?: string;\r\n}, transformer: Preprocessor | Transformer<unknown>, options?: Record<string, any>): Promise<import(\"../types\").Processed>;\r\n"}},"markup.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformMarkup = exports.parseAttributes = exports.stripTags = exports.createTagRegex = void 0;\r\n/** Create a tag matching regexp. */\r\nfunction createTagRegex(tagName, flags) {\r\n    return new RegExp(`/<!--[^]*?-->|<${tagName}(\\\\s[^]*?)?(?:>([^]*?)<\\\\/${tagName}>|\\\\/>)`, flags);\r\n}\r\nexports.createTagRegex = createTagRegex;\r\n/** Strip script and style tags from markup. */\r\nfunction stripTags(markup) {\r\n    return markup\r\n        .replace(createTagRegex('style', 'gi'), '')\r\n        .replace(createTagRegex('script', 'gi'), '');\r\n}\r\nexports.stripTags = stripTags;\r\n/** Transform an attribute string into a key-value object */\r\nfunction parseAttributes(attributesStr) {\r\n    return attributesStr\r\n        .split(/\\s+/)\r\n        .filter(Boolean)\r\n        .reduce((acc, attr) => {\r\n        const [name, value] = attr.split('=');\r\n        // istanbul ignore next\r\n        acc[name] = value ? value.replace(/['\"]/g, '') : true;\r\n        return acc;\r\n    }, {});\r\n}\r\nexports.parseAttributes = parseAttributes;\r\nasync function transformMarkup({ content, filename }, transformer, options = {}) {\r\n    let { markupTagName = 'template' } = options;\r\n    markupTagName = markupTagName.toLocaleLowerCase();\r\n    const markupPattern = createTagRegex(markupTagName);\r\n    const templateMatch = content.match(markupPattern);\r\n    /** If no <template> was found, run the transformer over the whole thing */\r\n    if (!templateMatch || templateMatch.index == null) {\r\n        return transformer({\r\n            content,\r\n            markup: content,\r\n            attributes: {},\r\n            filename,\r\n            options,\r\n        });\r\n    }\r\n    const [fullMatch, attributesStr = '', templateCode] = templateMatch;\r\n    const attributes = parseAttributes(attributesStr);\r\n    /** Transform the found template code */\r\n    let { code, map, dependencies } = await transformer({\r\n        content: templateCode,\r\n        markup: templateCode,\r\n        attributes,\r\n        filename,\r\n        options,\r\n    });\r\n    code =\r\n        content.slice(0, templateMatch.index) +\r\n            code +\r\n            content.slice(templateMatch.index + fullMatch.length);\r\n    return { code, map, dependencies };\r\n}\r\nexports.transformMarkup = transformMarkup;\r\n"}},"prepareContent.d.ts":{"file":{"contents":"export declare function prepareContent({ options, content, }: {\r\n    options: any;\r\n    content: string;\r\n}): string;\r\n"}},"prepareContent.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.prepareContent = void 0;\r\nconst strip_indent_1 = __importDefault(require(\"strip-indent\"));\r\n// todo: could use magig-string and generate some sourcemaps 🗺\r\nfunction prepareContent({ options, content, }) {\r\n    if (typeof options !== 'object') {\r\n        return content;\r\n    }\r\n    if (options.stripIndent) {\r\n        content = (0, strip_indent_1.default)(content);\r\n    }\r\n    if (options.prependData) {\r\n        content = `${options.prependData}\\n${content}`;\r\n    }\r\n    return content;\r\n}\r\nexports.prepareContent = prepareContent;\r\n"}},"tagInfo.d.ts":{"file":{"contents":"import type { PreprocessorArgs } from '../types';\r\nexport declare const getTagInfo: ({ attributes, filename, content, markup, }: PreprocessorArgs) => Promise<{\r\n    filename: string | undefined;\r\n    attributes: Record<string, string | boolean>;\r\n    content: string;\r\n    lang: string | null | undefined;\r\n    alias: string | null;\r\n    dependencies: string[];\r\n    markup: string;\r\n}>;\r\n"}},"tagInfo.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getTagInfo = void 0;\r\n/* eslint-disable node/prefer-promises/fs */\r\nconst fs_1 = require(\"fs\");\r\nconst path_1 = require(\"path\");\r\nconst language_1 = require(\"./language\");\r\nconst utils_1 = require(\"./utils\");\r\nconst resolveSrc = (importerFile, srcPath) => (0, path_1.resolve)((0, path_1.dirname)(importerFile), srcPath);\r\nconst getSrcContent = (file) => {\r\n    return new Promise((resolve, reject) => {\r\n        (0, fs_1.readFile)(file, (error, data) => {\r\n            // istanbul ignore if\r\n            if (error)\r\n                reject(error);\r\n            else\r\n                resolve(data.toString());\r\n        });\r\n    });\r\n};\r\nasync function doesFileExist(file) {\r\n    return new Promise((resolve) => (0, fs_1.access)(file, 0, (err) => resolve(!err)));\r\n}\r\nconst getTagInfo = async ({ attributes, filename, content, markup, }) => {\r\n    const dependencies = [];\r\n    // catches empty content and self-closing tags\r\n    const isEmptyContent = content == null || content.trim().length === 0;\r\n    /** only include src file if content of tag is empty */\r\n    if (attributes.src && isEmptyContent) {\r\n        // istanbul ignore if\r\n        if (typeof attributes.src !== 'string') {\r\n            throw new Error('src attribute must be string');\r\n        }\r\n        let path = attributes.src;\r\n        /** Only try to get local files (path starts with ./ or ../) */\r\n        if ((0, utils_1.isValidLocalPath)(path) && filename) {\r\n            path = resolveSrc(filename, path);\r\n            if (await doesFileExist(path)) {\r\n                content = await getSrcContent(path);\r\n                dependencies.push(path);\r\n            }\r\n            else {\r\n                console.warn(`[svelte-preprocess] The file  \"${path}\" was not found.`);\r\n            }\r\n        }\r\n    }\r\n    const { lang, alias } = (0, language_1.getLanguage)(attributes);\r\n    return {\r\n        filename,\r\n        attributes,\r\n        content,\r\n        lang,\r\n        alias,\r\n        dependencies,\r\n        markup,\r\n    };\r\n};\r\nexports.getTagInfo = getTagInfo;\r\n"}},"utils.d.ts":{"file":{"contents":"export declare function concat(...arrs: any[]): any[];\r\n/** Paths used by preprocessors to resolve @imports */\r\nexport declare function getIncludePaths(fromFilename?: string, base?: string[]): string[];\r\n/**\r\n * Checks if a package is installed.\r\n *\r\n * @export\r\n * @param {string} dep\r\n * @returns boolean\r\n */\r\nexport declare function hasDepInstalled(dep: string): Promise<boolean>;\r\nexport declare function isValidLocalPath(path: string): boolean;\r\nexport declare function findUp({ what, from }: {\r\n    what: string;\r\n    from: string;\r\n}): string | null;\r\nexport declare function setProp(obj: any, keyList: string[], value: any): void;\r\nexport declare const JAVASCRIPT_RESERVED_KEYWORD_SET: Set<string>;\r\n"}},"utils.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.JAVASCRIPT_RESERVED_KEYWORD_SET = exports.setProp = exports.findUp = exports.isValidLocalPath = exports.hasDepInstalled = exports.getIncludePaths = exports.concat = void 0;\r\nconst fs_1 = require(\"fs\");\r\nconst path_1 = require(\"path\");\r\nfunction concat(...arrs) {\r\n    return arrs.reduce((acc, a) => {\r\n        if (a)\r\n            return acc.concat(a);\r\n        return acc;\r\n    }, []);\r\n}\r\nexports.concat = concat;\r\n/** Paths used by preprocessors to resolve @imports */\r\nfunction getIncludePaths(fromFilename, base = []) {\r\n    if (fromFilename == null)\r\n        return [];\r\n    return [\r\n        ...new Set([...base, 'node_modules', process.cwd(), (0, path_1.dirname)(fromFilename)]),\r\n    ];\r\n}\r\nexports.getIncludePaths = getIncludePaths;\r\nconst depCheckCache = {};\r\n/**\r\n * Checks if a package is installed.\r\n *\r\n * @export\r\n * @param {string} dep\r\n * @returns boolean\r\n */\r\nasync function hasDepInstalled(dep) {\r\n    if (depCheckCache[dep] != null) {\r\n        return depCheckCache[dep];\r\n    }\r\n    let result = false;\r\n    try {\r\n        await (_a = dep, Promise.resolve().then(() => __importStar(require(_a))));\r\n        result = true;\r\n    }\r\n    catch (e) {\r\n        result = false;\r\n    }\r\n    return (depCheckCache[dep] = result);\r\n}\r\nexports.hasDepInstalled = hasDepInstalled;\r\nfunction isValidLocalPath(path) {\r\n    return path.startsWith('.');\r\n}\r\nexports.isValidLocalPath = isValidLocalPath;\r\n// finds a existing path up the tree\r\nfunction findUp({ what, from }) {\r\n    const { root, dir } = (0, path_1.parse)(from);\r\n    let cur = dir;\r\n    try {\r\n        while (cur !== root) {\r\n            const possiblePath = (0, path_1.join)(cur, what);\r\n            if ((0, fs_1.existsSync)(possiblePath)) {\r\n                return possiblePath;\r\n            }\r\n            cur = (0, path_1.dirname)(cur);\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n    return null;\r\n}\r\nexports.findUp = findUp;\r\n// set deep property in object\r\nfunction setProp(obj, keyList, value) {\r\n    let i = 0;\r\n    for (; i < keyList.length - 1; i++) {\r\n        const key = keyList[i];\r\n        if (typeof obj[key] !== 'object') {\r\n            obj[key] = {};\r\n        }\r\n        obj = obj[key];\r\n    }\r\n    obj[keyList[i]] = value;\r\n}\r\nexports.setProp = setProp;\r\nexports.JAVASCRIPT_RESERVED_KEYWORD_SET = new Set([\r\n    'arguments',\r\n    'await',\r\n    'break',\r\n    'case',\r\n    'catch',\r\n    'class',\r\n    'const',\r\n    'continue',\r\n    'debugger',\r\n    'default',\r\n    'delete',\r\n    'do',\r\n    'else',\r\n    'enum',\r\n    'eval',\r\n    'export',\r\n    'extends',\r\n    'false',\r\n    'finally',\r\n    'for',\r\n    'function',\r\n    'if',\r\n    'implements',\r\n    'import',\r\n    'in',\r\n    'instanceof',\r\n    'interface',\r\n    'let',\r\n    'new',\r\n    'null',\r\n    'package',\r\n    'private',\r\n    'protected',\r\n    'public',\r\n    'return',\r\n    'static',\r\n    'super',\r\n    'switch',\r\n    'this',\r\n    'throw',\r\n    'true',\r\n    'try',\r\n    'typeof',\r\n    'var',\r\n    'void',\r\n    'while',\r\n    'with',\r\n    'yield',\r\n]);\r\n"}}}},"processors":{"directory":{"babel.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\ndeclare const _default: (options?: Options.Babel) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"babel.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async script(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/babel')));\r\n        let { content, filename, dependencies, attributes } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        content = (0, prepareContent_1.prepareContent)({ options, content });\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"coffeescript.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\ndeclare const _default: (options?: Options.Coffeescript) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"coffeescript.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async script(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/coffeescript')));\r\n        let { content, filename, attributes, lang, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (lang !== 'coffeescript') {\r\n            return { code: content };\r\n        }\r\n        content = (0, prepareContent_1.prepareContent)({\r\n            options: {\r\n                ...options,\r\n                stripIndent: true,\r\n            },\r\n            content,\r\n        });\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"globalStyle.d.ts":{"file":{"contents":"import type { PreprocessorGroup } from '../types';\r\ndeclare const _default: () => PreprocessorGroup;\r\nexport default _default;\r\n"}},"globalStyle.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = () => {\r\n    return {\r\n        async style({ content, attributes, filename }) {\r\n            const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/globalStyle')));\r\n            if (!attributes.global) {\r\n                return { code: content };\r\n            }\r\n            return transformer({ content, filename, attributes });\r\n        },\r\n    };\r\n};\r\n"}},"less.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\ndeclare const _default: (options?: Options.Less) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"less.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async style(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/less')));\r\n        let { content, filename, attributes, lang, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (lang !== 'less') {\r\n            return { code: content };\r\n        }\r\n        content = (0, prepareContent_1.prepareContent)({ options, content });\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"postcss.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\n/** Adapted from https://github.com/TehShrike/svelte-preprocess-postcss */\r\ndeclare const _default: (options?: Options.Postcss) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"postcss.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\n/** Adapted from https://github.com/TehShrike/svelte-preprocess-postcss */\r\nexports.default = (options) => ({\r\n    async style(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/postcss')));\r\n        let { content, filename, attributes, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        content = (0, prepareContent_1.prepareContent)({ options, content });\r\n        /** If manually passed a plugins array, use it as the postcss config */\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"pug.d.ts":{"file":{"contents":"import type { Options, PreprocessorGroup } from '../types/index';\r\ndeclare const _default: (options?: Options.Pug) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"pug.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nconst markup_1 = require(\"../modules/markup\");\r\nexports.default = (options) => ({\r\n    async markup({ content, filename }) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/pug')));\r\n        content = (0, prepareContent_1.prepareContent)({\r\n            options: {\r\n                ...options,\r\n                stripIndent: true,\r\n            },\r\n            content,\r\n        });\r\n        return (0, markup_1.transformMarkup)({ content, filename }, transformer, options);\r\n    },\r\n});\r\n"}},"replace.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\ndeclare const _default: (options: Options.Replace) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"replace.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = (options) => ({\r\n    async markup({ content, filename }) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/replace')));\r\n        return transformer({ content, filename, options });\r\n    },\r\n});\r\n"}},"scss.d.ts":{"file":{"contents":"import type { PreprocessorGroup, Options } from '../types';\r\ndeclare const _default: (options?: Options.Sass) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"scss.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async style(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/scss')));\r\n        let { content, filename, attributes, lang, alias, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (alias === 'sass') {\r\n            options = {\r\n                ...options,\r\n                stripIndent: true,\r\n                indentedSyntax: true,\r\n            };\r\n        }\r\n        if (lang !== 'scss') {\r\n            return { code: content };\r\n        }\r\n        content = (0, prepareContent_1.prepareContent)({ options, content });\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"stylus.d.ts":{"file":{"contents":"import type { Options, PreprocessorGroup } from '../types';\r\ndeclare const _default: (options?: Options.Stylus) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"stylus.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async style(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/stylus')));\r\n        let { content, filename, attributes, lang, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (lang !== 'stylus') {\r\n            return { code: content };\r\n        }\r\n        content = (0, prepareContent_1.prepareContent)({\r\n            options: {\r\n                ...options,\r\n                stripIndent: true,\r\n            },\r\n            content,\r\n        });\r\n        const transformed = await transformer({\r\n            content,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}},"typescript.d.ts":{"file":{"contents":"import type { Options, PreprocessorGroup } from '../types';\r\ndeclare const _default: (options?: Options.Typescript) => PreprocessorGroup;\r\nexport default _default;\r\n"}},"typescript.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tagInfo_1 = require(\"../modules/tagInfo\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst prepareContent_1 = require(\"../modules/prepareContent\");\r\nexports.default = (options) => ({\r\n    async script(svelteFile) {\r\n        const { transformer } = await Promise.resolve().then(() => __importStar(require('../transformers/typescript')));\r\n        let { content, markup, filename, attributes, lang, dependencies } = await (0, tagInfo_1.getTagInfo)(svelteFile);\r\n        if (lang !== 'typescript') {\r\n            return { code: content };\r\n        }\r\n        content = (0, prepareContent_1.prepareContent)({ options, content });\r\n        const transformed = await transformer({\r\n            content,\r\n            markup,\r\n            filename,\r\n            attributes,\r\n            options,\r\n        });\r\n        return {\r\n            ...transformed,\r\n            dependencies: (0, utils_1.concat)(dependencies, transformed.dependencies),\r\n        };\r\n    },\r\n});\r\n"}}}},"transformers":{"directory":{"babel.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Babel>;\r\nexport { transformer };\r\n"}},"babel.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst core_1 = require(\"@babel/core\");\r\nconst transformer = async ({ content, filename, options, map = undefined, }) => {\r\n    const babelOptions = {\r\n        ...options,\r\n        inputSourceMap: typeof map === 'string' ? JSON.parse(map) : map !== null && map !== void 0 ? map : undefined,\r\n        sourceType: 'module',\r\n        // istanbul ignore next\r\n        sourceMaps: !!(options === null || options === void 0 ? void 0 : options.sourceMaps),\r\n        filename,\r\n        minified: false,\r\n        ast: false,\r\n        code: true,\r\n        caller: {\r\n            name: 'svelte-preprocess',\r\n            supportsStaticESM: true,\r\n            supportsDynamicImport: true,\r\n            // this isn't supported by Svelte but let it error with a good error on this syntax untouched\r\n            supportsTopLevelAwait: true,\r\n            // todo: this can be enabled once all \"peer deps\" understand this\r\n            // this syntax is supported since rollup@1.26.0 and webpack@5.0.0-beta.21\r\n            // supportsExportNamespaceFrom: true,\r\n            ...options === null || options === void 0 ? void 0 : options.caller,\r\n        },\r\n    };\r\n    const result = await (0, core_1.transformAsync)(content, babelOptions);\r\n    if (result == null) {\r\n        return { code: content };\r\n    }\r\n    const { code, map: sourcemap } = result;\r\n    return {\r\n        code: code,\r\n        map: sourcemap !== null && sourcemap !== void 0 ? sourcemap : undefined,\r\n    };\r\n};\r\nexports.transformer = transformer;\r\n"}},"coffeescript.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Coffeescript>;\r\nexport { transformer };\r\n"}},"coffeescript.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst coffeescript_1 = __importDefault(require(\"coffeescript\"));\r\nconst transformer = ({ content, filename, options, }) => {\r\n    const coffeeOptions = {\r\n        filename,\r\n        /*\r\n         * Since `coffeescript` transpiles variables to `var` definitions, it uses a safety mechanism to prevent variables from bleeding to outside contexts. This mechanism consists of wrapping your `coffeescript` code inside an IIFE which, unfortunately, prevents `svelte` from finding your variables. To bypass this behavior, `svelte-preprocess` sets the [`bare` coffeescript compiler option](https://coffeescript.org/#lexical-scope) to `true`.\r\n         */\r\n        bare: true,\r\n        ...options,\r\n    };\r\n    if (coffeeOptions.sourceMap) {\r\n        const { js: code, v3SourceMap } = coffeescript_1.default.compile(content, coffeeOptions);\r\n        const map = JSON.parse(v3SourceMap);\r\n        return { code, map };\r\n    }\r\n    return { code: coffeescript_1.default.compile(content, coffeeOptions) };\r\n};\r\nexports.transformer = transformer;\r\n"}},"globalStyle.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.GlobalStyle>;\r\nexport { transformer };\r\n"}},"globalStyle.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst postcss_1 = __importDefault(require(\"postcss\"));\r\nconst globalifySelector_1 = require(\"../modules/globalifySelector\");\r\nconst selectorPattern = /:global(?!\\()/;\r\nconst globalifyRulePlugin = (root) => {\r\n    root.walkRules(selectorPattern, (rule) => {\r\n        var _a;\r\n        const modifiedSelectors = rule.selectors\r\n            .filter((selector) => selector !== ':global')\r\n            .map((selector) => {\r\n            const [beginning, ...rest] = selector.split(selectorPattern);\r\n            if (rest.length === 0)\r\n                return beginning;\r\n            return [beginning, ...rest.map(globalifySelector_1.globalifySelector)]\r\n                .map((str) => str.trim())\r\n                .join(' ')\r\n                .trim();\r\n        });\r\n        if (modifiedSelectors.length === 0) {\r\n            if (((_a = rule.parent) === null || _a === void 0 ? void 0 : _a.type) === 'atrule' && rule.selector === ':global') {\r\n                rule.replaceWith(...rule.nodes);\r\n            }\r\n            else {\r\n                rule.remove();\r\n            }\r\n            return;\r\n        }\r\n        rule.replaceWith(rule.clone({\r\n            selectors: modifiedSelectors,\r\n        }));\r\n    });\r\n};\r\nconst globalAttrPlugin = (root) => {\r\n    root.walkAtRules(/keyframes$/, (atrule) => {\r\n        if (!atrule.params.startsWith('-global-')) {\r\n            atrule.replaceWith(atrule.clone({\r\n                params: `-global-${atrule.params}`,\r\n            }));\r\n        }\r\n    });\r\n    root.walkRules((rule) => {\r\n        var _a, _b;\r\n        // we use endsWith for checking @keyframes and prefixed @-{prefix}-keyframes\r\n        if ((_b = (_a = rule === null || rule === void 0 ? void 0 : rule.parent) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.endsWith('keyframes')) {\r\n            return;\r\n        }\r\n        rule.replaceWith(rule.clone({\r\n            selectors: rule.selectors.map(globalifySelector_1.globalifySelector),\r\n        }));\r\n    });\r\n};\r\nconst transformer = async ({ content, filename, options, map, attributes, }) => {\r\n    const plugins = [\r\n        globalifyRulePlugin,\r\n        (attributes === null || attributes === void 0 ? void 0 : attributes.global) && globalAttrPlugin,\r\n    ].filter(Boolean);\r\n    const { css, map: newMap } = await (0, postcss_1.default)(plugins).process(content, {\r\n        from: filename,\r\n        to: filename,\r\n        map: (options === null || options === void 0 ? void 0 : options.sourceMap) ? { prev: map } : false,\r\n    });\r\n    return { code: css, map: newMap };\r\n};\r\nexports.transformer = transformer;\r\n"}},"less.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Less>;\r\nexport { transformer };\r\n"}},"less.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst path_1 = require(\"path\");\r\nconst less_1 = __importDefault(require(\"less\"));\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst transformer = async ({ content, filename, options = {}, }) => {\r\n    options = {\r\n        paths: (0, utils_1.getIncludePaths)(filename, options.paths),\r\n        ...options,\r\n    };\r\n    const { css, map, imports } = await less_1.default.render(content, {\r\n        sourceMap: {},\r\n        filename,\r\n        ...options,\r\n    });\r\n    const dependencies = imports.map((path) => (0, path_1.isAbsolute)(path) ? path : (0, path_1.join)(process.cwd(), path));\r\n    return {\r\n        code: css,\r\n        map,\r\n        dependencies,\r\n    };\r\n};\r\nexports.transformer = transformer;\r\n"}},"postcss.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\n/** Adapted from https://github.com/TehShrike/svelte-preprocess-postcss */\r\ndeclare const transformer: Transformer<Options.Postcss>;\r\nexport { transformer };\r\n"}},"postcss.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst postcss_1 = __importDefault(require(\"postcss\"));\r\nasync function process({ options: { plugins = [], parser, syntax } = {}, content, filename, sourceMap, }) {\r\n    const { css, map, messages } = await (0, postcss_1.default)(plugins).process(content, {\r\n        from: filename,\r\n        to: filename,\r\n        map: { prev: sourceMap, inline: false },\r\n        parser,\r\n        syntax,\r\n    });\r\n    const dependencies = messages.reduce((acc, msg) => {\r\n        // istanbul ignore if\r\n        if (msg.type !== 'dependency')\r\n            return acc;\r\n        acc.push(msg.file);\r\n        return acc;\r\n    }, []);\r\n    return { code: css, map, dependencies };\r\n}\r\nasync function getConfigFromFile(options) {\r\n    try {\r\n        /** If not, look for a postcss config file */\r\n        const { default: postcssLoadConfig } = await Promise.resolve().then(() => __importStar(require(`postcss-load-config`)));\r\n        const loadedConfig = await postcssLoadConfig(options, options === null || options === void 0 ? void 0 : options.configFilePath);\r\n        return {\r\n            error: null,\r\n            config: {\r\n                plugins: loadedConfig.plugins,\r\n                // `postcss-load-config` puts all other props in a `options` object\r\n                ...loadedConfig.options,\r\n            },\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            config: null,\r\n            error: e,\r\n        };\r\n    }\r\n}\r\n/** Adapted from https://github.com/TehShrike/svelte-preprocess-postcss */\r\nconst transformer = async ({ content, filename, options = {}, map, }) => {\r\n    let fileConfig = null;\r\n    if (!options.plugins) {\r\n        fileConfig = await getConfigFromFile(options);\r\n        options = { ...options, ...fileConfig.config };\r\n    }\r\n    if (options.plugins || options.syntax || options.parser) {\r\n        return process({ options, content, filename, sourceMap: map });\r\n    }\r\n    if ((fileConfig === null || fileConfig === void 0 ? void 0 : fileConfig.error) != null) {\r\n        console.error(`[svelte-preprocess] PostCSS configuration was not passed or is invalid. If you expect to load it from a file make sure to install \"postcss-load-config\" and try again.\\n\\n${fileConfig.error}`);\r\n    }\r\n    return { code: content, map, dependencies: [] };\r\n};\r\nexports.transformer = transformer;\r\n"}},"pug.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Pug>;\r\nexport { transformer };\r\n"}},"pug.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst detect_indent_1 = __importDefault(require(\"detect-indent\"));\r\nconst pug_1 = __importDefault(require(\"pug\"));\r\n// Mixins to use svelte template features\r\nconst GET_MIXINS = (identationType) => `mixin if(condition)\r\n%_| {#if !{condition}}\r\n%_block\r\n%_| {/if}\r\n\r\nmixin else\r\n%_| {:else}\r\n%_block\r\n\r\nmixin elseif(condition)\r\n%_| {:else if !{condition}}\r\n%_block\r\n\r\nmixin key(expression)\r\n%_| {#key !{expression}}\r\n%_block\r\n%_| {/key}\r\n\r\nmixin each(loop)\r\n%_| {#each !{loop}}\r\n%_block\r\n%_| {/each}\r\n\r\nmixin await(promise)\r\n%_| {#await !{promise}}\r\n%_block\r\n%_| {/await}\r\n\r\nmixin then(answer)\r\n%_| {:then !{answer}}\r\n%_block\r\n\r\nmixin catch(error)\r\n%_| {:catch !{error}}\r\n%_block\r\n\r\nmixin html(expression)\r\n%_| {@html !{expression}}\r\n\r\nmixin const(expression)\r\n%_| {@const !{expression}}\r\n\r\nmixin debug(variables)\r\n%_| {@debug !{variables}}`.replace(/%_/g, identationType === 'tab' ? '\\t' : '  ');\r\nconst transformer = async ({ content, filename, options, }) => {\r\n    var _a;\r\n    const pugOptions = {\r\n        // needed so pug doesn't mirror boolean attributes\r\n        // and prop spreading expressions.\r\n        doctype: 'html',\r\n        compileDebug: false,\r\n        filename,\r\n        ...options,\r\n    };\r\n    const { type: identationType } = (0, detect_indent_1.default)(content);\r\n    const input = `${GET_MIXINS(identationType !== null && identationType !== void 0 ? identationType : 'space')}\\n${content}`;\r\n    const compiled = pug_1.default.compile(input, pugOptions);\r\n    let code;\r\n    try {\r\n        code = compiled();\r\n    }\r\n    catch (e) {\r\n        // The error message does not have much context, add more of it\r\n        if (e instanceof Error) {\r\n            e.message = `[svelte-preprocess] Pug error while preprocessing ${filename}\\n\\n${e.message}`;\r\n        }\r\n        throw e;\r\n    }\r\n    return {\r\n        code,\r\n        dependencies: (_a = compiled.dependencies) !== null && _a !== void 0 ? _a : [],\r\n    };\r\n};\r\nexports.transformer = transformer;\r\n"}},"replace.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Replace>;\r\nexport { transformer };\r\n"}},"replace.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst transformer = async ({ content, options, }) => {\r\n    let newContent = content;\r\n    if (options == null) {\r\n        return { code: content };\r\n    }\r\n    for (const [regex, replacer] of options) {\r\n        newContent = newContent.replace(regex, replacer);\r\n    }\r\n    return {\r\n        code: newContent,\r\n    };\r\n};\r\nexports.transformer = transformer;\r\n"}},"scss.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Sass>;\r\nexport { transformer };\r\n"}},"scss.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst fs_1 = require(\"fs\");\r\nconst path_1 = require(\"path\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst tildeImporter = (url, prev) => {\r\n    if (!url.startsWith('~')) {\r\n        return null;\r\n    }\r\n    // not sure why this ends up here, but let's remove it\r\n    prev = prev.replace('http://localhost', '');\r\n    // on windows, path comes encoded\r\n    if (process.platform === 'win32') {\r\n        prev = decodeURIComponent(prev);\r\n    }\r\n    const modulePath = (0, path_1.join)('node_modules', ...url.slice(1).split(/[\\\\/]/g));\r\n    const foundPath = (0, utils_1.findUp)({ what: modulePath, from: prev });\r\n    // istanbul ignore if\r\n    if (foundPath == null) {\r\n        return null;\r\n    }\r\n    const contents = (0, fs_1.readFileSync)(foundPath).toString();\r\n    return { contents };\r\n};\r\nconst transformer = async ({ content, filename, options = {}, }) => {\r\n    var _a;\r\n    const { renderSync } = await Promise.resolve().then(() => __importStar(require('sass')));\r\n    const { prependData, ...restOptions } = options;\r\n    const sassOptions = {\r\n        ...restOptions,\r\n        includePaths: (0, utils_1.getIncludePaths)(filename, options.includePaths),\r\n        sourceMap: true,\r\n        sourceMapEmbed: false,\r\n        omitSourceMapUrl: true,\r\n        outFile: `${filename}.css`,\r\n        outputStyle: 'expanded',\r\n        file: filename,\r\n        data: content,\r\n    };\r\n    if (Array.isArray(sassOptions.importer)) {\r\n        sassOptions.importer = [tildeImporter, ...sassOptions.importer];\r\n    }\r\n    else if (sassOptions.importer == null) {\r\n        sassOptions.importer = [tildeImporter];\r\n    }\r\n    else {\r\n        sassOptions.importer = [sassOptions.importer, tildeImporter];\r\n    }\r\n    // scss errors if passed an empty string\r\n    if (content.length === 0) {\r\n        return { code: '' };\r\n    }\r\n    const compiled = renderSync(sassOptions);\r\n    // For some reason, scss includes the main 'file' in the array, we don't want that\r\n    // Unfortunately I didn't manage to reproduce this in the test env\r\n    // More info: https://github.com/sveltejs/svelte-preprocess/issues/346\r\n    const absoluteEntryPath = (0, path_1.isAbsolute)(compiled.stats.entry)\r\n        ? compiled.stats.entry\r\n        : (0, path_1.join)(process.cwd(), compiled.stats.entry);\r\n    const processed = {\r\n        code: compiled.css.toString(),\r\n        map: (_a = compiled.map) === null || _a === void 0 ? void 0 : _a.toString(),\r\n        dependencies: Array.from(compiled.stats.includedFiles).filter((filepath) => filepath !== absoluteEntryPath),\r\n    };\r\n    return processed;\r\n};\r\nexports.transformer = transformer;\r\n"}},"stylus.d.ts":{"file":{"contents":"import type { Transformer, Options } from '../types';\r\ndeclare const transformer: Transformer<Options.Stylus>;\r\nexport { transformer };\r\n"}},"stylus.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = void 0;\r\nconst path_1 = __importDefault(require(\"path\"));\r\nconst stylus_1 = __importDefault(require(\"stylus\"));\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst transformer = ({ content, filename, options = {}, }) => {\r\n    options = {\r\n        paths: (0, utils_1.getIncludePaths)(filename, options.paths),\r\n        ...options,\r\n    };\r\n    return new Promise((resolve, reject) => {\r\n        const style = (0, stylus_1.default)(content, {\r\n            filename,\r\n            ...options,\r\n        }).set('sourcemap', options.sourcemap);\r\n        style.render((err, css) => {\r\n            var _a;\r\n            // istanbul ignore next\r\n            if (err)\r\n                reject(err);\r\n            if ((_a = style.sourcemap) === null || _a === void 0 ? void 0 : _a.sources) {\r\n                style.sourcemap.sources = style.sourcemap.sources.map((source) => path_1.default.resolve(source));\r\n            }\r\n            resolve({\r\n                code: css,\r\n                map: style.sourcemap,\r\n                // .map() necessary for windows compatibility\r\n                dependencies: style\r\n                    .deps(filename)\r\n                    .map((filePath) => path_1.default.resolve(filePath)),\r\n            });\r\n        });\r\n    });\r\n};\r\nexports.transformer = transformer;\r\n"}},"typescript.d.ts":{"file":{"contents":"import ts from 'typescript';\r\nimport type { Transformer, Options } from '../types';\r\nexport declare function loadTsconfig(compilerOptionsJSON: any, filename: string, tsOptions: Options.Typescript): {\r\n    errors: never[];\r\n    options: any;\r\n} | {\r\n    errors: ts.Diagnostic[];\r\n    options: ts.CompilerOptions;\r\n};\r\ndeclare const transformer: Transformer<Options.Typescript>;\r\nexport { transformer };\r\n"}},"typescript.js":{"file":{"contents":"\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.transformer = exports.loadTsconfig = void 0;\r\nconst path_1 = require(\"path\");\r\nconst typescript_1 = __importDefault(require(\"typescript\"));\r\nconst compiler_1 = require(\"svelte/compiler\");\r\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\r\nconst sorcery_1 = require(\"sorcery\");\r\nconst errors_1 = require(\"../modules/errors\");\r\nconst markup_1 = require(\"../modules/markup\");\r\nconst utils_1 = require(\"../modules/utils\");\r\nconst package_json_1 = __importDefault(require(\"svelte/package.json\"));\r\nconst injectedCodeSeparator = 'const $$$$$$$$ = null;';\r\n/**\r\n * Map of valid tsconfigs (no errors). Key is the path.\r\n */\r\nconst tsconfigMap = new Map();\r\nfunction createFormatDiagnosticsHost(cwd) {\r\n    return {\r\n        getCanonicalFileName: (fileName) => fileName.replace('.injected.ts', ''),\r\n        getCurrentDirectory: () => cwd,\r\n        getNewLine: () => typescript_1.default.sys.newLine,\r\n    };\r\n}\r\nfunction formatDiagnostics(diagnostics, basePath) {\r\n    if (Array.isArray(diagnostics)) {\r\n        return typescript_1.default.formatDiagnosticsWithColorAndContext(diagnostics, createFormatDiagnosticsHost(basePath));\r\n    }\r\n    return typescript_1.default.formatDiagnostic(diagnostics, createFormatDiagnosticsHost(basePath));\r\n}\r\nconst importTransformer = (context) => {\r\n    const visit = (node) => {\r\n        var _a;\r\n        if (typescript_1.default.isImportDeclaration(node)) {\r\n            if ((_a = node.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly) {\r\n                return typescript_1.default.createEmptyStatement();\r\n            }\r\n            return typescript_1.default.createImportDeclaration(node.decorators, node.modifiers, node.importClause, node.moduleSpecifier);\r\n        }\r\n        return typescript_1.default.visitEachChild(node, (child) => visit(child), context);\r\n    };\r\n    return (node) => typescript_1.default.visitNode(node, visit);\r\n};\r\nfunction getScriptContent(markup, module) {\r\n    const regex = (0, markup_1.createTagRegex)('script', 'gi');\r\n    let match;\r\n    while ((match = regex.exec(markup)) !== null) {\r\n        const { context } = (0, markup_1.parseAttributes)(match[1] || '');\r\n        if ((context !== 'module' && !module) || (context === 'module' && module)) {\r\n            return match[2];\r\n        }\r\n    }\r\n    return '';\r\n}\r\nfunction createSourceMapChain({ filename, content, compilerOptions, }) {\r\n    if (compilerOptions.sourceMap) {\r\n        return {\r\n            content: {\r\n                [filename]: content,\r\n            },\r\n            sourcemaps: {},\r\n        };\r\n    }\r\n}\r\nfunction injectVarsToCode({ content, markup, filename, attributes, sourceMapChain, }) {\r\n    if (!markup)\r\n        return content;\r\n    const { vars } = (0, compiler_1.compile)((0, markup_1.stripTags)(markup), {\r\n        generate: false,\r\n        varsReport: 'full',\r\n        errorMode: 'warn',\r\n        filename,\r\n    });\r\n    const sep = `\\n${injectedCodeSeparator}\\n`;\r\n    const varnames = vars.map((v) => v.name.startsWith('$') && !v.name.startsWith('$$')\r\n        ? `${v.name},${v.name.slice(1)}`\r\n        : v.name);\r\n    const contentForCodestores = content +\r\n        // Append instance script content because it's valid\r\n        // to import a store in module script and autosubscribe to it in instance script\r\n        ((attributes === null || attributes === void 0 ? void 0 : attributes.context) === 'module' ? getScriptContent(markup, false) : '');\r\n    // This regex extracts all possible store variables\r\n    // TODO investigate if it's possible to achieve this with a\r\n    // TS transformer (previous attemps have failed)\r\n    const codestores = Array.from(contentForCodestores.match(/\\$[^\\s();:,[\\]{}.?!+\\-=*/\\\\~|&%<>^`\"'°§#0-9][^\\s();:,[\\]{}.?!+\\-=*/\\\\~|&%<>^`\"'°§#]*/g) || [], (name) => name.slice(1)).filter((name) => !utils_1.JAVASCRIPT_RESERVED_KEYWORD_SET.has(name));\r\n    const varsString = [...codestores, ...varnames].join(',');\r\n    const injectedVars = `const $$vars$$ = [${varsString}];`;\r\n    // Append instance/markup script content because it's valid\r\n    // to import things in one and reference it in the other.\r\n    const injectedCode = (attributes === null || attributes === void 0 ? void 0 : attributes.context) === 'module'\r\n        ? `${sep}${getScriptContent(markup, false)}\\n${injectedVars}`\r\n        : `${sep}${getScriptContent(markup, true)}\\n${injectedVars}`;\r\n    if (sourceMapChain) {\r\n        const ms = new magic_string_1.default(content).append(injectedCode);\r\n        const fname = `${filename}.injected.ts`;\r\n        const code = ms.toString();\r\n        const map = ms.generateMap({\r\n            source: filename,\r\n            file: fname,\r\n            hires: true,\r\n        });\r\n        sourceMapChain.content[fname] = code;\r\n        sourceMapChain.sourcemaps[fname] = map;\r\n        return code;\r\n    }\r\n    return `${content}${injectedCode}`;\r\n}\r\nfunction stripInjectedCode({ transpiledCode, markup, filename, sourceMapChain, }) {\r\n    if (!markup)\r\n        return transpiledCode;\r\n    const injectedCodeStart = transpiledCode.indexOf(injectedCodeSeparator);\r\n    if (sourceMapChain) {\r\n        const ms = new magic_string_1.default(transpiledCode).snip(0, injectedCodeStart);\r\n        const source = `${filename}.transpiled.js`;\r\n        const file = `${filename}.js`;\r\n        const code = ms.toString();\r\n        const map = ms.generateMap({\r\n            source,\r\n            file,\r\n            hires: true,\r\n        });\r\n        sourceMapChain.content[file] = code;\r\n        sourceMapChain.sourcemaps[file] = map;\r\n        return code;\r\n    }\r\n    return transpiledCode.slice(0, injectedCodeStart);\r\n}\r\nasync function concatSourceMaps({ filename, markup, sourceMapChain, }) {\r\n    if (!sourceMapChain)\r\n        return;\r\n    if (!markup) {\r\n        return sourceMapChain.sourcemaps[`${filename}.js`];\r\n    }\r\n    const chain = await (0, sorcery_1.load)(`${filename}.js`, sourceMapChain);\r\n    return chain.apply();\r\n}\r\nfunction getCompilerOptions({ filename, options, basePath, }) {\r\n    var _a;\r\n    const inputOptions = (_a = options.compilerOptions) !== null && _a !== void 0 ? _a : {};\r\n    const { errors, options: convertedCompilerOptions } = options.tsconfigFile !== false || options.tsconfigDirectory\r\n        ? loadTsconfig(inputOptions, filename, options)\r\n        : typescript_1.default.convertCompilerOptionsFromJson(inputOptions, basePath);\r\n    if (errors.length) {\r\n        throw new Error(formatDiagnostics(errors, basePath));\r\n    }\r\n    const compilerOptions = {\r\n        target: typescript_1.default.ScriptTarget.ES2015,\r\n        moduleResolution: typescript_1.default.ModuleResolutionKind.NodeJs,\r\n        ...convertedCompilerOptions,\r\n        importsNotUsedAsValues: typescript_1.default.ImportsNotUsedAsValues.Error,\r\n        allowNonTsExtensions: true,\r\n        // Clear outDir since it causes source map issues when the files aren't actually written to disk.\r\n        outDir: undefined,\r\n    };\r\n    if (compilerOptions.target === typescript_1.default.ScriptTarget.ES3 ||\r\n        compilerOptions.target === typescript_1.default.ScriptTarget.ES5) {\r\n        throw new Error(`Svelte only supports es6+ syntax. Set your 'compilerOptions.target' to 'es6' or higher.`);\r\n    }\r\n    return compilerOptions;\r\n}\r\nfunction transpileTs({ code, fileName, basePath, options, compilerOptions, transformers, }) {\r\n    const { outputText: transpiledCode, sourceMapText, diagnostics, } = typescript_1.default.transpileModule(code, {\r\n        fileName,\r\n        compilerOptions,\r\n        reportDiagnostics: options.reportDiagnostics !== false,\r\n        transformers,\r\n    });\r\n    if (diagnostics && diagnostics.length > 0) {\r\n        // could this be handled elsewhere?\r\n        const hasError = diagnostics.some((d) => d.category === typescript_1.default.DiagnosticCategory.Error);\r\n        const formattedDiagnostics = formatDiagnostics(diagnostics, basePath);\r\n        console.log(formattedDiagnostics);\r\n        if (hasError) {\r\n            (0, errors_1.throwTypescriptError)();\r\n        }\r\n    }\r\n    return { transpiledCode, sourceMapText, diagnostics };\r\n}\r\nfunction loadTsconfig(compilerOptionsJSON, filename, tsOptions) {\r\n    if (typeof tsOptions.tsconfigFile === 'boolean') {\r\n        return { errors: [], options: compilerOptionsJSON };\r\n    }\r\n    let basePath = process.cwd();\r\n    const fileDirectory = (tsOptions.tsconfigDirectory ||\r\n        (0, path_1.dirname)(filename));\r\n    let tsconfigFile = tsOptions.tsconfigFile ||\r\n        typescript_1.default.findConfigFile(fileDirectory, typescript_1.default.sys.fileExists);\r\n    if (!tsconfigFile) {\r\n        return { errors: [], options: compilerOptionsJSON };\r\n    }\r\n    tsconfigFile = (0, path_1.isAbsolute)(tsconfigFile)\r\n        ? tsconfigFile\r\n        : (0, path_1.join)(basePath, tsconfigFile);\r\n    basePath = (0, path_1.dirname)(tsconfigFile);\r\n    if (tsconfigMap.has(tsconfigFile)) {\r\n        return {\r\n            errors: [],\r\n            options: tsconfigMap.get(tsconfigFile),\r\n        };\r\n    }\r\n    const { error, config } = typescript_1.default.readConfigFile(tsconfigFile, typescript_1.default.sys.readFile);\r\n    if (error) {\r\n        throw new Error(formatDiagnostics(error, basePath));\r\n    }\r\n    // Do this so TS will not search for initial files which might take a while\r\n    config.include = [];\r\n    let { errors, options } = typescript_1.default.parseJsonConfigFileContent(config, typescript_1.default.sys, basePath, compilerOptionsJSON, tsconfigFile);\r\n    // Filter out \"no files found error\"\r\n    errors = errors.filter((d) => d.code !== 18003);\r\n    if (errors.length === 0) {\r\n        tsconfigMap.set(tsconfigFile, options);\r\n    }\r\n    return { errors, options };\r\n}\r\nexports.loadTsconfig = loadTsconfig;\r\nasync function mixedImportsTranspiler({ content, filename = 'source.svelte', markup, options = {}, attributes, compilerOptions, basePath, }) {\r\n    const sourceMapChain = createSourceMapChain({\r\n        filename,\r\n        content,\r\n        compilerOptions,\r\n    });\r\n    const injectedCode = injectVarsToCode({\r\n        content,\r\n        markup,\r\n        filename,\r\n        attributes,\r\n        sourceMapChain,\r\n    });\r\n    const { transpiledCode, sourceMapText, diagnostics } = transpileTs({\r\n        code: injectedCode,\r\n        fileName: `${filename}.injected.ts`,\r\n        basePath,\r\n        options,\r\n        compilerOptions,\r\n    });\r\n    if (sourceMapChain && sourceMapText) {\r\n        const fname = `${filename}.transpiled.js`;\r\n        sourceMapChain.content[fname] = transpiledCode;\r\n        sourceMapChain.sourcemaps[fname] = JSON.parse(sourceMapText);\r\n    }\r\n    const code = stripInjectedCode({\r\n        transpiledCode,\r\n        markup,\r\n        filename,\r\n        sourceMapChain,\r\n    });\r\n    // Sorcery tries to load the code/map from disk if it's empty,\r\n    // prevent that because it would try to load inexistent files\r\n    // https://github.com/Rich-Harris/sorcery/issues/167\r\n    if (!code) {\r\n        return { code, diagnostics };\r\n    }\r\n    const map = await concatSourceMaps({\r\n        filename,\r\n        markup,\r\n        sourceMapChain,\r\n    });\r\n    return {\r\n        code,\r\n        map,\r\n        diagnostics,\r\n    };\r\n}\r\nasync function simpleTranspiler({ content, filename = 'source.svelte', options = {}, compilerOptions, basePath, }) {\r\n    const { transpiledCode, sourceMapText, diagnostics } = transpileTs({\r\n        code: content,\r\n        // `preserveValueImports` essentially does the same as our import transformer,\r\n        // keeping all imports that are not type imports\r\n        transformers: compilerOptions.preserveValueImports\r\n            ? undefined\r\n            : { before: [importTransformer] },\r\n        fileName: filename,\r\n        basePath,\r\n        options,\r\n        compilerOptions,\r\n    });\r\n    return {\r\n        code: transpiledCode,\r\n        map: sourceMapText,\r\n        diagnostics,\r\n    };\r\n}\r\nconst transformer = async ({ content, filename, markup, options = {}, attributes, }) => {\r\n    const basePath = process.cwd();\r\n    if (filename == null)\r\n        return { code: content };\r\n    filename = (0, path_1.isAbsolute)(filename) ? filename : (0, path_1.resolve)(basePath, filename);\r\n    const compilerOptions = getCompilerOptions({ filename, options, basePath });\r\n    const versionParts = package_json_1.default.version.split('.');\r\n    const canUseMixedImportsTranspiler = +versionParts[0] > 3 || (+versionParts[0] === 3 && +versionParts[1] >= 39);\r\n    if (!canUseMixedImportsTranspiler && options.handleMixedImports) {\r\n        throw new Error('You need at least Svelte 3.39 to use the handleMixedImports option');\r\n    }\r\n    const handleMixedImports = !compilerOptions.preserveValueImports &&\r\n        (options.handleMixedImports === false\r\n            ? false\r\n            : options.handleMixedImports || canUseMixedImportsTranspiler);\r\n    return handleMixedImports\r\n        ? mixedImportsTranspiler({\r\n            content,\r\n            filename,\r\n            markup,\r\n            options,\r\n            attributes,\r\n            compilerOptions,\r\n            basePath,\r\n        })\r\n        : simpleTranspiler({\r\n            content,\r\n            filename,\r\n            markup,\r\n            options,\r\n            attributes,\r\n            compilerOptions,\r\n            basePath,\r\n        });\r\n};\r\nexports.transformer = transformer;\r\n"}}}},"types":{"directory":{"index.d.ts":{"file":{"contents":"import * as Options from './options';\r\nimport type { Processed as SvelteProcessed, Preprocessor as SveltePreprocessor, PreprocessorGroup } from 'svelte/types/compiler/preprocess';\r\nexport { Options };\r\nexport { PreprocessorGroup } from 'svelte/types/compiler/preprocess';\r\nexport type PreprocessorArgs = Preprocessor extends (options: infer T) => any ? T : never;\r\nexport type TransformerArgs<T> = {\r\n    content: string;\r\n    filename?: string;\r\n    attributes?: Record<string, any>;\r\n    map?: string | object;\r\n    markup?: string;\r\n    dianostics?: unknown[];\r\n    options?: T;\r\n};\r\n/**\r\n * Small extension to the official SvelteProcessed type\r\n * to include possible diagnostics.\r\n * Used for the typescript transformer.\r\n */\r\nexport type Processed = SvelteProcessed & {\r\n    diagnostics?: any[];\r\n};\r\n/**\r\n * Svelte preprocessor type with guaranteed Processed results\r\n *\r\n * The official type also considers `void`\r\n * */\r\nexport type Preprocessor = (options: Parameters<SveltePreprocessor>[0]) => Processed | Promise<Processed>;\r\nexport type Transformer<T> = (args: TransformerArgs<T>) => Processed | Promise<Processed>;\r\nexport type TransformerOptions<T = any> = boolean | T | Transformer<T>;\r\nexport interface Transformers {\r\n    babel?: TransformerOptions<Options.Babel>;\r\n    typescript?: TransformerOptions<Options.Typescript>;\r\n    scss?: TransformerOptions<Options.Sass>;\r\n    sass?: TransformerOptions<Options.Sass>;\r\n    less?: TransformerOptions<Options.Less>;\r\n    stylus?: TransformerOptions<Options.Stylus>;\r\n    postcss?: TransformerOptions<Options.Postcss>;\r\n    coffeescript?: TransformerOptions<Options.Coffeescript>;\r\n    pug?: TransformerOptions<Options.Pug>;\r\n    globalStyle?: Options.GlobalStyle;\r\n    replace?: Options.Replace;\r\n    [language: string]: TransformerOptions;\r\n}\r\nexport type AutoPreprocessGroup = PreprocessorGroup;\r\nexport type AutoPreprocessOptions = {\r\n    markupTagName?: string;\r\n    aliases?: Array<[string, string]>;\r\n    preserve?: string[];\r\n    sourceMap?: boolean;\r\n    babel?: TransformerOptions<Options.Babel>;\r\n    typescript?: TransformerOptions<Options.Typescript>;\r\n    scss?: TransformerOptions<Options.Sass>;\r\n    sass?: TransformerOptions<Options.Sass>;\r\n    less?: TransformerOptions<Options.Less>;\r\n    stylus?: TransformerOptions<Options.Stylus>;\r\n    postcss?: TransformerOptions<Options.Postcss>;\r\n    coffeescript?: TransformerOptions<Options.Coffeescript>;\r\n    pug?: TransformerOptions<Options.Pug>;\r\n    globalStyle?: Options.GlobalStyle | boolean;\r\n    replace?: Options.Replace;\r\n    [languageName: string]: TransformerOptions;\r\n};\r\n"}},"index.js":{"file":{"contents":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Options = void 0;\r\nconst Options = __importStar(require(\"./options\"));\r\nexports.Options = Options;\r\n"}},"options.d.ts":{"file":{"contents":"import type { LegacyStringOptions } from 'sass';\r\nimport type * as postcss from 'postcss';\r\nimport type { Options as PugOptions } from 'pug';\r\nimport type { TransformOptions as BabelOptions } from '@babel/core';\r\ntype ContentModifier = {\r\n    prependData?: string;\r\n    stripIndent?: boolean;\r\n};\r\ntype MarkupOptions = {\r\n    markupTagName?: string;\r\n};\r\nexport type Coffeescript = {\r\n    sourceMap?: boolean;\r\n    filename?: never;\r\n    bare?: never;\r\n} & ContentModifier;\r\nexport type Postcss = postcss.ProcessOptions & {\r\n    plugins?: postcss.AcceptedPlugin[];\r\n    configFilePath?: string;\r\n} & ContentModifier;\r\nexport type Babel = BabelOptions & {\r\n    sourceType?: 'module';\r\n    minified?: false;\r\n    ast?: false;\r\n    code?: true;\r\n    sourceMaps?: boolean;\r\n} & ContentModifier;\r\nexport type Pug = Omit<PugOptions, 'filename' | 'doctype' | 'compileDebug'> & ContentModifier & MarkupOptions;\r\nexport type Sass = Omit<LegacyStringOptions<'sync'>, 'file' | 'data'> & ContentModifier;\r\nexport type Less = {\r\n    paths?: string[];\r\n    plugins?: any[];\r\n    strictImports?: boolean;\r\n    maxLineLen?: number;\r\n    dumpLineNumbers?: 'comment' | string;\r\n    silent?: boolean;\r\n    strictUnits?: boolean;\r\n    globalVars?: Record<string, string>;\r\n    modifyVars?: Record<string, string>;\r\n} & ContentModifier;\r\nexport type Stylus = {\r\n    globals?: Record<string, any>;\r\n    functions?: Record<string, any>;\r\n    imports?: string[];\r\n    paths?: string[];\r\n    sourcemap?: boolean;\r\n} & ContentModifier;\r\nexport type Typescript = {\r\n    compilerOptions?: any;\r\n    tsconfigFile?: string | boolean;\r\n    tsconfigDirectory?: string | boolean;\r\n    reportDiagnostics?: boolean;\r\n    handleMixedImports?: boolean;\r\n} & ContentModifier;\r\nexport interface GlobalStyle {\r\n    sourceMap: boolean;\r\n}\r\nexport type Replace = Array<[string | RegExp, string] | [RegExp, (substring: string, ...args: any[]) => string]>;\r\nexport {};\r\n"}},"options.js":{"file":{"contents":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"}}}}}},"LICENSE":{"file":{"contents":"Copyright (c) 2016-20 [these people](https://github.com/sveltejs/svelte-preprocess/graphs/contributors)\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n"}},"node_modules":{"directory":{"magic-string":{"directory":{"dist":{"directory":{"magic-string.cjs.js":{"file":{"contents":"'use strict';\n\nvar sourcemapCodec = require('@jridgewell/sourcemap-codec');\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa () {\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = sourcemapCodec.encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;\n//# sourceMappingURL=magic-string.cjs.js.map\n"}},"magic-string.cjs.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.cjs.js\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\",\"../src/index-legacy.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport Bundle from './Bundle.js';\\nimport SourceMap from './SourceMap.js';\\n\\nMagicString.Bundle = Bundle;\\nMagicString.SourceMap = SourceMap;\\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\\n\\nexport default MagicString;\\n\"],\"names\":[\"encode\"],\"mappings\":\"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\"}"}},"magic-string.es.mjs":{"file":{"contents":"import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa () {\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n"}},"magic-string.es.mjs.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.es.mjs\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}"}},"magic-string.umd.js":{"file":{"contents":"(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());\n})(this, (function () { 'use strict';\n\n\tclass BitSet {\n\t\tconstructor(arg) {\n\t\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t\t}\n\n\t\tadd(n) {\n\t\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t\t}\n\n\t\thas(n) {\n\t\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t\t}\n\t}\n\n\tclass Chunk {\n\t\tconstructor(start, end, content) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t\tthis.original = content;\n\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\n\t\t\tthis.content = content;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\n\t\t\t{\n\t\t\t\tthis.previous = null;\n\t\t\t\tthis.next = null;\n\t\t\t}\n\t\t}\n\n\t\tappendLeft(content) {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tappendRight(content) {\n\t\t\tthis.intro = this.intro + content;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\t\tchunk.intro = this.intro;\n\t\t\tchunk.outro = this.outro;\n\t\t\tchunk.content = this.content;\n\t\t\tchunk.storeName = this.storeName;\n\t\t\tchunk.edited = this.edited;\n\n\t\t\treturn chunk;\n\t\t}\n\n\t\tcontains(index) {\n\t\t\treturn this.start < index && index < this.end;\n\t\t}\n\n\t\teachNext(fn) {\n\t\t\tlet chunk = this;\n\t\t\twhile (chunk) {\n\t\t\t\tfn(chunk);\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\t\t}\n\n\t\teachPrevious(fn) {\n\t\t\tlet chunk = this;\n\t\t\twhile (chunk) {\n\t\t\t\tfn(chunk);\n\t\t\t\tchunk = chunk.previous;\n\t\t\t}\n\t\t}\n\n\t\tedit(content, storeName, contentOnly) {\n\t\t\tthis.content = content;\n\t\t\tif (!contentOnly) {\n\t\t\t\tthis.intro = '';\n\t\t\t\tthis.outro = '';\n\t\t\t}\n\t\t\tthis.storeName = storeName;\n\n\t\t\tthis.edited = true;\n\n\t\t\treturn this;\n\t\t}\n\n\t\tprependLeft(content) {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tprependRight(content) {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tsplit(index) {\n\t\t\tconst sliceIndex = index - this.start;\n\n\t\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\t\tthis.original = originalBefore;\n\n\t\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\t\tnewChunk.outro = this.outro;\n\t\t\tthis.outro = '';\n\n\t\t\tthis.end = index;\n\n\t\t\tif (this.edited) {\n\t\t\t\t// TODO is this block necessary?...\n\t\t\t\tnewChunk.edit('', false);\n\t\t\t\tthis.content = '';\n\t\t\t} else {\n\t\t\t\tthis.content = originalBefore;\n\t\t\t}\n\n\t\t\tnewChunk.next = this.next;\n\t\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\t\tnewChunk.previous = this;\n\t\t\tthis.next = newChunk;\n\n\t\t\treturn newChunk;\n\t\t}\n\n\t\ttoString() {\n\t\t\treturn this.intro + this.content + this.outro;\n\t\t}\n\n\t\ttrimEnd(rx) {\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\n\t\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\t\tif (trimmed.length) {\n\t\t\t\tif (trimmed !== this.content) {\n\t\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.edit('', undefined, true);\n\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tif (this.intro.length) return true;\n\t\t\t}\n\t\t}\n\n\t\ttrimStart(rx) {\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\n\t\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\t\tif (trimmed.length) {\n\t\t\t\tif (trimmed !== this.content) {\n\t\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\t\tthis.edit('', undefined, true);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthis.edit('', undefined, true);\n\n\t\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\t\tif (this.outro.length) return true;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst comma = ','.charCodeAt(0);\n\tconst semicolon = ';'.charCodeAt(0);\n\tconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\tconst intToChar = new Uint8Array(64); // 64 possible chars.\n\tconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\tfor (let i = 0; i < chars.length; i++) {\n\t    const c = chars.charCodeAt(i);\n\t    intToChar[i] = c;\n\t    charToInt[c] = i;\n\t}\n\t// Provide a fallback for older environments.\n\tconst td = typeof TextDecoder !== 'undefined'\n\t    ? /* #__PURE__ */ new TextDecoder()\n\t    : typeof Buffer !== 'undefined'\n\t        ? {\n\t            decode(buf) {\n\t                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n\t                return out.toString();\n\t            },\n\t        }\n\t        : {\n\t            decode(buf) {\n\t                let out = '';\n\t                for (let i = 0; i < buf.length; i++) {\n\t                    out += String.fromCharCode(buf[i]);\n\t                }\n\t                return out;\n\t            },\n\t        };\n\tfunction encode(decoded) {\n\t    const state = new Int32Array(5);\n\t    const bufLength = 1024 * 16;\n\t    const subLength = bufLength - 36;\n\t    const buf = new Uint8Array(bufLength);\n\t    const sub = buf.subarray(0, subLength);\n\t    let pos = 0;\n\t    let out = '';\n\t    for (let i = 0; i < decoded.length; i++) {\n\t        const line = decoded[i];\n\t        if (i > 0) {\n\t            if (pos === bufLength) {\n\t                out += td.decode(buf);\n\t                pos = 0;\n\t            }\n\t            buf[pos++] = semicolon;\n\t        }\n\t        if (line.length === 0)\n\t            continue;\n\t        state[0] = 0;\n\t        for (let j = 0; j < line.length; j++) {\n\t            const segment = line[j];\n\t            // We can push up to 5 ints, each int can take at most 7 chars, and we\n\t            // may push a comma.\n\t            if (pos > subLength) {\n\t                out += td.decode(sub);\n\t                buf.copyWithin(0, subLength, pos);\n\t                pos -= subLength;\n\t            }\n\t            if (j > 0)\n\t                buf[pos++] = comma;\n\t            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\t            if (segment.length === 1)\n\t                continue;\n\t            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n\t            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n\t            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\t            if (segment.length === 4)\n\t                continue;\n\t            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n\t        }\n\t    }\n\t    return out + td.decode(buf.subarray(0, pos));\n\t}\n\tfunction encodeInteger(buf, pos, state, segment, j) {\n\t    const next = segment[j];\n\t    let num = next - state[j];\n\t    state[j] = next;\n\t    num = num < 0 ? (-num << 1) | 1 : num << 1;\n\t    do {\n\t        let clamped = num & 0b011111;\n\t        num >>>= 5;\n\t        if (num > 0)\n\t            clamped |= 0b100000;\n\t        buf[pos++] = intToChar[clamped];\n\t    } while (num > 0);\n\t    return pos;\n\t}\n\n\tfunction getBtoa () {\n\t\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t\t} else if (typeof Buffer === 'function') {\n\t\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t\t} else {\n\t\t\treturn () => {\n\t\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t\t};\n\t\t}\n\t}\n\n\tconst btoa = /*#__PURE__*/ getBtoa();\n\n\tclass SourceMap {\n\t\tconstructor(properties) {\n\t\t\tthis.version = 3;\n\t\t\tthis.file = properties.file;\n\t\t\tthis.sources = properties.sources;\n\t\t\tthis.sourcesContent = properties.sourcesContent;\n\t\t\tthis.names = properties.names;\n\t\t\tthis.mappings = encode(properties.mappings);\n\t\t}\n\n\t\ttoString() {\n\t\t\treturn JSON.stringify(this);\n\t\t}\n\n\t\ttoUrl() {\n\t\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t\t}\n\t}\n\n\tfunction guessIndent(code) {\n\t\tconst lines = code.split('\\n');\n\n\t\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\t\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\t\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// More lines tabbed than spaced? Assume tabs, and\n\t\t// default to tabs in the case of a tie (or nothing\n\t\t// to go on)\n\t\tif (tabbed.length >= spaced.length) {\n\t\t\treturn '\\t';\n\t\t}\n\n\t\t// Otherwise, we need to guess the multiple\n\t\tconst min = spaced.reduce((previous, current) => {\n\t\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\t\treturn Math.min(numSpaces, previous);\n\t\t}, Infinity);\n\n\t\treturn new Array(min + 1).join(' ');\n\t}\n\n\tfunction getRelativePath(from, to) {\n\t\tconst fromParts = from.split(/[/\\\\]/);\n\t\tconst toParts = to.split(/[/\\\\]/);\n\n\t\tfromParts.pop(); // get dirname\n\n\t\twhile (fromParts[0] === toParts[0]) {\n\t\t\tfromParts.shift();\n\t\t\ttoParts.shift();\n\t\t}\n\n\t\tif (fromParts.length) {\n\t\t\tlet i = fromParts.length;\n\t\t\twhile (i--) fromParts[i] = '..';\n\t\t}\n\n\t\treturn fromParts.concat(toParts).join('/');\n\t}\n\n\tconst toString = Object.prototype.toString;\n\n\tfunction isObject(thing) {\n\t\treturn toString.call(thing) === '[object Object]';\n\t}\n\n\tfunction getLocator(source) {\n\t\tconst originalLines = source.split('\\n');\n\t\tconst lineOffsets = [];\n\n\t\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\t\tlineOffsets.push(pos);\n\t\t\tpos += originalLines[i].length + 1;\n\t\t}\n\n\t\treturn function locate(index) {\n\t\t\tlet i = 0;\n\t\t\tlet j = lineOffsets.length;\n\t\t\twhile (i < j) {\n\t\t\t\tconst m = (i + j) >> 1;\n\t\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\t\tj = m;\n\t\t\t\t} else {\n\t\t\t\t\ti = m + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst line = i - 1;\n\t\t\tconst column = index - lineOffsets[line];\n\t\t\treturn { line, column };\n\t\t};\n\t}\n\n\tclass Mappings {\n\t\tconstructor(hires) {\n\t\t\tthis.hires = hires;\n\t\t\tthis.generatedCodeLine = 0;\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t\tthis.raw = [];\n\t\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\t\tif (content.length) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t} else if (this.pending) {\n\t\t\t\tthis.rawSegments.push(this.pending);\n\t\t\t}\n\n\t\t\tthis.advance(content);\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\t\tlet originalCharIndex = chunk.start;\n\t\t\tlet first = true;\n\n\t\t\twhile (originalCharIndex < chunk.end) {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t\t}\n\n\t\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\t\tloc.line += 1;\n\t\t\t\t\tloc.column = 0;\n\t\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\t\tfirst = true;\n\t\t\t\t} else {\n\t\t\t\t\tloc.column += 1;\n\t\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\n\t\t\t\toriginalCharIndex += 1;\n\t\t\t}\n\n\t\t\tthis.pending = null;\n\t\t}\n\n\t\tadvance(str) {\n\t\t\tif (!str) return;\n\n\t\t\tconst lines = str.split('\\n');\n\n\t\t\tif (lines.length > 1) {\n\t\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\t}\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t}\n\n\t\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t\t}\n\t}\n\n\tconst n = '\\n';\n\n\tconst warned = {\n\t\tinsertLeft: false,\n\t\tinsertRight: false,\n\t\tstoreName: false,\n\t};\n\n\tclass MagicString {\n\t\tconstructor(string, options = {}) {\n\t\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\toriginal: { writable: true, value: string },\n\t\t\t\toutro: { writable: true, value: '' },\n\t\t\t\tintro: { writable: true, value: '' },\n\t\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\t\tbyStart: { writable: true, value: {} },\n\t\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\t});\n\n\t\t\tthis.byStart[0] = chunk;\n\t\t\tthis.byEnd[string.length] = chunk;\n\t\t}\n\n\t\taddSourcemapLocation(char) {\n\t\t\tthis.sourcemapLocations.add(char);\n\t\t}\n\n\t\tappend(content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\t\tthis.outro += content;\n\t\t\treturn this;\n\t\t}\n\n\t\tappendLeft(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byEnd[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.appendLeft(content);\n\t\t\t} else {\n\t\t\t\tthis.intro += content;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tappendRight(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byStart[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.appendRight(content);\n\t\t\t} else {\n\t\t\t\tthis.outro += content;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\t\tlet originalChunk = this.firstChunk;\n\t\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\t\twhile (originalChunk) {\n\t\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\t\tif (nextClonedChunk) {\n\t\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t\t}\n\n\t\t\t\toriginalChunk = nextOriginalChunk;\n\t\t\t}\n\n\t\t\tcloned.lastChunk = clonedChunk;\n\n\t\t\tif (this.indentExclusionRanges) {\n\t\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t\t}\n\n\t\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\t\tcloned.intro = this.intro;\n\t\t\tcloned.outro = this.outro;\n\n\t\t\treturn cloned;\n\t\t}\n\n\t\tgenerateDecodedMap(options) {\n\t\t\toptions = options || {};\n\n\t\t\tconst sourceIndex = 0;\n\t\t\tconst names = Object.keys(this.storedNames);\n\t\t\tconst mappings = new Mappings(options.hires);\n\n\t\t\tconst locate = getLocator(this.original);\n\n\t\t\tif (this.intro) {\n\t\t\t\tmappings.advance(this.intro);\n\t\t\t}\n\n\t\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (chunk.edited) {\n\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\tloc,\n\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\t\tnames,\n\t\t\t\tmappings: mappings.raw,\n\t\t\t};\n\t\t}\n\n\t\tgenerateMap(options) {\n\t\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t\t}\n\n\t\t_ensureindentStr() {\n\t\t\tif (this.indentStr === undefined) {\n\t\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t\t}\n\t\t}\n\n\t\t_getRawIndentString() {\n\t\t\tthis._ensureindentStr();\n\t\t\treturn this.indentStr;\n\t\t}\n\n\t\tgetIndentString() {\n\t\t\tthis._ensureindentStr();\n\t\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t\t}\n\n\t\tindent(indentStr, options) {\n\t\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\t\tif (isObject(indentStr)) {\n\t\t\t\toptions = indentStr;\n\t\t\t\tindentStr = undefined;\n\t\t\t}\n\n\t\t\tif (indentStr === undefined) {\n\t\t\t\tthis._ensureindentStr();\n\t\t\t\tindentStr = this.indentStr || '\\t';\n\t\t\t}\n\n\t\t\tif (indentStr === '') return this; // noop\n\n\t\t\toptions = options || {};\n\n\t\t\t// Process exclusion ranges\n\t\t\tconst isExcluded = {};\n\n\t\t\tif (options.exclude) {\n\t\t\t\tconst exclusions =\n\t\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\t\tconst replacer = (match) => {\n\t\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\treturn match;\n\t\t\t};\n\n\t\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\t\tlet charIndex = 0;\n\t\t\tlet chunk = this.firstChunk;\n\n\t\t\twhile (chunk) {\n\t\t\t\tconst end = chunk.end;\n\n\t\t\t\tif (chunk.edited) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcharIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharIndex = chunk.end;\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tinsert() {\n\t\t\tthrow new Error(\n\t\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t\t);\n\t\t}\n\n\t\tinsertLeft(index, content) {\n\t\t\tif (!warned.insertLeft) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.insertLeft = true;\n\t\t\t}\n\n\t\t\treturn this.appendLeft(index, content);\n\t\t}\n\n\t\tinsertRight(index, content) {\n\t\t\tif (!warned.insertRight) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.insertRight = true;\n\t\t\t}\n\n\t\t\treturn this.prependRight(index, content);\n\t\t}\n\n\t\tmove(start, end, index) {\n\t\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\t\t\tthis._split(index);\n\n\t\t\tconst first = this.byStart[start];\n\t\t\tconst last = this.byEnd[end];\n\n\t\t\tconst oldLeft = first.previous;\n\t\t\tconst oldRight = last.next;\n\n\t\t\tconst newRight = this.byStart[index];\n\t\t\tif (!newRight && last === this.lastChunk) return this;\n\t\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\t\tif (newLeft) newLeft.next = first;\n\t\t\tif (newRight) newRight.previous = last;\n\n\t\t\tif (!first.previous) this.firstChunk = last.next;\n\t\t\tif (!last.next) {\n\t\t\t\tthis.lastChunk = first.previous;\n\t\t\t\tthis.lastChunk.next = null;\n\t\t\t}\n\n\t\t\tfirst.previous = newLeft;\n\t\t\tlast.next = newRight || null;\n\n\t\t\tif (!newLeft) this.firstChunk = first;\n\t\t\tif (!newRight) this.lastChunk = last;\n\t\t\treturn this;\n\t\t}\n\n\t\toverwrite(start, end, content, options) {\n\t\t\toptions = options || {};\n\t\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t\t}\n\n\t\tupdate(start, end, content, options) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\t\tif (start === end)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t\t);\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\n\t\t\tif (options === true) {\n\t\t\t\tif (!warned.storeName) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\t\twarned.storeName = true;\n\t\t\t\t}\n\n\t\t\t\toptions = { storeName: true };\n\t\t\t}\n\t\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\t\tif (storeName) {\n\t\t\t\tconst original = this.original.slice(start, end);\n\t\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst first = this.byStart[start];\n\t\t\tconst last = this.byEnd[end];\n\n\t\t\tif (first) {\n\t\t\t\tlet chunk = first;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t\t}\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t}\n\n\t\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t\t} else {\n\t\t\t\t// must be inserting at the end\n\t\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\t\tlast.next = newChunk;\n\t\t\t\tnewChunk.previous = last;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tprepend(content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\t\tthis.intro = content + this.intro;\n\t\t\treturn this;\n\t\t}\n\n\t\tprependLeft(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byEnd[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.prependLeft(content);\n\t\t\t} else {\n\t\t\t\tthis.intro = content + this.intro;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tprependRight(index, content) {\n\t\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\t\tthis._split(index);\n\n\t\t\tconst chunk = this.byStart[index];\n\n\t\t\tif (chunk) {\n\t\t\t\tchunk.prependRight(content);\n\t\t\t} else {\n\t\t\t\tthis.outro = content + this.outro;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tremove(start, end) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tif (start === end) return this;\n\n\t\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\t\tthis._split(start);\n\t\t\tthis._split(end);\n\n\t\t\tlet chunk = this.byStart[start];\n\n\t\t\twhile (chunk) {\n\t\t\t\tchunk.intro = '';\n\t\t\t\tchunk.outro = '';\n\t\t\t\tchunk.edit('');\n\n\t\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tlastChar() {\n\t\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\t\tlet chunk = this.lastChunk;\n\t\t\tdo {\n\t\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t\t} while ((chunk = chunk.previous));\n\t\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\t\treturn '';\n\t\t}\n\n\t\tlastLine() {\n\t\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\t\tlet lineStr = this.outro;\n\t\t\tlet chunk = this.lastChunk;\n\t\t\tdo {\n\t\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t\t}\n\n\t\t\t\tif (chunk.content.length > 0) {\n\t\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t\t}\n\n\t\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t\t}\n\t\t\t} while ((chunk = chunk.previous));\n\t\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\t\treturn this.intro + lineStr;\n\t\t}\n\n\t\tslice(start = 0, end = this.original.length) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\n\t\t\tlet result = '';\n\n\t\t\t// find start chunk\n\t\t\tlet chunk = this.firstChunk;\n\t\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t\t// found end chunk before start\n\t\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\t\tconst startChunk = chunk;\n\t\t\twhile (chunk) {\n\t\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\t\tresult += chunk.intro;\n\t\t\t\t}\n\n\t\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\t\tresult += chunk.outro;\n\t\t\t\t}\n\n\t\t\t\tif (containsEnd) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// TODO deprecate this? not really very useful\n\t\tsnip(start, end) {\n\t\t\tconst clone = this.clone();\n\t\t\tclone.remove(0, start);\n\t\t\tclone.remove(end, clone.original.length);\n\n\t\t\treturn clone;\n\t\t}\n\n\t\t_split(index) {\n\t\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\t\tlet chunk = this.lastSearchedChunk;\n\t\t\tconst searchForward = index > chunk.end;\n\n\t\t\twhile (chunk) {\n\t\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t\t}\n\t\t}\n\n\t\t_splitChunk(chunk, index) {\n\t\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst newChunk = chunk.split(index);\n\n\t\t\tthis.byEnd[index] = chunk;\n\t\t\tthis.byStart[index] = newChunk;\n\t\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\t\tthis.lastSearchedChunk = chunk;\n\t\t\treturn true;\n\t\t}\n\n\t\ttoString() {\n\t\t\tlet str = this.intro;\n\n\t\t\tlet chunk = this.firstChunk;\n\t\t\twhile (chunk) {\n\t\t\t\tstr += chunk.toString();\n\t\t\t\tchunk = chunk.next;\n\t\t\t}\n\n\t\t\treturn str + this.outro;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\tlet chunk = this.firstChunk;\n\t\t\tdo {\n\t\t\t\tif (\n\t\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t\t)\n\t\t\t\t\treturn false;\n\t\t\t} while ((chunk = chunk.next));\n\t\t\treturn true;\n\t\t}\n\n\t\tlength() {\n\t\t\tlet chunk = this.firstChunk;\n\t\t\tlet length = 0;\n\t\t\tdo {\n\t\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t\t} while ((chunk = chunk.next));\n\t\t\treturn length;\n\t\t}\n\n\t\ttrimLines() {\n\t\t\treturn this.trim('[\\\\r\\\\n]');\n\t\t}\n\n\t\ttrim(charType) {\n\t\t\treturn this.trimStart(charType).trimEnd(charType);\n\t\t}\n\n\t\ttrimEndAborted(charType) {\n\t\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\n\t\t\tlet chunk = this.lastChunk;\n\n\t\t\tdo {\n\t\t\t\tconst end = chunk.end;\n\t\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\t\tif (chunk.end !== end) {\n\t\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tif (aborted) return true;\n\t\t\t\tchunk = chunk.previous;\n\t\t\t} while (chunk);\n\n\t\t\treturn false;\n\t\t}\n\n\t\ttrimEnd(charType) {\n\t\t\tthis.trimEndAborted(charType);\n\t\t\treturn this;\n\t\t}\n\t\ttrimStartAborted(charType) {\n\t\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\n\t\t\tlet chunk = this.firstChunk;\n\n\t\t\tdo {\n\t\t\t\tconst end = chunk.end;\n\t\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\t\tif (chunk.end !== end) {\n\t\t\t\t\t// special case...\n\t\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tif (aborted) return true;\n\t\t\t\tchunk = chunk.next;\n\t\t\t} while (chunk);\n\n\t\t\treturn false;\n\t\t}\n\n\t\ttrimStart(charType) {\n\t\t\tthis.trimStartAborted(charType);\n\t\t\treturn this;\n\t\t}\n\n\t\thasChanged() {\n\t\t\treturn this.original !== this.toString();\n\t\t}\n\n\t\t_replaceRegexp(searchValue, replacement) {\n\t\t\tfunction getReplacement(match, str) {\n\t\t\t\tif (typeof replacement === 'string') {\n\t\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\t\tconst num = +i;\n\t\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\t\treturn `$${i}`;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction matchAll(re, str) {\n\t\t\t\tlet match;\n\t\t\t\tconst matches = [];\n\t\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\t\tmatches.push(match);\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t\tif (searchValue.global) {\n\t\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\t\tmatches.forEach((match) => {\n\t\t\t\t\tif (match.index != null)\n\t\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst match = this.original.match(searchValue);\n\t\t\t\tif (match && match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t_replaceString(string, replacement) {\n\t\t\tconst { original } = this;\n\t\t\tconst index = original.indexOf(string);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\treplace(searchValue, replacement) {\n\t\t\tif (typeof searchValue === 'string') {\n\t\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t\t}\n\n\t\t\treturn this._replaceRegexp(searchValue, replacement);\n\t\t}\n\n\t\t_replaceAllString(string, replacement) {\n\t\t\tconst { original } = this;\n\t\t\tconst stringLength = string.length;\n\t\t\tfor (\n\t\t\t\tlet index = original.indexOf(string);\n\t\t\t\tindex !== -1;\n\t\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t\t) {\n\t\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\treplaceAll(searchValue, replacement) {\n\t\t\tif (typeof searchValue === 'string') {\n\t\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t\t}\n\n\t\t\tif (!searchValue.global) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this._replaceRegexp(searchValue, replacement);\n\t\t}\n\t}\n\n\tconst hasOwnProp = Object.prototype.hasOwnProperty;\n\n\tclass Bundle {\n\t\tconstructor(options = {}) {\n\t\t\tthis.intro = options.intro || '';\n\t\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\t\tthis.sources = [];\n\t\t\tthis.uniqueSources = [];\n\t\t\tthis.uniqueSourceIndexByFilename = {};\n\t\t}\n\n\t\taddSource(source) {\n\t\t\tif (source instanceof MagicString) {\n\t\t\t\treturn this.addSource({\n\t\t\t\t\tcontent: source,\n\t\t\t\t\tfilename: source.filename,\n\t\t\t\t\tseparator: this.separator,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!isObject(source) || !source.content) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t\t});\n\n\t\t\tif (source.separator === undefined) {\n\t\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\t\tsource.separator = this.separator;\n\t\t\t}\n\n\t\t\tif (source.filename) {\n\t\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t\t} else {\n\t\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.sources.push(source);\n\t\t\treturn this;\n\t\t}\n\n\t\tappend(str, options) {\n\t\t\tthis.addSource({\n\t\t\t\tcontent: new MagicString(str),\n\t\t\t\tseparator: (options && options.separator) || '',\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst bundle = new Bundle({\n\t\t\t\tintro: this.intro,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tbundle.addSource({\n\t\t\t\t\tfilename: source.filename,\n\t\t\t\t\tcontent: source.content.clone(),\n\t\t\t\t\tseparator: source.separator,\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn bundle;\n\t\t}\n\n\t\tgenerateDecodedMap(options = {}) {\n\t\t\tconst names = [];\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tconst mappings = new Mappings(options.hires);\n\n\t\t\tif (this.intro) {\n\t\t\t\tmappings.advance(this.intro);\n\t\t\t}\n\n\t\t\tthis.sources.forEach((source, i) => {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tmappings.advance(this.separator);\n\t\t\t\t}\n\n\t\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\t\tconst magicString = source.content;\n\t\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\t\tif (magicString.intro) {\n\t\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t\t}\n\n\t\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\t\tif (source.filename) {\n\t\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t\t});\n\n\t\t\t\tif (magicString.outro) {\n\t\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t\t}),\n\t\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t\t}),\n\t\t\t\tnames,\n\t\t\t\tmappings: mappings.raw,\n\t\t\t};\n\t\t}\n\n\t\tgenerateMap(options) {\n\t\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t\t}\n\n\t\tgetIndentString() {\n\t\t\tconst indentStringCounts = {};\n\n\t\t\tthis.sources.forEach((source) => {\n\t\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\t\tif (indentStr === null) return;\n\n\t\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\t\tindentStringCounts[indentStr] += 1;\n\t\t\t});\n\n\t\t\treturn (\n\t\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t\t})[0] || '\\t'\n\t\t\t);\n\t\t}\n\n\t\tindent(indentStr) {\n\t\t\tif (!arguments.length) {\n\t\t\t\tindentStr = this.getIndentString();\n\t\t\t}\n\n\t\t\tif (indentStr === '') return this; // noop\n\n\t\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\t\tthis.sources.forEach((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\t\tsource.content.indent(indentStr, {\n\t\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t\t});\n\n\t\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t\t});\n\n\t\t\tif (this.intro) {\n\t\t\t\tthis.intro =\n\t\t\t\t\tindentStr +\n\t\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tprepend(str) {\n\t\t\tthis.intro = str + this.intro;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoString() {\n\t\t\tconst body = this.sources\n\t\t\t\t.map((source, i) => {\n\t\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\t\treturn str;\n\t\t\t\t})\n\t\t\t\t.join('');\n\n\t\t\treturn this.intro + body;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\t\treturn true;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn this.sources.reduce(\n\t\t\t\t(length, source) => length + source.content.length(),\n\t\t\t\tthis.intro.length\n\t\t\t);\n\t\t}\n\n\t\ttrimLines() {\n\t\t\treturn this.trim('[\\\\r\\\\n]');\n\t\t}\n\n\t\ttrim(charType) {\n\t\t\treturn this.trimStart(charType).trimEnd(charType);\n\t\t}\n\n\t\ttrimStart(charType) {\n\t\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\t\tif (!this.intro) {\n\t\t\t\tlet source;\n\t\t\t\tlet i = 0;\n\n\t\t\t\tdo {\n\t\t\t\t\tsource = this.sources[i++];\n\t\t\t\t\tif (!source) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttrimEnd(charType) {\n\t\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\t\tlet source;\n\t\t\tlet i = this.sources.length - 1;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i--];\n\t\t\t\tif (!source) {\n\t\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tMagicString.Bundle = Bundle;\n\tMagicString.SourceMap = SourceMap;\n\tMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\n\treturn MagicString;\n\n}));\n//# sourceMappingURL=magic-string.umd.js.map\n"}},"magic-string.umd.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"magic-string.umd.js\",\"sources\":[\"../src/BitSet.js\",\"../src/Chunk.js\",\"../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\",\"../src/SourceMap.js\",\"../src/utils/guessIndent.js\",\"../src/utils/getRelativePath.js\",\"../src/utils/isObject.js\",\"../src/utils/getLocator.js\",\"../src/utils/Mappings.js\",\"../src/MagicString.js\",\"../src/Bundle.js\",\"../src/index-legacy.js\"],\"sourcesContent\":[\"export default class BitSet {\\n\\tconstructor(arg) {\\n\\t\\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\\n\\t}\\n\\n\\tadd(n) {\\n\\t\\tthis.bits[n >> 5] |= 1 << (n & 31);\\n\\t}\\n\\n\\thas(n) {\\n\\t\\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\\n\\t}\\n}\\n\",\"export default class Chunk {\\n\\tconstructor(start, end, content) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t\\tthis.original = content;\\n\\n\\t\\tthis.intro = '';\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.content = content;\\n\\t\\tthis.storeName = false;\\n\\t\\tthis.edited = false;\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\t// we make these non-enumerable, for sanity while debugging\\n\\t\\t\\tObject.defineProperties(this, {\\n\\t\\t\\t\\tprevious: { writable: true, value: null },\\n\\t\\t\\t\\tnext: { writable: true, value: null },\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.previous = null;\\n\\t\\t\\tthis.next = null;\\n\\t\\t}\\n\\t}\\n\\n\\tappendLeft(content) {\\n\\t\\tthis.outro += content;\\n\\t}\\n\\n\\tappendRight(content) {\\n\\t\\tthis.intro = this.intro + content;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst chunk = new Chunk(this.start, this.end, this.original);\\n\\n\\t\\tchunk.intro = this.intro;\\n\\t\\tchunk.outro = this.outro;\\n\\t\\tchunk.content = this.content;\\n\\t\\tchunk.storeName = this.storeName;\\n\\t\\tchunk.edited = this.edited;\\n\\n\\t\\treturn chunk;\\n\\t}\\n\\n\\tcontains(index) {\\n\\t\\treturn this.start < index && index < this.end;\\n\\t}\\n\\n\\teachNext(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\t}\\n\\n\\teachPrevious(fn) {\\n\\t\\tlet chunk = this;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tfn(chunk);\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t}\\n\\t}\\n\\n\\tedit(content, storeName, contentOnly) {\\n\\t\\tthis.content = content;\\n\\t\\tif (!contentOnly) {\\n\\t\\t\\tthis.intro = '';\\n\\t\\t\\tthis.outro = '';\\n\\t\\t}\\n\\t\\tthis.storeName = storeName;\\n\\n\\t\\tthis.edited = true;\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(content) {\\n\\t\\tthis.outro = content + this.outro;\\n\\t}\\n\\n\\tprependRight(content) {\\n\\t\\tthis.intro = content + this.intro;\\n\\t}\\n\\n\\tsplit(index) {\\n\\t\\tconst sliceIndex = index - this.start;\\n\\n\\t\\tconst originalBefore = this.original.slice(0, sliceIndex);\\n\\t\\tconst originalAfter = this.original.slice(sliceIndex);\\n\\n\\t\\tthis.original = originalBefore;\\n\\n\\t\\tconst newChunk = new Chunk(index, this.end, originalAfter);\\n\\t\\tnewChunk.outro = this.outro;\\n\\t\\tthis.outro = '';\\n\\n\\t\\tthis.end = index;\\n\\n\\t\\tif (this.edited) {\\n\\t\\t\\t// TODO is this block necessary?...\\n\\t\\t\\tnewChunk.edit('', false);\\n\\t\\t\\tthis.content = '';\\n\\t\\t} else {\\n\\t\\t\\tthis.content = originalBefore;\\n\\t\\t}\\n\\n\\t\\tnewChunk.next = this.next;\\n\\t\\tif (newChunk.next) newChunk.next.previous = newChunk;\\n\\t\\tnewChunk.previous = this;\\n\\t\\tthis.next = newChunk;\\n\\n\\t\\treturn newChunk;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn this.intro + this.content + this.outro;\\n\\t}\\n\\n\\ttrimEnd(rx) {\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.start + trimmed.length).edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\tif (this.intro.length) return true;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimStart(rx) {\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tconst trimmed = this.content.replace(rx, '');\\n\\n\\t\\tif (trimmed.length) {\\n\\t\\t\\tif (trimmed !== this.content) {\\n\\t\\t\\t\\tthis.split(this.end - trimmed.length);\\n\\t\\t\\t\\tthis.edit('', undefined, true);\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tthis.edit('', undefined, true);\\n\\n\\t\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\t\\tif (this.outro.length) return true;\\n\\t\\t}\\n\\t}\\n}\\n\",\"const comma = ','.charCodeAt(0);\\nconst semicolon = ';'.charCodeAt(0);\\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\nconst intToChar = new Uint8Array(64); // 64 possible chars.\\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\\nfor (let i = 0; i < chars.length; i++) {\\n    const c = chars.charCodeAt(i);\\n    intToChar[i] = c;\\n    charToInt[c] = i;\\n}\\n// Provide a fallback for older environments.\\nconst td = typeof TextDecoder !== 'undefined'\\n    ? /* #__PURE__ */ new TextDecoder()\\n    : typeof Buffer !== 'undefined'\\n        ? {\\n            decode(buf) {\\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\\n                return out.toString();\\n            },\\n        }\\n        : {\\n            decode(buf) {\\n                let out = '';\\n                for (let i = 0; i < buf.length; i++) {\\n                    out += String.fromCharCode(buf[i]);\\n                }\\n                return out;\\n            },\\n        };\\nfunction decode(mappings) {\\n    const state = new Int32Array(5);\\n    const decoded = [];\\n    let index = 0;\\n    do {\\n        const semi = indexOf(mappings, index);\\n        const line = [];\\n        let sorted = true;\\n        let lastCol = 0;\\n        state[0] = 0;\\n        for (let i = index; i < semi; i++) {\\n            let seg;\\n            i = decodeInteger(mappings, i, state, 0); // genColumn\\n            const col = state[0];\\n            if (col < lastCol)\\n                sorted = false;\\n            lastCol = col;\\n            if (hasMoreVlq(mappings, i, semi)) {\\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\\n                if (hasMoreVlq(mappings, i, semi)) {\\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\\n                    seg = [col, state[1], state[2], state[3], state[4]];\\n                }\\n                else {\\n                    seg = [col, state[1], state[2], state[3]];\\n                }\\n            }\\n            else {\\n                seg = [col];\\n            }\\n            line.push(seg);\\n        }\\n        if (!sorted)\\n            sort(line);\\n        decoded.push(line);\\n        index = semi + 1;\\n    } while (index <= mappings.length);\\n    return decoded;\\n}\\nfunction indexOf(mappings, index) {\\n    const idx = mappings.indexOf(';', index);\\n    return idx === -1 ? mappings.length : idx;\\n}\\nfunction decodeInteger(mappings, pos, state, j) {\\n    let value = 0;\\n    let shift = 0;\\n    let integer = 0;\\n    do {\\n        const c = mappings.charCodeAt(pos++);\\n        integer = charToInt[c];\\n        value |= (integer & 31) << shift;\\n        shift += 5;\\n    } while (integer & 32);\\n    const shouldNegate = value & 1;\\n    value >>>= 1;\\n    if (shouldNegate) {\\n        value = -0x80000000 | -value;\\n    }\\n    state[j] += value;\\n    return pos;\\n}\\nfunction hasMoreVlq(mappings, i, length) {\\n    if (i >= length)\\n        return false;\\n    return mappings.charCodeAt(i) !== comma;\\n}\\nfunction sort(line) {\\n    line.sort(sortComparator);\\n}\\nfunction sortComparator(a, b) {\\n    return a[0] - b[0];\\n}\\nfunction encode(decoded) {\\n    const state = new Int32Array(5);\\n    const bufLength = 1024 * 16;\\n    const subLength = bufLength - 36;\\n    const buf = new Uint8Array(bufLength);\\n    const sub = buf.subarray(0, subLength);\\n    let pos = 0;\\n    let out = '';\\n    for (let i = 0; i < decoded.length; i++) {\\n        const line = decoded[i];\\n        if (i > 0) {\\n            if (pos === bufLength) {\\n                out += td.decode(buf);\\n                pos = 0;\\n            }\\n            buf[pos++] = semicolon;\\n        }\\n        if (line.length === 0)\\n            continue;\\n        state[0] = 0;\\n        for (let j = 0; j < line.length; j++) {\\n            const segment = line[j];\\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\\n            // may push a comma.\\n            if (pos > subLength) {\\n                out += td.decode(sub);\\n                buf.copyWithin(0, subLength, pos);\\n                pos -= subLength;\\n            }\\n            if (j > 0)\\n                buf[pos++] = comma;\\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\\n            if (segment.length === 1)\\n                continue;\\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\\n            if (segment.length === 4)\\n                continue;\\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\\n        }\\n    }\\n    return out + td.decode(buf.subarray(0, pos));\\n}\\nfunction encodeInteger(buf, pos, state, segment, j) {\\n    const next = segment[j];\\n    let num = next - state[j];\\n    state[j] = next;\\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\\n    do {\\n        let clamped = num & 0b011111;\\n        num >>>= 5;\\n        if (num > 0)\\n            clamped |= 0b100000;\\n        buf[pos++] = intToChar[clamped];\\n    } while (num > 0);\\n    return pos;\\n}\\n\\nexport { decode, encode };\\n//# sourceMappingURL=sourcemap-codec.mjs.map\\n\",\"import { encode } from '@jridgewell/sourcemap-codec';\\n\\nfunction getBtoa () {\\n\\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\\n\\t\\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\\n\\t} else if (typeof Buffer === 'function') {\\n\\t\\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\\n\\t} else {\\n\\t\\treturn () => {\\n\\t\\t\\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\\n\\t\\t};\\n\\t}\\n}\\n\\nconst btoa = /*#__PURE__*/ getBtoa();\\n\\nexport default class SourceMap {\\n\\tconstructor(properties) {\\n\\t\\tthis.version = 3;\\n\\t\\tthis.file = properties.file;\\n\\t\\tthis.sources = properties.sources;\\n\\t\\tthis.sourcesContent = properties.sourcesContent;\\n\\t\\tthis.names = properties.names;\\n\\t\\tthis.mappings = encode(properties.mappings);\\n\\t}\\n\\n\\ttoString() {\\n\\t\\treturn JSON.stringify(this);\\n\\t}\\n\\n\\ttoUrl() {\\n\\t\\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\\n\\t}\\n}\\n\",\"export default function guessIndent(code) {\\n\\tconst lines = code.split('\\\\n');\\n\\n\\tconst tabbed = lines.filter((line) => /^\\\\t+/.test(line));\\n\\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\\n\\n\\tif (tabbed.length === 0 && spaced.length === 0) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// More lines tabbed than spaced? Assume tabs, and\\n\\t// default to tabs in the case of a tie (or nothing\\n\\t// to go on)\\n\\tif (tabbed.length >= spaced.length) {\\n\\t\\treturn '\\\\t';\\n\\t}\\n\\n\\t// Otherwise, we need to guess the multiple\\n\\tconst min = spaced.reduce((previous, current) => {\\n\\t\\tconst numSpaces = /^ +/.exec(current)[0].length;\\n\\t\\treturn Math.min(numSpaces, previous);\\n\\t}, Infinity);\\n\\n\\treturn new Array(min + 1).join(' ');\\n}\\n\",\"export default function getRelativePath(from, to) {\\n\\tconst fromParts = from.split(/[/\\\\\\\\]/);\\n\\tconst toParts = to.split(/[/\\\\\\\\]/);\\n\\n\\tfromParts.pop(); // get dirname\\n\\n\\twhile (fromParts[0] === toParts[0]) {\\n\\t\\tfromParts.shift();\\n\\t\\ttoParts.shift();\\n\\t}\\n\\n\\tif (fromParts.length) {\\n\\t\\tlet i = fromParts.length;\\n\\t\\twhile (i--) fromParts[i] = '..';\\n\\t}\\n\\n\\treturn fromParts.concat(toParts).join('/');\\n}\\n\",\"const toString = Object.prototype.toString;\\n\\nexport default function isObject(thing) {\\n\\treturn toString.call(thing) === '[object Object]';\\n}\\n\",\"export default function getLocator(source) {\\n\\tconst originalLines = source.split('\\\\n');\\n\\tconst lineOffsets = [];\\n\\n\\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\\n\\t\\tlineOffsets.push(pos);\\n\\t\\tpos += originalLines[i].length + 1;\\n\\t}\\n\\n\\treturn function locate(index) {\\n\\t\\tlet i = 0;\\n\\t\\tlet j = lineOffsets.length;\\n\\t\\twhile (i < j) {\\n\\t\\t\\tconst m = (i + j) >> 1;\\n\\t\\t\\tif (index < lineOffsets[m]) {\\n\\t\\t\\t\\tj = m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = m + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconst line = i - 1;\\n\\t\\tconst column = index - lineOffsets[line];\\n\\t\\treturn { line, column };\\n\\t};\\n}\\n\",\"export default class Mappings {\\n\\tconstructor(hires) {\\n\\t\\tthis.hires = hires;\\n\\t\\tthis.generatedCodeLine = 0;\\n\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\tthis.raw = [];\\n\\t\\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddEdit(sourceIndex, content, loc, nameIndex) {\\n\\t\\tif (content.length) {\\n\\t\\t\\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\\n\\t\\t\\tif (nameIndex >= 0) {\\n\\t\\t\\t\\tsegment.push(nameIndex);\\n\\t\\t\\t}\\n\\t\\t\\tthis.rawSegments.push(segment);\\n\\t\\t} else if (this.pending) {\\n\\t\\t\\tthis.rawSegments.push(this.pending);\\n\\t\\t}\\n\\n\\t\\tthis.advance(content);\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\\n\\t\\tlet originalCharIndex = chunk.start;\\n\\t\\tlet first = true;\\n\\n\\t\\twhile (originalCharIndex < chunk.end) {\\n\\t\\t\\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\\n\\t\\t\\t\\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (original[originalCharIndex] === '\\\\n') {\\n\\t\\t\\t\\tloc.line += 1;\\n\\t\\t\\t\\tloc.column = 0;\\n\\t\\t\\t\\tthis.generatedCodeLine += 1;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tloc.column += 1;\\n\\t\\t\\t\\tthis.generatedCodeColumn += 1;\\n\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalCharIndex += 1;\\n\\t\\t}\\n\\n\\t\\tthis.pending = null;\\n\\t}\\n\\n\\tadvance(str) {\\n\\t\\tif (!str) return;\\n\\n\\t\\tconst lines = str.split('\\\\n');\\n\\n\\t\\tif (lines.length > 1) {\\n\\t\\t\\tfor (let i = 0; i < lines.length - 1; i++) {\\n\\t\\t\\t\\tthis.generatedCodeLine++;\\n\\t\\t\\t\\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\\n\\t\\t\\t}\\n\\t\\t\\tthis.generatedCodeColumn = 0;\\n\\t\\t}\\n\\n\\t\\tthis.generatedCodeColumn += lines[lines.length - 1].length;\\n\\t}\\n}\\n\",\"import BitSet from './BitSet.js';\\nimport Chunk from './Chunk.js';\\nimport SourceMap from './SourceMap.js';\\nimport guessIndent from './utils/guessIndent.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\nimport Stats from './utils/Stats.js';\\n\\nconst n = '\\\\n';\\n\\nconst warned = {\\n\\tinsertLeft: false,\\n\\tinsertRight: false,\\n\\tstoreName: false,\\n};\\n\\nexport default class MagicString {\\n\\tconstructor(string, options = {}) {\\n\\t\\tconst chunk = new Chunk(0, string.length, string);\\n\\n\\t\\tObject.defineProperties(this, {\\n\\t\\t\\toriginal: { writable: true, value: string },\\n\\t\\t\\toutro: { writable: true, value: '' },\\n\\t\\t\\tintro: { writable: true, value: '' },\\n\\t\\t\\tfirstChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastChunk: { writable: true, value: chunk },\\n\\t\\t\\tlastSearchedChunk: { writable: true, value: chunk },\\n\\t\\t\\tbyStart: { writable: true, value: {} },\\n\\t\\t\\tbyEnd: { writable: true, value: {} },\\n\\t\\t\\tfilename: { writable: true, value: options.filename },\\n\\t\\t\\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\\n\\t\\t\\tsourcemapLocations: { writable: true, value: new BitSet() },\\n\\t\\t\\tstoredNames: { writable: true, value: {} },\\n\\t\\t\\tindentStr: { writable: true, value: undefined },\\n\\t\\t});\\n\\n\\t\\tif (DEBUG) {\\n\\t\\t\\tObject.defineProperty(this, 'stats', { value: new Stats() });\\n\\t\\t}\\n\\n\\t\\tthis.byStart[0] = chunk;\\n\\t\\tthis.byEnd[string.length] = chunk;\\n\\t}\\n\\n\\taddSourcemapLocation(char) {\\n\\t\\tthis.sourcemapLocations.add(char);\\n\\t}\\n\\n\\tappend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.outro += content;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendLeft');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendLeft');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappendRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('appendRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.appendRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro += content;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('appendRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst cloned = new MagicString(this.original, { filename: this.filename });\\n\\n\\t\\tlet originalChunk = this.firstChunk;\\n\\t\\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\\n\\n\\t\\twhile (originalChunk) {\\n\\t\\t\\tcloned.byStart[clonedChunk.start] = clonedChunk;\\n\\t\\t\\tcloned.byEnd[clonedChunk.end] = clonedChunk;\\n\\n\\t\\t\\tconst nextOriginalChunk = originalChunk.next;\\n\\t\\t\\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\\n\\n\\t\\t\\tif (nextClonedChunk) {\\n\\t\\t\\t\\tclonedChunk.next = nextClonedChunk;\\n\\t\\t\\t\\tnextClonedChunk.previous = clonedChunk;\\n\\n\\t\\t\\t\\tclonedChunk = nextClonedChunk;\\n\\t\\t\\t}\\n\\n\\t\\t\\toriginalChunk = nextOriginalChunk;\\n\\t\\t}\\n\\n\\t\\tcloned.lastChunk = clonedChunk;\\n\\n\\t\\tif (this.indentExclusionRanges) {\\n\\t\\t\\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\\n\\t\\t}\\n\\n\\t\\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\\n\\n\\t\\tcloned.intro = this.intro;\\n\\t\\tcloned.outro = this.outro;\\n\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tgenerateDecodedMap(options) {\\n\\t\\toptions = options || {};\\n\\n\\t\\tconst sourceIndex = 0;\\n\\t\\tconst names = Object.keys(this.storedNames);\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tconst locate = getLocator(this.original);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.firstChunk.eachNext((chunk) => {\\n\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\\n\\t\\t\\tsourcesContent: options.includeContent ? [this.original] : [null],\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\t_ensureindentStr() {\\n\\t\\tif (this.indentStr === undefined) {\\n\\t\\t\\tthis.indentStr = guessIndent(this.original);\\n\\t\\t}\\n\\t}\\n\\n\\t_getRawIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr;\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tthis._ensureindentStr();\\n\\t\\treturn this.indentStr === null ? '\\\\t' : this.indentStr;\\n\\t}\\n\\n\\tindent(indentStr, options) {\\n\\t\\tconst pattern = /^[^\\\\r\\\\n]/gm;\\n\\n\\t\\tif (isObject(indentStr)) {\\n\\t\\t\\toptions = indentStr;\\n\\t\\t\\tindentStr = undefined;\\n\\t\\t}\\n\\n\\t\\tif (indentStr === undefined) {\\n\\t\\t\\tthis._ensureindentStr();\\n\\t\\t\\tindentStr = this.indentStr || '\\\\t';\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Process exclusion ranges\\n\\t\\tconst isExcluded = {};\\n\\n\\t\\tif (options.exclude) {\\n\\t\\t\\tconst exclusions =\\n\\t\\t\\t\\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\\n\\t\\t\\texclusions.forEach((exclusion) => {\\n\\t\\t\\t\\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\\n\\t\\t\\t\\t\\tisExcluded[i] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tlet shouldIndentNextCharacter = options.indentStart !== false;\\n\\t\\tconst replacer = (match) => {\\n\\t\\t\\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\\n\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\treturn match;\\n\\t\\t};\\n\\n\\t\\tthis.intro = this.intro.replace(pattern, replacer);\\n\\n\\t\\tlet charIndex = 0;\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tconst end = chunk.end;\\n\\n\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\tchunk.content = chunk.content.replace(pattern, replacer);\\n\\n\\t\\t\\t\\t\\tif (chunk.content.length) {\\n\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\\\n';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharIndex = chunk.start;\\n\\n\\t\\t\\t\\twhile (charIndex < end) {\\n\\t\\t\\t\\t\\tif (!isExcluded[charIndex]) {\\n\\t\\t\\t\\t\\t\\tconst char = this.original[charIndex];\\n\\n\\t\\t\\t\\t\\t\\tif (char === '\\\\n') {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = true;\\n\\t\\t\\t\\t\\t\\t} else if (char !== '\\\\r' && shouldIndentNextCharacter) {\\n\\t\\t\\t\\t\\t\\t\\tshouldIndentNextCharacter = false;\\n\\n\\t\\t\\t\\t\\t\\t\\tif (charIndex === chunk.start) {\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis._splitChunk(chunk, charIndex);\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\t\\t\\t\\t\\tchunk.prependRight(indentStr);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcharIndex += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcharIndex = chunk.end;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tthis.outro = this.outro.replace(pattern, replacer);\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tinsert() {\\n\\t\\tthrow new Error(\\n\\t\\t\\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\\n\\t\\t);\\n\\t}\\n\\n\\tinsertLeft(index, content) {\\n\\t\\tif (!warned.insertLeft) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertLeft = true;\\n\\t\\t}\\n\\n\\t\\treturn this.appendLeft(index, content);\\n\\t}\\n\\n\\tinsertRight(index, content) {\\n\\t\\tif (!warned.insertRight) {\\n\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\\n\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\twarned.insertRight = true;\\n\\t\\t}\\n\\n\\t\\treturn this.prependRight(index, content);\\n\\t}\\n\\n\\tmove(start, end, index) {\\n\\t\\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\\n\\n\\t\\tif (DEBUG) this.stats.time('move');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tconst oldLeft = first.previous;\\n\\t\\tconst oldRight = last.next;\\n\\n\\t\\tconst newRight = this.byStart[index];\\n\\t\\tif (!newRight && last === this.lastChunk) return this;\\n\\t\\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\\n\\n\\t\\tif (oldLeft) oldLeft.next = oldRight;\\n\\t\\tif (oldRight) oldRight.previous = oldLeft;\\n\\n\\t\\tif (newLeft) newLeft.next = first;\\n\\t\\tif (newRight) newRight.previous = last;\\n\\n\\t\\tif (!first.previous) this.firstChunk = last.next;\\n\\t\\tif (!last.next) {\\n\\t\\t\\tthis.lastChunk = first.previous;\\n\\t\\t\\tthis.lastChunk.next = null;\\n\\t\\t}\\n\\n\\t\\tfirst.previous = newLeft;\\n\\t\\tlast.next = newRight || null;\\n\\n\\t\\tif (!newLeft) this.firstChunk = first;\\n\\t\\tif (!newRight) this.lastChunk = last;\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('move');\\n\\t\\treturn this;\\n\\t}\\n\\n\\toverwrite(start, end, content, options) {\\n\\t\\toptions = options || {};\\n\\t\\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\\n\\t}\\n\\n\\tupdate(start, end, content, options) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\\n\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (end > this.original.length) throw new Error('end is out of bounds');\\n\\t\\tif (start === end)\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\\n\\t\\t\\t);\\n\\n\\t\\tif (DEBUG) this.stats.time('overwrite');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tif (options === true) {\\n\\t\\t\\tif (!warned.storeName) {\\n\\t\\t\\t\\tconsole.warn(\\n\\t\\t\\t\\t\\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\\n\\t\\t\\t\\t); // eslint-disable-line no-console\\n\\t\\t\\t\\twarned.storeName = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\toptions = { storeName: true };\\n\\t\\t}\\n\\t\\tconst storeName = options !== undefined ? options.storeName : false;\\n\\t\\tconst overwrite = options !== undefined ? options.overwrite : false;\\n\\n\\t\\tif (storeName) {\\n\\t\\t\\tconst original = this.original.slice(start, end);\\n\\t\\t\\tObject.defineProperty(this.storedNames, original, {\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tvalue: true,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tconst first = this.byStart[start];\\n\\t\\tconst last = this.byEnd[end];\\n\\n\\t\\tif (first) {\\n\\t\\t\\tlet chunk = first;\\n\\t\\t\\twhile (chunk !== last) {\\n\\t\\t\\t\\tif (chunk.next !== this.byStart[chunk.end]) {\\n\\t\\t\\t\\t\\tthrow new Error('Cannot overwrite across a split point');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchunk = chunk.next;\\n\\t\\t\\t\\tchunk.edit('', false);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst.edit(content, storeName, !overwrite);\\n\\t\\t} else {\\n\\t\\t\\t// must be inserting at the end\\n\\t\\t\\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\\n\\n\\t\\t\\t// TODO last chunk in the array may not be the last chunk, if it's moved...\\n\\t\\t\\tlast.next = newChunk;\\n\\t\\t\\tnewChunk.previous = last;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('overwrite');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\\n\\n\\t\\tthis.intro = content + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependLeft(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byEnd[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependLeft(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.intro = content + this.intro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprependRight(index, content) {\\n\\t\\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\\n\\n\\t\\tif (DEBUG) this.stats.time('insertRight');\\n\\n\\t\\tthis._split(index);\\n\\n\\t\\tconst chunk = this.byStart[index];\\n\\n\\t\\tif (chunk) {\\n\\t\\t\\tchunk.prependRight(content);\\n\\t\\t} else {\\n\\t\\t\\tthis.outro = content + this.outro;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('insertRight');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tremove(start, end) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tif (start === end) return this;\\n\\n\\t\\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\\n\\t\\tif (start > end) throw new Error('end must be greater than start');\\n\\n\\t\\tif (DEBUG) this.stats.time('remove');\\n\\n\\t\\tthis._split(start);\\n\\t\\tthis._split(end);\\n\\n\\t\\tlet chunk = this.byStart[start];\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tchunk.intro = '';\\n\\t\\t\\tchunk.outro = '';\\n\\t\\t\\tchunk.edit('');\\n\\n\\t\\t\\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\\n\\t\\t}\\n\\n\\t\\tif (DEBUG) this.stats.timeEnd('remove');\\n\\t\\treturn this;\\n\\t}\\n\\n\\tlastChar() {\\n\\t\\tif (this.outro.length) return this.outro[this.outro.length - 1];\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\\n\\t\\t\\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\\n\\t\\t\\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tif (this.intro.length) return this.intro[this.intro.length - 1];\\n\\t\\treturn '';\\n\\t}\\n\\n\\tlastLine() {\\n\\t\\tlet lineIndex = this.outro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\\n\\t\\tlet lineStr = this.outro;\\n\\t\\tlet chunk = this.lastChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (chunk.outro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.outro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.outro + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.content.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.content.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.content + lineStr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (chunk.intro.length > 0) {\\n\\t\\t\\t\\tlineIndex = chunk.intro.lastIndexOf(n);\\n\\t\\t\\t\\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\t\\t\\tlineStr = chunk.intro + lineStr;\\n\\t\\t\\t}\\n\\t\\t} while ((chunk = chunk.previous));\\n\\t\\tlineIndex = this.intro.lastIndexOf(n);\\n\\t\\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\\n\\t\\treturn this.intro + lineStr;\\n\\t}\\n\\n\\tslice(start = 0, end = this.original.length) {\\n\\t\\twhile (start < 0) start += this.original.length;\\n\\t\\twhile (end < 0) end += this.original.length;\\n\\n\\t\\tlet result = '';\\n\\n\\t\\t// find start chunk\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\\n\\t\\t\\t// found end chunk before start\\n\\t\\t\\tif (chunk.start < end && chunk.end >= end) {\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\tif (chunk && chunk.edited && chunk.start !== start)\\n\\t\\t\\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\\n\\n\\t\\tconst startChunk = chunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\\n\\t\\t\\t\\tresult += chunk.intro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst containsEnd = chunk.start < end && chunk.end >= end;\\n\\t\\t\\tif (containsEnd && chunk.edited && chunk.end !== end)\\n\\t\\t\\t\\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\\n\\n\\t\\t\\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\\n\\t\\t\\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\\n\\n\\t\\t\\tresult += chunk.content.slice(sliceStart, sliceEnd);\\n\\n\\t\\t\\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\\n\\t\\t\\t\\tresult += chunk.outro;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (containsEnd) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// TODO deprecate this? not really very useful\\n\\tsnip(start, end) {\\n\\t\\tconst clone = this.clone();\\n\\t\\tclone.remove(0, start);\\n\\t\\tclone.remove(end, clone.original.length);\\n\\n\\t\\treturn clone;\\n\\t}\\n\\n\\t_split(index) {\\n\\t\\tif (this.byStart[index] || this.byEnd[index]) return;\\n\\n\\t\\tif (DEBUG) this.stats.time('_split');\\n\\n\\t\\tlet chunk = this.lastSearchedChunk;\\n\\t\\tconst searchForward = index > chunk.end;\\n\\n\\t\\twhile (chunk) {\\n\\t\\t\\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\\n\\n\\t\\t\\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\\n\\t\\t}\\n\\t}\\n\\n\\t_splitChunk(chunk, index) {\\n\\t\\tif (chunk.edited && chunk.content.length) {\\n\\t\\t\\t// zero-length edited chunks are a special case (overlapping replacements)\\n\\t\\t\\tconst loc = getLocator(this.original)(index);\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \\\"${chunk.original}\\\")`\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tconst newChunk = chunk.split(index);\\n\\n\\t\\tthis.byEnd[index] = chunk;\\n\\t\\tthis.byStart[index] = newChunk;\\n\\t\\tthis.byEnd[newChunk.end] = newChunk;\\n\\n\\t\\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\\n\\n\\t\\tthis.lastSearchedChunk = chunk;\\n\\t\\tif (DEBUG) this.stats.timeEnd('_split');\\n\\t\\treturn true;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tlet str = this.intro;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\twhile (chunk) {\\n\\t\\t\\tstr += chunk.toString();\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t}\\n\\n\\t\\treturn str + this.outro;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tdo {\\n\\t\\t\\tif (\\n\\t\\t\\t\\t(chunk.intro.length && chunk.intro.trim()) ||\\n\\t\\t\\t\\t(chunk.content.length && chunk.content.trim()) ||\\n\\t\\t\\t\\t(chunk.outro.length && chunk.outro.trim())\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\tlet chunk = this.firstChunk;\\n\\t\\tlet length = 0;\\n\\t\\tdo {\\n\\t\\t\\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\\n\\t\\t} while ((chunk = chunk.next));\\n\\t\\treturn length;\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimEndAborted(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tthis.outro = this.outro.replace(rx, '');\\n\\t\\tif (this.outro.length) return true;\\n\\n\\t\\tlet chunk = this.lastChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimEnd(rx);\\n\\n\\t\\t\\t// if chunk was trimmed, we have a new lastChunk\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\tif (this.lastChunk === chunk) {\\n\\t\\t\\t\\t\\tthis.lastChunk = chunk.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.previous;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tthis.trimEndAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\ttrimStartAborted(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\tif (this.intro.length) return true;\\n\\n\\t\\tlet chunk = this.firstChunk;\\n\\n\\t\\tdo {\\n\\t\\t\\tconst end = chunk.end;\\n\\t\\t\\tconst aborted = chunk.trimStart(rx);\\n\\n\\t\\t\\tif (chunk.end !== end) {\\n\\t\\t\\t\\t// special case...\\n\\t\\t\\t\\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\\n\\n\\t\\t\\t\\tthis.byEnd[chunk.end] = chunk;\\n\\t\\t\\t\\tthis.byStart[chunk.next.start] = chunk.next;\\n\\t\\t\\t\\tthis.byEnd[chunk.next.end] = chunk.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (aborted) return true;\\n\\t\\t\\tchunk = chunk.next;\\n\\t\\t} while (chunk);\\n\\n\\t\\treturn false;\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tthis.trimStartAborted(charType);\\n\\t\\treturn this;\\n\\t}\\n\\n\\thasChanged() {\\n\\t\\treturn this.original !== this.toString();\\n\\t}\\n\\n\\t_replaceRegexp(searchValue, replacement) {\\n\\t\\tfunction getReplacement(match, str) {\\n\\t\\t\\tif (typeof replacement === 'string') {\\n\\t\\t\\t\\treturn replacement.replace(/\\\\$(\\\\$|&|\\\\d+)/g, (_, i) => {\\n\\t\\t\\t\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\\n\\t\\t\\t\\t\\tif (i === '$') return '$';\\n\\t\\t\\t\\t\\tif (i === '&') return match[0];\\n\\t\\t\\t\\t\\tconst num = +i;\\n\\t\\t\\t\\t\\tif (num < match.length) return match[+i];\\n\\t\\t\\t\\t\\treturn `$${i}`;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn replacement(...match, match.index, str, match.groups);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction matchAll(re, str) {\\n\\t\\t\\tlet match;\\n\\t\\t\\tconst matches = [];\\n\\t\\t\\twhile ((match = re.exec(str))) {\\n\\t\\t\\t\\tmatches.push(match);\\n\\t\\t\\t}\\n\\t\\t\\treturn matches;\\n\\t\\t}\\n\\t\\tif (searchValue.global) {\\n\\t\\t\\tconst matches = matchAll(searchValue, this.original);\\n\\t\\t\\tmatches.forEach((match) => {\\n\\t\\t\\t\\tif (match.index != null)\\n\\t\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tconst match = this.original.match(searchValue);\\n\\t\\t\\tif (match && match.index != null)\\n\\t\\t\\t\\tthis.overwrite(\\n\\t\\t\\t\\t\\tmatch.index,\\n\\t\\t\\t\\t\\tmatch.index + match[0].length,\\n\\t\\t\\t\\t\\tgetReplacement(match, this.original)\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n\\n\\t_replaceString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst index = original.indexOf(string);\\n\\n\\t\\tif (index !== -1) {\\n\\t\\t\\tthis.overwrite(index, index + string.length, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplace(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n\\n\\t_replaceAllString(string, replacement) {\\n\\t\\tconst { original } = this;\\n\\t\\tconst stringLength = string.length;\\n\\t\\tfor (\\n\\t\\t\\tlet index = original.indexOf(string);\\n\\t\\t\\tindex !== -1;\\n\\t\\t\\tindex = original.indexOf(string, index + stringLength)\\n\\t\\t) {\\n\\t\\t\\tthis.overwrite(index, index + stringLength, replacement);\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\treplaceAll(searchValue, replacement) {\\n\\t\\tif (typeof searchValue === 'string') {\\n\\t\\t\\treturn this._replaceAllString(searchValue, replacement);\\n\\t\\t}\\n\\n\\t\\tif (!searchValue.global) {\\n\\t\\t\\tthrow new TypeError(\\n\\t\\t\\t\\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn this._replaceRegexp(searchValue, replacement);\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport SourceMap from './SourceMap.js';\\nimport getRelativePath from './utils/getRelativePath.js';\\nimport isObject from './utils/isObject.js';\\nimport getLocator from './utils/getLocator.js';\\nimport Mappings from './utils/Mappings.js';\\n\\nconst hasOwnProp = Object.prototype.hasOwnProperty;\\n\\nexport default class Bundle {\\n\\tconstructor(options = {}) {\\n\\t\\tthis.intro = options.intro || '';\\n\\t\\tthis.separator = options.separator !== undefined ? options.separator : '\\\\n';\\n\\t\\tthis.sources = [];\\n\\t\\tthis.uniqueSources = [];\\n\\t\\tthis.uniqueSourceIndexByFilename = {};\\n\\t}\\n\\n\\taddSource(source) {\\n\\t\\tif (source instanceof MagicString) {\\n\\t\\t\\treturn this.addSource({\\n\\t\\t\\t\\tcontent: source,\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tseparator: this.separator,\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif (!isObject(source) || !source.content) {\\n\\t\\t\\tthrow new Error(\\n\\t\\t\\t\\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\\n\\t\\t\\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\\n\\t\\t});\\n\\n\\t\\tif (source.separator === undefined) {\\n\\t\\t\\t// TODO there's a bunch of this sort of thing, needs cleaning up\\n\\t\\t\\tsource.separator = this.separator;\\n\\t\\t}\\n\\n\\t\\tif (source.filename) {\\n\\t\\t\\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\\n\\t\\t\\t\\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\\n\\t\\t\\t\\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\\n\\t\\t\\t\\tif (source.content.original !== uniqueSource.content) {\\n\\t\\t\\t\\t\\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.sources.push(source);\\n\\t\\treturn this;\\n\\t}\\n\\n\\tappend(str, options) {\\n\\t\\tthis.addSource({\\n\\t\\t\\tcontent: new MagicString(str),\\n\\t\\t\\tseparator: (options && options.separator) || '',\\n\\t\\t});\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tclone() {\\n\\t\\tconst bundle = new Bundle({\\n\\t\\t\\tintro: this.intro,\\n\\t\\t\\tseparator: this.separator,\\n\\t\\t});\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tbundle.addSource({\\n\\t\\t\\t\\tfilename: source.filename,\\n\\t\\t\\t\\tcontent: source.content.clone(),\\n\\t\\t\\t\\tseparator: source.separator,\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\treturn bundle;\\n\\t}\\n\\n\\tgenerateDecodedMap(options = {}) {\\n\\t\\tconst names = [];\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tObject.keys(source.content.storedNames).forEach((name) => {\\n\\t\\t\\t\\tif (!~names.indexOf(name)) names.push(name);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tconst mappings = new Mappings(options.hires);\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tmappings.advance(this.intro);\\n\\t\\t}\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tif (i > 0) {\\n\\t\\t\\t\\tmappings.advance(this.separator);\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\\n\\t\\t\\tconst magicString = source.content;\\n\\t\\t\\tconst locate = getLocator(magicString.original);\\n\\n\\t\\t\\tif (magicString.intro) {\\n\\t\\t\\t\\tmappings.advance(magicString.intro);\\n\\t\\t\\t}\\n\\n\\t\\t\\tmagicString.firstChunk.eachNext((chunk) => {\\n\\t\\t\\t\\tconst loc = locate(chunk.start);\\n\\n\\t\\t\\t\\tif (chunk.intro.length) mappings.advance(chunk.intro);\\n\\n\\t\\t\\t\\tif (source.filename) {\\n\\t\\t\\t\\t\\tif (chunk.edited) {\\n\\t\\t\\t\\t\\t\\tmappings.addEdit(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk.content,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tchunk.storeName ? names.indexOf(chunk.original) : -1\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmappings.addUneditedChunk(\\n\\t\\t\\t\\t\\t\\t\\tsourceIndex,\\n\\t\\t\\t\\t\\t\\t\\tchunk,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.original,\\n\\t\\t\\t\\t\\t\\t\\tloc,\\n\\t\\t\\t\\t\\t\\t\\tmagicString.sourcemapLocations\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmappings.advance(chunk.content);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (chunk.outro.length) mappings.advance(chunk.outro);\\n\\t\\t\\t});\\n\\n\\t\\t\\tif (magicString.outro) {\\n\\t\\t\\t\\tmappings.advance(magicString.outro);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn {\\n\\t\\t\\tfile: options.file ? options.file.split(/[/\\\\\\\\]/).pop() : null,\\n\\t\\t\\tsources: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\\n\\t\\t\\t}),\\n\\t\\t\\tsourcesContent: this.uniqueSources.map((source) => {\\n\\t\\t\\t\\treturn options.includeContent ? source.content : null;\\n\\t\\t\\t}),\\n\\t\\t\\tnames,\\n\\t\\t\\tmappings: mappings.raw,\\n\\t\\t};\\n\\t}\\n\\n\\tgenerateMap(options) {\\n\\t\\treturn new SourceMap(this.generateDecodedMap(options));\\n\\t}\\n\\n\\tgetIndentString() {\\n\\t\\tconst indentStringCounts = {};\\n\\n\\t\\tthis.sources.forEach((source) => {\\n\\t\\t\\tconst indentStr = source.content._getRawIndentString();\\n\\n\\t\\t\\tif (indentStr === null) return;\\n\\n\\t\\t\\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\\n\\t\\t\\tindentStringCounts[indentStr] += 1;\\n\\t\\t});\\n\\n\\t\\treturn (\\n\\t\\t\\tObject.keys(indentStringCounts).sort((a, b) => {\\n\\t\\t\\t\\treturn indentStringCounts[a] - indentStringCounts[b];\\n\\t\\t\\t})[0] || '\\\\t'\\n\\t\\t);\\n\\t}\\n\\n\\tindent(indentStr) {\\n\\t\\tif (!arguments.length) {\\n\\t\\t\\tindentStr = this.getIndentString();\\n\\t\\t}\\n\\n\\t\\tif (indentStr === '') return this; // noop\\n\\n\\t\\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\\\n';\\n\\n\\t\\tthis.sources.forEach((source, i) => {\\n\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\tconst indentStart = trailingNewline || (i > 0 && /\\\\r?\\\\n$/.test(separator));\\n\\n\\t\\t\\tsource.content.indent(indentStr, {\\n\\t\\t\\t\\texclude: source.indentExclusionRanges,\\n\\t\\t\\t\\tindentStart, //: trailingNewline || /\\\\r?\\\\n$/.test( separator )  //true///\\\\r?\\\\n/.test( separator )\\n\\t\\t\\t});\\n\\n\\t\\t\\ttrailingNewline = source.content.lastChar() === '\\\\n';\\n\\t\\t});\\n\\n\\t\\tif (this.intro) {\\n\\t\\t\\tthis.intro =\\n\\t\\t\\t\\tindentStr +\\n\\t\\t\\t\\tthis.intro.replace(/^[^\\\\n]/gm, (match, index) => {\\n\\t\\t\\t\\t\\treturn index > 0 ? indentStr + match : match;\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\tprepend(str) {\\n\\t\\tthis.intro = str + this.intro;\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttoString() {\\n\\t\\tconst body = this.sources\\n\\t\\t\\t.map((source, i) => {\\n\\t\\t\\t\\tconst separator = source.separator !== undefined ? source.separator : this.separator;\\n\\t\\t\\t\\tconst str = (i > 0 ? separator : '') + source.content.toString();\\n\\n\\t\\t\\t\\treturn str;\\n\\t\\t\\t})\\n\\t\\t\\t.join('');\\n\\n\\t\\treturn this.intro + body;\\n\\t}\\n\\n\\tisEmpty() {\\n\\t\\tif (this.intro.length && this.intro.trim()) return false;\\n\\t\\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlength() {\\n\\t\\treturn this.sources.reduce(\\n\\t\\t\\t(length, source) => length + source.content.length(),\\n\\t\\t\\tthis.intro.length\\n\\t\\t);\\n\\t}\\n\\n\\ttrimLines() {\\n\\t\\treturn this.trim('[\\\\\\\\r\\\\\\\\n]');\\n\\t}\\n\\n\\ttrim(charType) {\\n\\t\\treturn this.trimStart(charType).trimEnd(charType);\\n\\t}\\n\\n\\ttrimStart(charType) {\\n\\t\\tconst rx = new RegExp('^' + (charType || '\\\\\\\\s') + '+');\\n\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\n\\t\\tif (!this.intro) {\\n\\t\\t\\tlet source;\\n\\t\\t\\tlet i = 0;\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tsource = this.sources[i++];\\n\\t\\t\\t\\tif (!source) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!source.content.trimStartAborted(charType));\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t}\\n\\n\\ttrimEnd(charType) {\\n\\t\\tconst rx = new RegExp((charType || '\\\\\\\\s') + '+$');\\n\\n\\t\\tlet source;\\n\\t\\tlet i = this.sources.length - 1;\\n\\n\\t\\tdo {\\n\\t\\t\\tsource = this.sources[i--];\\n\\t\\t\\tif (!source) {\\n\\t\\t\\t\\tthis.intro = this.intro.replace(rx, '');\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t} while (!source.content.trimEndAborted(charType));\\n\\n\\t\\treturn this;\\n\\t}\\n}\\n\",\"import MagicString from './MagicString.js';\\nimport Bundle from './Bundle.js';\\nimport SourceMap from './SourceMap.js';\\n\\nMagicString.Bundle = Bundle;\\nMagicString.SourceMap = SourceMap;\\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\\n\\nexport default MagicString;\\n\"],\"names\":[],\"mappings\":\"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\"}"}}}},"index.d.ts":{"file":{"contents":"export interface BundleOptions {\n  intro?: string;\n  separator?: string;\n}\n\nexport interface SourceMapOptions {\n  /**\n   * Whether the mapping should be high-resolution.\n   * Hi-res mappings map every single character, meaning (for example) your devtools will always\n   * be able to pinpoint the exact location of function calls and so on.\n   * With lo-res mappings, devtools may only be able to identify the correct\n   * line - but they're quicker to generate and less bulky.\n   * If sourcemap locations have been specified with s.addSourceMapLocation(), they will be used here.\n   */\n  hires?: boolean;\n  /**\n   * The filename where you plan to write the sourcemap.\n   */\n  file?: string;\n  /**\n   * The filename of the file containing the original source.\n   */\n  source?: string;\n  /**\n   * Whether to include the original content in the map's sourcesContent array.\n   */\n  includeContent?: boolean;\n}\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\n\nexport interface DecodedSourceMap {\n  file: string;\n  sources: string[];\n  sourcesContent: string[];\n  names: string[];\n  mappings: SourceMapSegment[][];\n}\n\nexport class SourceMap {\n  constructor(properties: DecodedSourceMap);\n\n  version: number;\n  file: string;\n  sources: string[];\n  sourcesContent: string[];\n  names: string[];\n  mappings: string;\n\n  /**\n   * Returns the equivalent of `JSON.stringify(map)`\n   */\n  toString(): string;\n  /**\n   * Returns a DataURI containing the sourcemap. Useful for doing this sort of thing:\n   * `generateMap(options?: SourceMapOptions): SourceMap;`\n   */\n  toUrl(): string;\n}\n\nexport class Bundle {\n  constructor(options?: BundleOptions);\n  addSource(source: MagicString | { filename?: string, content: MagicString }): Bundle;\n  append(str: string, options?: BundleOptions): Bundle;\n  clone(): Bundle;\n  generateMap(options?: SourceMapOptions): SourceMap;\n  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;\n  getIndentString(): string;\n  indent(indentStr?: string): Bundle;\n  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;\n  prepend(str: string): Bundle;\n  toString(): string;\n  trimLines(): Bundle;\n  trim(charType?: string): Bundle;\n  trimStart(charType?: string): Bundle;\n  trimEnd(charType?: string): Bundle;\n  isEmpty(): boolean;\n  length(): number;\n}\n\nexport type ExclusionRange = [ number, number ];\n\nexport interface MagicStringOptions {\n  filename?: string,\n  indentExclusionRanges?: ExclusionRange | Array<ExclusionRange>;\n}\n\nexport interface IndentOptions {\n  exclude?: ExclusionRange | Array<ExclusionRange>;\n  indentStart?: boolean;\n}\n\nexport interface OverwriteOptions {\n  storeName?: boolean;\n  contentOnly?: boolean;\n}\n\nexport interface UpdateOptions {\n  storeName?: boolean;\n  overwrite?: boolean;\n}\n\nexport default class MagicString {\n  constructor(str: string, options?: MagicStringOptions);\n  /**\n   * Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is false.\n   */\n  addSourcemapLocation(char: number): void;\n  /**\n   * Appends the specified content to the end of the string.\n   */\n  append(content: string): MagicString;\n  /**\n   * Appends the specified content at the index in the original string.\n   * If a range *ending* with index is subsequently moved, the insert will be moved with it. \n   * See also `s.prependLeft(...)`.\n   */\n  appendLeft(index: number, content: string): MagicString;\n  /**\n   * Appends the specified content at the index in the original string.\n   * If a range *starting* with index is subsequently moved, the insert will be moved with it.\n   * See also `s.prependRight(...)`.\n   */\n  appendRight(index: number, content: string): MagicString;\n  /**\n   * Does what you'd expect.\n   */\n  clone(): MagicString;\n  /**\n   * Generates a version 3 sourcemap.\n   */\n  generateMap(options?: SourceMapOptions): SourceMap;\n  /**\n   * Generates a sourcemap object with raw mappings in array form, rather than encoded as a string.\n   * Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.\n   */\n  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;\n  getIndentString(): string;\n\n  /**\n   * Prefixes each line of the string with prefix.\n   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.\n   */\n  indent(options?: IndentOptions): MagicString;\n  /**\n   * Prefixes each line of the string with prefix.\n   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.\n   *\n   * The options argument can have an exclude property, which is an array of [start, end] character ranges.\n   * These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.\n   */\n  indent(indentStr?: string, options?: IndentOptions): MagicString;\n  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;\n\n  /**\n   * Moves the characters from `start and `end` to `index`.\n   */\n  move(start: number, end: number, index: number): MagicString;\n  /**\n   * Replaces the characters from `start` to `end` with `content`, along with the appended/prepended content in \n   * that range. The same restrictions as `s.remove()` apply.\n   *\n   * The fourth argument is optional. It can have a storeName property — if true, the original name will be stored\n   * for later inclusion in a sourcemap's names array — and a contentOnly property which determines whether only\n   * the content is overwritten, or anything that was appended/prepended to the range as well.\n   * \n   * It may be preferred to use `s.update(...)` instead if you wish to avoid overwriting the appended/prepended content.\n   */\n  overwrite(start: number, end: number, content: string, options?: boolean | OverwriteOptions): MagicString;\n  /**\n   * Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply.\n   *\n   * The fourth argument is optional. It can have a storeName property — if true, the original name will be stored\n   * for later inclusion in a sourcemap's names array — and an overwrite property which determines whether only\n   * the content is overwritten, or anything that was appended/prepended to the range as well.\n   */\n  update(start: number, end: number, content: string, options?: boolean | UpdateOptions): MagicString;\n  /**\n   * Prepends the string with the specified content. \n   */\n  prepend(content: string): MagicString;\n  /**\n   * Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at index\n   */\n  prependLeft(index: number, content: string): MagicString;\n  /**\n   * Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n   */\n  prependRight(index: number, content: string): MagicString;\n  /**\n   * Removes the characters from `start` to `end` (of the original string, **not** the generated string).\n   * Removing the same content twice, or making removals that partially overlap, will cause an error.\n   */\n  remove(start: number, end: number): MagicString;\n  /**\n   * Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string.\n   * Throws error if the indices are for characters that were already removed.\n   */\n  slice(start: number, end: number): string;\n  /**\n   * Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.\n   */\n  snip(start: number, end: number): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start and end.\n   */\n  trim(charType?: string): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start.\n   */\n  trimStart(charType?: string): MagicString;\n  /**\n   * Trims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the end.\n   */\n  trimEnd(charType?: string): MagicString;\n  /**\n   * Removes empty lines from the start and end.\n   */\n  trimLines(): MagicString;\n  /**\n   * String replacement with RegExp or string.\n   */\n  replace(regex: RegExp | string, replacement: string | ((substring: string, ...args: any[]) => string)): MagicString;\n  /**\n   * Same as `s.replace`, but replace all matched strings instead of just one.\n   */\n  replaceAll(regex: RegExp | string, replacement: string | ((substring: string, ...args: any[]) => string)): MagicString;\n\n  lastChar(): string;\n  lastLine(): string;\n  /**\n   * Returns true if the resulting source is empty (disregarding white space).\n   */\n  isEmpty(): boolean;\n  length(): number;\n\n  /**\n   * Indicates if the string has been changed.\n   */\n  hasChanged(): boolean;\n\n  original: string;\n  /**\n   * Returns the generated string.\n   */\n  toString(): string;\n}\n"}},"LICENSE":{"file":{"contents":"Copyright 2018 Rich Harris\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"magic-string\",\n  \"version\": \"0.27.0\",\n  \"description\": \"Modify strings, generate sourcemaps\",\n  \"keywords\": [\n    \"string\",\n    \"string manipulation\",\n    \"sourcemap\",\n    \"templating\",\n    \"transpilation\"\n  ],\n  \"repository\": \"https://github.com/rich-harris/magic-string\",\n  \"license\": \"MIT\",\n  \"author\": \"Rich Harris\",\n  \"main\": \"./dist/magic-string.cjs.js\",\n  \"module\": \"./dist/magic-string.es.mjs\",\n  \"jsnext:main\": \"./dist/magic-string.es.mjs\",\n  \"types\": \"./index.d.ts\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": {\n      \"import\": \"./dist/magic-string.es.mjs\",\n      \"require\": \"./dist/magic-string.cjs.js\",\n      \"types\": \"./index.d.ts\"\n    }\n  },\n  \"files\": [\n    \"dist/*\",\n    \"index.d.ts\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"rollup -c\",\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s\",\n    \"format\": \"prettier --single-quote --print-width 100 --use-tabs --write src/*.js src/**/*.js\",\n    \"lint\": \"eslint src test\",\n    \"prepare\": \"npm run build\",\n    \"prepublishOnly\": \"rm -rf dist && npm test\",\n    \"release\": \"bumpp -x \\\"npm run changelog\\\" --all --commit --tag --push && npm publish\",\n    \"pretest\": \"npm run lint && npm run build\",\n    \"test\": \"mocha\",\n    \"bench\": \"npm run build && node benchmark/index.mjs\",\n    \"watch\": \"rollup -cw\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-node-resolve\": \"^14.1.0\",\n    \"@rollup/plugin-replace\": \"^4.0.0\",\n    \"benchmark\": \"^2.1.4\",\n    \"bumpp\": \"^8.2.1\",\n    \"conventional-changelog-cli\": \"^2.2.2\",\n    \"eslint\": \"^8.23.1\",\n    \"mocha\": \"^10.0.0\",\n    \"prettier\": \"^2.7.1\",\n    \"rollup\": \"^2.79.1\",\n    \"source-map-js\": \"^1.0.2\",\n    \"source-map-support\": \"^0.5.21\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"dependencies\": {\n    \"@jridgewell/sourcemap-codec\": \"^1.4.13\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# magic-string\n\n<a href=\"https://travis-ci.org/Rich-Harris/magic-string\">\n  <img src=\"http://img.shields.io/travis/Rich-Harris/magic-string.svg\"\n       alt=\"build status\">\n</a>\n<a href=\"https://npmjs.org/package/magic-string\">\n  <img src=\"https://img.shields.io/npm/v/magic-string.svg\"\n       alt=\"npm version\">\n</a>\n<a href=\"https://github.com/Rich-Harris/magic-string/blob/master/LICENSE.md\">\n  <img src=\"https://img.shields.io/npm/l/magic-string.svg\"\n       alt=\"license\">\n</a>\n\nSuppose you have some source code. You want to make some light modifications to it - replacing a few characters here and there, wrapping it with a header and footer, etc - and ideally you'd like to generate a [source map](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/) at the end of it. You've thought about using something like [recast](https://github.com/benjamn/recast) (which allows you to generate an AST from some JavaScript, manipulate it, and reprint it with a sourcemap without losing your comments and formatting), but it seems like overkill for your needs (or maybe the source code isn't JavaScript).\n\nYour requirements are, frankly, rather niche. But they're requirements that I also have, and for which I made magic-string. It's a small, fast utility for manipulating strings and generating sourcemaps.\n\n## Installation\n\nmagic-string works in both node.js and browser environments. For node, install with npm:\n\n```bash\nnpm i magic-string\n```\n\nTo use in browser, grab the [magic-string.umd.js](https://unpkg.com/magic-string/dist/magic-string.umd.js) file and add it to your page:\n\n```html\n<script src='magic-string.umd.js'></script>\n```\n\n(It also works with various module systems, if you prefer that sort of thing - it has a dependency on [vlq](https://github.com/Rich-Harris/vlq).)\n\n## Usage\n\nThese examples assume you're in node.js, or something similar:\n\n```js\nimport MagicString from 'magic-string';\nimport fs from 'fs'\n\nconst s = new MagicString('problems = 99');\n\ns.update(0, 8, 'answer');\ns.toString(); // 'answer = 99'\n\ns.update(11, 13, '42'); // character indices always refer to the original string\ns.toString(); // 'answer = 42'\n\ns.prepend('var ').append(';'); // most methods are chainable\ns.toString(); // 'var answer = 42;'\n\nconst map = s.generateMap({\n  source: 'source.js',\n  file: 'converted.js.map',\n  includeContent: true\n}); // generates a v3 sourcemap\n\nfs.writeFileSync('converted.js', s.toString());\nfs.writeFileSync('converted.js.map', map.toString());\n```\n\nYou can pass an options argument:\n\n```js\nconst s = new MagicString(someCode, {\n  // both these options will be used if you later\n  // call `bundle.addSource( s )` - see below\n  filename: 'foo.js',\n  indentExclusionRanges: [/*...*/]\n});\n```\n\n## Methods\n\n### s.addSourcemapLocation( index )\n\nAdds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is `false` (see below).\n\n### s.append( content )\n\nAppends the specified content to the end of the string. Returns `this`.\n\n### s.appendLeft( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *ending* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependLeft(...)`.\n\n### s.appendRight( index, content )\n\nAppends the specified `content` at the `index` in the original string. If a range *starting* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependRight(...)`.\n\n### s.clone()\n\nDoes what you'd expect.\n\n### s.generateDecodedMap( options )\n\nGenerates a sourcemap object with raw mappings in array form, rather than encoded as a string. See `generateMap` documentation below for options details. Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.\n\n### s.generateMap( options )\n\nGenerates a [version 3 sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit). All options are, well, optional:\n\n* `file` - the filename where you plan to write the sourcemap\n* `source` - the filename of the file containing the original source\n* `includeContent` - whether to include the original content in the map's `sourcesContent` array\n* `hires` - whether the mapping should be high-resolution. Hi-res mappings map every single character, meaning (for example) your devtools will always be able to pinpoint the exact location of function calls and so on. With lo-res mappings, devtools may only be able to identify the correct line - but they're quicker to generate and less bulky. If sourcemap locations have been specified with `s.addSourceMapLocation()`, they will be used here.\n\nThe returned sourcemap has two (non-enumerable) methods attached for convenience:\n\n* `toString` - returns the equivalent of `JSON.stringify(map)`\n* `toUrl` - returns a DataURI containing the sourcemap. Useful for doing this sort of thing:\n\n```js\ncode += '\\n//# sourceMappingURL=' + map.toUrl();\n```\n\n### s.hasChanged()\n\nIndicates if the string has been changed.\n\n### s.indent( prefix[, options] )\n\nPrefixes each line of the string with `prefix`. If `prefix` is not supplied, the indentation will be guessed from the original content, falling back to a single tab character. Returns `this`.\n\nThe `options` argument can have an `exclude` property, which is an array of `[start, end]` character ranges. These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.\n\n### s.insertLeft( index, content )\n\n**DEPRECATED** since 0.17 – use `s.appendLeft(...)` instead\n\n### s.insertRight( index, content )\n\n**DEPRECATED** since 0.17 – use `s.prependRight(...)` instead\n\n### s.isEmpty()\n\nReturns true if the resulting source is empty (disregarding white space).\n\n### s.locate( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.locateOrigin( index )\n\n**DEPRECATED** since 0.10 – see [#30](https://github.com/Rich-Harris/magic-string/pull/30)\n\n### s.move( start, end, index )\n\nMoves the characters from `start` and `end` to `index`. Returns `this`.\n\n### s.overwrite( start, end, content[, options] )\n\nReplaces the characters from `start` to `end` with `content`, along with the appended/prepended content in that range. The same restrictions as `s.remove()` apply. Returns `this`.\n\nThe fourth argument is optional. It can have a `storeName` property — if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array — and a `contentOnly` property which determines whether only the content is overwritten, or anything that was appended/prepended to the range as well.\n\nIt may be preferred to use `s.update(...)` instead if you wish to avoid overwriting the appended/prepended content.\n\n### s.prepend( content )\n\nPrepends the string with the specified content. Returns `this`.\n\n### s.prependLeft ( index, content )\n\nSame as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.prependRight ( index, content )\n\nSame as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`\n\n### s.replace( regexpOrString, substitution )\n\nString replacement with RegExp or string. When using a RegExp, replacer function is also supported. Returns `this`.\n\n```ts\nimport MagicString from 'magic-string'\n\nconst s = new MagicString(source)\n\ns.replace('foo', 'bar')\ns.replace(/foo/g, 'bar')\ns.replace(/(\\w)(\\d+)/g, (_, $1, $2) => $1.toUpperCase() + $2)\n```\n\nThe differences from [`String.replace`]((https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)):\n- It will always match against the **original string**\n- It mutates the magic string state (use `.clone()` to be immutable)\n\n### s.replaceAll( regexpOrString, substitution )\n\nSame as `s.replace`, but replace all matched strings instead of just one.\nIf `substitution` is a regex, then it must have the global (`g`) flag set, or a `TypeError` is thrown. Matches the behavior of the bultin [`String.property.replaceAll`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll).\n\n### s.remove( start, end )\n\nRemoves the characters from `start` to `end` (of the original string, **not** the generated string). Removing the same content twice, or making removals that partially overlap, will cause an error. Returns `this`.\n\n### s.slice( start, end )\n\nReturns the content of the generated string that corresponds to the slice between `start` and `end` of the original string. Throws error if the indices are for characters that were already removed.\n\n### s.snip( start, end )\n\nReturns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.\n\n### s.toString()\n\nReturns the generated string.\n\n### s.trim([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start and end. Returns `this`.\n\n### s.trimStart([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the start. Returns `this`.\n\n### s.trimEnd([ charType ])\n\nTrims content matching `charType` (defaults to `\\s`, i.e. whitespace) from the end. Returns `this`.\n\n### s.trimLines()\n\nRemoves empty lines from the start and end. Returns `this`.\n\n### s.update( start, end, content[, options] )\n\nReplaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply. Returns `this`.\n\nThe fourth argument is optional. It can have a `storeName` property — if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array — and an `overwrite` property which defaults to `false` and determines whether anything that was appended/prepended to the range will be overwritten along with the original content.\n\n`s.update(start, end, content)` is equivalent to `s.overwrite(start, end, content, { contentOnly: true })`.\n\n## Bundling\n\nTo concatenate several sources, use `MagicString.Bundle`:\n\n```js\nconst bundle = new MagicString.Bundle();\n\nbundle.addSource({\n  filename: 'foo.js',\n  content: new MagicString('var answer = 42;')\n});\n\nbundle.addSource({\n  filename: 'bar.js',\n  content: new MagicString('console.log( answer )')\n});\n\n// Advanced: a source can include an `indentExclusionRanges` property\n// alongside `filename` and `content`. This will be passed to `s.indent()`\n// - see documentation above\n\nbundle.indent() // optionally, pass an indent string, otherwise it will be guessed\n  .prepend('(function () {\\n')\n  .append('}());');\n\nbundle.toString();\n// (function () {\n//   var answer = 42;\n//   console.log( answer );\n// }());\n\n// options are as per `s.generateMap()` above\nconst map = bundle.generateMap({\n  file: 'bundle.js',\n  includeContent: true,\n  hires: true\n});\n```\n\nAs an alternative syntax, if you a) don't have `filename` or `indentExclusionRanges` options, or b) passed those in when you used `new MagicString(...)`, you can simply pass the `MagicString` instance itself:\n\n```js\nconst bundle = new MagicString.Bundle();\nconst source = new MagicString(someCode, {\n  filename: 'foo.js'\n});\n\nbundle.addSource(source);\n```\n\n## License\n\nMIT\n"}}}}}},"package.json":{"file":{"contents":"{\r\n  \"name\": \"svelte-preprocess\",\r\n  \"version\": \"5.0.1\",\r\n  \"license\": \"MIT\",\r\n  \"main\": \"dist/index.js\",\r\n  \"types\": \"dist/index.d.ts\",\r\n  \"description\": \"A Svelte preprocessor wrapper with baked-in support for commonly used preprocessors\",\r\n  \"author\": \"Christian Kaisermann <christian@kaisermann.me>\",\r\n  \"repository\": \"https://github.com/sveltejs/svelte-preprocess\",\r\n  \"keywords\": [\r\n    \"svelte\",\r\n    \"preprocess\",\r\n    \"less\",\r\n    \"stylus\",\r\n    \"sass\",\r\n    \"scss\",\r\n    \"pug\",\r\n    \"coffeescript\"\r\n  ],\r\n  \"engines\": {\r\n    \"node\": \">= 14.10.0\"\r\n  },\r\n  \"volta\": {\r\n    \"node\": \"14.19.2\"\r\n  },\r\n  \"files\": [\r\n    \"dist/\"\r\n  ],\r\n  \"scripts\": {\r\n    \"prebuild\": \"node scripts.js rmrf ./dist\",\r\n    \"build\": \"tsc --build tsconfig.build.json\",\r\n    \"dev\": \"pnpm build -w\",\r\n    \"test\": \"jest\",\r\n    \"lint\": \"eslint --ext js,ts .\",\r\n    \"format\": \"prettier --write \\\"**/*.{ts,js,json}\\\"\",\r\n    \"postinstall\": \"echo \\\"[svelte-preprocess] Don't forget to install the preprocessors packages that will be used: sass, stylus, less, postcss & postcss-load-config, coffeescript, pug, etc...\\\"\",\r\n    \"version\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 1 && git add CHANGELOG.md\",\r\n    \"patch\": \"npm version patch -m 'chore(release): %s'\",\r\n    \"minor\": \"npm version minor -m 'chore(release): %s'\",\r\n    \"major\": \"npm version major -m 'chore(release): %s'\",\r\n    \"prepublishOnly\": \"pnpm test && pnpm build\",\r\n    \"prepare\": \"husky install\"\r\n  },\r\n  \"commitlint\": {\r\n    \"extends\": [\r\n      \"@commitlint/config-conventional\"\r\n    ]\r\n  },\r\n  \"lint-staged\": {\r\n    \"*.{ts,js,tsx,jsx}\": [\r\n      \"eslint --fix\",\r\n      \"prettier --write\"\r\n    ],\r\n    \"*.json\": [\r\n      \"prettier --write\"\r\n    ]\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/core\": \"^7.20.5\",\r\n    \"@babel/preset-env\": \"^7.20.2\",\r\n    \"@commitlint/cli\": \"^11.0.0\",\r\n    \"@commitlint/config-conventional\": \"^11.0.0\",\r\n    \"@kiwi/eslint-config\": \"^2.0.2\",\r\n    \"@kiwi/prettier-config\": \"^2.0.2\",\r\n    \"@types/babel__core\": \"^7.1.20\",\r\n    \"@types/jest\": \"^27.5.2\",\r\n    \"@types/node\": \"^14.18.34\",\r\n    \"@types/stylus\": \"^0.48.38\",\r\n    \"autoprefixer\": \"^9.8.8\",\r\n    \"babel-minify\": \"^0.5.2\",\r\n    \"coffeescript\": \"^2.7.0\",\r\n    \"conventional-changelog-cli\": \"^2.2.2\",\r\n    \"eslint\": \"^8.29.0\",\r\n    \"husky\": \"^8.0.2\",\r\n    \"jest\": \"^27.5.1\",\r\n    \"less\": \"^3.13.1\",\r\n    \"lint-staged\": \"^10.5.4\",\r\n    \"postcss\": \"^8.4.19\",\r\n    \"postcss-easy-import\": \"^3.0.0\",\r\n    \"postcss-load-config\": \"^3.1.4\",\r\n    \"prettier\": \"^2.8.1\",\r\n    \"pug\": \"^3.0.2\",\r\n    \"sass\": \"^1.56.2\",\r\n    \"stylus\": \"^0.55.0\",\r\n    \"sugarss\": \"^4.0.0\",\r\n    \"svelte\": \"^3.54.0\",\r\n    \"ts-jest\": \"^27.1.5\",\r\n    \"typescript\": \"^4.9.4\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@types/pug\": \"^2.0.6\",\r\n    \"@types/sass\": \"^1.43.1\",\r\n    \"detect-indent\": \"^6.1.0\",\r\n    \"magic-string\": \"^0.27.0\",\r\n    \"sorcery\": \"^0.11.0\",\r\n    \"strip-indent\": \"^3.0.0\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"@babel/core\": \"^7.10.2\",\r\n    \"coffeescript\": \"^2.5.1\",\r\n    \"less\": \"^3.11.3 || ^4.0.0\",\r\n    \"postcss\": \"^7 || ^8\",\r\n    \"postcss-load-config\": \"^2.1.0 || ^3.0.0 || ^4.0.0\",\r\n    \"pug\": \"^3.0.0\",\r\n    \"sass\": \"^1.26.8\",\r\n    \"stylus\": \"^0.55.0\",\r\n    \"sugarss\": \"^2.0.0 || ^3.0.0 || ^4.0.0\",\r\n    \"svelte\": \"^3.23.0\",\r\n    \"typescript\": \"^3.9.5 || ^4.0.0\"\r\n  },\r\n  \"peerDependenciesMeta\": {\r\n    \"@babel/core\": {\r\n      \"optional\": true\r\n    },\r\n    \"coffeescript\": {\r\n      \"optional\": true\r\n    },\r\n    \"less\": {\r\n      \"optional\": true\r\n    },\r\n    \"postcss\": {\r\n      \"optional\": true\r\n    },\r\n    \"postcss-load-config\": {\r\n      \"optional\": true\r\n    },\r\n    \"pug\": {\r\n      \"optional\": true\r\n    },\r\n    \"sass\": {\r\n      \"optional\": true\r\n    },\r\n    \"stylus\": {\r\n      \"optional\": true\r\n    },\r\n    \"sugarss\": {\r\n      \"optional\": true\r\n    },\r\n    \"typescript\": {\r\n      \"optional\": true\r\n    }\r\n  }\r\n}\r\n"}},"README.md":{"file":{"contents":"# Svelte Preprocess\r\n\r\n> A [Svelte](https://svelte.dev) preprocessor with sensible defaults and support for: PostCSS, SCSS, Less, Stylus, CoffeeScript, TypeScript, Pug and much more.\r\n\r\n<p>\r\n  <a href=\"https://www.npmjs.com/package/svelte-preprocess\">\r\n    <img src=\"https://img.shields.io/npm/v/svelte-preprocess.svg\" alt=\"npm version\">\r\n  </a>\r\n\r\n  <a href=\"https://github.com/sveltejs/svelte-preprocess/blob/master/LICENSE\">\r\n    <img src=\"https://img.shields.io/npm/l/svelte-preprocess.svg\" alt=\"license\">\r\n  </a>\r\n\r\n  <a href=\"https://github.com/sveltejs/svelte-preprocess/actions?query=workflow%3ACI\">\r\n    <img src=\"https://github.com/sveltejs/svelte-preprocess/workflows/CI/badge.svg\" alt=\"action-CI\">\r\n  </a>\r\n</p>\r\n\r\n- [What is it?](#what-is-it)\r\n- [Getting Started](docs/getting-started.md)\r\n- [Usage](docs/usage.md)\r\n- [Migration Guide](docs/migration-guide.md)\r\n- [Preprocessing](docs/preprocessing.md)\r\n  - [Preprocessors](docs/preprocessing.md#preprocessors)\r\n- [Features](#features)\r\n  - [Template tag](#template-tag)\r\n  - [External files](#external-files)\r\n  - [Global style](#global-style)\r\n  - [Modern JavaScript syntax](#modern-javascript-syntax)\r\n  - [Replace values](#replace-values)\r\n  - [Built-in support for commonly used languages](#built-in-support-for-commonly-used-languages)\r\n\r\n## What is it?\r\n\r\n`Svelte`'s own parser understands only JavaScript, CSS and its HTML-like syntax. To make it possible to write components in other languages, such as TypeScript or SCSS, `Svelte` provides the [preprocess API](https://svelte.dev/docs#compile-time-svelte-preprocess), which allows to easily transform the content of your `markup` and your `style`/`script` tags.\r\n\r\nWriting your own preprocessor for, i.e SCSS is easy enough, but it can be cumbersome to have to always configure multiple preprocessors for the languages you'll be using.\r\n\r\n`svelte-preprocess` is a custom svelte preprocessor that acts as a facilitator to use other languages with Svelte, providing multiple features, sensible defaults and a less noisy development experience.\r\n\r\nIt is recommended to use with `svelte.config.js` file, located at the project root. For other usage, please refer to [usage documentation](#usage-documentation).\r\n\r\n```js\r\nimport preprocess from 'svelte-preprocess';\r\n\r\nconst config = {\r\n  preprocess: preprocess({ ... })\r\n}\r\n\r\nexport default config;\r\n```\r\n\r\n## Features\r\n\r\n### Template tag\r\n\r\n_Vue-like_ support for defining your markup between a specific tag. The default tag is `template` but it can be [customized](/docs/preprocessing.md#auto-preprocessing-options).\r\n\r\n```html\r\n<template>\r\n  <div>Hey</div>\r\n</template>\r\n\r\n<style></style>\r\n\r\n<script></script>\r\n```\r\n\r\n### External files\r\n\r\n```html\r\n<template src=\"./template.html\"></template>\r\n<script src=\"./script.js\"></script>\r\n<style src=\"./style.css\"></style>\r\n```\r\n\r\n> Note: using a relative path starting with `.` is important. Otherwise `svelte-preprocess` will ignore the `src` attribute.\r\n\r\n### Global style\r\n\r\n#### `global` attribute\r\n\r\nAdd a `global` attribute to your `style` tag and instead of scoping the CSS, all of its content will be interpreted as global style.\r\n\r\n```html\r\n<style global>\r\n  div {\r\n    color: red;\r\n  }\r\n</style>\r\n```\r\n\r\n#### `:global` rule\r\n\r\nUse a `:global` rule to only expose parts of the stylesheet:\r\n\r\n```html\r\n<style lang=\"scss\">\r\n  .scoped-style {\r\n  }\r\n\r\n  :global {\r\n    @import 'global-stylesheet.scss';\r\n\r\n    .global-style {\r\n      .global-child-style {\r\n      }\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\nWorks best with nesting-enabled CSS preprocessors, but regular CSS selectors like `div :global .global1 .global2` are also supported.\r\n\r\n_**Note**: needs PostCSS to be installed._\r\n\r\n### Modern JavaScript syntax\r\n\r\n`svelte-preprocess` allows you to run your component code through Babel before sending it to the compiler, allowing you to use new language features such as optional operators and nullish coalescing. However, note that Babel should transpile your component code to the javascript version supported by the Svelte compiler, so ES6+.\r\n\r\nFor example, with `@babel/preset-env` your config could be:\r\n\r\n```js\r\nimport preprocess from 'svelte-preprocess'\r\n  ...\r\n  preprocess: preprocess({\r\n    babel: {\r\n      presets: [\r\n        [\r\n          '@babel/preset-env',\r\n          {\r\n            loose: true,\r\n            // No need for babel to resolve modules\r\n            modules: false,\r\n            targets: {\r\n              // ! Very important. Target es6+\r\n              esmodules: true,\r\n            },\r\n          },\r\n        ],\r\n      ],\r\n    },\r\n  });\r\n  ...\r\n```\r\n\r\n_**Note:** If you want to transpile your app to be supported in older browsers, you must run babel from the context of your bundler._\r\n\r\n### Replace values\r\n\r\nReplace a set of string patterns in your components markup by passing an array of `[RegExp, ReplaceFn | string]`, the same arguments received by the `String.prototype.replace` method.\r\n\r\nIn example, to replace inject the value of `process.env.NODE_ENV`:\r\n\r\n```js\r\nautoPreprocess({\r\n  replace: [[/process\\.env\\.NODE_ENV/g, JSON.stringify(process.env.NODE_ENV)]],\r\n});\r\n```\r\n\r\nWhich, in a production environment, would turn\r\n\r\n```svelte\r\n{#if process.env.NODE_ENV !== 'development'}\r\n  <h1>Production environment!</h1>\r\n{/if}\r\n```\r\n\r\ninto\r\n\r\n```svelte\r\n{#if \"production\" !== 'development'}\r\n  <h1>Production environment!</h1>\r\n{/if}\r\n```\r\n\r\n### Built-in support for commonly used languages\r\n\r\nThe current supported languages out-of-the-box are Sass, Stylus, Less, CoffeeScript, TypeScript, Pug, PostCSS, Babel.\r\n\r\n```html\r\n<template lang=\"pug\">\r\n  div Posts +each('posts as post') a(href=\"{post.url}\") {post.title}\r\n</template>\r\n\r\n<script lang=\"ts\">\r\n  export const hello: string = 'world';\r\n</script>\r\n\r\n<style src=\"./style.scss\"></style>\r\n```\r\n\r\n---\r\n\r\n### [Getting started](/docs/getting-started.md)\r\n\r\n### [Preprocessing documentation](/docs/preprocessing.md)\r\n\r\n### [Usage documentation](/docs/usage.md)\r\n\r\n### [Migration Guide](/docs/migration-guide.md)\r\n\r\n---\r\n\r\n## License\r\n\r\n[MIT](LICENSE)\r\n"}}}}