{"directory":{"index.d.ts":{"file":{"contents":"import type { DepOptimizationOptions, SSROptions, UserConfig } from 'vite'\n\nexport interface CrawlFrameworkPkgsOptions {\n  /**\n   * Path to the root of the project that contains the `package.json`\n   */\n  root: string\n  /**\n   * Whether we're currently in a Vite build\n   */\n  isBuild: boolean\n  /**\n   * Optional. If a Vite user config is passed, the output Vite config will respect the\n   * set `optimizeDeps` and `ssr` options so it doesn't override it\n   */\n  viteUserConfig?: UserConfig\n  /**\n   * Whether this is a framework package by checking it's `package.json`.\n   * A framework package is one that exports special files that can't be processed\n   * by esbuild natively. For example, exporting `.framework` files.\n   *\n   * @example\n   * ```ts\n   * return pkgJson.keywords?.includes('my-framework')\n   * ```\n   */\n  isFrameworkPkgByJson?: (pkgJson: Record<string, any>) => boolean\n  /**\n   * Whether this is a framework package by checking it's name. This is\n   * usually used as a fast path. Return `true` or `false` if you know 100%\n   * if it's a framework package or not. Return `undefined` to fallback to\n   * `isFrameworkPkgByJson`.\n   *\n   * @example\n   * ```ts\n   * return SPECIAL_PACKAGES.includes(pkgName) || undefined\n   * ```\n   */\n  isFrameworkPkgByName?: (pkgName: string) => boolean | undefined\n  /**\n   * Whether this is a semi-framework package by checking it's `package.json`.\n   * A semi-framework package is one that **doesn't** export special files but\n   * consumes other APIs of the framework. For example, it only does\n   * `import { debounce } from 'my-framework/utils'`.\n   *\n   * @example\n   * ```ts\n   * return Object.keys(pkgJson.dependencies || {}).includes('my-framework')\n   * ```\n   */\n  isSemiFrameworkPkgByJson?: (pkgJson: Record<string, any>) => boolean\n  /**\n   * Whether this is a semi-framework package by checking it's name. This is\n   * usually used as a fast path. Return `true` or `false` if you know 100%\n   * if it's a semi-framework package or not. Return `undefined` to fallback to\n   * `isSemiFrameworkPkgByJson`.\n   *\n   * @example\n   * ```ts\n   * return SPECIAL_SEMI_PACKAGES.includes(pkgName) || undefined\n   * ```\n   */\n  isSemiFrameworkPkgByName?: (pkgName: string) => boolean | undefined\n}\n\nexport interface CrawlFrameworkPkgsResult {\n  optimizeDeps: {\n    include: string[]\n    exclude: string[]\n  }\n  ssr: {\n    noExternal: string[]\n    external: string[]\n  }\n}\n\n/**\n * Crawls for framework packages starting from `<root>/package.json` to build\n * out a partial Vite config. See the source code for details of how this is built.\n */\nexport declare function crawlFrameworkPkgs(\n  options: CrawlFrameworkPkgsOptions\n): Promise<CrawlFrameworkPkgsResult>\n\n/**\n * Find the `package.json` of a dep, starting from the parent, e.g. `process.cwd()`.\n * A simplified implementation of https://nodejs.org/api/esm.html#resolver-algorithm-specification\n * (PACKAGE_RESOLVE) for `package.json` specifically.\n */\nexport declare function findDepPkgJsonPath(\n  dep: string,\n  parent: string\n): Promise<string | undefined>\n\n/**\n * Find the closest `package.json` path by walking `dir` upwards.\n *\n * Pass a function to `predicate` to check if the current `package.json` is the\n * one you're looking for. For example, finding `package.json` that has the\n * `name` field only. Throwing inside the `predicate` is safe and acts the same\n *  as returning false.\n */\nexport declare function findClosestPkgJsonPath(\n  dir: string,\n  predicate?: (pkgJsonPath: string) => boolean | Promise<boolean>\n): Promise<string | undefined>\n\n/**\n * Check if a package needs to be optimized by Vite, aka if it's CJS-only\n */\nexport declare function pkgNeedsOptimization(\n  pkgJson: Record<string, any>,\n  pkgJsonPath: string\n): Promise<boolean>\n\n/**\n * Check if a dependency is part of an existing `optimizeDeps.exclude` config\n * @param dep Dependency to be included\n * @param optimizeDepsExclude Existing `optimizeDeps.exclude` config\n * @example\n * ```ts\n * optimizeDeps: {\n *   include: includesToAdd.filter((dep) => !isDepExcluded(dep, existingExclude))\n * }\n * ```\n */\nexport declare function isDepExcluded(\n  dep: string,\n  optimizeDepsExclude: NonNullable<DepOptimizationOptions['exclude']>\n): boolean\n\n/**\n * Check if a dependency is part of an existing `optimizeDeps.include` config\n * @param dep Dependency to be excluded\n * @param optimizeDepsInclude Existing `optimizeDeps.include` config\n * @example\n * ```ts\n * optimizeDeps: {\n *   exclude: excludesToAdd.filter((dep) => !isDepIncluded(dep, existingInclude))\n * }\n * ```\n */\nexport declare function isDepIncluded(\n  dep: string,\n  optimizeDepsInclude: NonNullable<DepOptimizationOptions['include']>\n): boolean\n\n/**\n * Check if a dependency is part of an existing `ssr.noExternal` config\n * @param dep Dependency to be excluded\n * @param ssrNoExternal Existing `ssr.noExternal` config\n * @example\n * ```ts\n * ssr: {\n *   external: externalsToAdd.filter((dep) => !isDepNoExternal(dep, existingNoExternal))\n * }\n * ```\n */\nexport declare function isDepNoExternaled(\n  dep: string,\n  ssrNoExternal: NonNullable<SSROptions['noExternal']>\n): boolean\n\n/**\n * Check if a dependency is part of an existing `ssr.external` config\n * @param dep Dependency to be noExternaled\n * @param ssrExternal Existing `ssr.external` config\n * @example\n * ```ts\n * ssr: {\n *   noExternal: noExternalsToAdd.filter((dep) => !isDepExternal(dep, existingExternal))\n * }\n * ```\n */\nexport declare function isDepExternaled(\n  dep: string,\n  ssrExternal: NonNullable<SSROptions['external']>\n): boolean\n"}},"LICENSE":{"file":{"contents":"MIT License\n\nCopyright (c) 2022 Bjorn and Dominik\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"vitefu\",\n  \"description\": \"Utilities for building frameworks with Vite\",\n  \"version\": \"0.2.4\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"types\": \"./index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"import\": \"./src/index.js\",\n      \"require\": \"./src/index.cjs\"\n    }\n  },\n  \"files\": [\n    \"src\",\n    \"index.d.ts\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/svitejs/vitefu.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/svitejs/vitefu/issues\"\n  },\n  \"keywords\": [\n    \"vite\",\n    \"framework\",\n    \"utilities\"\n  ],\n  \"peerDependencies\": {\n    \"vite\": \"^3.0.0 || ^4.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"vite\": {\n      \"optional\": true\n    }\n  },\n  \"devDependencies\": {\n    \"uvu\": \"^0.5.6\",\n    \"vite\": \"^3.2.3\"\n  },\n  \"scripts\": {\n    \"test\": \"uvu tests \\\".*\\\\.test\\\\.js\\\"\"\n  }\n}"}},"README.md":{"file":{"contents":"# vitefu\n\nUtilities for building frameworks with Vite.\n\n## Usage\n\nSee [index.d.ts](./index.d.ts).\n\n## License\n\nMIT\n"}},"src":{"directory":{"index.cjs":{"file":{"contents":"// CJS -> ESM proxy file\n// Reference: https://github.com/vitejs/vite/blob/9f268dad2e82c0f1276b1098c0a28f1cf245aa50/packages/vite/index.cjs\n\nmodule.exports = require('./sync.cjs')\n\n// redirect async functions to ESM\nconst asyncFunctions = [\n  'crawlFrameworkPkgs',\n  'findDepPkgJsonPath',\n  'findClosestPkgJsonPath',\n  'pkgNeedsOptimization'\n]\n\nfor (const fn of asyncFunctions) {\n  module.exports[fn] = function () {\n    return import('./index.js').then((mod) => mod[fn].apply(this, arguments))\n  }\n}\n"}},"index.js":{"file":{"contents":"import fs from 'node:fs/promises'\nimport fsSync from 'node:fs'\nimport path from 'node:path'\nimport {\n  isDepIncluded,\n  isDepExcluded,\n  isDepNoExternaled,\n  isDepExternaled\n} from './sync.cjs'\n\n/** @type {import('pnpapi')} */\nlet pnp\nif (process.versions.pnp) {\n  try {\n    const { createRequire } = (await import('module')).default\n    pnp = createRequire(import.meta.url)('pnpapi')\n  } catch {}\n}\n\nexport { isDepIncluded, isDepExcluded, isDepNoExternaled, isDepExternaled }\n\n/** @type {import('..').crawlFrameworkPkgs} */\nexport async function crawlFrameworkPkgs(options) {\n  const pkgJsonPath = await findClosestPkgJsonPath(options.root)\n  if (!pkgJsonPath) {\n    // @ts-expect-error don't throw in deno as package.json is not required\n    if (typeof Deno !== 'undefined') {\n      return {\n        optimizeDeps: { include: [], exclude: [] },\n        ssr: { noExternal: [], external: [] }\n      }\n    } else {\n      throw new Error(`Cannot find package.json from ${options.root}`)\n    }\n  }\n  const pkgJson = await readJson(pkgJsonPath).catch((e) => {\n    throw new Error(`Unable to read ${pkgJsonPath}`, { cause: e })\n  })\n\n  /** @type {string[]} */\n  let optimizeDepsInclude = []\n  /** @type {string[]} */\n  let optimizeDepsExclude = []\n  /** @type {string[]} */\n  let ssrNoExternal = []\n  /** @type {string[]} */\n  let ssrExternal = []\n\n  await crawl(pkgJsonPath, pkgJson)\n\n  // respect vite user config\n  if (options.viteUserConfig) {\n    // remove includes that are explicitly excluded in optimizeDeps\n    const _optimizeDepsExclude = options.viteUserConfig?.optimizeDeps?.exclude\n    if (_optimizeDepsExclude) {\n      optimizeDepsInclude = optimizeDepsInclude.filter(\n        (dep) => !isDepExcluded(dep, _optimizeDepsExclude)\n      )\n    }\n    // remove excludes that are explicitly included in optimizeDeps\n    const _optimizeDepsInclude = options.viteUserConfig?.optimizeDeps?.include\n    if (_optimizeDepsInclude) {\n      optimizeDepsExclude = optimizeDepsExclude.filter(\n        (dep) => !isDepIncluded(dep, _optimizeDepsInclude)\n      )\n    }\n    // remove noExternals that are explicitly externalized\n    const _ssrExternal = options.viteUserConfig?.ssr?.external\n    if (_ssrExternal) {\n      ssrNoExternal = ssrNoExternal.filter(\n        (dep) => !isDepExternaled(dep, _ssrExternal)\n      )\n    }\n    // remove externals that are explicitly noExternal\n    const _ssrNoExternal = options.viteUserConfig?.ssr?.noExternal\n    if (_ssrNoExternal) {\n      ssrExternal = ssrExternal.filter(\n        (dep) => !isDepNoExternaled(dep, _ssrNoExternal)\n      )\n    }\n  }\n\n  return {\n    optimizeDeps: {\n      include: optimizeDepsInclude,\n      exclude: optimizeDepsExclude\n    },\n    ssr: {\n      noExternal: ssrNoExternal,\n      external: ssrExternal\n    }\n  }\n\n  /**\n   * crawl the package.json dependencies for framework packages. rules:\n   * 1. a framework package should be `optimizeDeps.exclude` and `ssr.noExternal`.\n   * 2. the deps of the framework package should be `optimizeDeps.include` and `ssr.external`\n   *    unless the dep is also a framework package, in which case do no1 & no2 recursively.\n   * 3. any non-framework packages that aren't imported by a framework package can be skipped entirely.\n   * 4. a semi-framework package is like a framework package, except it isn't `optimizeDeps.exclude`,\n   *    but only applies `ssr.noExternal`.\n   * @param {string} pkgJsonPath\n   * @param {Record<string, any>} pkgJson\n   * @param {string[]} [parentDepNames]\n   */\n  async function crawl(pkgJsonPath, pkgJson, parentDepNames = []) {\n    const isRoot = parentDepNames.length === 0\n\n    /** @type {string[]} */\n    let deps = [\n      ...Object.keys(pkgJson.dependencies || {}),\n      ...(isRoot ? Object.keys(pkgJson.devDependencies || {}) : [])\n    ]\n\n    deps = deps.filter((dep) => {\n      // skip circular deps\n      if (parentDepNames.includes(dep)) {\n        return false\n      }\n\n      const isFrameworkPkg = options.isFrameworkPkgByName?.(dep)\n      const isSemiFrameworkPkg = options.isSemiFrameworkPkgByName?.(dep)\n      if (isFrameworkPkg) {\n        // framework packages should be excluded from optimization as esbuild can't handle them.\n        // otherwise it'll cause https://github.com/vitejs/vite/issues/3910\n        optimizeDepsExclude.push(dep)\n        // framework packages should be noExternal so that they go through vite's transformation\n        // pipeline, since nodejs can't support them.\n        ssrNoExternal.push(dep)\n      } else if (isSemiFrameworkPkg) {\n        // semi-framework packages should do the same except for optimization exclude as they\n        // aren't needed to work (they don't contain raw framework components)\n        ssrNoExternal.push(dep)\n      }\n\n      // only those that are explictly false can skip crawling since we don't need to do anything\n      // special for them\n      if (isFrameworkPkg === false || isSemiFrameworkPkg === false) {\n        return false\n      }\n      // if `true`, we need to crawl the nested deps to deep include and ssr externalize them in dev.\n      // if `undefined`, it's the same as \"i don't know\". we need to crawl and find the package.json\n      // to find out.\n      else {\n        return true\n      }\n    })\n\n    const promises = deps.map(async (dep) => {\n      const depPkgJsonPath = await findDepPkgJsonPath(dep, pkgJsonPath)\n      if (!depPkgJsonPath) return\n      const depPkgJson = await readJson(depPkgJsonPath).catch(() => {})\n      if (!depPkgJson) return\n\n      // fast path if this dep is already a framework dep based on the filter condition above\n      const cachedIsFrameworkPkg = ssrNoExternal.includes(dep)\n      if (cachedIsFrameworkPkg) {\n        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep))\n      }\n\n      // check if this dep is a framework dep, if so, track and crawl it\n      const isFrameworkPkg = options.isFrameworkPkgByJson?.(depPkgJson)\n      const isSemiFrameworkPkg = options.isSemiFrameworkPkgByJson?.(depPkgJson)\n      if (isFrameworkPkg || isSemiFrameworkPkg) {\n        // see explanation in filter condition above\n        if (isFrameworkPkg) {\n          optimizeDepsExclude.push(dep)\n          ssrNoExternal.push(dep)\n        } else if (isSemiFrameworkPkg) {\n          ssrNoExternal.push(dep)\n        }\n        return crawl(depPkgJsonPath, depPkgJson, parentDepNames.concat(dep))\n      }\n\n      // if we're crawling in a non-root state, the parent is 100% a framework package\n      // because of the above if block. in this case, if it's dep of a non-framework\n      // package, handle special cases for them.\n      if (!isRoot) {\n        // deep include it if it's a CJS package, so it becomes ESM and vite is happy.\n        if (await pkgNeedsOptimization(depPkgJson, depPkgJsonPath)) {\n          optimizeDepsInclude.push(parentDepNames.concat(dep).join(' > '))\n        }\n        // also externalize it in dev so it doesn't trip vite's SSR transformation.\n        // we do in dev only as build cannot access deep external packages in strict\n        // dependency installations, such as pnpm.\n        if (!options.isBuild && !ssrExternal.includes(dep)) {\n          ssrExternal.push(dep)\n        }\n      }\n    })\n\n    await Promise.all(promises)\n  }\n}\n\n/** @type {import('..').findDepPkgJsonPath} */\nexport async function findDepPkgJsonPath(dep, parent) {\n  if (pnp) {\n    const depRoot = pnp.resolveToUnqualified(dep, parent)\n    if (!depRoot) return undefined\n    return path.join(depRoot, 'package.json')\n  }\n\n  let root = await findClosestPkgJsonPath(parent)\n  if (!root) return undefined\n  root = path.dirname(root)\n  while (root) {\n    const pkg = path.join(root, 'node_modules', dep, 'package.json')\n    try {\n      await fs.access(pkg)\n      // use 'node:fs' version to match 'vite:resolve' and avoid realpath.native quirk\n      // https://github.com/sveltejs/vite-plugin-svelte/issues/525#issuecomment-1355551264\n      return fsSync.realpathSync(pkg)\n    } catch {}\n    const nextRoot = path.dirname(root)\n    if (nextRoot === root) break\n    root = nextRoot\n  }\n  return undefined\n}\n\n/** @type {import('..').findClosestPkgJsonPath} */\nexport async function findClosestPkgJsonPath(dir, predicate = undefined) {\n  if (dir.endsWith('package.json')) {\n    dir = path.dirname(dir)\n  }\n  while (dir) {\n    const pkg = path.join(dir, 'package.json')\n    try {\n      const stat = await fs.stat(pkg)\n      if (stat.isFile() && (!predicate || (await predicate(pkg)))) {\n        return pkg\n      }\n    } catch {}\n    const nextDir = path.dirname(dir)\n    if (nextDir === dir) break\n    dir = nextDir\n  }\n  return undefined\n}\n\n/** @type {import('..').pkgNeedsOptimization} */\nexport async function pkgNeedsOptimization(pkgJson, pkgJsonPath) {\n  // only optimize if is cjs, using the below as heuristic\n  // see https://github.com/sveltejs/vite-plugin-svelte/issues/162\n  if (pkgJson.module || pkgJson.exports) return false\n  // if have main, ensure entry is js so vite can prebundle it\n  // see https://github.com/sveltejs/vite-plugin-svelte/issues/233\n  if (pkgJson.main) {\n    const entryExt = path.extname(pkgJson.main)\n    return !entryExt || entryExt === '.js' || entryExt === '.cjs'\n  }\n  // check if has implicit index.js entrypoint to prebundle\n  // see https://github.com/sveltejs/vite-plugin-svelte/issues/281\n  // see https://github.com/solidjs/vite-plugin-solid/issues/70#issuecomment-1306488154\n  try {\n    await fs.access(path.join(path.dirname(pkgJsonPath), 'index.js'))\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string} findDepPkgJsonPath\n * @returns {Promise<Record<string, any>>}\n */\nasync function readJson(findDepPkgJsonPath) {\n  return JSON.parse(await fs.readFile(findDepPkgJsonPath, 'utf8'))\n}\n"}},"sync.cjs":{"file":{"contents":"// contains synchronous API only so it can be exported as CJS and ESM\n\n/** @type {import('..').isDepIncluded} */\nfunction isDepIncluded(dep, optimizeDepsInclude) {\n  return optimizeDepsInclude.some((id) => parseIncludeStr(id) === dep)\n}\n\n/** @type {import('..').isDepExcluded} */\nfunction isDepExcluded(dep, optimizeDepsExclude) {\n  dep = parseIncludeStr(dep)\n  return optimizeDepsExclude.some(\n    (id) => id === dep || dep.startsWith(`${id}/`)\n  )\n}\n\n/** @type {import('..').isDepNoExternaled} */\nfunction isDepNoExternaled(dep, ssrNoExternal) {\n  if (ssrNoExternal === true) {\n    return true\n  } else {\n    return isMatch(dep, ssrNoExternal)\n  }\n}\n\n/** @type {import('..').isDepExternaled} */\nfunction isDepExternaled(dep, ssrExternal) {\n  return ssrExternal.includes(dep)\n}\n\n/**\n * @param {string} raw could be \"foo\" or \"foo > bar\" etc\n */\nfunction parseIncludeStr(raw) {\n  const lastArrow = raw.lastIndexOf('>')\n  return lastArrow === -1 ? raw : raw.slice(lastArrow + 1).trim()\n}\n\n/**\n * @param {string} target\n * @param {string | RegExp | (string | RegExp)[]} pattern\n */\nfunction isMatch(target, pattern) {\n  if (Array.isArray(pattern)) {\n    return pattern.some((p) => isMatch(target, p))\n  } else if (typeof pattern === 'string') {\n    return target === pattern\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(target)\n  }\n}\n\nmodule.exports = {\n  isDepIncluded,\n  isDepExcluded,\n  isDepNoExternaled,\n  isDepExternaled\n}\n"}}}}}}