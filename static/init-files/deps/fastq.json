{"directory":{".github":{"directory":{"dependabot.yml":{"file":{"contents":"version: 2\nupdates:\n- package-ecosystem: npm\n  directory: \"/\"\n  schedule:\n    interval: daily\n  open-pull-requests-limit: 10\n  ignore:\n  - dependency-name: standard\n    versions:\n    - 16.0.3\n"}},"workflows":{"directory":{"ci.yml":{"file":{"contents":"name: ci\n\non: [push, pull_request]\n\njobs:\n  legacy:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: ['0.10', '0.12', 4.x, 6.x, 8.x]\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Use Node.js\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Install\n        run: |\n          npm install --production && npm install tape\n\n      - name: Run tests\n        run: |\n          npm run legacy\n\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x, 12.x, 13.x, 14.x, 15.x, 16.x]\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Use Node.js\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n\n      - name: Install\n        run: |\n          npm install\n\n      - name: Run tests\n        run: |\n          npm run test\n"}}}}}},"bench.js":{"file":{"contents":"'use strict'\n\nconst max = 1000000\nconst fastqueue = require('./')(worker, 1)\nconst { promisify } = require('util')\nconst immediate = promisify(setImmediate)\nconst qPromise = require('./').promise(immediate, 1)\nconst async = require('async')\nconst neo = require('neo-async')\nconst asyncqueue = async.queue(worker, 1)\nconst neoqueue = neo.queue(worker, 1)\n\nfunction bench (func, done) {\n  const key = max + '*' + func.name\n  let count = -1\n\n  console.time(key)\n  end()\n\n  function end () {\n    if (++count < max) {\n      func(end)\n    } else {\n      console.timeEnd(key)\n      if (done) {\n        done()\n      }\n    }\n  }\n}\n\nfunction benchFastQ (done) {\n  fastqueue.push(42, done)\n}\n\nfunction benchAsyncQueue (done) {\n  asyncqueue.push(42, done)\n}\n\nfunction benchNeoQueue (done) {\n  neoqueue.push(42, done)\n}\n\nfunction worker (arg, cb) {\n  setImmediate(cb)\n}\n\nfunction benchSetImmediate (cb) {\n  worker(42, cb)\n}\n\nfunction benchFastQPromise (done) {\n  qPromise.push(42).then(function () { done() }, done)\n}\n\nfunction runBench (done) {\n  async.eachSeries([\n    benchSetImmediate,\n    benchFastQ,\n    benchNeoQueue,\n    benchAsyncQueue,\n    benchFastQPromise\n  ], bench, done)\n}\n\nrunBench(runBench)\n"}},"example.js":{"file":{"contents":"'use strict'\n\n/* eslint-disable no-var */\n\nvar queue = require('./')(worker, 1)\n\nqueue.push(42, function (err, result) {\n  if (err) { throw err }\n  console.log('the result is', result)\n})\n\nfunction worker (arg, cb) {\n  cb(null, 42 * 2)\n}\n"}},"example.mjs":{"file":{"contents":"import { promise as queueAsPromised } from './queue.js'\n\n/* eslint-disable */\n\nconst queue = queueAsPromised(worker, 1)\n\nconsole.log('the result is', await queue.push(42))\n\nasync function worker (arg) {\n  return 42 * 2\n}\n"}},"index.d.ts":{"file":{"contents":"declare function fastq<C, T = any, R = any>(context: C, worker: fastq.worker<C, T, R>, concurrency: number): fastq.queue<T, R>\ndeclare function fastq<C, T = any, R = any>(worker: fastq.worker<C, T, R>, concurrency: number): fastq.queue<T, R>\n\ndeclare namespace fastq {\n  type worker<C, T = any, R = any> = (this: C, task: T, cb: fastq.done<R>) => void\n  type asyncWorker<C, T = any, R = any> = (this: C, task: T) => Promise<R>\n  type done<R = any> = (err: Error | null, result?: R) => void\n  type errorHandler<T = any> = (err: Error, task: T) => void\n\n  interface queue<T = any, R = any> {\n    push(task: T, done?: done<R>): void\n    unshift(task: T, done?: done<R>): void\n    pause(): any\n    resume(): any\n    idle(): boolean\n    length(): number\n    getQueue(): T[]\n    kill(): any\n    killAndDrain(): any\n    error(handler: errorHandler<T>): void\n    concurrency: number\n    drain(): any\n    empty: () => void\n    saturated: () => void\n  }\n\n  interface queueAsPromised<T = any, R = any> extends queue<T, R> {\n    push(task: T): Promise<R>\n    unshift(task: T): Promise<R>\n    drained(): Promise<void>\n  }\n\n  function promise<C, T = any, R = any>(context: C, worker: fastq.asyncWorker<C, T, R>, concurrency: number): fastq.queueAsPromised<T, R>\n  function promise<C, T = any, R = any>(worker: fastq.asyncWorker<C, T, R>, concurrency: number): fastq.queueAsPromised<T, R>\n}\n\nexport = fastq\n"}},"LICENSE":{"file":{"contents":"Copyright (c) 2015-2020, Matteo Collina <matteo.collina@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"fastq\",\n  \"version\": \"1.15.0\",\n  \"description\": \"Fast, in memory work queue\",\n  \"main\": \"queue.js\",\n  \"scripts\": {\n    \"lint\": \"standard --verbose | snazzy\",\n    \"unit\": \"nyc --lines 100 --branches 100 --functions 100 --check-coverage --reporter=text tape test/test.js test/promise.js\",\n    \"coverage\": \"nyc --reporter=html --reporter=cobertura --reporter=text tape test/test.js test/promise.js\",\n    \"test:report\": \"npm run lint && npm run unit:report\",\n    \"test\": \"npm run lint && npm run unit && npm run typescript\",\n    \"typescript\": \"tsc --project ./test/tsconfig.json\",\n    \"legacy\": \"tape test/test.js\"\n  },\n  \"pre-commit\": [\n    \"test\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/mcollina/fastq.git\"\n  },\n  \"keywords\": [\n    \"fast\",\n    \"queue\",\n    \"async\",\n    \"worker\"\n  ],\n  \"author\": \"Matteo Collina <hello@matteocollina.com>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mcollina/fastq/issues\"\n  },\n  \"homepage\": \"https://github.com/mcollina/fastq#readme\",\n  \"devDependencies\": {\n    \"async\": \"^3.1.0\",\n    \"neo-async\": \"^2.6.1\",\n    \"nyc\": \"^15.0.0\",\n    \"pre-commit\": \"^1.2.2\",\n    \"snazzy\": \"^9.0.0\",\n    \"standard\": \"^16.0.0\",\n    \"tape\": \"^5.0.0\",\n    \"typescript\": \"^4.0.2\"\n  },\n  \"dependencies\": {\n    \"reusify\": \"^1.0.4\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"example.mjs\"\n    ]\n  }\n}\n"}},"queue.js":{"file":{"contents":"'use strict'\n\n/* eslint-disable no-var */\n\nvar reusify = require('reusify')\n\nfunction fastqueue (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  if (concurrency < 1) {\n    throw new Error('fastqueue concurrency must be greater than 1')\n  }\n\n  var cache = reusify(Task)\n  var queueHead = null\n  var queueTail = null\n  var _running = 0\n  var errorHandler = null\n\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  }\n\n  return self\n\n  function running () {\n    return _running\n  }\n\n  function pause () {\n    self.paused = true\n  }\n\n  function length () {\n    var current = queueHead\n    var counter = 0\n\n    while (current) {\n      current = current.next\n      counter++\n    }\n\n    return counter\n  }\n\n  function getQueue () {\n    var current = queueHead\n    var tasks = []\n\n    while (current) {\n      tasks.push(current.value)\n      current = current.next\n    }\n\n    return tasks\n  }\n\n  function resume () {\n    if (!self.paused) return\n    self.paused = false\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++\n      release()\n    }\n  }\n\n  function idle () {\n    return _running === 0 && self.length() === 0\n  }\n\n  function push (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n    current.errorHandler = errorHandler\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current\n        queueTail = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function unshift (value, done) {\n    var current = cache.get()\n\n    current.context = context\n    current.release = release\n    current.value = value\n    current.callback = done || noop\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead\n        queueHead = current\n      } else {\n        queueHead = current\n        queueTail = current\n        self.saturated()\n      }\n    } else {\n      _running++\n      worker.call(context, current.value, current.worked)\n    }\n  }\n\n  function release (holder) {\n    if (holder) {\n      cache.release(holder)\n    }\n    var next = queueHead\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null\n        }\n        queueHead = next.next\n        next.next = null\n        worker.call(context, next.value, next.worked)\n        if (queueTail === null) {\n          self.empty()\n        }\n      } else {\n        _running--\n      }\n    } else if (--_running === 0) {\n      self.drain()\n    }\n  }\n\n  function kill () {\n    queueHead = null\n    queueTail = null\n    self.drain = noop\n  }\n\n  function killAndDrain () {\n    queueHead = null\n    queueTail = null\n    self.drain()\n    self.drain = noop\n  }\n\n  function error (handler) {\n    errorHandler = handler\n  }\n}\n\nfunction noop () {}\n\nfunction Task () {\n  this.value = null\n  this.callback = noop\n  this.next = null\n  this.release = noop\n  this.context = null\n  this.errorHandler = null\n\n  var self = this\n\n  this.worked = function worked (err, result) {\n    var callback = self.callback\n    var errorHandler = self.errorHandler\n    var val = self.value\n    self.value = null\n    self.callback = noop\n    if (self.errorHandler) {\n      errorHandler(err, val)\n    }\n    callback.call(self.context, err, result)\n    self.release(self)\n  }\n}\n\nfunction queueAsPromised (context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker\n    worker = context\n    context = null\n  }\n\n  function asyncWrapper (arg, cb) {\n    worker.call(this, arg)\n      .then(function (res) {\n        cb(null, res)\n      }, cb)\n  }\n\n  var queue = fastqueue(context, asyncWrapper, concurrency)\n\n  var pushCb = queue.push\n  var unshiftCb = queue.unshift\n\n  queue.push = push\n  queue.unshift = unshift\n  queue.drained = drained\n\n  return queue\n\n  function push (value) {\n    var p = new Promise(function (resolve, reject) {\n      pushCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function unshift (value) {\n    var p = new Promise(function (resolve, reject) {\n      unshiftCb(value, function (err, result) {\n        if (err) {\n          reject(err)\n          return\n        }\n        resolve(result)\n      })\n    })\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop)\n\n    return p\n  }\n\n  function drained () {\n    if (queue.idle()) {\n      return new Promise(function (resolve) {\n        resolve()\n      })\n    }\n\n    var previousDrain = queue.drain\n\n    var p = new Promise(function (resolve) {\n      queue.drain = function () {\n        previousDrain()\n        resolve()\n      }\n    })\n\n    return p\n  }\n}\n\nmodule.exports = fastqueue\nmodule.exports.promise = queueAsPromised\n"}},"README.md":{"file":{"contents":"# fastq\n\n![ci][ci-url]\n[![npm version][npm-badge]][npm-url]\n[![Dependency Status][david-badge]][david-url]\n\nFast, in memory work queue.\n\nBenchmarks (1 million tasks):\n\n* setImmediate: 812ms\n* fastq: 854ms\n* async.queue: 1298ms\n* neoAsync.queue: 1249ms\n\nObtained on node 12.16.1, on a dedicated server.\n\nIf you need zero-overhead series function call, check out\n[fastseries](http://npm.im/fastseries). For zero-overhead parallel\nfunction call, check out [fastparallel](http://npm.im/fastparallel).\n\n[![js-standard-style](https://raw.githubusercontent.com/feross/standard/master/badge.png)](https://github.com/feross/standard)\n\n  * <a href=\"#install\">Installation</a>\n  * <a href=\"#usage\">Usage</a>\n  * <a href=\"#api\">API</a>\n  * <a href=\"#license\">Licence &amp; copyright</a>\n\n## Install\n\n`npm i fastq --save`\n\n## Usage (callback API)\n\n```js\n'use strict'\n\nconst queue = require('fastq')(worker, 1)\n\nqueue.push(42, function (err, result) {\n  if (err) { throw err }\n  console.log('the result is', result)\n})\n\nfunction worker (arg, cb) {\n  cb(null, arg * 2)\n}\n```\n\n## Usage (promise API)\n\n```js\nconst queue = require('fastq').promise(worker, 1)\n\nasync function worker (arg) {\n  return arg * 2\n}\n\nasync function run () {\n  const result = await queue.push(42)\n  console.log('the result is', result)\n}\n\nrun()\n```\n\n### Setting \"this\"\n\n```js\n'use strict'\n\nconst that = { hello: 'world' }\nconst queue = require('fastq')(that, worker, 1)\n\nqueue.push(42, function (err, result) {\n  if (err) { throw err }\n  console.log(this)\n  console.log('the result is', result)\n})\n\nfunction worker (arg, cb) {\n  console.log(this)\n  cb(null, arg * 2)\n}\n```\n\n### Using with TypeScript (callback API)\n\n```ts\n'use strict'\n\nimport * as fastq from \"fastq\";\nimport type { queue, done } from \"fastq\";\n\ntype Task = {\n  id: number\n}\n\nconst q: queue<Task> = fastq(worker, 1)\n\nq.push({ id: 42})\n\nfunction worker (arg: Task, cb: done) {\n  console.log(arg.id)\n  cb(null)\n}\n```\n\n### Using with TypeScript (promise API)\n\n```ts\n'use strict'\n\nimport * as fastq from \"fastq\";\nimport type { queueAsPromised } from \"fastq\";\n\ntype Task = {\n  id: number\n}\n\nconst q: queueAsPromised<Task> = fastq.promise(asyncWorker, 1)\n\nq.push({ id: 42}).catch((err) => console.error(err))\n\nasync function asyncWorker (arg: Task): Promise<void> {\n  // No need for a try-catch block, fastq handles errors automatically\n  console.log(arg.id)\n}\n```\n\n## API\n\n* <a href=\"#fastqueue\"><code>fastqueue()</code></a>\n* <a href=\"#push\"><code>queue#<b>push()</b></code></a>\n* <a href=\"#unshift\"><code>queue#<b>unshift()</b></code></a>\n* <a href=\"#pause\"><code>queue#<b>pause()</b></code></a>\n* <a href=\"#resume\"><code>queue#<b>resume()</b></code></a>\n* <a href=\"#idle\"><code>queue#<b>idle()</b></code></a>\n* <a href=\"#length\"><code>queue#<b>length()</b></code></a>\n* <a href=\"#getQueue\"><code>queue#<b>getQueue()</b></code></a>\n* <a href=\"#kill\"><code>queue#<b>kill()</b></code></a>\n* <a href=\"#killAndDrain\"><code>queue#<b>killAndDrain()</b></code></a>\n* <a href=\"#error\"><code>queue#<b>error()</b></code></a>\n* <a href=\"#concurrency\"><code>queue#<b>concurrency</b></code></a>\n* <a href=\"#drain\"><code>queue#<b>drain</b></code></a>\n* <a href=\"#empty\"><code>queue#<b>empty</b></code></a>\n* <a href=\"#saturated\"><code>queue#<b>saturated</b></code></a>\n* <a href=\"#promise\"><code>fastqueue.promise()</code></a>\n\n-------------------------------------------------------\n<a name=\"fastqueue\"></a>\n### fastqueue([that], worker, concurrency)\n\nCreates a new queue.\n\nArguments:\n\n* `that`, optional context of the `worker` function.\n* `worker`, worker function, it would be called with `that` as `this`,\n  if that is specified.\n* `concurrency`, number of concurrent tasks that could be executed in\n  parallel.\n\n-------------------------------------------------------\n<a name=\"push\"></a>\n### queue.push(task, done)\n\nAdd a task at the end of the queue. `done(err, result)` will be called\nwhen the task was processed.\n\n-------------------------------------------------------\n<a name=\"unshift\"></a>\n### queue.unshift(task, done)\n\nAdd a task at the beginning of the queue. `done(err, result)` will be called\nwhen the task was processed.\n\n-------------------------------------------------------\n<a name=\"pause\"></a>\n### queue.pause()\n\nPause the processing of tasks. Currently worked tasks are not\nstopped.\n\n-------------------------------------------------------\n<a name=\"resume\"></a>\n### queue.resume()\n\nResume the processing of tasks.\n\n-------------------------------------------------------\n<a name=\"idle\"></a>\n### queue.idle()\n\nReturns `false` if there are tasks being processed or waiting to be processed.\n`true` otherwise.\n\n-------------------------------------------------------\n<a name=\"length\"></a>\n### queue.length()\n\nReturns the number of tasks waiting to be processed (in the queue).\n\n-------------------------------------------------------\n<a name=\"getQueue\"></a>\n### queue.getQueue()\n\nReturns all the tasks be processed (in the queue). Returns empty array when there are no tasks\n\n-------------------------------------------------------\n<a name=\"kill\"></a>\n### queue.kill()\n\nRemoves all tasks waiting to be processed, and reset `drain` to an empty\nfunction.\n\n-------------------------------------------------------\n<a name=\"killAndDrain\"></a>\n### queue.killAndDrain()\n\nSame than `kill` but the `drain` function will be called before reset to empty.\n\n-------------------------------------------------------\n<a name=\"error\"></a>\n### queue.error(handler)\n\nSet a global error handler. `handler(err, task)` will be called\neach time a task is completed, `err` will be not null if the task has thrown an error.\n\n-------------------------------------------------------\n<a name=\"concurrency\"></a>\n### queue.concurrency\n\nProperty that returns the number of concurrent tasks that could be executed in\nparallel. It can be altered at runtime.\n\n-------------------------------------------------------\n<a name=\"drain\"></a>\n### queue.drain\n\nFunction that will be called when the last\nitem from the queue has been processed by a worker.\nIt can be altered at runtime.\n\n-------------------------------------------------------\n<a name=\"empty\"></a>\n### queue.empty\n\nFunction that will be called when the last\nitem from the queue has been assigned to a worker.\nIt can be altered at runtime.\n\n-------------------------------------------------------\n<a name=\"saturated\"></a>\n### queue.saturated\n\nFunction that will be called when the queue hits the concurrency\nlimit.\nIt can be altered at runtime.\n\n-------------------------------------------------------\n<a name=\"promise\"></a>\n### fastqueue.promise([that], worker(arg), concurrency)\n\nCreates a new queue with `Promise` apis. It also offers all the methods\nand properties of the object returned by [`fastqueue`](#fastqueue) with the modified\n[`push`](#pushPromise) and [`unshift`](#unshiftPromise) methods.\n\nNode v10+ is required to use the promisified version.\n\nArguments:\n* `that`, optional context of the `worker` function.\n* `worker`, worker function, it would be called with `that` as `this`,\n  if that is specified. It MUST return a `Promise`.\n* `concurrency`, number of concurrent tasks that could be executed in\n  parallel.\n\n<a name=\"pushPromise\"></a>\n#### queue.push(task) => Promise\n\nAdd a task at the end of the queue. The returned `Promise`  will be fulfilled (rejected)\nwhen the task is completed successfully (unsuccessfully).\n\nThis promise could be ignored as it will not lead to a `'unhandledRejection'`.\n\n<a name=\"unshiftPromise\"></a>\n#### queue.unshift(task) => Promise\n\nAdd a task at the beginning of the queue. The returned `Promise`  will be fulfilled (rejected)\nwhen the task is completed successfully (unsuccessfully).\n\nThis promise could be ignored as it will not lead to a `'unhandledRejection'`.\n\n<a name=\"drained\"></a>\n#### queue.drained() => Promise\n\nWait for the queue to be drained. The returned `Promise` will be resolved when all tasks in the queue have been processed by a worker.\n\nThis promise could be ignored as it will not lead to a `'unhandledRejection'`.\n\n## License\n\nISC\n\n[ci-url]: https://github.com/mcollina/fastq/workflows/ci/badge.svg\n[npm-badge]: https://badge.fury.io/js/fastq.svg\n[npm-url]: https://badge.fury.io/js/fastq\n[david-badge]: https://david-dm.org/mcollina/fastq.svg\n[david-url]: https://david-dm.org/mcollina/fastq\n"}},"test":{"directory":{"example.ts":{"file":{"contents":"import * as fastq from '../'\nimport { promise as queueAsPromised } from '../'\n\n// Basic example\n\nconst queue = fastq(worker, 1)\n\nqueue.push('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.push('push without cb')\n\nqueue.concurrency\n\nqueue.drain()\n\nqueue.empty = () => undefined\n\nconsole.log('the queue tasks are', queue.getQueue())\n\nqueue.idle()\n\nqueue.kill()\n\nqueue.killAndDrain()\n\nqueue.length\n\nqueue.pause()\n\nqueue.resume()\n\nqueue.saturated = () => undefined\n\nqueue.unshift('world', (err, result) => {\n  if (err) throw err\n  console.log('the result is', result)\n})\n\nqueue.unshift('unshift without cb')\n\nfunction worker(task: any, cb: fastq.done) {\n  cb(null, 'hello ' + task)\n}\n\n// Generics example\n\ninterface GenericsContext {\n  base: number;\n}\n\nconst genericsQueue = fastq<GenericsContext, number, string>({ base: 6 }, genericsWorker, 1)\n\ngenericsQueue.push(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\ngenericsQueue.unshift(7, (err, done) => {\n  if (err) throw err\n  console.log('the result is', done)\n})\n\nfunction genericsWorker(this: GenericsContext, task: number, cb: fastq.done<string>) {\n  cb(null, 'the meaning of life is ' + (this.base * task))\n}\n\nconst queue2 = queueAsPromised(asyncWorker, 1)\n\nasync function asyncWorker(task: any) {\n  return 'hello ' + task\n}\n\nasync function run () {\n  await queue.push(42)\n  await queue.unshift(42)\n}\n\nrun()\n"}},"promise.js":{"file":{"contents":"'use strict'\n\nconst test = require('tape')\nconst buildQueue = require('../').promise\nconst { promisify } = require('util')\nconst sleep = promisify(setTimeout)\nconst immediate = promisify(setImmediate)\n\ntest('concurrency', function (t) {\n  t.plan(2)\n  t.throws(buildQueue.bind(null, worker, 0))\n  t.doesNotThrow(buildQueue.bind(null, worker, 1))\n\n  async function worker (arg) {\n    return true\n  }\n})\n\ntest('worker execution', async function (t) {\n  const queue = buildQueue(worker, 1)\n\n  const result = await queue.push(42)\n\n  t.equal(result, true, 'result matches')\n\n  async function worker (arg) {\n    t.equal(arg, 42)\n    return true\n  }\n})\n\ntest('limit', async function (t) {\n  const queue = buildQueue(worker, 1)\n\n  const [res1, res2] = await Promise.all([queue.push(10), queue.push(0)])\n  t.equal(res1, 10, 'the result matches')\n  t.equal(res2, 0, 'the result matches')\n\n  async function worker (arg) {\n    await sleep(arg)\n    return arg\n  }\n})\n\ntest('multiple executions', async function (t) {\n  const queue = buildQueue(worker, 1)\n  const toExec = [1, 2, 3, 4, 5]\n  const expected = ['a', 'b', 'c', 'd', 'e']\n  let count = 0\n\n  await Promise.all(toExec.map(async function (task, i) {\n    const result = await queue.push(task)\n    t.equal(result, expected[i], 'the result matches')\n  }))\n\n  async function worker (arg) {\n    t.equal(arg, toExec[count], 'arg matches')\n    return expected[count++]\n  }\n})\n\ntest('drained', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  const toExec = new Array(10).fill(10)\n  let count = 0\n\n  async function worker (arg) {\n    await sleep(arg)\n    count++\n  }\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length)\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length * 2)\n})\n\ntest('drained with exception should not throw', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  const toExec = new Array(10).fill(10)\n\n  async function worker () {\n    throw new Error('foo')\n  }\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n})\n\ntest('drained with drain function', async function (t) {\n  let drainCalled = false\n  const queue = buildQueue(worker, 2)\n\n  queue.drain = function () {\n    drainCalled = true\n  }\n\n  const toExec = new Array(10).fill(10)\n  let count = 0\n\n  async function worker (arg) {\n    await sleep(arg)\n    count++\n  }\n\n  toExec.forEach(function () {\n    queue.push()\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length)\n  t.equal(drainCalled, true)\n})\n\ntest('drained while idle should resolve', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  async function worker (arg) {\n    await sleep(arg)\n  }\n\n  await queue.drained()\n})\n\ntest('drained while idle should not call the drain function', async function (t) {\n  let drainCalled = false\n  const queue = buildQueue(worker, 2)\n\n  queue.drain = function () {\n    drainCalled = true\n  }\n\n  async function worker (arg) {\n    await sleep(arg)\n  }\n\n  await queue.drained()\n\n  t.equal(drainCalled, false)\n})\n\ntest('set this', async function (t) {\n  t.plan(1)\n  const that = {}\n  const queue = buildQueue(that, worker, 1)\n\n  await queue.push(42)\n\n  async function worker (arg) {\n    t.equal(this, that, 'this matches')\n  }\n})\n\ntest('unshift', async function (t) {\n  const queue = buildQueue(worker, 1)\n  const expected = [1, 2, 3, 4]\n\n  await Promise.all([\n    queue.push(1),\n    queue.push(4),\n    queue.unshift(3),\n    queue.unshift(2)\n  ])\n\n  t.is(expected.length, 0)\n\n  async function worker (arg) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n  }\n})\n\ntest('push with worker throwing error', async function (t) {\n  t.plan(5)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n  q.error(function (err, task) {\n    t.ok(err instanceof Error, 'global error handler should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n    t.equal(task, 42, 'The task executed should be passed')\n  })\n  try {\n    await q.push(42)\n  } catch (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  }\n})\n\ntest('unshift with worker throwing error', async function (t) {\n  t.plan(2)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n  try {\n    await q.unshift(42)\n  } catch (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  }\n})\n\ntest('no unhandledRejection (push)', async function (t) {\n  function handleRejection () {\n    t.fail('unhandledRejection')\n  }\n  process.once('unhandledRejection', handleRejection)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n\n  q.push(42)\n\n  await immediate()\n  process.removeListener('unhandledRejection', handleRejection)\n})\n\ntest('no unhandledRejection (unshift)', async function (t) {\n  function handleRejection () {\n    t.fail('unhandledRejection')\n  }\n  process.once('unhandledRejection', handleRejection)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n\n  q.unshift(42)\n\n  await immediate()\n  process.removeListener('unhandledRejection', handleRejection)\n})\n"}},"test.js":{"file":{"contents":"'use strict'\n\n/* eslint-disable no-var */\n\nvar test = require('tape')\nvar buildQueue = require('../')\n\ntest('concurrency', function (t) {\n  t.plan(2)\n  t.throws(buildQueue.bind(null, worker, 0))\n  t.doesNotThrow(buildQueue.bind(null, worker, 1))\n\n  function worker (arg, cb) {\n    cb(null, true)\n  }\n})\n\ntest('worker execution', function (t) {\n  t.plan(3)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb(null, true)\n  }\n})\n\ntest('limit', function (t) {\n  t.plan(4)\n\n  var expected = [10, 0]\n  var queue = buildQueue(worker, 1)\n\n  queue.push(10, result)\n  queue.push(0, result)\n\n  function result (err, arg) {\n    t.error(err, 'no error')\n    t.equal(arg, expected.shift(), 'the result matches')\n  }\n\n  function worker (arg, cb) {\n    setTimeout(cb, arg, null, arg)\n  }\n})\n\ntest('multiple executions', function (t) {\n  t.plan(15)\n\n  var queue = buildQueue(worker, 1)\n  var toExec = [1, 2, 3, 4, 5]\n  var count = 0\n\n  toExec.forEach(function (task) {\n    queue.push(task, done)\n  })\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, toExec[count - 1], 'the result matches')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, toExec[count], 'arg matches')\n    count++\n    setImmediate(cb, null, arg)\n  }\n})\n\ntest('multiple executions, one after another', function (t) {\n  t.plan(15)\n\n  var queue = buildQueue(worker, 1)\n  var toExec = [1, 2, 3, 4, 5]\n  var count = 0\n\n  queue.push(toExec[0], done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, toExec[count - 1], 'the result matches')\n    if (count < toExec.length) {\n      queue.push(toExec[count], done)\n    }\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, toExec[count], 'arg matches')\n    count++\n    setImmediate(cb, null, arg)\n  }\n})\n\ntest('set this', function (t) {\n  t.plan(3)\n\n  var that = {}\n  var queue = buildQueue(that, worker, 1)\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(this, that, 'this matches')\n  })\n\n  function worker (arg, cb) {\n    t.equal(this, that, 'this matches')\n    cb(null, true)\n  }\n})\n\ntest('drain', function (t) {\n  t.plan(4)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  queue.drain = function () {\n    t.equal(true, worked, 'drained')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    worked = true\n    setImmediate(cb, null, true)\n  }\n})\n\ntest('pause && resume', function (t) {\n  t.plan(7)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n\n  t.notOk(queue.paused, 'it should not be paused')\n\n  queue.pause()\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  t.notOk(worked, 'it should be paused')\n  t.ok(queue.paused, 'it should be paused')\n\n  queue.resume()\n  queue.resume() // second resume is a no-op\n\n  t.notOk(queue.paused, 'it should not be paused')\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    worked = true\n    cb(null, true)\n  }\n})\n\ntest('pause in flight && resume', function (t) {\n  t.plan(9)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [42, 24]\n\n  t.notOk(queue.paused, 'it should not be paused')\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.ok(queue.paused, 'it should be paused')\n    process.nextTick(function () { queue.resume() })\n  })\n\n  queue.push(24, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.notOk(queue.paused, 'it should not be paused')\n  })\n\n  queue.pause()\n\n  function worker (arg, cb) {\n    t.equal(arg, expected.shift())\n    process.nextTick(function () { cb(null, true) })\n  }\n})\n\ntest('altering concurrency', function (t) {\n  t.plan(7)\n\n  var queue = buildQueue(worker, 1)\n  var count = 0\n\n  queue.pause()\n\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n\n  queue.concurrency = 2\n\n  queue.resume()\n\n  t.equal(queue.running(), 2, '2 jobs running')\n\n  function workDone (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  }\n\n  function worker (arg, cb) {\n    t.equal(0, count, 'works in parallel')\n    setImmediate(function () {\n      count++\n      cb(null, true)\n    })\n  }\n})\n\ntest('idle()', function (t) {\n  t.plan(12)\n\n  var queue = buildQueue(worker, 1)\n\n  t.ok(queue.idle(), 'queue is idle')\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.notOk(queue.idle(), 'queue is not idle')\n  })\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    // it will go idle after executing this function\n    setImmediate(function () {\n      t.ok(queue.idle(), 'queue is now idle')\n    })\n  })\n\n  t.notOk(queue.idle(), 'queue is not idle')\n\n  function worker (arg, cb) {\n    t.notOk(queue.idle(), 'queue is not idle')\n    t.equal(arg, 42)\n    setImmediate(cb, null, true)\n  }\n})\n\ntest('saturated', function (t) {\n  t.plan(9)\n\n  var queue = buildQueue(worker, 1)\n  var preworked = 0\n  var worked = 0\n\n  queue.saturated = function () {\n    t.pass('saturated')\n    t.equal(preworked, 1, 'started 1 task')\n    t.equal(worked, 0, 'worked zero task')\n  }\n\n  queue.push(42, done)\n  queue.push(42, done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    preworked++\n    setImmediate(function () {\n      worked++\n      cb(null, true)\n    })\n  }\n})\n\ntest('length', function (t) {\n  t.plan(7)\n\n  var queue = buildQueue(worker, 1)\n\n  t.equal(queue.length(), 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 1, 'one task waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 2, 'two tasks waiting')\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('getQueue', function (t) {\n  t.plan(10)\n\n  var queue = buildQueue(worker, 1)\n\n  t.equal(queue.getQueue().length, 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.getQueue().length, 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.getQueue().length, 1, 'one task waiting')\n  t.equal(queue.getQueue()[0], 42, 'should be equal')\n  queue.push(43, done)\n  t.equal(queue.getQueue().length, 2, 'two tasks waiting')\n  t.equal(queue.getQueue()[0], 42, 'should be equal')\n  t.equal(queue.getQueue()[1], 43, 'should be equal')\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('unshift', function (t) {\n  t.plan(8)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1, 2, 3, 4]\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('unshift && empty', function (t) {\n  t.plan(2)\n\n  var queue = buildQueue(worker, 1)\n  var completed = false\n\n  queue.pause()\n\n  queue.empty = function () {\n    t.notOk(completed, 'the task has not completed yet')\n  }\n\n  queue.unshift(1, done)\n\n  queue.resume()\n\n  function done (err, result) {\n    completed = true\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('push && empty', function (t) {\n  t.plan(2)\n\n  var queue = buildQueue(worker, 1)\n  var completed = false\n\n  queue.pause()\n\n  queue.empty = function () {\n    t.notOk(completed, 'the task has not completed yet')\n  }\n\n  queue.push(1, done)\n\n  queue.resume()\n\n  function done (err, result) {\n    completed = true\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('kill', function (t) {\n  t.plan(5)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1]\n\n  var predrain = queue.drain\n\n  queue.drain = function drain () {\n    t.fail('drain should never be called')\n  }\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n  queue.kill()\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    setImmediate(function () {\n      t.equal(queue.length(), 0, 'no queued tasks')\n      t.equal(queue.running(), 0, 'no running tasks')\n      t.equal(queue.drain, predrain, 'drain is back to default')\n    })\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('killAndDrain', function (t) {\n  t.plan(6)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1]\n\n  var predrain = queue.drain\n\n  queue.drain = function drain () {\n    t.pass('drain has been called')\n  }\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n  queue.killAndDrain()\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    setImmediate(function () {\n      t.equal(queue.length(), 0, 'no queued tasks')\n      t.equal(queue.running(), 0, 'no running tasks')\n      t.equal(queue.drain, predrain, 'drain is back to default')\n    })\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('pause && idle', function (t) {\n  t.plan(11)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n\n  t.notOk(queue.paused, 'it should not be paused')\n  t.ok(queue.idle(), 'should be idle')\n\n  queue.pause()\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  t.notOk(worked, 'it should be paused')\n  t.ok(queue.paused, 'it should be paused')\n  t.notOk(queue.idle(), 'should not be idle')\n\n  queue.resume()\n\n  t.notOk(queue.paused, 'it should not be paused')\n  t.notOk(queue.idle(), 'it should not be idle')\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    worked = true\n    process.nextTick(cb.bind(null, null, true))\n    process.nextTick(function () {\n      t.ok(queue.idle(), 'is should be idle')\n    })\n  }\n})\n\ntest('push without cb', function (t) {\n  t.plan(1)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.push(42)\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb()\n  }\n})\n\ntest('unshift without cb', function (t) {\n  t.plan(1)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.unshift(42)\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb()\n  }\n})\n\ntest('push with worker throwing error', function (t) {\n  t.plan(5)\n  var q = buildQueue(function (task, cb) {\n    cb(new Error('test error'), null)\n  }, 1)\n  q.error(function (err, task) {\n    t.ok(err instanceof Error, 'global error handler should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n    t.equal(task, 42, 'The task executed should be passed')\n  })\n  q.push(42, function (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  })\n})\n"}},"tsconfig.json":{"file":{"contents":"{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"commonjs\",\n    \"noEmit\": true,\n    \"strict\": true\n  },\n  \"files\": [\n    \"./example.ts\"\n  ]\n}\n"}}}}}}