{"directory":{"index.d.ts":{"file":{"contents":"/**\n * Match `import.meta.resolve` except that `parent` is required (you can pass\n * `import.meta.url`).\n *\n * @param {string} specifier\n *   The module specifier to resolve relative to parent\n *   (`/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`,\n *   etc).\n * @param {string} parent\n *   The absolute parent module URL to resolve from.\n *   You should pass `import.meta.url` or something else.\n * @returns {Promise<string>}\n *   Returns a promise that resolves to a full `file:`, `data:`, or `node:` URL\n *   to the found thing.\n */\nexport function resolve(specifier: string, parent: string): Promise<string>\nexport {moduleResolve} from './lib/resolve.js'\nexport type ErrnoException = import('./lib/errors.js').ErrnoException\n"}},"index.js":{"file":{"contents":"/**\n * @typedef {import('./lib/errors.js').ErrnoException} ErrnoException\n */\n\nimport {defaultResolve} from './lib/resolve.js'\n\n/**\n * Match `import.meta.resolve` except that `parent` is required (you can pass\n * `import.meta.url`).\n *\n * @param {string} specifier\n *   The module specifier to resolve relative to parent\n *   (`/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`,\n *   etc).\n * @param {string} parent\n *   The absolute parent module URL to resolve from.\n *   You should pass `import.meta.url` or something else.\n * @returns {Promise<string>}\n *   Returns a promise that resolves to a full `file:`, `data:`, or `node:` URL\n *   to the found thing.\n */\nexport async function resolve(specifier, parent) {\n  if (!parent) {\n    throw new Error(\n      'Please pass `parent`: `import-meta-resolve` cannot ponyfill that'\n    )\n  }\n\n  try {\n    return defaultResolve(specifier, {parentURL: parent}).url\n  } catch (error) {\n    const exception = /** @type {ErrnoException} */ (error)\n\n    return exception.code === 'ERR_UNSUPPORTED_DIR_IMPORT' &&\n      typeof exception.url === 'string'\n      ? exception.url\n      : Promise.reject(error)\n  }\n}\n\nexport {moduleResolve} from './lib/resolve.js'\n"}},"lib":{"directory":{"errors.d.ts":{"file":{"contents":"export namespace codes {\n  const ERR_INVALID_MODULE_SPECIFIER: new (...args: any[]) => Error\n  const ERR_INVALID_PACKAGE_CONFIG: new (...args: any[]) => Error\n  const ERR_INVALID_PACKAGE_TARGET: new (...args: any[]) => Error\n  const ERR_MODULE_NOT_FOUND: new (...args: any[]) => Error\n  const ERR_NETWORK_IMPORT_DISALLOWED: new (...args: any[]) => Error\n  const ERR_PACKAGE_IMPORT_NOT_DEFINED: new (...args: any[]) => Error\n  const ERR_PACKAGE_PATH_NOT_EXPORTED: new (...args: any[]) => Error\n  const ERR_UNSUPPORTED_DIR_IMPORT: new (...args: any[]) => Error\n  const ERR_UNKNOWN_FILE_EXTENSION: new (...args: any[]) => Error\n  const ERR_INVALID_ARG_VALUE: new (...args: any[]) => Error\n  const ERR_UNSUPPORTED_ESM_URL_SCHEME: new (...args: any[]) => Error\n}\nexport type ErrnoExceptionFields = {\n  errnode?: number | undefined\n  code?: string | undefined\n  path?: string | undefined\n  syscall?: string | undefined\n  url?: string | undefined\n}\nexport type ErrnoException = Error & ErrnoExceptionFields\nexport type MessageFunction = (...args: Array<any>) => string\n"}},"errors.js":{"file":{"contents":"/**\n * @typedef ErrnoExceptionFields\n * @property {number | undefined} [errnode]\n * @property {string | undefined} [code]\n * @property {string | undefined} [path]\n * @property {string | undefined} [syscall]\n * @property {string | undefined} [url]\n *\n * @typedef {Error & ErrnoExceptionFields} ErrnoException\n */\n\n/**\n * @typedef {(...args: Array<any>) => string} MessageFunction\n */\n\n// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/errors.js>\n// Last checked on: Jan 6, 2023.\nimport v8 from 'node:v8'\nimport process from 'node:process'\nimport assert from 'node:assert'\n// Needed for types.\n// eslint-disable-next-line no-unused-vars\nimport {URL} from 'node:url'\nimport {format, inspect} from 'node:util'\n\nconst isWindows = process.platform === 'win32'\n\nconst own = {}.hasOwnProperty\n\nexport const codes = {}\n\n/**\n * Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.\n * We cannot use Intl.ListFormat because it's not available in\n * --without-intl builds.\n *\n * @param {Array<string>} array\n *   An array of strings.\n * @param {string} [type]\n *   The list type to be inserted before the last element.\n * @returns {string}\n */\nfunction formatList(array, type = 'and') {\n  return array.length < 3\n    ? array.join(` ${type} `)\n    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`\n}\n\n/** @type {Map<string, MessageFunction|string>} */\nconst messages = new Map()\nconst nodeInternalPrefix = '__node_internal_'\n/** @type {number} */\nlet userStackTraceLimit\n\ncodes.ERR_INVALID_MODULE_SPECIFIER = createError(\n  'ERR_INVALID_MODULE_SPECIFIER',\n  /**\n   * @param {string} request\n   * @param {string} reason\n   * @param {string} [base]\n   */\n  (request, reason, base = undefined) => {\n    return `Invalid module \"${request}\" ${reason}${\n      base ? ` imported from ${base}` : ''\n    }`\n  },\n  TypeError\n)\n\ncodes.ERR_INVALID_PACKAGE_CONFIG = createError(\n  'ERR_INVALID_PACKAGE_CONFIG',\n  /**\n   * @param {string} path\n   * @param {string} [base]\n   * @param {string} [message]\n   */\n  (path, base, message) => {\n    return `Invalid package config ${path}${\n      base ? ` while importing ${base}` : ''\n    }${message ? `. ${message}` : ''}`\n  },\n  Error\n)\n\ncodes.ERR_INVALID_PACKAGE_TARGET = createError(\n  'ERR_INVALID_PACKAGE_TARGET',\n  /**\n   * @param {string} pkgPath\n   * @param {string} key\n   * @param {unknown} target\n   * @param {boolean} [isImport=false]\n   * @param {string} [base]\n   */\n  (pkgPath, key, target, isImport = false, base = undefined) => {\n    const relError =\n      typeof target === 'string' &&\n      !isImport &&\n      target.length > 0 &&\n      !target.startsWith('./')\n    if (key === '.') {\n      assert(isImport === false)\n      return (\n        `Invalid \"exports\" main target ${JSON.stringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${\n          base ? ` imported from ${base}` : ''\n        }${relError ? '; targets must start with \"./\"' : ''}`\n      )\n    }\n\n    return `Invalid \"${\n      isImport ? 'imports' : 'exports'\n    }\" target ${JSON.stringify(\n      target\n    )} defined for '${key}' in the package config ${pkgPath}package.json${\n      base ? ` imported from ${base}` : ''\n    }${relError ? '; targets must start with \"./\"' : ''}`\n  },\n  Error\n)\n\ncodes.ERR_MODULE_NOT_FOUND = createError(\n  'ERR_MODULE_NOT_FOUND',\n  /**\n   * @param {string} path\n   * @param {string} base\n   * @param {string} [type]\n   */\n  (path, base, type = 'package') => {\n    return `Cannot find ${type} '${path}' imported from ${base}`\n  },\n  Error\n)\n\ncodes.ERR_NETWORK_IMPORT_DISALLOWED = createError(\n  'ERR_NETWORK_IMPORT_DISALLOWED',\n  \"import of '%s' by %s is not supported: %s\",\n  Error\n)\n\ncodes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(\n  'ERR_PACKAGE_IMPORT_NOT_DEFINED',\n  /**\n   * @param {string} specifier\n   * @param {string} packagePath\n   * @param {string} base\n   */\n  (specifier, packagePath, base) => {\n    return `Package import specifier \"${specifier}\" is not defined${\n      packagePath ? ` in package ${packagePath}package.json` : ''\n    } imported from ${base}`\n  },\n  TypeError\n)\n\ncodes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(\n  'ERR_PACKAGE_PATH_NOT_EXPORTED',\n  /**\n   * @param {string} pkgPath\n   * @param {string} subpath\n   * @param {string} [base]\n   */\n  (pkgPath, subpath, base = undefined) => {\n    if (subpath === '.')\n      return `No \"exports\" main defined in ${pkgPath}package.json${\n        base ? ` imported from ${base}` : ''\n      }`\n    return `Package subpath '${subpath}' is not defined by \"exports\" in ${pkgPath}package.json${\n      base ? ` imported from ${base}` : ''\n    }`\n  },\n  Error\n)\n\ncodes.ERR_UNSUPPORTED_DIR_IMPORT = createError(\n  'ERR_UNSUPPORTED_DIR_IMPORT',\n  \"Directory import '%s' is not supported \" +\n    'resolving ES modules imported from %s',\n  Error\n)\n\ncodes.ERR_UNKNOWN_FILE_EXTENSION = createError(\n  'ERR_UNKNOWN_FILE_EXTENSION',\n  /**\n   * @param {string} ext\n   * @param {string} path\n   */\n  (ext, path) => {\n    return `Unknown file extension \"${ext}\" for ${path}`\n  },\n  TypeError\n)\n\ncodes.ERR_INVALID_ARG_VALUE = createError(\n  'ERR_INVALID_ARG_VALUE',\n  /**\n   * @param {string} name\n   * @param {unknown} value\n   * @param {string} [reason='is invalid']\n   */\n  (name, value, reason = 'is invalid') => {\n    let inspected = inspect(value)\n\n    if (inspected.length > 128) {\n      inspected = `${inspected.slice(0, 128)}...`\n    }\n\n    const type = name.includes('.') ? 'property' : 'argument'\n\n    return `The ${type} '${name}' ${reason}. Received ${inspected}`\n  },\n  TypeError\n  // Note: extra classes have been shaken out.\n  // , RangeError\n)\n\ncodes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError(\n  'ERR_UNSUPPORTED_ESM_URL_SCHEME',\n  /**\n   * @param {URL} url\n   * @param {Array<string>} supported\n   */\n  (url, supported) => {\n    let message = `Only URLs with a scheme in: ${formatList(\n      supported\n    )} are supported by the default ESM loader`\n\n    if (isWindows && url.protocol.length === 2) {\n      message += '. On Windows, absolute paths must be valid file:// URLs'\n    }\n\n    message += `. Received protocol '${url.protocol}'`\n    return message\n  },\n  Error\n)\n\n/**\n * Utility function for registering the error codes. Only used here. Exported\n * *only* to allow for testing.\n * @param {string} sym\n * @param {MessageFunction|string} value\n * @param {ErrorConstructor} def\n * @returns {new (...args: Array<any>) => Error}\n */\nfunction createError(sym, value, def) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym, value)\n\n  return makeNodeErrorWithCode(def, sym)\n}\n\n/**\n * @param {ErrorConstructor} Base\n * @param {string} key\n * @returns {ErrorConstructor}\n */\nfunction makeNodeErrorWithCode(Base, key) {\n  // @ts-expect-error It’s a Node error.\n  return NodeError\n  /**\n   * @param {Array<unknown>} args\n   */\n  function NodeError(...args) {\n    const limit = Error.stackTraceLimit\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0\n    const error = new Base()\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit\n    const message = getMessage(key, args, error)\n    Object.defineProperties(error, {\n      // Note: no need to implement `kIsNodeError` symbol, would be hard,\n      // probably.\n      message: {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      toString: {\n        /** @this {Error} */\n        value() {\n          return `${this.name} [${key}]: ${this.message}`\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    })\n\n    captureLargerStackTrace(error)\n    // @ts-expect-error It’s a Node error.\n    error.code = key\n    return error\n  }\n}\n\n/**\n * @returns {boolean}\n */\nfunction isErrorStackTraceLimitWritable() {\n  // Do no touch Error.stackTraceLimit as V8 would attempt to install\n  // it again during deserialization.\n  try {\n    // @ts-expect-error: not in types?\n    if (v8.startupSnapshot.isBuildingSnapshot()) {\n      return false\n    }\n  } catch {}\n\n  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit')\n  if (desc === undefined) {\n    return Object.isExtensible(Error)\n  }\n\n  return own.call(desc, 'writable') && desc.writable !== undefined\n    ? desc.writable\n    : desc.set !== undefined\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: unknown[]) => unknown} T\n * @param {T} fn\n * @returns {T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name\n  Object.defineProperty(fn, 'name', {value: hidden})\n  return fn\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  /**\n   * @param {Error} error\n   * @returns {Error}\n   */\n  // @ts-expect-error: fine\n  function (error) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable()\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit\n      Error.stackTraceLimit = Number.POSITIVE_INFINITY\n    }\n\n    Error.captureStackTrace(error)\n\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit\n\n    return error\n  }\n)\n\n/**\n * @param {string} key\n * @param {Array<unknown>} args\n * @param {Error} self\n * @returns {string}\n */\nfunction getMessage(key, args, self) {\n  const message = messages.get(key)\n  assert(typeof message !== 'undefined', 'expected `message` to be found')\n\n  if (typeof message === 'function') {\n    assert(\n      message.length <= args.length, // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${message.length}).`\n    )\n    return Reflect.apply(message, self, args)\n  }\n\n  const regex = /%[dfijoOs]/g\n  let expectedLength = 0\n  while (regex.exec(message) !== null) expectedLength++\n  assert(\n    expectedLength === args.length,\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  )\n  if (args.length === 0) return message\n\n  args.unshift(message)\n  return Reflect.apply(format, null, args)\n}\n"}},"get-format.d.ts":{"file":{"contents":"/// <reference types=\"node\" resolution-mode=\"require\"/>\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {string|null}\n */\nexport function defaultGetFormatWithoutErrors(\n  url: URL,\n  context: {\n    parentURL: string\n  }\n): string | null\n/**\n * @param {string} url\n * @param {{parentURL: string}} context\n * @returns {string|null|void}\n */\nexport function defaultGetFormat(\n  url: string,\n  context: {\n    parentURL: string\n  }\n): string | null | void\nexport type ProtocolHandler = (\n  parsed: URL,\n  context: {\n    parentURL: string\n  },\n  ignoreErrors: boolean\n) => string | null | void\nimport {URL} from 'url'\n"}},"get-format.js":{"file":{"contents":"// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/modules/esm/get_format.js>\n// Last checked on: Jan 6, 2023.\n\nimport path from 'node:path'\nimport {URL, fileURLToPath} from 'node:url'\nimport {getPackageType} from './resolve.js'\nimport {codes} from './errors.js'\n\nconst {ERR_UNKNOWN_FILE_EXTENSION} = codes\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/** @type {Record<string, string>} */\nconst extensionFormatMap = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  '.cjs': 'commonjs',\n  '.js': 'module',\n  '.json': 'json',\n  '.mjs': 'module'\n}\n\n/**\n * @param {string|null} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    mime &&\n    /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i.test(mime)\n  )\n    return 'module'\n  if (mime === 'application/json') return 'json'\n  return null\n}\n\n/**\n * @callback ProtocolHandler\n * @param {URL} parsed\n * @param {{parentURL: string}} context\n * @param {boolean} ignoreErrors\n * @returns {string|null|void}\n */\n\n/**\n * @type {Record<string, ProtocolHandler>}\n */\nconst protocolHandlers = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  'data:': getDataProtocolModuleFormat,\n  'file:': getFileProtocolModuleFormat,\n  'http:': getHttpProtocolModuleFormat,\n  'https:': getHttpProtocolModuleFormat,\n  'node:'() {\n    return 'builtin'\n  }\n}\n\n/**\n * @param {URL} parsed\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const {1: mime} = /^([^/]+\\/[^;,]+)[^,]*?(;base64)?,/.exec(\n    parsed.pathname\n  ) || [null, null, null]\n  return mimeToFormat(mime)\n}\n\n/**\n * @type {ProtocolHandler}\n */\nfunction getFileProtocolModuleFormat(url, _context, ignoreErrors) {\n  const filepath = fileURLToPath(url)\n  const ext = path.extname(filepath)\n  if (ext === '.js') {\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs'\n  }\n\n  const format = extensionFormatMap[ext]\n  if (format) return format\n\n  // Explicit undefined return indicates load hook should rerun format check\n  if (ignoreErrors) {\n    return undefined\n  }\n\n  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath)\n}\n\nfunction getHttpProtocolModuleFormat() {\n  // To do: HTTPS imports.\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {string|null}\n */\nexport function defaultGetFormatWithoutErrors(url, context) {\n  if (!hasOwnProperty.call(protocolHandlers, url.protocol)) {\n    return null\n  }\n\n  return protocolHandlers[url.protocol](url, context, true) || null\n}\n\n/**\n * @param {string} url\n * @param {{parentURL: string}} context\n * @returns {string|null|void}\n */\nexport function defaultGetFormat(url, context) {\n  const parsed = new URL(url)\n\n  return hasOwnProperty.call(protocolHandlers, parsed.protocol)\n    ? protocolHandlers[parsed.protocol](parsed, context, false)\n    : null\n}\n"}},"package-config.d.ts":{"file":{"contents":"/// <reference types=\"node\" resolution-mode=\"require\"/>\n/**\n * @param {string} path\n * @param {string|URL} specifier Note: `specifier` is actually optional, not base.\n * @param {URL} [base]\n * @returns {PackageConfig}\n */\nexport function getPackageConfig(\n  path: string,\n  specifier: string | URL,\n  base?: URL | undefined\n): PackageConfig\n/**\n * @param {URL} resolved\n * @returns {PackageConfig}\n */\nexport function getPackageScopeConfig(resolved: URL): PackageConfig\nexport type ErrnoException = import('./errors.js').ErrnoException\nexport type PackageType = 'module' | 'commonjs' | 'none'\nexport type PackageConfig = {\n  pjsonPath: string\n  exists: boolean\n  main: string | undefined\n  name: string | undefined\n  type: PackageType\n  exports: Record<string, unknown> | undefined\n  imports: Record<string, unknown> | undefined\n}\nimport {URL} from 'url'\n"}},"package-config.js":{"file":{"contents":"// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/modules/esm/package_config.js>\n// Last checked on: Jan 6, 2023.\n\n/**\n * @typedef {import('./errors.js').ErrnoException} ErrnoException\n *\n * @typedef {'module'|'commonjs'|'none'} PackageType\n *\n * @typedef PackageConfig\n * @property {string} pjsonPath\n * @property {boolean} exists\n * @property {string|undefined} main\n * @property {string|undefined} name\n * @property {PackageType} type\n * @property {Record<string, unknown>|undefined} exports\n * @property {Record<string, unknown>|undefined} imports\n */\n\nimport {URL, fileURLToPath} from 'node:url'\nimport {codes} from './errors.js'\nimport packageJsonReader from './package-json-reader.js'\n\nconst {ERR_INVALID_PACKAGE_CONFIG} = codes\n\n/** @type {Map<string, PackageConfig>} */\nconst packageJsonCache = new Map()\n\n/**\n * @param {string} path\n * @param {string|URL} specifier Note: `specifier` is actually optional, not base.\n * @param {URL} [base]\n * @returns {PackageConfig}\n */\nexport function getPackageConfig(path, specifier, base) {\n  const existing = packageJsonCache.get(path)\n  if (existing !== undefined) {\n    return existing\n  }\n\n  const source = packageJsonReader.read(path).string\n\n  if (source === undefined) {\n    /** @type {PackageConfig} */\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined\n    }\n    packageJsonCache.set(path, packageConfig)\n    return packageConfig\n  }\n\n  /** @type {Record<string, unknown>} */\n  let packageJson\n  try {\n    packageJson = JSON.parse(source)\n  } catch (error) {\n    const exception = /** @type {ErrnoException} */ (error)\n\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path,\n      (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n      exception.message\n    )\n  }\n\n  const {exports, imports, main, name, type} = packageJson\n\n  /** @type {PackageConfig} */\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main: typeof main === 'string' ? main : undefined,\n    name: typeof name === 'string' ? name : undefined,\n    type: type === 'module' || type === 'commonjs' ? type : 'none',\n    // @ts-expect-error Assume `Record<string, unknown>`.\n    exports,\n    // @ts-expect-error Assume `Record<string, unknown>`.\n    imports: imports && typeof imports === 'object' ? imports : undefined\n  }\n  packageJsonCache.set(path, packageConfig)\n  return packageConfig\n}\n\n/**\n * @param {URL} resolved\n * @returns {PackageConfig}\n */\nexport function getPackageScopeConfig(resolved) {\n  let packageJsonUrl = new URL('package.json', resolved)\n\n  while (true) {\n    const packageJsonPath = packageJsonUrl.pathname\n\n    if (packageJsonPath.endsWith('node_modules/package.json')) break\n\n    const packageConfig = getPackageConfig(\n      fileURLToPath(packageJsonUrl),\n      resolved\n    )\n    if (packageConfig.exists) return packageConfig\n\n    const lastPackageJsonUrl = packageJsonUrl\n    packageJsonUrl = new URL('../package.json', packageJsonUrl)\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break\n  }\n\n  const packageJsonPath = fileURLToPath(packageJsonUrl)\n  /** @type {PackageConfig} */\n  const packageConfig = {\n    pjsonPath: packageJsonPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined\n  }\n  packageJsonCache.set(packageJsonPath, packageConfig)\n  return packageConfig\n}\n"}},"package-json-reader.d.ts":{"file":{"contents":"export default reader\nexport type ErrnoException = import('./errors.js').ErrnoException\ndeclare namespace reader {\n  export {read}\n}\n/**\n * @param {string} jsonPath\n * @returns {{string: string|undefined}}\n */\ndeclare function read(jsonPath: string): {\n  string: string | undefined\n}\n"}},"package-json-reader.js":{"file":{"contents":"// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/modules/package_json_reader.js>\n// Last checked on: Jan 6, 2023.\n// Removed the native dependency.\n// Also: no need to cache, we do that in resolve already.\n\n/**\n * @typedef {import('./errors.js').ErrnoException} ErrnoException\n */\n\nimport fs from 'node:fs'\nimport path from 'node:path'\n\nconst reader = {read}\nexport default reader\n\n/**\n * @param {string} jsonPath\n * @returns {{string: string|undefined}}\n */\nfunction read(jsonPath) {\n  try {\n    const string = fs.readFileSync(\n      path.toNamespacedPath(path.join(path.dirname(jsonPath), 'package.json')),\n      'utf8'\n    )\n    return {string}\n  } catch (error) {\n    const exception = /** @type {ErrnoException} */ (error)\n\n    if (exception.code === 'ENOENT') {\n      return {string: undefined}\n      // Throw all other errors.\n      /* c8 ignore next 4 */\n    }\n\n    throw exception\n  }\n}\n"}},"resolve.d.ts":{"file":{"contents":"/// <reference types=\"node\" resolution-mode=\"require\"/>\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nexport function getPackageType(url: URL): PackageType\n/**\n * The “Resolver Algorithm Specification” as detailed in the Node docs (which is\n * sync and slightly lower-level than `resolve`).\n *\n * @param {string} specifier\n *   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.\n * @param {URL} base\n *   Full URL (to a file) that `specifier` is resolved relative from.\n * @param {Set<string>} [conditions]\n *   Conditions.\n * @param {boolean} [preserveSymlinks]\n *   Keep symlinks instead of resolving them.\n * @returns {URL}\n *   A URL object to the found thing.\n */\nexport function moduleResolve(\n  specifier: string,\n  base: URL,\n  conditions?: Set<string> | undefined,\n  preserveSymlinks?: boolean | undefined\n): URL\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string|null}}\n */\nexport function defaultResolve(\n  specifier: string,\n  context?: {\n    parentURL?: string\n    conditions?: Array<string>\n  }\n): {\n  url: string\n  format?: string | null\n}\nexport type ErrnoException = import('./errors.js').ErrnoException\nexport type PackageConfig = import('./package-config.js').PackageConfig\nexport type PackageType = import('./package-config.js').PackageType\nimport {URL} from 'url'\n"}},"resolve.js":{"file":{"contents":"// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/modules/esm/resolve.js>\n// Last checked on: Jan 6, 2023.\n\n/**\n * @typedef {import('./errors.js').ErrnoException} ErrnoException\n * @typedef {import('./package-config.js').PackageConfig} PackageConfig\n * @typedef {import('./package-config.js').PackageType} PackageType\n */\n\nimport assert from 'node:assert'\nimport {Stats, statSync, realpathSync} from 'node:fs'\nimport process from 'node:process'\nimport {URL, fileURLToPath, pathToFileURL} from 'node:url'\nimport path from 'node:path'\nimport {builtinModules} from 'node:module'\nimport {defaultGetFormatWithoutErrors} from './get-format.js'\nimport {codes} from './errors.js'\nimport {getPackageConfig, getPackageScopeConfig} from './package-config.js'\nimport {getConditionsSet} from './utils.js'\n\nconst RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace]\n\n// To do: potentially enable?\nconst experimentalNetworkImports = false\n\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\n} = codes\n\nconst own = {}.hasOwnProperty\n\nconst invalidSegmentRegEx =\n  /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\\\|\\/|$)/i\nconst deprecatedInvalidSegmentRegEx =\n  /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/\nconst patternRegEx = /\\*/g\nconst encodedSepRegEx = /%2f|%5c/i\n/** @type {Set<string>} */\nconst emittedPackageWarnings = new Set()\n\nconst doubleSlashRegEx = /[/\\\\]{2}/\n\n/**\n *\n * @param {string} target\n * @param {string} request\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} base\n * @param {boolean} isTarget\n */\nfunction emitInvalidSegmentDeprecation(\n  target,\n  request,\n  match,\n  packageJsonUrl,\n  internal,\n  base,\n  isTarget\n) {\n  const pjsonPath = fileURLToPath(packageJsonUrl)\n  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null\n  process.emitWarning(\n    `Use of deprecated ${\n      double ? 'double slash' : 'leading or trailing slash matching'\n    } resolving \"${target}\" for module ` +\n      `request \"${request}\" ${\n        request === match ? '' : `matched to \"${match}\" `\n      }in the \"${\n        internal ? 'imports' : 'exports'\n      }\" field module resolution of the package at ${pjsonPath}${\n        base ? ` imported from ${fileURLToPath(base)}` : ''\n      }.`,\n    'DeprecationWarning',\n    'DEP0166'\n  )\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @param {unknown} [main]\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {\n  const format = defaultGetFormatWithoutErrors(url, {parentURL: base.href})\n  if (format !== 'module') return\n  const path = fileURLToPath(url.href)\n  const pkgPath = fileURLToPath(new URL('.', packageJsonUrl))\n  const basePath = fileURLToPath(base)\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a \"main\" field set to ${JSON.stringify(main)}, ` +\n        `excluding the full filename and extension to the resolved file at \"${path.slice(\n          pkgPath.length\n        )}\", imported from ${basePath}.\\n Automatic extension resolution of the \"main\" field is` +\n        'deprecated for ES modules.',\n      'DeprecationWarning',\n      'DEP0151'\n    )\n  else\n    process.emitWarning(\n      `No \"main\" or \"exports\" field defined in the package.json for ${pkgPath} resolving the main entry point \"${path.slice(\n        pkgPath.length\n      )}\", imported from ${basePath}.\\nDefault \"index\" lookups for the main are deprecated for ES modules.`,\n      'DeprecationWarning',\n      'DEP0151'\n    )\n}\n\n/**\n * @param {string} path\n * @returns {Stats}\n */\nfunction tryStatSync(path) {\n  // Note: from Node 15 onwards we can use `throwIfNoEntry: false` instead.\n  try {\n    return statSync(path)\n  } catch {\n    return new Stats()\n  }\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n *\n * @param {URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  const stats = statSync(url, {throwIfNoEntry: false})\n  const isFile = stats ? stats.isFile() : undefined\n  return isFile === null || isFile === undefined ? false : isFile\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {PackageConfig} packageConfig\n * @param {URL} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJsonUrl, packageConfig, base) {\n  /** @type {URL|undefined} */\n  let guess\n  if (packageConfig.main !== undefined) {\n    guess = new URL(packageConfig.main, packageJsonUrl)\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess)) return guess\n\n    const tries = [\n      `./${packageConfig.main}.js`,\n      `./${packageConfig.main}.json`,\n      `./${packageConfig.main}.node`,\n      `./${packageConfig.main}/index.js`,\n      `./${packageConfig.main}/index.json`,\n      `./${packageConfig.main}/index.node`\n    ]\n    let i = -1\n\n    while (++i < tries.length) {\n      guess = new URL(tries[i], packageJsonUrl)\n      if (fileExists(guess)) break\n      guess = undefined\n    }\n\n    if (guess) {\n      emitLegacyIndexDeprecation(\n        guess,\n        packageJsonUrl,\n        base,\n        packageConfig.main\n      )\n      return guess\n    }\n    // Fallthrough.\n  }\n\n  const tries = ['./index.js', './index.json', './index.node']\n  let i = -1\n\n  while (++i < tries.length) {\n    guess = new URL(tries[i], packageJsonUrl)\n    if (fileExists(guess)) break\n    guess = undefined\n  }\n\n  if (guess) {\n    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main)\n    return guess\n  }\n\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.', packageJsonUrl)),\n    fileURLToPath(base)\n  )\n}\n\n/**\n * @param {URL} resolved\n * @param {URL} base\n * @param {boolean} [preserveSymlinks]\n * @returns {URL}\n */\nfunction finalizeResolution(resolved, base, preserveSymlinks) {\n  if (encodedSepRegEx.exec(resolved.pathname) !== null)\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname,\n      'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base)\n    )\n\n  const filePath = fileURLToPath(resolved)\n\n  const stats = tryStatSync(\n    filePath.endsWith('/') ? filePath.slice(-1) : filePath\n  )\n\n  if (stats.isDirectory()) {\n    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base))\n    // @ts-expect-error Add this for `import.meta.resolve`.\n    error.url = String(resolved)\n    throw error\n  }\n\n  if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      filePath || resolved.pathname,\n      base && fileURLToPath(base),\n      'module'\n    )\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(filePath)\n    const {search, hash} = resolved\n    resolved = pathToFileURL(real + (filePath.endsWith(path.sep) ? '/' : ''))\n    resolved.search = search\n    resolved.hash = hash\n  }\n\n  return resolved\n}\n\n/**\n * @param {string} specifier\n * @param {URL|undefined} packageJsonUrl\n * @param {URL} base\n * @returns {Error}\n */\nfunction importNotDefined(specifier, packageJsonUrl, base) {\n  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier,\n    packageJsonUrl && fileURLToPath(new URL('.', packageJsonUrl)),\n    fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @returns {Error}\n */\nfunction exportsNotFound(subpath, packageJsonUrl, base) {\n  return new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.', packageJsonUrl)),\n    subpath,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} request\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} [base]\n * @returns {never}\n */\nfunction throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {\n  const reason = `request is not a valid match in pattern \"${match}\" for the \"${\n    internal ? 'imports' : 'exports'\n  }\" resolution of ${fileURLToPath(packageJsonUrl)}`\n  throw new ERR_INVALID_MODULE_SPECIFIER(\n    request,\n    reason,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} subpath\n * @param {unknown} target\n * @param {URL} packageJsonUrl\n * @param {boolean} internal\n * @param {URL} [base]\n * @returns {Error}\n */\nfunction invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {\n  target =\n    typeof target === 'object' && target !== null\n      ? JSON.stringify(target, null, '')\n      : `${target}`\n\n  return new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.', packageJsonUrl)),\n    subpath,\n    target,\n    internal,\n    base && fileURLToPath(base)\n  )\n}\n\n/**\n * @param {string} target\n * @param {string} subpath\n * @param {string} match\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @param {boolean} pattern\n * @param {boolean} internal\n * @param {boolean} isPathMap\n * @param {Set<string>|undefined} conditions\n * @returns {URL}\n */\nfunction resolvePackageTargetString(\n  target,\n  subpath,\n  match,\n  packageJsonUrl,\n  base,\n  pattern,\n  internal,\n  isPathMap,\n  conditions\n) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n\n  if (!target.startsWith('./')) {\n    if (internal && !target.startsWith('../') && !target.startsWith('/')) {\n      let isURL = false\n\n      try {\n        new URL(target)\n        isURL = true\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (!isURL) {\n        const exportTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target + subpath\n\n        return packageResolve(exportTarget, packageJsonUrl, conditions)\n      }\n    }\n\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n  }\n\n  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {\n    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {\n      if (!isPathMap) {\n        const request = pattern\n          ? match.replace('*', () => subpath)\n          : match + subpath\n        const resolvedTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          true\n        )\n      }\n    } else {\n      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n    }\n  }\n\n  const resolved = new URL(target, packageJsonUrl)\n  const resolvedPath = resolved.pathname\n  const packagePath = new URL('.', packageJsonUrl).pathname\n\n  if (!resolvedPath.startsWith(packagePath))\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base)\n\n  if (subpath === '') return resolved\n\n  if (invalidSegmentRegEx.exec(subpath) !== null) {\n    const request = pattern\n      ? match.replace('*', () => subpath)\n      : match + subpath\n    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {\n      if (!isPathMap) {\n        const resolvedTarget = pattern\n          ? RegExpPrototypeSymbolReplace.call(\n              patternRegEx,\n              target,\n              () => subpath\n            )\n          : target\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          false\n        )\n      }\n    } else {\n      throwInvalidSubpath(request, match, packageJsonUrl, internal, base)\n    }\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace.call(\n        patternRegEx,\n        resolved.href,\n        () => subpath\n      )\n    )\n  }\n\n  return new URL(subpath, resolved)\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNumber = Number(key)\n  if (`${keyNumber}` !== key) return false\n  return keyNumber >= 0 && keyNumber < 0xff_ff_ff_ff\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {unknown} target\n * @param {string} subpath\n * @param {string} packageSubpath\n * @param {URL} base\n * @param {boolean} pattern\n * @param {boolean} internal\n * @param {boolean} isPathMap\n * @param {Set<string>|undefined} conditions\n * @returns {URL|null}\n */\nfunction resolvePackageTarget(\n  packageJsonUrl,\n  target,\n  subpath,\n  packageSubpath,\n  base,\n  pattern,\n  internal,\n  isPathMap,\n  conditions\n) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target,\n      subpath,\n      packageSubpath,\n      packageJsonUrl,\n      base,\n      pattern,\n      internal,\n      isPathMap,\n      conditions\n    )\n  }\n\n  if (Array.isArray(target)) {\n    /** @type {Array<unknown>} */\n    const targetList = target\n    if (targetList.length === 0) return null\n\n    /** @type {ErrnoException|null|undefined} */\n    let lastException\n    let i = -1\n\n    while (++i < targetList.length) {\n      const targetItem = targetList[i]\n      /** @type {URL|null} */\n      let resolveResult\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          targetItem,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        )\n      } catch (error) {\n        const exception = /** @type {ErrnoException} */ (error)\n        lastException = exception\n        if (exception.code === 'ERR_INVALID_PACKAGE_TARGET') continue\n        throw error\n      }\n\n      if (resolveResult === undefined) continue\n\n      if (resolveResult === null) {\n        lastException = null\n        continue\n      }\n\n      return resolveResult\n    }\n\n    if (lastException === undefined || lastException === null) {\n      return null\n    }\n\n    throw lastException\n  }\n\n  if (typeof target === 'object' && target !== null) {\n    const keys = Object.getOwnPropertyNames(target)\n    let i = -1\n\n    while (++i < keys.length) {\n      const key = keys[i]\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJsonUrl),\n          base,\n          '\"exports\" cannot contain numeric property keys.'\n        )\n      }\n    }\n\n    i = -1\n\n    while (++i < keys.length) {\n      const key = keys[i]\n      if (key === 'default' || (conditions && conditions.has(key))) {\n        // @ts-expect-error: indexable.\n        const conditionalTarget = /** @type {unknown} */ (target[key])\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          conditionalTarget,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        )\n        if (resolveResult === undefined) continue\n        return resolveResult\n      }\n    }\n\n    return null\n  }\n\n  if (target === null) {\n    return null\n  }\n\n  throw invalidPackageTarget(\n    packageSubpath,\n    target,\n    packageJsonUrl,\n    internal,\n    base\n  )\n}\n\n/**\n * @param {unknown} exports\n * @param {URL} packageJsonUrl\n * @param {URL} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports, packageJsonUrl, base) {\n  if (typeof exports === 'string' || Array.isArray(exports)) return true\n  if (typeof exports !== 'object' || exports === null) return false\n\n  const keys = Object.getOwnPropertyNames(exports)\n  let isConditionalSugar = false\n  let i = 0\n  let j = -1\n  while (++j < keys.length) {\n    const key = keys[j]\n    const curIsConditionalSugar = key === '' || key[0] !== '.'\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJsonUrl),\n        base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n          ' The exports object must either be an object of package subpath keys' +\n          ' or an object of main entry condition name keys only.'\n      )\n    }\n  }\n\n  return isConditionalSugar\n}\n\n/**\n * @param {string} match\n * @param {URL} pjsonUrl\n * @param {URL} base\n */\nfunction emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {\n  const pjsonPath = fileURLToPath(pjsonUrl)\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return\n  emittedPackageWarnings.add(pjsonPath + '|' + match)\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping \"${match}\" in the ` +\n      `\"exports\" field module resolution of the package at ${pjsonPath}${\n        base ? ` imported from ${fileURLToPath(base)}` : ''\n      }. Mapping specifiers ending in \"/\" is no longer supported.`,\n    'DeprecationWarning',\n    'DEP0155'\n  )\n}\n\n/**\n * @param {URL} packageJsonUrl\n * @param {string} packageSubpath\n * @param {Record<string, unknown>} packageConfig\n * @param {URL} base\n * @param {Set<string>|undefined} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJsonUrl,\n  packageSubpath,\n  packageConfig,\n  base,\n  conditions\n) {\n  let exports = packageConfig.exports\n\n  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {\n    exports = {'.': exports}\n  }\n\n  if (\n    own.call(exports, packageSubpath) &&\n    !packageSubpath.includes('*') &&\n    !packageSubpath.endsWith('/')\n  ) {\n    // @ts-expect-error: indexable.\n    const target = exports[packageSubpath]\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      '',\n      packageSubpath,\n      base,\n      false,\n      false,\n      false,\n      conditions\n    )\n    if (resolveResult === null || resolveResult === undefined) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n    }\n\n    return resolveResult\n  }\n\n  let bestMatch = ''\n  let bestMatchSubpath = ''\n  const keys = Object.getOwnPropertyNames(exports)\n  let i = -1\n\n  while (++i < keys.length) {\n    const key = keys[i]\n    const patternIndex = key.indexOf('*')\n\n    if (\n      patternIndex !== -1 &&\n      packageSubpath.startsWith(key.slice(0, patternIndex))\n    ) {\n      // When this reaches EOL, this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath, '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match \"imports\" and the spec.\n      if (packageSubpath.endsWith('/')) {\n        emitTrailingSlashPatternDeprecation(\n          packageSubpath,\n          packageJsonUrl,\n          base\n        )\n      }\n\n      const patternTrailer = key.slice(patternIndex + 1)\n\n      if (\n        packageSubpath.length >= key.length &&\n        packageSubpath.endsWith(patternTrailer) &&\n        patternKeyCompare(bestMatch, key) === 1 &&\n        key.lastIndexOf('*') === patternIndex\n      ) {\n        bestMatch = key\n        bestMatchSubpath = packageSubpath.slice(\n          patternIndex,\n          packageSubpath.length - patternTrailer.length\n        )\n      }\n    }\n  }\n\n  if (bestMatch) {\n    // @ts-expect-error: indexable.\n    const target = /** @type {unknown} */ (exports[bestMatch])\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      bestMatchSubpath,\n      bestMatch,\n      base,\n      true,\n      false,\n      packageSubpath.endsWith('/'),\n      conditions\n    )\n\n    if (resolveResult === null || resolveResult === undefined) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n    }\n\n    return resolveResult\n  }\n\n  throw exportsNotFound(packageSubpath, packageJsonUrl, base)\n}\n\n/**\n * @param {string} a\n * @param {string} b\n */\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf('*')\n  const bPatternIndex = b.indexOf('*')\n  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1\n  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1\n  if (baseLengthA > baseLengthB) return -1\n  if (baseLengthB > baseLengthA) return 1\n  if (aPatternIndex === -1) return 1\n  if (bPatternIndex === -1) return -1\n  if (a.length > b.length) return -1\n  if (b.length > a.length) return 1\n  return 0\n}\n\n/**\n * @param {string} name\n * @param {URL} base\n * @param {Set<string>} [conditions]\n * @returns {URL}\n */\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || name.startsWith('#/') || name.endsWith('/')) {\n    const reason = 'is not a valid internal imports specifier name'\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base))\n  }\n\n  /** @type {URL|undefined} */\n  let packageJsonUrl\n\n  const packageConfig = getPackageScopeConfig(base)\n\n  if (packageConfig.exists) {\n    packageJsonUrl = pathToFileURL(packageConfig.pjsonPath)\n    const imports = packageConfig.imports\n    if (imports) {\n      if (own.call(imports, name) && !name.includes('*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          imports[name],\n          '',\n          name,\n          base,\n          false,\n          true,\n          false,\n          conditions\n        )\n        if (resolveResult !== null && resolveResult !== undefined) {\n          return resolveResult\n        }\n      } else {\n        let bestMatch = ''\n        let bestMatchSubpath = ''\n        const keys = Object.getOwnPropertyNames(imports)\n        let i = -1\n\n        while (++i < keys.length) {\n          const key = keys[i]\n          const patternIndex = key.indexOf('*')\n\n          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {\n            const patternTrailer = key.slice(patternIndex + 1)\n            if (\n              name.length >= key.length &&\n              name.endsWith(patternTrailer) &&\n              patternKeyCompare(bestMatch, key) === 1 &&\n              key.lastIndexOf('*') === patternIndex\n            ) {\n              bestMatch = key\n              bestMatchSubpath = name.slice(\n                patternIndex,\n                name.length - patternTrailer.length\n              )\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch]\n          const resolveResult = resolvePackageTarget(\n            packageJsonUrl,\n            target,\n            bestMatchSubpath,\n            bestMatch,\n            base,\n            true,\n            true,\n            false,\n            conditions\n          )\n\n          if (resolveResult !== null && resolveResult !== undefined) {\n            return resolveResult\n          }\n        }\n      }\n    }\n  }\n\n  throw importNotDefined(name, packageJsonUrl, base)\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nexport function getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url)\n  return packageConfig.type\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n */\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = specifier.indexOf('/')\n  let validPackageName = true\n  let isScoped = false\n  if (specifier[0] === '@') {\n    isScoped = true\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false\n    } else {\n      separatorIndex = specifier.indexOf('/', separatorIndex + 1)\n    }\n  }\n\n  const packageName =\n    separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex)\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (invalidPackageNameRegEx.exec(packageName) !== null) {\n    validPackageName = false\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier,\n      'is not a valid package name',\n      fileURLToPath(base)\n    )\n  }\n\n  const packageSubpath =\n    '.' + (separatorIndex === -1 ? '' : specifier.slice(separatorIndex))\n\n  return {packageName, packageSubpath, isScoped}\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>|undefined} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  if (builtinModules.includes(specifier)) {\n    return new URL('node:' + specifier)\n  }\n\n  const {packageName, packageSubpath, isScoped} = parsePackageName(\n    specifier,\n    base\n  )\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base)\n\n  // Can’t test.\n  /* c8 ignore next 16 */\n  if (packageConfig.exists) {\n    const packageJsonUrl = pathToFileURL(packageConfig.pjsonPath)\n    if (\n      packageConfig.name === packageName &&\n      packageConfig.exports !== undefined &&\n      packageConfig.exports !== null\n    ) {\n      return packageExportsResolve(\n        packageJsonUrl,\n        packageSubpath,\n        packageConfig,\n        base,\n        conditions\n      )\n    }\n  }\n\n  let packageJsonUrl = new URL(\n    './node_modules/' + packageName + '/package.json',\n    base\n  )\n  let packageJsonPath = fileURLToPath(packageJsonUrl)\n  /** @type {string} */\n  let lastPath\n  do {\n    const stat = tryStatSync(packageJsonPath.slice(0, -13))\n    if (!stat.isDirectory()) {\n      lastPath = packageJsonPath\n      packageJsonUrl = new URL(\n        (isScoped ? '../../../../node_modules/' : '../../../node_modules/') +\n          packageName +\n          '/package.json',\n        packageJsonUrl\n      )\n      packageJsonPath = fileURLToPath(packageJsonUrl)\n      continue\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJsonPath, specifier, base)\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJsonUrl,\n        packageSubpath,\n        packageConfig,\n        base,\n        conditions\n      )\n    }\n\n    if (packageSubpath === '.') {\n      return legacyMainResolve(packageJsonUrl, packageConfig, base)\n    }\n\n    return new URL(packageSubpath, packageJsonUrl)\n    // Cross-platform root check.\n  } while (packageJsonPath.length !== lastPath.length)\n\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base))\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true\n    if (\n      specifier[1] === '.' &&\n      (specifier.length === 2 || specifier[2] === '/')\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false\n  if (specifier[0] === '/') return true\n  return isRelativeSpecifier(specifier)\n}\n\n/**\n * The “Resolver Algorithm Specification” as detailed in the Node docs (which is\n * sync and slightly lower-level than `resolve`).\n *\n * @param {string} specifier\n *   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.\n * @param {URL} base\n *   Full URL (to a file) that `specifier` is resolved relative from.\n * @param {Set<string>} [conditions]\n *   Conditions.\n * @param {boolean} [preserveSymlinks]\n *   Keep symlinks instead of resolving them.\n * @returns {URL}\n *   A URL object to the found thing.\n */\nexport function moduleResolve(specifier, base, conditions, preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' || base.protocol === 'https:'\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  /** @type {URL|undefined} */\n  let resolved\n\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base)\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier, base, conditions)\n  } else {\n    try {\n      resolved = new URL(specifier)\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier, base, conditions)\n      }\n    }\n  }\n\n  assert(typeof resolved !== 'undefined', 'expected to be defined')\n\n  if (resolved.protocol !== 'file:') {\n    return resolved\n  }\n\n  return finalizeResolution(resolved, base, preserveSymlinks)\n}\n\n/**\n * @param {string} specifier\n * @param {URL|undefined} parsed\n * @param {URL|undefined} parsedParentURL\n */\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (\n    parsed &&\n    parsedParentURL &&\n    (parsedParentURL.protocol === 'http:' ||\n      parsedParentURL.protocol === 'https:')\n  ) {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      // Data: and blob: disallowed due to allowing file: access via\n      // indirection\n      if (\n        parsed &&\n        parsed.protocol !== 'https:' &&\n        parsed.protocol !== 'http:'\n      ) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          'remote imports cannot import from a local location.'\n        )\n      }\n\n      return {url: parsed.href}\n    }\n\n    if (builtinModules.includes(specifier)) {\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        'remote imports cannot import from a local location.'\n      )\n    }\n\n    throw new ERR_NETWORK_IMPORT_DISALLOWED(\n      specifier,\n      parsedParentURL,\n      'only relative and absolute specifiers are supported.'\n    )\n  }\n}\n\n/**\n * @param {URL} url\n */\nfunction throwIfUnsupportedURLProtocol(url) {\n  if (\n    url.protocol !== 'file:' &&\n    url.protocol !== 'data:' &&\n    url.protocol !== 'node:'\n  ) {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url)\n  }\n}\n\n/**\n * @param {URL|undefined} parsed\n * @param {boolean} experimentalNetworkImports\n */\nfunction throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports) {\n  if (\n    parsed &&\n    parsed.protocol !== 'file:' &&\n    parsed.protocol !== 'data:' &&\n    (!experimentalNetworkImports ||\n      (parsed.protocol !== 'https:' && parsed.protocol !== 'http:'))\n  ) {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(\n      parsed,\n      ['file', 'data'].concat(\n        experimentalNetworkImports ? ['https', 'http'] : []\n      )\n    )\n  }\n}\n\n/**\n * @param {string} specifier\n * @param {{parentURL?: string, conditions?: Array<string>}} context\n * @returns {{url: string, format?: string|null}}\n */\nexport function defaultResolve(specifier, context = {}) {\n  const {parentURL} = context\n  assert(typeof parentURL !== 'undefined', 'expected `parentURL` to be defined')\n\n  /** @type {URL|undefined} */\n  let parsedParentURL\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL)\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  /** @type {URL|undefined} */\n  let parsed\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)\n      ? new URL(specifier, parsedParentURL)\n      : new URL(specifier)\n\n    if (\n      parsed.protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (parsed.protocol === 'https:' || parsed.protocol === 'http:'))\n    ) {\n      return {url: parsed.href, format: null}\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns, DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  )\n\n  if (maybeReturn) return maybeReturn\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return {url: specifier}\n\n  throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports)\n\n  const conditions = getConditionsSet(context.conditions)\n\n  const url = moduleResolve(specifier, new URL(parentURL), conditions, false)\n\n  throwIfUnsupportedURLProtocol(url)\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url.href,\n    format: defaultGetFormatWithoutErrors(url, {parentURL})\n  }\n}\n"}},"utils.d.ts":{"file":{"contents":"/**\n * @param {Array<string>} [conditions]\n * @returns {Set<string>}\n */\nexport function getConditionsSet(conditions?: string[] | undefined): Set<string>\n"}},"utils.js":{"file":{"contents":"// Manually “tree shaken” from:\n// <https://github.com/nodejs/node/blob/6668c4d/lib/internal/modules/esm/utils.js>\n// Last checked on: Jan 6, 2023.\n\nimport {codes} from './errors.js'\n\nconst {ERR_INVALID_ARG_VALUE} = codes\n\n// In Node itself these values are populated from CLI arguments, before any\n// user code runs.\n// Here we just define the defaults.\nconst DEFAULT_CONDITIONS = Object.freeze(['node', 'import'])\nconst DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS)\n\nfunction getDefaultConditions() {\n  return DEFAULT_CONDITIONS\n}\n\nfunction getDefaultConditionsSet() {\n  return DEFAULT_CONDITIONS_SET\n}\n\n/**\n * @param {Array<string>} [conditions]\n * @returns {Set<string>}\n */\nexport function getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== getDefaultConditions()) {\n    if (!Array.isArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'conditions',\n        conditions,\n        'expected an array'\n      )\n    }\n\n    return new Set(conditions)\n  }\n\n  return getDefaultConditionsSet()\n}\n"}}}},"license":{"file":{"contents":"(The MIT License)\n\nCopyright (c) 2021 Titus Wormer <mailto:tituswormer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n---\n\nThis is a derivative work based on:\n<https://github.com/nodejs/node>.\nWhich is licensed:\n\n\"\"\"\nCopyright Node.js contributors. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\"\"\"\n\nThis license applies to parts of Node.js originating from the\nhttps://github.com/joyent/node repository:\n\n\"\"\"\nCopyright Joyent, Inc. and other Node contributors. All rights reserved.\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE.\n\"\"\"\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"import-meta-resolve\",\n  \"version\": \"2.2.1\",\n  \"description\": \"Resolve things like Node.js — ponyfill for `import.meta.resolve`\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"resolve\",\n    \"node\",\n    \"esm\",\n    \"module\"\n  ],\n  \"repository\": \"wooorm/import-meta-resolve\",\n  \"bugs\": \"https://github.com/wooorm/import-meta-resolve/issues\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/wooorm\"\n  },\n  \"author\": \"Titus Wormer <tituswormer@gmail.com> (https://wooorm.com)\",\n  \"contributors\": [\n    \"Titus Wormer <tituswormer@gmail.com> (https://wooorm.com)\"\n  ],\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"main\": \"index.js\",\n  \"types\": \"index.d.ts\",\n  \"files\": [\n    \"lib/\",\n    \"index.d.ts\",\n    \"index.js\"\n  ],\n  \"devDependencies\": {\n    \"@types/node\": \"^18.0.0\",\n    \"@types/semver\": \"^7.0.0\",\n    \"c8\": \"^7.0.0\",\n    \"prettier\": \"^2.0.0\",\n    \"remark-cli\": \"^11.0.0\",\n    \"remark-preset-wooorm\": \"^9.0.0\",\n    \"semver\": \"^7.0.0\",\n    \"type-coverage\": \"^2.0.0\",\n    \"typescript\": \"^4.0.0\",\n    \"xo\": \"^0.53.0\"\n  },\n  \"scripts\": {\n    \"prepack\": \"npm run generate && npm run build && npm run format\",\n    \"generate\": \"node --conditions development script.js\",\n    \"build\": \"tsc --build --clean && tsc --build && type-coverage\",\n    \"format\": \"remark . -qfo && prettier . -w --loglevel warn && xo --fix\",\n    \"test-api\": \"node --experimental-import-meta-resolve test/baseline.js && node test/index.js\",\n    \"test-coverage\": \"c8 --check-coverage --branches 75 --functions 75 --lines 75 --statements 75 --reporter lcov npm run test-api\",\n    \"test\": \"npm run generate && npm run build && npm run format && npm run test-coverage\"\n  },\n  \"prettier\": {\n    \"tabWidth\": 2,\n    \"useTabs\": false,\n    \"singleQuote\": true,\n    \"bracketSpacing\": false,\n    \"semi\": false,\n    \"trailingComma\": \"none\"\n  },\n  \"xo\": {\n    \"prettier\": true,\n    \"rules\": {\n      \"complexity\": \"off\",\n      \"max-depth\": \"off\",\n      \"max-params\": \"off\",\n      \"no-constant-condition\": \"off\",\n      \"no-new\": \"off\",\n      \"prefer-arrow-callback\": \"off\"\n    },\n    \"ignore\": [\n      \"test/node_modules/\"\n    ]\n  },\n  \"remarkConfig\": {\n    \"plugins\": [\n      \"preset-wooorm\",\n      [\n        \"remark-lint-maximum-heading-length\",\n        false\n      ]\n    ]\n  },\n  \"typeCoverage\": {\n    \"atLeast\": 100,\n    \"detail\": true,\n    \"strict\": true,\n    \"ignoreCatch\": true,\n    \"ignoreFiles\": [\n      \"lib/errors.d.ts\"\n    ]\n  }\n}\n"}},"readme.md":{"file":{"contents":"# import-meta-resolve\n\n[![Build][build-badge]][build]\n[![Coverage][coverage-badge]][coverage]\n[![Downloads][downloads-badge]][downloads]\n\nResolve things like Node.js.\n\n## Contents\n\n*   [What is this?](#what-is-this)\n*   [When to use this?](#when-to-use-this)\n*   [Install](#install)\n*   [Use](#use)\n*   [API](#api)\n    *   [`resolve(specifier, parent)`](#resolvespecifier-parent)\n    *   [`moduleResolve(specifier, parent, conditions, preserveSymlinks)`](#moduleresolvespecifier-parent-conditions-preservesymlinks)\n    *   [`ErrnoException`](#errnoexception)\n*   [Algorithm](#algorithm)\n*   [Differences to Node](#differences-to-node)\n*   [Types](#types)\n*   [Compatibility](#compatibility)\n*   [Contribute](#contribute)\n*   [License](#license)\n\n## What is this?\n\nThis package is a ponyfill for [`import.meta.resolve`][native-resolve].\nIt supports everything you need to resolve files just like modern Node does:\nimport maps, export maps, loading CJS and ESM projects, all of that!\n\n## When to use this?\n\nAs of Node.js 19.3, `import.meta.resolve` is still behind an experimental flag.\nThis package can be used to do what it does in Node 14–19.\n\n## Install\n\nThis package is [ESM only][esm].\nIn Node.js (version 14.14+ and 16.0+), install with [npm][]:\n\n```sh\nnpm install import-meta-resolve\n```\n\n## Use\n\n```js\nimport {resolve} from 'import-meta-resolve'\n\n// A file:\nconsole.log(await resolve('./index.js', import.meta.url))\n//=> file:///Users/tilde/Projects/oss/import-meta-resolve/index.js\n\n// A CJS package:\nconsole.log(await resolve('builtins', import.meta.url))\n//=> file:///Users/tilde/Projects/oss/import-meta-resolve/node_modules/builtins/index.js\n\n// A scoped CJS package:\nconsole.log(await resolve('@eslint/eslintrc', import.meta.url))\n//=> file:///Users/tilde/Projects/oss/import-meta-resolve/node_modules/@eslint/eslintrc/lib/index.js\n\n// A package with an export map:\nconsole.log(await resolve('tape/lib/test', import.meta.url))\n//=> file:///Users/tilde/Projects/oss/import-meta-resolve/node_modules/tape/lib/test.js\n\n// A node builtin:\nconsole.log(await resolve('fs', import.meta.url))\n//=> node:fs\n```\n\n## API\n\nThis package exports the identifiers [`resolve`][resolve] and\n[`moduleResolve`][moduleresolve].\nThere is no default export.\n\n### `resolve(specifier, parent)`\n\nMatch `import.meta.resolve` except that `parent` is required (you can pass\n`import.meta.url`).\n\n###### Parameters\n\n*   `specifier` (`string`)\n    — the module specifier to resolve relative to parent\n    (`/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc).\n*   `parent` (`string`, example: `import.meta.url`)\n    — the absolute parent module URL to resolve from.\n    You should pass `import.meta.url` or something else.\n\n###### Returns\n\nReturns a promise that resolves to a full `file:`, `data:`, or `node:` URL\n(`string`) to the found thing or rejects to an\n[`ErrnoException`][errnoexception].\n\n### `moduleResolve(specifier, parent, conditions, preserveSymlinks)`\n\nThe [“Resolver Algorithm Specification”][algo] as detailed in the Node docs\n(which is sync and slightly lower-level than `resolve`).\n\n###### Parameters\n\n*   `specifier` (`string`)\n    — `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc\n*   `parent` (`URL`, example: `import.meta.url`)\n    — full URL (to a file) that `specifier` is resolved relative from\n*   `conditions` (`Set<string>`, default: `new Set(['node', 'import'])`)\n    — conditions\n*   `preserveSymlinks` (`boolean`, default: `false`)\n    — keep symlinks instead of resolving them\n\n###### Returns\n\nA URL object (`URL`) to the found thing.\n\n###### Throws\n\nThrows an [`ErrnoException`][errnoexception].\n\n### `ErrnoException`\n\nOne of many different errors that occur when resolving (TypeScript type).\n\n###### Type\n\n```ts\ntype ErrnoExceptionFields = Error & {\n  errnode?: number | undefined\n  code?: string | undefined\n  path?: string | undefined\n  syscall?: string | undefined\n  url?: string | undefined\n}\n```\n\nThe `code` field on errors is one of the following strings:\n\n*   `'ERR_INVALID_MODULE_SPECIFIER'`\n    — when `specifier` is invalid (example: `'#'`)\n*   `'ERR_INVALID_PACKAGE_CONFIG'`\n    — when a `package.json` is invalid (example: invalid JSON)\n*   `'ERR_INVALID_PACKAGE_TARGET'`\n    — when a `package.json` `exports` or `imports` is invalid (example: when it\n    does not start with `'./'`)\n*   `'ERR_MODULE_NOT_FOUND'`\n    — when `specifier` cannot be found in `parent` (example: `'some-missing-package'`)\n*   `'ERR_NETWORK_IMPORT_DISALLOWED'`\n    — thrown when trying to resolve a local file or builtin from a remote file\n    (`node:fs` relative to `'https://example.com'`)\n*   `'ERR_PACKAGE_IMPORT_NOT_DEFINED'`\n    — when a local import is not defined in an import map (example: `'#local'`\n    when not defined)\n*   `'ERR_PACKAGE_PATH_NOT_EXPORTED'`\n    — when an export is not defined in an export map (example: `'tape/index.js'`,\n    which is not in its export map)\n*   `'ERR_UNSUPPORTED_DIR_IMPORT'`\n    — when attempting to import a directory (example: `'./lib/'`)\n*   `'ERR_UNKNOWN_FILE_EXTENSION'`\n    — when somehow reading a file that has an unexpected extensions (`'./readme.md'`)\n*   `'ERR_INVALID_ARG_VALUE'`\n    — when `conditions` is incorrect\n*   `'ERR_UNSUPPORTED_ESM_URL_SCHEME'`\n    — when an unexpected protocol is found (`'xss:alert(1)'`)\n\n## Algorithm\n\nThe algorithm for `resolve` matches how Node handles `import.meta.resolve`, with\na couple of differences.\n\nThe algorithm for `moduleResolve` matches the [Resolver Algorithm\nSpecification][algo] as detailed in the Node docs (which is sync and slightly\nlower-level than `resolve`).\n\n## Differences to Node\n\n*   `parent` defaulting to `import.meta.url` cannot be ponyfilled: you have to\n    explicitly pass it\n*   no support for CLI flags:\n    `--experimental-json-modules`, `--experimental-wasm-modules`,\n    `--experimental-policy`, `--experimental-network-imports`, `--no-addons`,\n    `--input-type`, `--preserve-symlinks`,\n    `--preserve-symlinks-main`, nor `--conditions` work\n*   no support for `WATCH_REPORT_DEPENDENCIES` env variable\n*   no attempt is made to add a suggestion based on how things used to work in\n    CJS before to not-found errors\n*   prototypal methods are not guarded: Node protects for example `String#slice`\n    or so from being tampered with, whereas this doesn’t\n\n## Types\n\nThis package is fully typed with [TypeScript][].\nIt exports the additional type [`ErrnoException`][errnoexception].\n\n## Compatibility\n\nThis package is at least compatible with all maintained versions of Node.js.\nAs of now, that is Node.js 14.14+ and 16.0+.\n\n## Contribute\n\nYes please!\nSee [How to Contribute to Open Source][contribute].\n\n## License\n\n[MIT][license] © [Titus Wormer][author]\n\n<!-- Definitions -->\n\n[build-badge]: https://github.com/wooorm/import-meta-resolve/workflows/main/badge.svg\n\n[build]: https://github.com/wooorm/import-meta-resolve/actions\n\n[coverage-badge]: https://img.shields.io/codecov/c/github/wooorm/import-meta-resolve.svg\n\n[coverage]: https://codecov.io/github/wooorm/import-meta-resolve\n\n[downloads-badge]: https://img.shields.io/npm/dm/import-meta-resolve.svg\n\n[downloads]: https://www.npmjs.com/package/import-meta-resolve\n\n[npm]: https://docs.npmjs.com/cli/install\n\n[license]: license\n\n[author]: https://wooorm.com\n\n[esm]: https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\n\n[typescript]: https://www.typescriptlang.org\n\n[contribute]: https://opensource.guide/how-to-contribute/\n\n[algo]: https://nodejs.org/dist/latest-v14.x/docs/api/esm.html#esm_resolver_algorithm\n\n[native-resolve]: https://nodejs.org/api/esm.html#esm_import_meta_resolve_specifier_parent\n\n[resolve]: #resolvespecifier-parent\n\n[moduleresolve]: #moduleResolvespecifier-parent-conditions-preserveSymlinks\n\n[errnoexception]: #errnoexception\n"}}}}