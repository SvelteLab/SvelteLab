{"directory":{"resolve-uri":{"directory":{"dist":{"directory":{"resolve-uri.mjs":{"file":{"contents":"// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? UrlType.Query\n            : input.startsWith('#')\n                ? UrlType.Hash\n                : UrlType.RelativePath\n        : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\nexport { resolve as default };\n//# sourceMappingURL=resolve-uri.mjs.map\n"}},"resolve-uri.mjs.map":{"file":{"contents":"{\"version\":3,\"file\":\"resolve-uri.mjs\",\"sources\":[\"../src/resolve-uri.ts\"],\"sourcesContent\":[\"// Matches the scheme of a URL, eg \\\"http://\\\"\\nconst schemeRegex = /^[\\\\w+.-]+:\\\\/\\\\//;\\n\\n/**\\n * Matches the parts of a URL:\\n * 1. Scheme, including \\\":\\\", guaranteed.\\n * 2. User/password, including \\\"@\\\", optional.\\n * 3. Host, guaranteed.\\n * 4. Port, including \\\":\\\", optional.\\n * 5. Path, including \\\"/\\\", optional.\\n * 6. Query, including \\\"?\\\", optional.\\n * 7. Hash, including \\\"#\\\", optional.\\n */\\nconst urlRegex = /^([\\\\w+.-]+:)\\\\/\\\\/([^@/#?]*@)?([^:/#?]*)(:\\\\d+)?(\\\\/[^#?]*)?(\\\\?[^#]*)?(#.*)?/;\\n\\n/**\\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\\n *\\n * 1. Host, optional.\\n * 2. Path, which may include \\\"/\\\", guaranteed.\\n * 3. Query, including \\\"?\\\", optional.\\n * 4. Hash, including \\\"#\\\", optional.\\n */\\nconst fileRegex = /^file:(?:\\\\/\\\\/((?![a-z]:)[^/#?]*)?)?(\\\\/?[^#?]*)(\\\\?[^#]*)?(#.*)?/i;\\n\\ntype Url = {\\n  scheme: string;\\n  user: string;\\n  host: string;\\n  port: string;\\n  path: string;\\n  query: string;\\n  hash: string;\\n  type: UrlType;\\n};\\n\\nenum UrlType {\\n  Empty = 1,\\n  Hash = 2,\\n  Query = 3,\\n  RelativePath = 4,\\n  AbsolutePath = 5,\\n  SchemeRelative = 6,\\n  Absolute = 7,\\n}\\n\\nfunction isAbsoluteUrl(input: string): boolean {\\n  return schemeRegex.test(input);\\n}\\n\\nfunction isSchemeRelativeUrl(input: string): boolean {\\n  return input.startsWith('//');\\n}\\n\\nfunction isAbsolutePath(input: string): boolean {\\n  return input.startsWith('/');\\n}\\n\\nfunction isFileUrl(input: string): boolean {\\n  return input.startsWith('file:');\\n}\\n\\nfunction isRelative(input: string): boolean {\\n  return /^[.?#]/.test(input);\\n}\\n\\nfunction parseAbsoluteUrl(input: string): Url {\\n  const match = urlRegex.exec(input)!;\\n  return makeUrl(\\n    match[1],\\n    match[2] || '',\\n    match[3],\\n    match[4] || '',\\n    match[5] || '/',\\n    match[6] || '',\\n    match[7] || '',\\n  );\\n}\\n\\nfunction parseFileUrl(input: string): Url {\\n  const match = fileRegex.exec(input)!;\\n  const path = match[2];\\n  return makeUrl(\\n    'file:',\\n    '',\\n    match[1] || '',\\n    '',\\n    isAbsolutePath(path) ? path : '/' + path,\\n    match[3] || '',\\n    match[4] || '',\\n  );\\n}\\n\\nfunction makeUrl(\\n  scheme: string,\\n  user: string,\\n  host: string,\\n  port: string,\\n  path: string,\\n  query: string,\\n  hash: string,\\n): Url {\\n  return {\\n    scheme,\\n    user,\\n    host,\\n    port,\\n    path,\\n    query,\\n    hash,\\n    type: UrlType.Absolute,\\n  };\\n}\\n\\nfunction parseUrl(input: string): Url {\\n  if (isSchemeRelativeUrl(input)) {\\n    const url = parseAbsoluteUrl('http:' + input);\\n    url.scheme = '';\\n    url.type = UrlType.SchemeRelative;\\n    return url;\\n  }\\n\\n  if (isAbsolutePath(input)) {\\n    const url = parseAbsoluteUrl('http://foo.com' + input);\\n    url.scheme = '';\\n    url.host = '';\\n    url.type = UrlType.AbsolutePath;\\n    return url;\\n  }\\n\\n  if (isFileUrl(input)) return parseFileUrl(input);\\n\\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\\n\\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\\n  url.scheme = '';\\n  url.host = '';\\n  url.type = input\\n    ? input.startsWith('?')\\n      ? UrlType.Query\\n      : input.startsWith('#')\\n      ? UrlType.Hash\\n      : UrlType.RelativePath\\n    : UrlType.Empty;\\n  return url;\\n}\\n\\nfunction stripPathFilename(path: string): string {\\n  // If a path ends with a parent directory \\\"..\\\", then it's a relative path with excess parent\\n  // paths. It's not a file, so we can't strip it.\\n  if (path.endsWith('/..')) return path;\\n  const index = path.lastIndexOf('/');\\n  return path.slice(0, index + 1);\\n}\\n\\nfunction mergePaths(url: Url, base: Url) {\\n  normalizePath(base, base.type);\\n\\n  // If the path is just a \\\"/\\\", then it was an empty path to begin with (remember, we're a relative\\n  // path).\\n  if (url.path === '/') {\\n    url.path = base.path;\\n  } else {\\n    // Resolution happens relative to the base path's directory, not the file.\\n    url.path = stripPathFilename(base.path) + url.path;\\n  }\\n}\\n\\n/**\\n * The path can have empty directories \\\"//\\\", unneeded parents \\\"foo/..\\\", or current directory\\n * \\\"foo/.\\\". We need to normalize to a standard representation.\\n */\\nfunction normalizePath(url: Url, type: UrlType) {\\n  const rel = type <= UrlType.RelativePath;\\n  const pieces = url.path.split('/');\\n\\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\\n  // pieces[0] is an empty string.\\n  let pointer = 1;\\n\\n  // Positive is the number of real directories we've output, used for popping a parent directory.\\n  // Eg, \\\"foo/bar/..\\\" will have a positive 2, and we can decrement to be left with just \\\"foo\\\".\\n  let positive = 0;\\n\\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \\\"foo/\\\" will\\n  // generate `[\\\"foo\\\", \\\"\\\"]` pieces). And, if we pop a parent directory. But once we encounter a\\n  // real directory, we won't need to append, unless the other conditions happen again.\\n  let addTrailingSlash = false;\\n\\n  for (let i = 1; i < pieces.length; i++) {\\n    const piece = pieces[i];\\n\\n    // An empty directory, could be a trailing slash, or just a double \\\"//\\\" in the path.\\n    if (!piece) {\\n      addTrailingSlash = true;\\n      continue;\\n    }\\n\\n    // If we encounter a real directory, then we don't need to append anymore.\\n    addTrailingSlash = false;\\n\\n    // A current directory, which we can always drop.\\n    if (piece === '.') continue;\\n\\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\\n    // have an excess of parents, and we'll need to keep the \\\"..\\\".\\n    if (piece === '..') {\\n      if (positive) {\\n        addTrailingSlash = true;\\n        positive--;\\n        pointer--;\\n      } else if (rel) {\\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\\n        pieces[pointer++] = piece;\\n      }\\n      continue;\\n    }\\n\\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\\n    // any popped or dropped directories.\\n    pieces[pointer++] = piece;\\n    positive++;\\n  }\\n\\n  let path = '';\\n  for (let i = 1; i < pointer; i++) {\\n    path += '/' + pieces[i];\\n  }\\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\\n    path += '/';\\n  }\\n  url.path = path;\\n}\\n\\n/**\\n * Attempts to resolve `input` URL/path relative to `base`.\\n */\\nexport default function resolve(input: string, base: string | undefined): string {\\n  if (!input && !base) return '';\\n\\n  const url = parseUrl(input);\\n  let inputType = url.type;\\n\\n  if (base && inputType !== UrlType.Absolute) {\\n    const baseUrl = parseUrl(base);\\n    const baseType = baseUrl.type;\\n\\n    switch (inputType) {\\n      case UrlType.Empty:\\n        url.hash = baseUrl.hash;\\n      // fall through\\n\\n      case UrlType.Hash:\\n        url.query = baseUrl.query;\\n      // fall through\\n\\n      case UrlType.Query:\\n      case UrlType.RelativePath:\\n        mergePaths(url, baseUrl);\\n      // fall through\\n\\n      case UrlType.AbsolutePath:\\n        // The host, user, and port are joined, you can't copy one without the others.\\n        url.user = baseUrl.user;\\n        url.host = baseUrl.host;\\n        url.port = baseUrl.port;\\n      // fall through\\n\\n      case UrlType.SchemeRelative:\\n        // The input doesn't have a schema at least, so we need to copy at least that over.\\n        url.scheme = baseUrl.scheme;\\n    }\\n    if (baseType > inputType) inputType = baseType;\\n  }\\n\\n  normalizePath(url, inputType);\\n\\n  const queryHash = url.query + url.hash;\\n  switch (inputType) {\\n    // This is impossible, because of the empty checks at the start of the function.\\n    // case UrlType.Empty:\\n\\n    case UrlType.Hash:\\n    case UrlType.Query:\\n      return queryHash;\\n\\n    case UrlType.RelativePath: {\\n      // The first char is always a \\\"/\\\", and we need it to be relative.\\n      const path = url.path.slice(1);\\n\\n      if (!path) return queryHash || '.';\\n\\n      if (isRelative(base || input) && !isRelative(path)) {\\n        // If base started with a leading \\\".\\\", or there is no base and input started with a \\\".\\\",\\n        // then we need to ensure that the relative path starts with a \\\".\\\". We don't know if\\n        // relative starts with a \\\"..\\\", though, so check before prepending.\\n        return './' + path + queryHash;\\n      }\\n\\n      return path + queryHash;\\n    }\\n\\n    case UrlType.AbsolutePath:\\n      return url.path + queryHash;\\n\\n    default:\\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA;AACA,MAAM,WAAW,GAAG,gBAAgB,CAAC;AAErC;;;;;;;;;;AAUA,MAAM,QAAQ,GAAG,0EAA0E,CAAC;AAE5F;;;;;;;;;AASA,MAAM,SAAS,GAAG,iEAAiE,CAAC;AAapF,IAAK,OAQJ;AARD,WAAK,OAAO;IACV,uCAAS,CAAA;IACT,qCAAQ,CAAA;IACR,uCAAS,CAAA;IACT,qDAAgB,CAAA;IAChB,qDAAgB,CAAA;IAChB,yDAAkB,CAAA;IAClB,6CAAY,CAAA;AACd,CAAC,EARI,OAAO,KAAP,OAAO,QAQX;AAED,SAAS,aAAa,CAAC,KAAa;IAClC,OAAO,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjC,CAAC;AAED,SAAS,mBAAmB,CAAC,KAAa;IACxC,OAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,SAAS,cAAc,CAAC,KAAa;IACnC,OAAO,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC/B,CAAC;AAED,SAAS,SAAS,CAAC,KAAa;IAC9B,OAAO,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AACnC,CAAC;AAED,SAAS,UAAU,CAAC,KAAa;IAC/B,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAa;IACrC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAE,CAAC;IACpC,OAAO,OAAO,CACZ,KAAK,CAAC,CAAC,CAAC,EACR,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EACd,KAAK,CAAC,CAAC,CAAC,EACR,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EACd,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,EACf,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EACd,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CACf,CAAC;AACJ,CAAC;AAED,SAAS,YAAY,CAAC,KAAa;IACjC,MAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAE,CAAC;IACrC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACtB,OAAO,OAAO,CACZ,OAAO,EACP,EAAE,EACF,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EACd,EAAE,EACF,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,EACxC,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,EACd,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CACf,CAAC;AACJ,CAAC;AAED,SAAS,OAAO,CACd,MAAc,EACd,IAAY,EACZ,IAAY,EACZ,IAAY,EACZ,IAAY,EACZ,KAAa,EACb,IAAY;IAEZ,OAAO;QACL,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,KAAK;QACL,IAAI;QACJ,IAAI,EAAE,OAAO,CAAC,QAAQ;KACvB,CAAC;AACJ,CAAC;AAED,SAAS,QAAQ,CAAC,KAAa;IAC7B,IAAI,mBAAmB,CAAC,KAAK,CAAC,EAAE;QAC9B,MAAM,GAAG,GAAG,gBAAgB,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;QAC9C,GAAG,CAAC,MAAM,GAAG,EAAE,CAAC;QAChB,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC;QAClC,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE;QACzB,MAAM,GAAG,GAAG,gBAAgB,CAAC,gBAAgB,GAAG,KAAK,CAAC,CAAC;QACvD,GAAG,CAAC,MAAM,GAAG,EAAE,CAAC;QAChB,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC;QACd,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;QAChC,OAAO,GAAG,CAAC;KACZ;IAED,IAAI,SAAS,CAAC,KAAK,CAAC;QAAE,OAAO,YAAY,CAAC,KAAK,CAAC,CAAC;IAEjD,IAAI,aAAa,CAAC,KAAK,CAAC;QAAE,OAAO,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAEzD,MAAM,GAAG,GAAG,gBAAgB,CAAC,iBAAiB,GAAG,KAAK,CAAC,CAAC;IACxD,GAAG,CAAC,MAAM,GAAG,EAAE,CAAC;IAChB,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC;IACd,GAAG,CAAC,IAAI,GAAG,KAAK;UACZ,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC;cACnB,OAAO,CAAC,KAAK;cACb,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC;kBACrB,OAAO,CAAC,IAAI;kBACZ,OAAO,CAAC,YAAY;UACtB,OAAO,CAAC,KAAK,CAAC;IAClB,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAY;;;IAGrC,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;QAAE,OAAO,IAAI,CAAC;IACtC,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IACpC,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;AAClC,CAAC;AAED,SAAS,UAAU,CAAC,GAAQ,EAAE,IAAS;IACrC,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;;;IAI/B,IAAI,GAAG,CAAC,IAAI,KAAK,GAAG,EAAE;QACpB,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;KACtB;SAAM;;QAEL,GAAG,CAAC,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;KACpD;AACH,CAAC;AAED;;;;AAIA,SAAS,aAAa,CAAC,GAAQ,EAAE,IAAa;IAC5C,MAAM,GAAG,GAAG,IAAI,IAAI,OAAO,CAAC,YAAY,CAAC;IACzC,MAAM,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;;IAInC,IAAI,OAAO,GAAG,CAAC,CAAC;;;IAIhB,IAAI,QAAQ,GAAG,CAAC,CAAC;;;;IAKjB,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAE7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;;QAGxB,IAAI,CAAC,KAAK,EAAE;YACV,gBAAgB,GAAG,IAAI,CAAC;YACxB,SAAS;SACV;;QAGD,gBAAgB,GAAG,KAAK,CAAC;;QAGzB,IAAI,KAAK,KAAK,GAAG;YAAE,SAAS;;;QAI5B,IAAI,KAAK,KAAK,IAAI,EAAE;YAClB,IAAI,QAAQ,EAAE;gBACZ,gBAAgB,GAAG,IAAI,CAAC;gBACxB,QAAQ,EAAE,CAAC;gBACX,OAAO,EAAE,CAAC;aACX;iBAAM,IAAI,GAAG,EAAE;;;gBAGd,MAAM,CAAC,OAAO,EAAE,CAAC,GAAG,KAAK,CAAC;aAC3B;YACD,SAAS;SACV;;;QAID,MAAM,CAAC,OAAO,EAAE,CAAC,GAAG,KAAK,CAAC;QAC1B,QAAQ,EAAE,CAAC;KACZ;IAED,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE;QAChC,IAAI,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;KACzB;IACD,IAAI,CAAC,IAAI,KAAK,gBAAgB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;QACxD,IAAI,IAAI,GAAG,CAAC;KACb;IACD,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;AAClB,CAAC;AAED;;;SAGwB,OAAO,CAAC,KAAa,EAAE,IAAwB;IACrE,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI;QAAE,OAAO,EAAE,CAAC;IAE/B,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;IAC5B,IAAI,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC;IAEzB,IAAI,IAAI,IAAI,SAAS,KAAK,OAAO,CAAC,QAAQ,EAAE;QAC1C,MAAM,OAAO,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC/B,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;QAE9B,QAAQ,SAAS;YACf,KAAK,OAAO,CAAC,KAAK;gBAChB,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;;YAG1B,KAAK,OAAO,CAAC,IAAI;gBACf,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;;YAG5B,KAAK,OAAO,CAAC,KAAK,CAAC;YACnB,KAAK,OAAO,CAAC,YAAY;gBACvB,UAAU,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;;YAG3B,KAAK,OAAO,CAAC,YAAY;;gBAEvB,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;gBACxB,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;gBACxB,GAAG,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;;YAG1B,KAAK,OAAO,CAAC,cAAc;;gBAEzB,GAAG,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;SAC/B;QACD,IAAI,QAAQ,GAAG,SAAS;YAAE,SAAS,GAAG,QAAQ,CAAC;KAChD;IAED,aAAa,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;IAE9B,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC;IACvC,QAAQ,SAAS;;;QAIf,KAAK,OAAO,CAAC,IAAI,CAAC;QAClB,KAAK,OAAO,CAAC,KAAK;YAChB,OAAO,SAAS,CAAC;QAEnB,KAAK,OAAO,CAAC,YAAY,EAAE;;YAEzB,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAE/B,IAAI,CAAC,IAAI;gBAAE,OAAO,SAAS,IAAI,GAAG,CAAC;YAEnC,IAAI,UAAU,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;;;;gBAIlD,OAAO,IAAI,GAAG,IAAI,GAAG,SAAS,CAAC;aAChC;YAED,OAAO,IAAI,GAAG,SAAS,CAAC;SACzB;QAED,KAAK,OAAO,CAAC,YAAY;YACvB,OAAO,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC;QAE9B;YACE,OAAO,GAAG,CAAC,MAAM,GAAG,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC;KACpF;AACH;;;;\"}"}},"resolve-uri.umd.js":{"file":{"contents":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    var UrlType;\n    (function (UrlType) {\n        UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n        UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n        UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n        UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n        UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n        UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n        UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n    })(UrlType || (UrlType = {}));\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: UrlType.Absolute,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = UrlType.SchemeRelative;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = UrlType.AbsolutePath;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? UrlType.Query\n                : input.startsWith('#')\n                    ? UrlType.Hash\n                    : UrlType.RelativePath\n            : UrlType.Empty;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= UrlType.RelativePath;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== UrlType.Absolute) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case UrlType.Empty:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case UrlType.Hash:\n                    url.query = baseUrl.query;\n                // fall through\n                case UrlType.Query:\n                case UrlType.RelativePath:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case UrlType.AbsolutePath:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case UrlType.SchemeRelative:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case UrlType.Hash:\n            case UrlType.Query:\n                return queryHash;\n            case UrlType.RelativePath: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case UrlType.AbsolutePath:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n"}},"resolve-uri.umd.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"resolve-uri.umd.js\",\"sources\":[\"../src/resolve-uri.ts\"],\"sourcesContent\":[\"// Matches the scheme of a URL, eg \\\"http://\\\"\\nconst schemeRegex = /^[\\\\w+.-]+:\\\\/\\\\//;\\n\\n/**\\n * Matches the parts of a URL:\\n * 1. Scheme, including \\\":\\\", guaranteed.\\n * 2. User/password, including \\\"@\\\", optional.\\n * 3. Host, guaranteed.\\n * 4. Port, including \\\":\\\", optional.\\n * 5. Path, including \\\"/\\\", optional.\\n * 6. Query, including \\\"?\\\", optional.\\n * 7. Hash, including \\\"#\\\", optional.\\n */\\nconst urlRegex = /^([\\\\w+.-]+:)\\\\/\\\\/([^@/#?]*@)?([^:/#?]*)(:\\\\d+)?(\\\\/[^#?]*)?(\\\\?[^#]*)?(#.*)?/;\\n\\n/**\\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\\n *\\n * 1. Host, optional.\\n * 2. Path, which may include \\\"/\\\", guaranteed.\\n * 3. Query, including \\\"?\\\", optional.\\n * 4. Hash, including \\\"#\\\", optional.\\n */\\nconst fileRegex = /^file:(?:\\\\/\\\\/((?![a-z]:)[^/#?]*)?)?(\\\\/?[^#?]*)(\\\\?[^#]*)?(#.*)?/i;\\n\\ntype Url = {\\n  scheme: string;\\n  user: string;\\n  host: string;\\n  port: string;\\n  path: string;\\n  query: string;\\n  hash: string;\\n  type: UrlType;\\n};\\n\\nenum UrlType {\\n  Empty = 1,\\n  Hash = 2,\\n  Query = 3,\\n  RelativePath = 4,\\n  AbsolutePath = 5,\\n  SchemeRelative = 6,\\n  Absolute = 7,\\n}\\n\\nfunction isAbsoluteUrl(input: string): boolean {\\n  return schemeRegex.test(input);\\n}\\n\\nfunction isSchemeRelativeUrl(input: string): boolean {\\n  return input.startsWith('//');\\n}\\n\\nfunction isAbsolutePath(input: string): boolean {\\n  return input.startsWith('/');\\n}\\n\\nfunction isFileUrl(input: string): boolean {\\n  return input.startsWith('file:');\\n}\\n\\nfunction isRelative(input: string): boolean {\\n  return /^[.?#]/.test(input);\\n}\\n\\nfunction parseAbsoluteUrl(input: string): Url {\\n  const match = urlRegex.exec(input)!;\\n  return makeUrl(\\n    match[1],\\n    match[2] || '',\\n    match[3],\\n    match[4] || '',\\n    match[5] || '/',\\n    match[6] || '',\\n    match[7] || '',\\n  );\\n}\\n\\nfunction parseFileUrl(input: string): Url {\\n  const match = fileRegex.exec(input)!;\\n  const path = match[2];\\n  return makeUrl(\\n    'file:',\\n    '',\\n    match[1] || '',\\n    '',\\n    isAbsolutePath(path) ? path : '/' + path,\\n    match[3] || '',\\n    match[4] || '',\\n  );\\n}\\n\\nfunction makeUrl(\\n  scheme: string,\\n  user: string,\\n  host: string,\\n  port: string,\\n  path: string,\\n  query: string,\\n  hash: string,\\n): Url {\\n  return {\\n    scheme,\\n    user,\\n    host,\\n    port,\\n    path,\\n    query,\\n    hash,\\n    type: UrlType.Absolute,\\n  };\\n}\\n\\nfunction parseUrl(input: string): Url {\\n  if (isSchemeRelativeUrl(input)) {\\n    const url = parseAbsoluteUrl('http:' + input);\\n    url.scheme = '';\\n    url.type = UrlType.SchemeRelative;\\n    return url;\\n  }\\n\\n  if (isAbsolutePath(input)) {\\n    const url = parseAbsoluteUrl('http://foo.com' + input);\\n    url.scheme = '';\\n    url.host = '';\\n    url.type = UrlType.AbsolutePath;\\n    return url;\\n  }\\n\\n  if (isFileUrl(input)) return parseFileUrl(input);\\n\\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\\n\\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\\n  url.scheme = '';\\n  url.host = '';\\n  url.type = input\\n    ? input.startsWith('?')\\n      ? UrlType.Query\\n      : input.startsWith('#')\\n      ? UrlType.Hash\\n      : UrlType.RelativePath\\n    : UrlType.Empty;\\n  return url;\\n}\\n\\nfunction stripPathFilename(path: string): string {\\n  // If a path ends with a parent directory \\\"..\\\", then it's a relative path with excess parent\\n  // paths. It's not a file, so we can't strip it.\\n  if (path.endsWith('/..')) return path;\\n  const index = path.lastIndexOf('/');\\n  return path.slice(0, index + 1);\\n}\\n\\nfunction mergePaths(url: Url, base: Url) {\\n  normalizePath(base, base.type);\\n\\n  // If the path is just a \\\"/\\\", then it was an empty path to begin with (remember, we're a relative\\n  // path).\\n  if (url.path === '/') {\\n    url.path = base.path;\\n  } else {\\n    // Resolution happens relative to the base path's directory, not the file.\\n    url.path = stripPathFilename(base.path) + url.path;\\n  }\\n}\\n\\n/**\\n * The path can have empty directories \\\"//\\\", unneeded parents \\\"foo/..\\\", or current directory\\n * \\\"foo/.\\\". We need to normalize to a standard representation.\\n */\\nfunction normalizePath(url: Url, type: UrlType) {\\n  const rel = type <= UrlType.RelativePath;\\n  const pieces = url.path.split('/');\\n\\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\\n  // pieces[0] is an empty string.\\n  let pointer = 1;\\n\\n  // Positive is the number of real directories we've output, used for popping a parent directory.\\n  // Eg, \\\"foo/bar/..\\\" will have a positive 2, and we can decrement to be left with just \\\"foo\\\".\\n  let positive = 0;\\n\\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \\\"foo/\\\" will\\n  // generate `[\\\"foo\\\", \\\"\\\"]` pieces). And, if we pop a parent directory. But once we encounter a\\n  // real directory, we won't need to append, unless the other conditions happen again.\\n  let addTrailingSlash = false;\\n\\n  for (let i = 1; i < pieces.length; i++) {\\n    const piece = pieces[i];\\n\\n    // An empty directory, could be a trailing slash, or just a double \\\"//\\\" in the path.\\n    if (!piece) {\\n      addTrailingSlash = true;\\n      continue;\\n    }\\n\\n    // If we encounter a real directory, then we don't need to append anymore.\\n    addTrailingSlash = false;\\n\\n    // A current directory, which we can always drop.\\n    if (piece === '.') continue;\\n\\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\\n    // have an excess of parents, and we'll need to keep the \\\"..\\\".\\n    if (piece === '..') {\\n      if (positive) {\\n        addTrailingSlash = true;\\n        positive--;\\n        pointer--;\\n      } else if (rel) {\\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\\n        pieces[pointer++] = piece;\\n      }\\n      continue;\\n    }\\n\\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\\n    // any popped or dropped directories.\\n    pieces[pointer++] = piece;\\n    positive++;\\n  }\\n\\n  let path = '';\\n  for (let i = 1; i < pointer; i++) {\\n    path += '/' + pieces[i];\\n  }\\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\\n    path += '/';\\n  }\\n  url.path = path;\\n}\\n\\n/**\\n * Attempts to resolve `input` URL/path relative to `base`.\\n */\\nexport default function resolve(input: string, base: string | undefined): string {\\n  if (!input && !base) return '';\\n\\n  const url = parseUrl(input);\\n  let inputType = url.type;\\n\\n  if (base && inputType !== UrlType.Absolute) {\\n    const baseUrl = parseUrl(base);\\n    const baseType = baseUrl.type;\\n\\n    switch (inputType) {\\n      case UrlType.Empty:\\n        url.hash = baseUrl.hash;\\n      // fall through\\n\\n      case UrlType.Hash:\\n        url.query = baseUrl.query;\\n      // fall through\\n\\n      case UrlType.Query:\\n      case UrlType.RelativePath:\\n        mergePaths(url, baseUrl);\\n      // fall through\\n\\n      case UrlType.AbsolutePath:\\n        // The host, user, and port are joined, you can't copy one without the others.\\n        url.user = baseUrl.user;\\n        url.host = baseUrl.host;\\n        url.port = baseUrl.port;\\n      // fall through\\n\\n      case UrlType.SchemeRelative:\\n        // The input doesn't have a schema at least, so we need to copy at least that over.\\n        url.scheme = baseUrl.scheme;\\n    }\\n    if (baseType > inputType) inputType = baseType;\\n  }\\n\\n  normalizePath(url, inputType);\\n\\n  const queryHash = url.query + url.hash;\\n  switch (inputType) {\\n    // This is impossible, because of the empty checks at the start of the function.\\n    // case UrlType.Empty:\\n\\n    case UrlType.Hash:\\n    case UrlType.Query:\\n      return queryHash;\\n\\n    case UrlType.RelativePath: {\\n      // The first char is always a \\\"/\\\", and we need it to be relative.\\n      const path = url.path.slice(1);\\n\\n      if (!path) return queryHash || '.';\\n\\n      if (isRelative(base || input) && !isRelative(path)) {\\n        // If base started with a leading \\\".\\\", or there is no base and input started with a \\\".\\\",\\n        // then we need to ensure that the relative path starts with a \\\".\\\". We don't know if\\n        // relative starts with a \\\"..\\\", though, so check before prepending.\\n        return './' + path + queryHash;\\n      }\\n\\n      return path + queryHash;\\n    }\\n\\n    case UrlType.AbsolutePath:\\n      return url.path + queryHash;\\n\\n    default:\\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}"}},"types":{"directory":{"resolve-uri.d.ts":{"file":{"contents":"/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string;\n"}}}}}},"LICENSE":{"file":{"contents":"Copyright 2019 Justin Ridgewell <jridgewell@google.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."}},"package.json":{"file":{"contents":"{\n  \"name\": \"@jridgewell/resolve-uri\",\n  \"version\": \"3.1.0\",\n  \"description\": \"Resolve a URI relative to an optional base URI\",\n  \"keywords\": [\n    \"resolve\",\n    \"uri\",\n    \"url\",\n    \"path\"\n  ],\n  \"author\": \"Justin Ridgewell <justin@ridgewell.name>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/jridgewell/resolve-uri\",\n  \"main\": \"dist/resolve-uri.umd.js\",\n  \"module\": \"dist/resolve-uri.mjs\",\n  \"typings\": \"dist/types/resolve-uri.d.ts\",\n  \"exports\": {\n    \".\": [\n      {\n        \"types\": \"./dist/types/resolve-uri.d.ts\",\n        \"browser\": \"./dist/resolve-uri.umd.js\",\n        \"require\": \"./dist/resolve-uri.umd.js\",\n        \"import\": \"./dist/resolve-uri.mjs\"\n      },\n      \"./dist/resolve-uri.umd.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"rm -rf dist\",\n    \"build\": \"run-s -n build:*\",\n    \"build:rollup\": \"rollup -c rollup.config.js\",\n    \"build:ts\": \"tsc --project tsconfig.build.json\",\n    \"lint\": \"run-s -n lint:*\",\n    \"lint:prettier\": \"npm run test:lint:prettier -- --write\",\n    \"lint:ts\": \"npm run test:lint:ts -- --fix\",\n    \"pretest\": \"run-s build:rollup\",\n    \"test\": \"run-s -n test:lint test:only\",\n    \"test:debug\": \"mocha --inspect-brk\",\n    \"test:lint\": \"run-s -n test:lint:*\",\n    \"test:lint:prettier\": \"prettier --check '{src,test}/**/*.ts'\",\n    \"test:lint:ts\": \"eslint '{src,test}/**/*.ts'\",\n    \"test:only\": \"mocha\",\n    \"test:coverage\": \"c8 mocha\",\n    \"test:watch\": \"mocha --watch\",\n    \"prepublishOnly\": \"npm run preversion\",\n    \"preversion\": \"run-s test build\"\n  },\n  \"devDependencies\": {\n    \"@jridgewell/resolve-uri-latest\": \"npm:@jridgewell/resolve-uri@*\",\n    \"@rollup/plugin-typescript\": \"8.3.0\",\n    \"@typescript-eslint/eslint-plugin\": \"5.10.0\",\n    \"@typescript-eslint/parser\": \"5.10.0\",\n    \"c8\": \"7.11.0\",\n    \"eslint\": \"8.7.0\",\n    \"eslint-config-prettier\": \"8.3.0\",\n    \"mocha\": \"9.2.0\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"2.5.1\",\n    \"rollup\": \"2.66.0\",\n    \"typescript\": \"4.5.5\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# @jridgewell/resolve-uri\n\n> Resolve a URI relative to an optional base URI\n\nResolve any combination of absolute URIs, protocol-realtive URIs, absolute paths, or relative paths.\n\n## Installation\n\n```sh\nnpm install @jridgewell/resolve-uri\n```\n\n## Usage\n\n```typescript\nfunction resolve(input: string, base?: string): string;\n```\n\n```js\nimport resolve from '@jridgewell/resolve-uri';\n\nresolve('foo', 'https://example.com'); // => 'https://example.com/foo'\n```\n\n| Input                 | Base                    | Resolution                     | Explanation                                                  |\n|-----------------------|-------------------------|--------------------------------|--------------------------------------------------------------|\n| `https://example.com` | _any_                   | `https://example.com/`         | Input is normalized only                                     |\n| `//example.com`       | `https://base.com/`     | `https://example.com/`         | Input inherits the base's protocol                           |\n| `//example.com`       | _rest_                  | `//example.com/`               | Input is normalized only                                     |\n| `/example`            | `https://base.com/`     | `https://base.com/example`     | Input inherits the base's origin                             |\n| `/example`            | `//base.com/`           | `//base.com/example`           | Input inherits the base's host and remains protocol relative |\n| `/example`            | _rest_                  | `/example`                     | Input is normalized only                                     |\n| `example`             | `https://base.com/dir/` | `https://base.com/dir/example` | Input is joined with the base                                |\n| `example`             | `https://base.com/file` | `https://base.com/example`     | Input is joined with the base without its file               |\n| `example`             | `//base.com/dir/`       | `//base.com/dir/example`       | Input is joined with the base's last directory               |\n| `example`             | `//base.com/file`       | `//base.com/example`           | Input is joined with the base without its file               |\n| `example`             | `/base/dir/`            | `/base/dir/example`            | Input is joined with the base's last directory               |\n| `example`             | `/base/file`            | `/base/example`                | Input is joined with the base without its file               |\n| `example`             | `base/dir/`             | `base/dir/example`             | Input is joined with the base's last directory               |\n| `example`             | `base/file`             | `base/example`                 | Input is joined with the base without its file               |\n"}}}},"sourcemap-codec":{"directory":{"dist":{"directory":{"sourcemap-codec.mjs":{"file":{"contents":"const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n        }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n"}},"sourcemap-codec.mjs.map":{"file":{"contents":"{\"version\":3,\"file\":\"sourcemap-codec.mjs\",\"sources\":[\"../src/sourcemap-codec.ts\"],\"sourcesContent\":[null],\"names\":[],\"mappings\":\"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\"}"}},"sourcemap-codec.umd.js":{"file":{"contents":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n"}},"sourcemap-codec.umd.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"sourcemap-codec.umd.js\",\"sources\":[\"../src/sourcemap-codec.ts\"],\"sourcesContent\":[null],\"names\":[],\"mappings\":\"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\"}"}},"types":{"directory":{"sourcemap-codec.d.ts":{"file":{"contents":"export declare type SourceMapSegment = [number] | [number, number, number, number] | [number, number, number, number, number];\nexport declare type SourceMapLine = SourceMapSegment[];\nexport declare type SourceMapMappings = SourceMapLine[];\nexport declare function decode(mappings: string): SourceMapMappings;\nexport declare function encode(decoded: SourceMapMappings): string;\nexport declare function encode(decoded: Readonly<SourceMapMappings>): string;\n"}}}}}},"LICENSE":{"file":{"contents":"The MIT License\n\nCopyright (c) 2015 Rich Harris\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"@jridgewell/sourcemap-codec\",\n  \"version\": \"1.4.14\",\n  \"description\": \"Encode/decode sourcemap mappings\",\n  \"keywords\": [\n    \"sourcemap\",\n    \"vlq\"\n  ],\n  \"main\": \"dist/sourcemap-codec.umd.js\",\n  \"module\": \"dist/sourcemap-codec.mjs\",\n  \"typings\": \"dist/types/sourcemap-codec.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"src\"\n  ],\n  \"exports\": {\n    \".\": [\n      {\n        \"types\": \"./dist/types/sourcemap-codec.d.ts\",\n        \"browser\": \"./dist/sourcemap-codec.umd.js\",\n        \"import\": \"./dist/sourcemap-codec.mjs\",\n        \"require\": \"./dist/sourcemap-codec.umd.js\"\n      },\n      \"./dist/sourcemap-codec.umd.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"benchmark\": \"run-s build:rollup benchmark:*\",\n    \"benchmark:install\": \"cd benchmark && npm install\",\n    \"benchmark:only\": \"node --expose-gc benchmark/index.js\",\n    \"build\": \"run-s -n build:*\",\n    \"build:rollup\": \"rollup -c rollup.config.js\",\n    \"build:ts\": \"tsc --project tsconfig.build.json\",\n    \"lint\": \"run-s -n lint:*\",\n    \"lint:prettier\": \"npm run test:lint:prettier -- --write\",\n    \"lint:ts\": \"npm run test:lint:ts -- --fix\",\n    \"prebuild\": \"rm -rf dist\",\n    \"prepublishOnly\": \"npm run preversion\",\n    \"preversion\": \"run-s test build\",\n    \"pretest\": \"run-s build:rollup\",\n    \"test\": \"run-s -n test:lint test:only\",\n    \"test:debug\": \"mocha --inspect-brk\",\n    \"test:lint\": \"run-s -n test:lint:*\",\n    \"test:lint:prettier\": \"prettier --check '{src,test}/**/*.ts'\",\n    \"test:lint:ts\": \"eslint '{src,test}/**/*.ts'\",\n    \"test:only\": \"mocha\",\n    \"test:coverage\": \"c8 mocha\",\n    \"test:watch\": \"mocha --watch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jridgewell/sourcemap-codec.git\"\n  },\n  \"author\": \"Rich Harris\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@rollup/plugin-typescript\": \"8.3.0\",\n    \"@types/node\": \"17.0.15\",\n    \"@typescript-eslint/eslint-plugin\": \"5.10.0\",\n    \"@typescript-eslint/parser\": \"5.10.0\",\n    \"benchmark\": \"2.1.4\",\n    \"c8\": \"7.11.2\",\n    \"eslint\": \"8.7.0\",\n    \"eslint-config-prettier\": \"8.3.0\",\n    \"mocha\": \"9.2.0\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"2.5.1\",\n    \"rollup\": \"2.64.0\",\n    \"source-map\": \"0.6.1\",\n    \"source-map-js\": \"1.0.2\",\n    \"sourcemap-codec\": \"1.4.8\",\n    \"typescript\": \"4.5.4\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# sourcemap-codec\n\nEncode/decode the `mappings` property of a [sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit).\n\n\n## Why?\n\nSourcemaps are difficult to generate and manipulate, because the `mappings` property – the part that actually links the generated code back to the original source – is encoded using an obscure method called [Variable-length quantity](https://en.wikipedia.org/wiki/Variable-length_quantity). On top of that, each segment in the mapping contains offsets rather than absolute indices, which means that you can't look at a segment in isolation – you have to understand the whole sourcemap.\n\nThis package makes the process slightly easier.\n\n\n## Installation\n\n```bash\nnpm install sourcemap-codec\n```\n\n\n## Usage\n\n```js\nimport { encode, decode } from 'sourcemap-codec';\n\nvar decoded = decode( ';EAEEA,EAAE,EAAC,CAAE;ECQY,UACC' );\n\nassert.deepEqual( decoded, [\n\t// the first line (of the generated code) has no mappings,\n\t// as shown by the starting semi-colon (which separates lines)\n\t[],\n\n\t// the second line contains four (comma-separated) segments\n\t[\n\t\t// segments are encoded as you'd expect:\n\t\t// [ generatedCodeColumn, sourceIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n\n\t\t// i.e. the first segment begins at column 2, and maps back to the second column\n\t\t// of the second line (both zero-based) of the 0th source, and uses the 0th\n\t\t// name in the `map.names` array\n\t\t[ 2, 0, 2, 2, 0 ],\n\n\t\t// the remaining segments are 4-length rather than 5-length,\n\t\t// because they don't map a name\n\t\t[ 4, 0, 2, 4 ],\n\t\t[ 6, 0, 2, 5 ],\n\t\t[ 7, 0, 2, 7 ]\n\t],\n\n\t// the final line contains two segments\n\t[\n\t\t[ 2, 1, 10, 19 ],\n\t\t[ 12, 1, 11, 20 ]\n\t]\n]);\n\nvar encoded = encode( decoded );\nassert.equal( encoded, ';EAEEA,EAAE,EAAC,CAAE;ECQY,UACC' );\n```\n\n## Benchmarks\n\n```\nnode v18.0.0\n\namp.js.map - 45120 segments\n\nDecode Memory Usage:\n@jridgewell/sourcemap-codec       5479160 bytes\nsourcemap-codec                   5659336 bytes\nsource-map-0.6.1                 17144440 bytes\nsource-map-0.8.0                  6867424 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nDecode speed:\ndecode: @jridgewell/sourcemap-codec x 502 ops/sec ±1.03% (90 runs sampled)\ndecode: sourcemap-codec x 445 ops/sec ±0.97% (92 runs sampled)\ndecode: source-map-0.6.1 x 36.01 ops/sec ±1.64% (49 runs sampled)\ndecode: source-map-0.8.0 x 367 ops/sec ±0.04% (95 runs sampled)\nFastest is decode: @jridgewell/sourcemap-codec\n\nEncode Memory Usage:\n@jridgewell/sourcemap-codec       1261620 bytes\nsourcemap-codec                   9119248 bytes\nsource-map-0.6.1                  8968560 bytes\nsource-map-0.8.0                  8952952 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nEncode speed:\nencode: @jridgewell/sourcemap-codec x 738 ops/sec ±0.42% (98 runs sampled)\nencode: sourcemap-codec x 238 ops/sec ±0.73% (88 runs sampled)\nencode: source-map-0.6.1 x 162 ops/sec ±0.43% (84 runs sampled)\nencode: source-map-0.8.0 x 191 ops/sec ±0.34% (90 runs sampled)\nFastest is encode: @jridgewell/sourcemap-codec\n\n\n***\n\n\nbabel.min.js.map - 347793 segments\n\nDecode Memory Usage:\n@jridgewell/sourcemap-codec      35338184 bytes\nsourcemap-codec                  35922736 bytes\nsource-map-0.6.1                 62366360 bytes\nsource-map-0.8.0                 44337416 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nDecode speed:\ndecode: @jridgewell/sourcemap-codec x 40.35 ops/sec ±4.47% (54 runs sampled)\ndecode: sourcemap-codec x 36.76 ops/sec ±3.67% (51 runs sampled)\ndecode: source-map-0.6.1 x 4.44 ops/sec ±2.15% (16 runs sampled)\ndecode: source-map-0.8.0 x 59.35 ops/sec ±0.05% (78 runs sampled)\nFastest is decode: source-map-0.8.0\n\nEncode Memory Usage:\n@jridgewell/sourcemap-codec       7212604 bytes\nsourcemap-codec                  21421456 bytes\nsource-map-0.6.1                 25286888 bytes\nsource-map-0.8.0                 25498744 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nEncode speed:\nencode: @jridgewell/sourcemap-codec x 112 ops/sec ±0.13% (84 runs sampled)\nencode: sourcemap-codec x 30.23 ops/sec ±2.76% (53 runs sampled)\nencode: source-map-0.6.1 x 19.43 ops/sec ±3.70% (37 runs sampled)\nencode: source-map-0.8.0 x 19.40 ops/sec ±3.26% (37 runs sampled)\nFastest is encode: @jridgewell/sourcemap-codec\n\n\n***\n\n\npreact.js.map - 1992 segments\n\nDecode Memory Usage:\n@jridgewell/sourcemap-codec        500272 bytes\nsourcemap-codec                    516864 bytes\nsource-map-0.6.1                  1596672 bytes\nsource-map-0.8.0                   517272 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nDecode speed:\ndecode: @jridgewell/sourcemap-codec x 16,137 ops/sec ±0.17% (99 runs sampled)\ndecode: sourcemap-codec x 12,139 ops/sec ±0.13% (99 runs sampled)\ndecode: source-map-0.6.1 x 1,264 ops/sec ±0.12% (100 runs sampled)\ndecode: source-map-0.8.0 x 9,894 ops/sec ±0.08% (101 runs sampled)\nFastest is decode: @jridgewell/sourcemap-codec\n\nEncode Memory Usage:\n@jridgewell/sourcemap-codec        321026 bytes\nsourcemap-codec                    830832 bytes\nsource-map-0.6.1                   586608 bytes\nsource-map-0.8.0                   586680 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nEncode speed:\nencode: @jridgewell/sourcemap-codec x 19,876 ops/sec ±0.78% (95 runs sampled)\nencode: sourcemap-codec x 6,983 ops/sec ±0.15% (100 runs sampled)\nencode: source-map-0.6.1 x 5,070 ops/sec ±0.12% (102 runs sampled)\nencode: source-map-0.8.0 x 5,641 ops/sec ±0.17% (100 runs sampled)\nFastest is encode: @jridgewell/sourcemap-codec\n\n\n***\n\n\nreact.js.map - 5726 segments\n\nDecode Memory Usage:\n@jridgewell/sourcemap-codec        734848 bytes\nsourcemap-codec                    954200 bytes\nsource-map-0.6.1                  2276432 bytes\nsource-map-0.8.0                   955488 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nDecode speed:\ndecode: @jridgewell/sourcemap-codec x 5,723 ops/sec ±0.12% (98 runs sampled)\ndecode: sourcemap-codec x 4,555 ops/sec ±0.09% (101 runs sampled)\ndecode: source-map-0.6.1 x 437 ops/sec ±0.11% (93 runs sampled)\ndecode: source-map-0.8.0 x 3,441 ops/sec ±0.15% (100 runs sampled)\nFastest is decode: @jridgewell/sourcemap-codec\n\nEncode Memory Usage:\n@jridgewell/sourcemap-codec        638672 bytes\nsourcemap-codec                   1109840 bytes\nsource-map-0.6.1                  1321224 bytes\nsource-map-0.8.0                  1324448 bytes\nSmallest memory usage is @jridgewell/sourcemap-codec\n\nEncode speed:\nencode: @jridgewell/sourcemap-codec x 6,801 ops/sec ±0.48% (98 runs sampled)\nencode: sourcemap-codec x 2,533 ops/sec ±0.13% (101 runs sampled)\nencode: source-map-0.6.1 x 2,248 ops/sec ±0.08% (100 runs sampled)\nencode: source-map-0.8.0 x 2,303 ops/sec ±0.15% (100 runs sampled)\nFastest is encode: @jridgewell/sourcemap-codec\n```\n\n# License\n\nMIT\n"}},"src":{"directory":{"sourcemap-codec.ts":{"file":{"contents":"export type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array) {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array) {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport function decode(mappings: string): SourceMapMappings {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const decoded: SourceMapMappings = [];\n\n  let index = 0;\n  do {\n    const semi = indexOf(mappings, index);\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    state[0] = 0;\n\n    for (let i = index; i < semi; i++) {\n      let seg: SourceMapSegment;\n\n      i = decodeInteger(mappings, i, state, 0); // genColumn\n      const col = state[0];\n      if (col < lastCol) sorted = false;\n      lastCol = col;\n\n      if (hasMoreVlq(mappings, i, semi)) {\n        i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n        i = decodeInteger(mappings, i, state, 2); // sourceLine\n        i = decodeInteger(mappings, i, state, 3); // sourceColumn\n\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 4); // namesIndex\n          seg = [col, state[1], state[2], state[3], state[4]];\n        } else {\n          seg = [col, state[1], state[2], state[3]];\n        }\n      } else {\n        seg = [col];\n      }\n\n      line.push(seg);\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    index = semi + 1;\n  } while (index <= mappings.length);\n\n  return decoded;\n}\n\nfunction indexOf(mappings: string, index: number): number {\n  const idx = mappings.indexOf(';', index);\n  return idx === -1 ? mappings.length : idx;\n}\n\nfunction decodeInteger(mappings: string, pos: number, state: SourceMapSegment, j: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = mappings.charCodeAt(pos++);\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  state[j] += value;\n  return pos;\n}\n\nfunction hasMoreVlq(mappings: string, i: number, length: number): boolean {\n  if (i >= length) return false;\n  return mappings.charCodeAt(i) !== comma;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const bufLength = 1024 * 16;\n  const subLength = bufLength - 36;\n  const buf = new Uint8Array(bufLength);\n  const sub = buf.subarray(0, subLength);\n  let pos = 0;\n  let out = '';\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) {\n      if (pos === bufLength) {\n        out += td.decode(buf);\n        pos = 0;\n      }\n      buf[pos++] = semicolon;\n    }\n    if (line.length === 0) continue;\n\n    state[0] = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      // We can push up to 5 ints, each int can take at most 7 chars, and we\n      // may push a comma.\n      if (pos > subLength) {\n        out += td.decode(sub);\n        buf.copyWithin(0, subLength, pos);\n        pos -= subLength;\n      }\n      if (j > 0) buf[pos++] = comma;\n\n      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\n      if (segment.length === 1) continue;\n      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\n      if (segment.length === 4) continue;\n      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n    }\n  }\n\n  return out + td.decode(buf.subarray(0, pos));\n}\n\nfunction encodeInteger(\n  buf: Uint8Array,\n  pos: number,\n  state: SourceMapSegment,\n  segment: SourceMapSegment,\n  j: number,\n): number {\n  const next = segment[j];\n  let num = next - state[j];\n  state[j] = next;\n\n  num = num < 0 ? (-num << 1) | 1 : num << 1;\n  do {\n    let clamped = num & 0b011111;\n    num >>>= 5;\n    if (num > 0) clamped |= 0b100000;\n    buf[pos++] = intToChar[clamped];\n  } while (num > 0);\n\n  return pos;\n}\n"}}}}}},"trace-mapping":{"directory":{"dist":{"directory":{"trace-mapping.mjs":{"file":{"contents":"import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed))\n        return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for (let i = 0; i < sections.length; i++) {\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) {\n                sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            }\n            else if (sl < stopLine) {\n                sc = columnOffset + nextOffset.column;\n            }\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    if ('sections' in input)\n        return recurse(...arguments);\n    const map = new TraceMap(input, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents)\n        append(sourcesContent, contents);\n    else\n        for (let i = 0; i < resolvedSources.length; i++)\n            sourcesContent.push(null);\n    for (let i = 0; i < decoded.length; i++) {\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine)\n            return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn)\n                return;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4\n                ? [column, sourcesIndex, sourceLine, sourceColumn]\n                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++)\n        arr[i] = [];\n    return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nlet generatedPositionFor;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nlet allGeneratedPositionsFor;\n/**\n * Iterates each mapping in generated position order.\n */\nlet eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nlet sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet encodedMap;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names;\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n(() => {\n    encodedMappings = (map) => {\n        var _a;\n        return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = encode(map._decoded)));\n    };\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    traceSegment = (map, line, column) => {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n        return index === -1 ? null : segments[index];\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n    eachMapping = (map, cb) => {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    };\n    sourceContentFor = (map, source) => {\n        const { sources, resolvedSources, sourcesContent } = map;\n        if (sourcesContent == null)\n            return null;\n        let index = sources.indexOf(source);\n        if (index === -1)\n            index = resolvedSources.indexOf(source);\n        return index === -1 ? null : sourcesContent[index];\n    };\n    presortedDecodedMap = (map, mapUrl) => {\n        const tracer = new TraceMap(clone(map, []), mapUrl);\n        tracer._decoded = map.mappings;\n        return tracer;\n    };\n    decodedMap = (map) => {\n        return clone(map, decodedMappings(map));\n    };\n    encodedMap = (map) => {\n        return clone(map, encodedMappings(map));\n    };\n    function generatedPosition(map, source, line, column, bias, all) {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return all ? [] : GMapping(null, null);\n        const generated = (map._bySources || (map._bySources = buildBySources(decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return all ? [] : GMapping(null, null);\n        const memo = map._bySourceMemos[sourceIndex];\n        if (all)\n            return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1)\n            return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n})();\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings,\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };\n//# sourceMappingURL=trace-mapping.mjs.map\n"}},"trace-mapping.mjs.map":{"file":{"contents":"{\"version\":3,\"file\":\"trace-mapping.mjs\",\"sources\":[\"../src/resolve.ts\",\"../src/strip-filename.ts\",\"../src/sourcemap-segment.ts\",\"../src/sort.ts\",\"../src/binary-search.ts\",\"../src/by-source.ts\",\"../src/any-map.ts\",\"../src/trace-mapping.ts\"],\"sourcesContent\":[\"import resolveUri from '@jridgewell/resolve-uri';\\n\\nexport default function resolve(input: string, base: string | undefined): string {\\n  // The base is always treated as a directory, if it's not empty.\\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\\n  if (base && !base.endsWith('/')) base += '/';\\n\\n  return resolveUri(input, base);\\n}\\n\",\"/**\\n * Removes everything after the last \\\"/\\\", but leaves the slash.\\n */\\nexport default function stripFilename(path: string | undefined | null): string {\\n  if (!path) return '';\\n  const index = path.lastIndexOf('/');\\n  return path.slice(0, index + 1);\\n}\\n\",\"type GeneratedColumn = number;\\ntype SourcesIndex = number;\\ntype SourceLine = number;\\ntype SourceColumn = number;\\ntype NamesIndex = number;\\n\\ntype GeneratedLine = number;\\n\\nexport type SourceMapSegment =\\n  | [GeneratedColumn]\\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\\n\\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\\n\\nexport const COLUMN = 0;\\nexport const SOURCES_INDEX = 1;\\nexport const SOURCE_LINE = 2;\\nexport const SOURCE_COLUMN = 3;\\nexport const NAMES_INDEX = 4;\\n\\nexport const REV_GENERATED_LINE = 1;\\nexport const REV_GENERATED_COLUMN = 2;\\n\",\"import { COLUMN } from './sourcemap-segment';\\n\\nimport type { SourceMapSegment } from './sourcemap-segment';\\n\\nexport default function maybeSort(\\n  mappings: SourceMapSegment[][],\\n  owned: boolean,\\n): SourceMapSegment[][] {\\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\\n  if (unsortedIndex === mappings.length) return mappings;\\n\\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\\n  // not, we do not want to modify the consumer's input array.\\n  if (!owned) mappings = mappings.slice();\\n\\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\\n    mappings[i] = sortSegments(mappings[i], owned);\\n  }\\n  return mappings;\\n}\\n\\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\\n  for (let i = start; i < mappings.length; i++) {\\n    if (!isSorted(mappings[i])) return i;\\n  }\\n  return mappings.length;\\n}\\n\\nfunction isSorted(line: SourceMapSegment[]): boolean {\\n  for (let j = 1; j < line.length; j++) {\\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\\n  if (!owned) line = line.slice();\\n  return line.sort(sortComparator);\\n}\\n\\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\\n  return a[COLUMN] - b[COLUMN];\\n}\\n\",\"import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\\nimport { COLUMN } from './sourcemap-segment';\\n\\nexport type MemoState = {\\n  lastKey: number;\\n  lastNeedle: number;\\n  lastIndex: number;\\n};\\n\\nexport let found = false;\\n\\n/**\\n * A binary search implementation that returns the index if a match is found.\\n * If no match is found, then the left-index (the index associated with the item that comes just\\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\\n * the next index:\\n *\\n * ```js\\n * const array = [1, 3];\\n * const needle = 2;\\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\\n *\\n * assert.equal(index, 0);\\n * array.splice(index + 1, 0, needle);\\n * assert.deepEqual(array, [1, 2, 3]);\\n * ```\\n */\\nexport function binarySearch(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  low: number,\\n  high: number,\\n): number {\\n  while (low <= high) {\\n    const mid = low + ((high - low) >> 1);\\n    const cmp = haystack[mid][COLUMN] - needle;\\n\\n    if (cmp === 0) {\\n      found = true;\\n      return mid;\\n    }\\n\\n    if (cmp < 0) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  found = false;\\n  return low - 1;\\n}\\n\\nexport function upperBound(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  index: number,\\n): number {\\n  for (let i = index + 1; i < haystack.length; index = i++) {\\n    if (haystack[i][COLUMN] !== needle) break;\\n  }\\n  return index;\\n}\\n\\nexport function lowerBound(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  index: number,\\n): number {\\n  for (let i = index - 1; i >= 0; index = i--) {\\n    if (haystack[i][COLUMN] !== needle) break;\\n  }\\n  return index;\\n}\\n\\nexport function memoizedState(): MemoState {\\n  return {\\n    lastKey: -1,\\n    lastNeedle: -1,\\n    lastIndex: -1,\\n  };\\n}\\n\\n/**\\n * This overly complicated beast is just to record the last tested line/column and the resulting\\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\\n */\\nexport function memoizedBinarySearch(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  state: MemoState,\\n  key: number,\\n): number {\\n  const { lastKey, lastNeedle, lastIndex } = state;\\n\\n  let low = 0;\\n  let high = haystack.length - 1;\\n  if (key === lastKey) {\\n    if (needle === lastNeedle) {\\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\\n      return lastIndex;\\n    }\\n\\n    if (needle >= lastNeedle) {\\n      // lastIndex may be -1 if the previous needle was not found.\\n      low = lastIndex === -1 ? 0 : lastIndex;\\n    } else {\\n      high = lastIndex;\\n    }\\n  }\\n  state.lastKey = key;\\n  state.lastNeedle = needle;\\n\\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\\n}\\n\",\"import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\\nimport { memoizedBinarySearch, upperBound } from './binary-search';\\n\\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\\nimport type { MemoState } from './binary-search';\\n\\nexport type Source = {\\n  __proto__: null;\\n  [line: number]: Exclude<ReverseSegment, [number]>[];\\n};\\n\\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\\n// of generated line/column.\\nexport default function buildBySources(\\n  decoded: readonly SourceMapSegment[][],\\n  memos: MemoState[],\\n): Source[] {\\n  const sources: Source[] = memos.map(buildNullArray);\\n\\n  for (let i = 0; i < decoded.length; i++) {\\n    const line = decoded[i];\\n    for (let j = 0; j < line.length; j++) {\\n      const seg = line[j];\\n      if (seg.length === 1) continue;\\n\\n      const sourceIndex = seg[SOURCES_INDEX];\\n      const sourceLine = seg[SOURCE_LINE];\\n      const sourceColumn = seg[SOURCE_COLUMN];\\n      const originalSource = sources[sourceIndex];\\n      const originalLine = (originalSource[sourceLine] ||= []);\\n      const memo = memos[sourceIndex];\\n\\n      // The binary search either found a match, or it found the left-index just before where the\\n      // segment should go. Either way, we want to insert after that. And there may be multiple\\n      // generated segments associated with an original location, so there may need to move several\\n      // indexes before we find where we need to insert.\\n      const index = upperBound(\\n        originalLine,\\n        sourceColumn,\\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\\n      );\\n\\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\\n    }\\n  }\\n\\n  return sources;\\n}\\n\\nfunction insert<T>(array: T[], index: number, value: T) {\\n  for (let i = array.length; i > index; i--) {\\n    array[i] = array[i - 1];\\n  }\\n  array[index] = value;\\n}\\n\\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\\n// order when iterating with for-in.\\nfunction buildNullArray<T extends { __proto__: null }>(): T {\\n  return { __proto__: null } as T;\\n}\\n\",\"import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\\nimport {\\n  COLUMN,\\n  SOURCES_INDEX,\\n  SOURCE_LINE,\\n  SOURCE_COLUMN,\\n  NAMES_INDEX,\\n} from './sourcemap-segment';\\n\\nimport type {\\n  Section,\\n  SectionedSourceMap,\\n  DecodedSourceMap,\\n  SectionedSourceMapInput,\\n  Ro,\\n} from './types';\\nimport type { SourceMapSegment } from './sourcemap-segment';\\n\\ntype AnyMap = {\\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\\n};\\n\\nexport const AnyMap: AnyMap = function (map, mapUrl) {\\n  const parsed =\\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\\n\\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\\n\\n  const mappings: SourceMapSegment[][] = [];\\n  const sources: string[] = [];\\n  const sourcesContent: (string | null)[] = [];\\n  const names: string[] = [];\\n\\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\\n\\n  const joined: DecodedSourceMap = {\\n    version: 3,\\n    file: parsed.file,\\n    names,\\n    sources,\\n    sourcesContent,\\n    mappings,\\n  };\\n\\n  return presortedDecodedMap(joined);\\n} as AnyMap;\\n\\nfunction recurse(\\n  input: Ro<SectionedSourceMap>,\\n  mapUrl: string | null | undefined,\\n  mappings: SourceMapSegment[][],\\n  sources: string[],\\n  sourcesContent: (string | null)[],\\n  names: string[],\\n  lineOffset: number,\\n  columnOffset: number,\\n  stopLine: number,\\n  stopColumn: number,\\n) {\\n  const { sections } = input;\\n  for (let i = 0; i < sections.length; i++) {\\n    const { map, offset } = sections[i];\\n\\n    let sl = stopLine;\\n    let sc = stopColumn;\\n    if (i + 1 < sections.length) {\\n      const nextOffset = sections[i + 1].offset;\\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\\n\\n      if (sl === stopLine) {\\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\\n      } else if (sl < stopLine) {\\n        sc = columnOffset + nextOffset.column;\\n      }\\n    }\\n\\n    addSection(\\n      map,\\n      mapUrl,\\n      mappings,\\n      sources,\\n      sourcesContent,\\n      names,\\n      lineOffset + offset.line,\\n      columnOffset + offset.column,\\n      sl,\\n      sc,\\n    );\\n  }\\n}\\n\\nfunction addSection(\\n  input: Ro<Section['map']>,\\n  mapUrl: string | null | undefined,\\n  mappings: SourceMapSegment[][],\\n  sources: string[],\\n  sourcesContent: (string | null)[],\\n  names: string[],\\n  lineOffset: number,\\n  columnOffset: number,\\n  stopLine: number,\\n  stopColumn: number,\\n) {\\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\\n\\n  const map = new TraceMap(input, mapUrl);\\n  const sourcesOffset = sources.length;\\n  const namesOffset = names.length;\\n  const decoded = decodedMappings(map);\\n  const { resolvedSources, sourcesContent: contents } = map;\\n\\n  append(sources, resolvedSources);\\n  append(names, map.names);\\n  if (contents) append(sourcesContent, contents);\\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\\n\\n  for (let i = 0; i < decoded.length; i++) {\\n    const lineI = lineOffset + i;\\n\\n    // We can only add so many lines before we step into the range that the next section's map\\n    // controls. When we get to the last line, then we'll start checking the segments to see if\\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\\n    // still need to check that we don't overstep lines, too.\\n    if (lineI > stopLine) return;\\n\\n    // The out line may already exist in mappings (if we're continuing the line started by a\\n    // previous section). Or, we may have jumped ahead several lines to start this section.\\n    const out = getLine(mappings, lineI);\\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\\n    // map can be multiple lines), it doesn't.\\n    const cOffset = i === 0 ? columnOffset : 0;\\n\\n    const line = decoded[i];\\n    for (let j = 0; j < line.length; j++) {\\n      const seg = line[j];\\n      const column = cOffset + seg[COLUMN];\\n\\n      // If this segment steps into the column range that the next section's map controls, we need\\n      // to stop early.\\n      if (lineI === stopLine && column >= stopColumn) return;\\n\\n      if (seg.length === 1) {\\n        out.push([column]);\\n        continue;\\n      }\\n\\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\\n      const sourceLine = seg[SOURCE_LINE];\\n      const sourceColumn = seg[SOURCE_COLUMN];\\n      out.push(\\n        seg.length === 4\\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\\n      );\\n    }\\n  }\\n}\\n\\nfunction append<T>(arr: T[], other: T[]) {\\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\\n}\\n\\nfunction getLine<T>(arr: T[][], index: number): T[] {\\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\\n  return arr[index];\\n}\\n\",\"import { encode, decode } from '@jridgewell/sourcemap-codec';\\n\\nimport resolve from './resolve';\\nimport stripFilename from './strip-filename';\\nimport maybeSort from './sort';\\nimport buildBySources from './by-source';\\nimport {\\n  memoizedState,\\n  memoizedBinarySearch,\\n  upperBound,\\n  lowerBound,\\n  found as bsFound,\\n} from './binary-search';\\nimport {\\n  COLUMN,\\n  SOURCES_INDEX,\\n  SOURCE_LINE,\\n  SOURCE_COLUMN,\\n  NAMES_INDEX,\\n  REV_GENERATED_LINE,\\n  REV_GENERATED_COLUMN,\\n} from './sourcemap-segment';\\n\\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\\nimport type {\\n  SourceMapV3,\\n  DecodedSourceMap,\\n  EncodedSourceMap,\\n  InvalidOriginalMapping,\\n  OriginalMapping,\\n  InvalidGeneratedMapping,\\n  GeneratedMapping,\\n  SourceMapInput,\\n  Needle,\\n  SourceNeedle,\\n  SourceMap,\\n  EachMapping,\\n  Bias,\\n} from './types';\\nimport type { Source } from './by-source';\\nimport type { MemoState } from './binary-search';\\n\\nexport type { SourceMapSegment } from './sourcemap-segment';\\nexport type {\\n  SourceMapInput,\\n  SectionedSourceMapInput,\\n  DecodedSourceMap,\\n  EncodedSourceMap,\\n  SectionedSourceMap,\\n  InvalidOriginalMapping,\\n  OriginalMapping as Mapping,\\n  OriginalMapping,\\n  InvalidGeneratedMapping,\\n  GeneratedMapping,\\n  EachMapping,\\n} from './types';\\n\\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\\n\\nexport const LEAST_UPPER_BOUND = -1;\\nexport const GREATEST_LOWER_BOUND = 1;\\n\\n/**\\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\\n */\\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\\n\\n/**\\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\\n */\\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\\n\\n/**\\n * A low-level API to find the segment associated with a generated line/column (think, from a\\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\\n */\\nexport let traceSegment: (\\n  map: TraceMap,\\n  line: number,\\n  column: number,\\n) => Readonly<SourceMapSegment> | null;\\n\\n/**\\n * A higher-level API to find the source/line/column associated with a generated line/column\\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\\n * `source-map` library.\\n */\\nexport let originalPositionFor: (\\n  map: TraceMap,\\n  needle: Needle,\\n) => OriginalMapping | InvalidOriginalMapping;\\n\\n/**\\n * Finds the generated line/column position of the provided source/line/column source position.\\n */\\nexport let generatedPositionFor: (\\n  map: TraceMap,\\n  needle: SourceNeedle,\\n) => GeneratedMapping | InvalidGeneratedMapping;\\n\\n/**\\n * Finds all generated line/column positions of the provided source/line/column source position.\\n */\\nexport let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\\n\\n/**\\n * Iterates each mapping in generated position order.\\n */\\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\\n\\n/**\\n * Retrieves the source content for a particular source, if its found. Returns null if not.\\n */\\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\\n\\n/**\\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\\n * maps.\\n */\\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\\n\\n/**\\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\\n * a sourcemap, or to JSON.stringify.\\n */\\nexport let decodedMap: (\\n  map: TraceMap,\\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\\n\\n/**\\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\\n * a sourcemap, or to JSON.stringify.\\n */\\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\\n\\nexport { AnyMap } from './any-map';\\n\\nexport class TraceMap implements SourceMap {\\n  declare version: SourceMapV3['version'];\\n  declare file: SourceMapV3['file'];\\n  declare names: SourceMapV3['names'];\\n  declare sourceRoot: SourceMapV3['sourceRoot'];\\n  declare sources: SourceMapV3['sources'];\\n  declare sourcesContent: SourceMapV3['sourcesContent'];\\n\\n  declare resolvedSources: string[];\\n  private declare _encoded: string | undefined;\\n\\n  private declare _decoded: SourceMapSegment[][] | undefined;\\n  private declare _decodedMemo: MemoState;\\n\\n  private declare _bySources: Source[] | undefined;\\n  private declare _bySourceMemos: MemoState[] | undefined;\\n\\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\\n    const isString = typeof map === 'string';\\n\\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\\n\\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\\n\\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\\n    this.version = version;\\n    this.file = file;\\n    this.names = names;\\n    this.sourceRoot = sourceRoot;\\n    this.sources = sources;\\n    this.sourcesContent = sourcesContent;\\n\\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\\n\\n    const { mappings } = parsed;\\n    if (typeof mappings === 'string') {\\n      this._encoded = mappings;\\n      this._decoded = undefined;\\n    } else {\\n      this._encoded = undefined;\\n      this._decoded = maybeSort(mappings, isString);\\n    }\\n\\n    this._decodedMemo = memoizedState();\\n    this._bySources = undefined;\\n    this._bySourceMemos = undefined;\\n  }\\n\\n  static {\\n    encodedMappings = (map) => {\\n      return (map._encoded ??= encode(map._decoded!));\\n    };\\n\\n    decodedMappings = (map) => {\\n      return (map._decoded ||= decode(map._encoded!));\\n    };\\n\\n    traceSegment = (map, line, column) => {\\n      const decoded = decodedMappings(map);\\n\\n      // It's common for parent source maps to have pointers to lines that have no\\n      // mapping (like a \\\"//# sourceMappingURL=\\\") at the end of the child file.\\n      if (line >= decoded.length) return null;\\n\\n      const segments = decoded[line];\\n      const index = traceSegmentInternal(\\n        segments,\\n        map._decodedMemo,\\n        line,\\n        column,\\n        GREATEST_LOWER_BOUND,\\n      );\\n\\n      return index === -1 ? null : segments[index];\\n    };\\n\\n    originalPositionFor = (map, { line, column, bias }) => {\\n      line--;\\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\\n\\n      const decoded = decodedMappings(map);\\n\\n      // It's common for parent source maps to have pointers to lines that have no\\n      // mapping (like a \\\"//# sourceMappingURL=\\\") at the end of the child file.\\n      if (line >= decoded.length) return OMapping(null, null, null, null);\\n\\n      const segments = decoded[line];\\n      const index = traceSegmentInternal(\\n        segments,\\n        map._decodedMemo,\\n        line,\\n        column,\\n        bias || GREATEST_LOWER_BOUND,\\n      );\\n\\n      if (index === -1) return OMapping(null, null, null, null);\\n\\n      const segment = segments[index];\\n      if (segment.length === 1) return OMapping(null, null, null, null);\\n\\n      const { names, resolvedSources } = map;\\n      return OMapping(\\n        resolvedSources[segment[SOURCES_INDEX]],\\n        segment[SOURCE_LINE] + 1,\\n        segment[SOURCE_COLUMN],\\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\\n      );\\n    };\\n\\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\\n    };\\n\\n    generatedPositionFor = (map, { source, line, column, bias }) => {\\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\\n    };\\n\\n    eachMapping = (map, cb) => {\\n      const decoded = decodedMappings(map);\\n      const { names, resolvedSources } = map;\\n\\n      for (let i = 0; i < decoded.length; i++) {\\n        const line = decoded[i];\\n        for (let j = 0; j < line.length; j++) {\\n          const seg = line[j];\\n\\n          const generatedLine = i + 1;\\n          const generatedColumn = seg[0];\\n          let source = null;\\n          let originalLine = null;\\n          let originalColumn = null;\\n          let name = null;\\n          if (seg.length !== 1) {\\n            source = resolvedSources[seg[1]];\\n            originalLine = seg[2] + 1;\\n            originalColumn = seg[3];\\n          }\\n          if (seg.length === 5) name = names[seg[4]];\\n\\n          cb({\\n            generatedLine,\\n            generatedColumn,\\n            source,\\n            originalLine,\\n            originalColumn,\\n            name,\\n          } as EachMapping);\\n        }\\n      }\\n    };\\n\\n    sourceContentFor = (map, source) => {\\n      const { sources, resolvedSources, sourcesContent } = map;\\n      if (sourcesContent == null) return null;\\n\\n      let index = sources.indexOf(source);\\n      if (index === -1) index = resolvedSources.indexOf(source);\\n\\n      return index === -1 ? null : sourcesContent[index];\\n    };\\n\\n    presortedDecodedMap = (map, mapUrl) => {\\n      const tracer = new TraceMap(clone(map, []), mapUrl);\\n      tracer._decoded = map.mappings;\\n      return tracer;\\n    };\\n\\n    decodedMap = (map) => {\\n      return clone(map, decodedMappings(map));\\n    };\\n\\n    encodedMap = (map) => {\\n      return clone(map, encodedMappings(map));\\n    };\\n\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: false,\\n    ): GeneratedMapping | InvalidGeneratedMapping;\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: true,\\n    ): GeneratedMapping[];\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: boolean,\\n    ): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\\n      line--;\\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\\n\\n      const { sources, resolvedSources } = map;\\n      let sourceIndex = sources.indexOf(source);\\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\\n\\n      const generated = (map._bySources ||= buildBySources(\\n        decodedMappings(map),\\n        (map._bySourceMemos = sources.map(memoizedState)),\\n      ));\\n\\n      const segments = generated[sourceIndex][line];\\n      if (segments == null) return all ? [] : GMapping(null, null);\\n\\n      const memo = map._bySourceMemos![sourceIndex];\\n\\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\\n\\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\\n      if (index === -1) return GMapping(null, null);\\n\\n      const segment = segments[index];\\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\\n    }\\n  }\\n}\\n\\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\\n  mappings: T,\\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\\n  return {\\n    version: map.version,\\n    file: map.file,\\n    names: map.names,\\n    sourceRoot: map.sourceRoot,\\n    sources: map.sources,\\n    sourcesContent: map.sourcesContent,\\n    mappings,\\n  } as any;\\n}\\n\\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\\nfunction OMapping(\\n  source: string,\\n  line: number,\\n  column: number,\\n  name: string | null,\\n): OriginalMapping;\\nfunction OMapping(\\n  source: string | null,\\n  line: number | null,\\n  column: number | null,\\n  name: string | null,\\n): OriginalMapping | InvalidOriginalMapping {\\n  return { source, line, column, name } as any;\\n}\\n\\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\\nfunction GMapping(line: number, column: number): GeneratedMapping;\\nfunction GMapping(\\n  line: number | null,\\n  column: number | null,\\n): GeneratedMapping | InvalidGeneratedMapping {\\n  return { line, column } as any;\\n}\\n\\nfunction traceSegmentInternal(\\n  segments: SourceMapSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number;\\nfunction traceSegmentInternal(\\n  segments: ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number;\\nfunction traceSegmentInternal(\\n  segments: SourceMapSegment[] | ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number {\\n  let index = memoizedBinarySearch(segments, column, memo, line);\\n  if (bsFound) {\\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\\n  } else if (bias === LEAST_UPPER_BOUND) index++;\\n\\n  if (index === -1 || index === segments.length) return -1;\\n  return index;\\n}\\n\\nfunction sliceGeneratedPositions(\\n  segments: ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): GeneratedMapping[] {\\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\\n\\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\\n  // match LEAST_UPPER_BOUND.\\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\\n\\n  if (min === -1 || min === segments.length) return [];\\n\\n  // We may have found the segment that started at an earlier column. If this is the case, then we\\n  // need to slice all generated segments that match _that_ column, because all such segments span\\n  // to our desired column.\\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\\n\\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\\n  const max = upperBound(segments, matchedColumn, min);\\n\\n  const result = [];\\n  for (; min <= max; min++) {\\n    const segment = segments[min];\\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\\n  }\\n  return result;\\n}\\n\"],\"names\":[\"bsFound\"],\"mappings\":\"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\"}"}},"trace-mapping.umd.js":{"file":{"contents":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, (function (exports, sourcemapCodec, resolveUri) { 'use strict';\n\n    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n    var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n    function resolve(input, base) {\n        // The base is always treated as a directory, if it's not empty.\n        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n        if (base && !base.endsWith('/'))\n            base += '/';\n        return resolveUri__default[\"default\"](input, base);\n    }\n\n    /**\n     * Removes everything after the last \"/\", but leaves the slash.\n     */\n    function stripFilename(path) {\n        if (!path)\n            return '';\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n    const REV_GENERATED_LINE = 1;\n    const REV_GENERATED_COLUMN = 2;\n\n    function maybeSort(mappings, owned) {\n        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n        if (unsortedIndex === mappings.length)\n            return mappings;\n        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n        // not, we do not want to modify the consumer's input array.\n        if (!owned)\n            mappings = mappings.slice();\n        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n            mappings[i] = sortSegments(mappings[i], owned);\n        }\n        return mappings;\n    }\n    function nextUnsortedSegmentLine(mappings, start) {\n        for (let i = start; i < mappings.length; i++) {\n            if (!isSorted(mappings[i]))\n                return i;\n        }\n        return mappings.length;\n    }\n    function isSorted(line) {\n        for (let j = 1; j < line.length; j++) {\n            if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sortSegments(line, owned) {\n        if (!owned)\n            line = line.slice();\n        return line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[COLUMN] - b[COLUMN];\n    }\n\n    let found = false;\n    /**\n     * A binary search implementation that returns the index if a match is found.\n     * If no match is found, then the left-index (the index associated with the item that comes just\n     * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n     * the next index:\n     *\n     * ```js\n     * const array = [1, 3];\n     * const needle = 2;\n     * const index = binarySearch(array, needle, (item, needle) => item - needle);\n     *\n     * assert.equal(index, 0);\n     * array.splice(index + 1, 0, needle);\n     * assert.deepEqual(array, [1, 2, 3]);\n     * ```\n     */\n    function binarySearch(haystack, needle, low, high) {\n        while (low <= high) {\n            const mid = low + ((high - low) >> 1);\n            const cmp = haystack[mid][COLUMN] - needle;\n            if (cmp === 0) {\n                found = true;\n                return mid;\n            }\n            if (cmp < 0) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        found = false;\n        return low - 1;\n    }\n    function upperBound(haystack, needle, index) {\n        for (let i = index + 1; i < haystack.length; index = i++) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function lowerBound(haystack, needle, index) {\n        for (let i = index - 1; i >= 0; index = i--) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function memoizedState() {\n        return {\n            lastKey: -1,\n            lastNeedle: -1,\n            lastIndex: -1,\n        };\n    }\n    /**\n     * This overly complicated beast is just to record the last tested line/column and the resulting\n     * index, allowing us to skip a few tests if mappings are monotonically increasing.\n     */\n    function memoizedBinarySearch(haystack, needle, state, key) {\n        const { lastKey, lastNeedle, lastIndex } = state;\n        let low = 0;\n        let high = haystack.length - 1;\n        if (key === lastKey) {\n            if (needle === lastNeedle) {\n                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n                return lastIndex;\n            }\n            if (needle >= lastNeedle) {\n                // lastIndex may be -1 if the previous needle was not found.\n                low = lastIndex === -1 ? 0 : lastIndex;\n            }\n            else {\n                high = lastIndex;\n            }\n        }\n        state.lastKey = key;\n        state.lastNeedle = needle;\n        return (state.lastIndex = binarySearch(haystack, needle, low, high));\n    }\n\n    // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n    // of generated line/column.\n    function buildBySources(decoded, memos) {\n        const sources = memos.map(buildNullArray);\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                if (seg.length === 1)\n                    continue;\n                const sourceIndex = seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                const originalSource = sources[sourceIndex];\n                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n                const memo = memos[sourceIndex];\n                // The binary search either found a match, or it found the left-index just before where the\n                // segment should go. Either way, we want to insert after that. And there may be multiple\n                // generated segments associated with an original location, so there may need to move several\n                // indexes before we find where we need to insert.\n                const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n                insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n            }\n        }\n        return sources;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n    // order when iterating with for-in.\n    function buildNullArray() {\n        return { __proto__: null };\n    }\n\n    const AnyMap = function (map, mapUrl) {\n        const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n        if (!('sections' in parsed))\n            return new TraceMap(parsed, mapUrl);\n        const mappings = [];\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n        const joined = {\n            version: 3,\n            file: parsed.file,\n            names,\n            sources,\n            sourcesContent,\n            mappings,\n        };\n        return exports.presortedDecodedMap(joined);\n    };\n    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        const { sections } = input;\n        for (let i = 0; i < sections.length; i++) {\n            const { map, offset } = sections[i];\n            let sl = stopLine;\n            let sc = stopColumn;\n            if (i + 1 < sections.length) {\n                const nextOffset = sections[i + 1].offset;\n                sl = Math.min(stopLine, lineOffset + nextOffset.line);\n                if (sl === stopLine) {\n                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n                }\n                else if (sl < stopLine) {\n                    sc = columnOffset + nextOffset.column;\n                }\n            }\n            addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n        }\n    }\n    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n        if ('sections' in input)\n            return recurse(...arguments);\n        const map = new TraceMap(input, mapUrl);\n        const sourcesOffset = sources.length;\n        const namesOffset = names.length;\n        const decoded = exports.decodedMappings(map);\n        const { resolvedSources, sourcesContent: contents } = map;\n        append(sources, resolvedSources);\n        append(names, map.names);\n        if (contents)\n            append(sourcesContent, contents);\n        else\n            for (let i = 0; i < resolvedSources.length; i++)\n                sourcesContent.push(null);\n        for (let i = 0; i < decoded.length; i++) {\n            const lineI = lineOffset + i;\n            // We can only add so many lines before we step into the range that the next section's map\n            // controls. When we get to the last line, then we'll start checking the segments to see if\n            // they've crossed into the column range. But it may not have any columns that overstep, so we\n            // still need to check that we don't overstep lines, too.\n            if (lineI > stopLine)\n                return;\n            // The out line may already exist in mappings (if we're continuing the line started by a\n            // previous section). Or, we may have jumped ahead several lines to start this section.\n            const out = getLine(mappings, lineI);\n            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n            // map can be multiple lines), it doesn't.\n            const cOffset = i === 0 ? columnOffset : 0;\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const column = cOffset + seg[COLUMN];\n                // If this segment steps into the column range that the next section's map controls, we need\n                // to stop early.\n                if (lineI === stopLine && column >= stopColumn)\n                    return;\n                if (seg.length === 1) {\n                    out.push([column]);\n                    continue;\n                }\n                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                out.push(seg.length === 4\n                    ? [column, sourcesIndex, sourceLine, sourceColumn]\n                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n            }\n        }\n    }\n    function append(arr, other) {\n        for (let i = 0; i < other.length; i++)\n            arr.push(other[i]);\n    }\n    function getLine(arr, index) {\n        for (let i = arr.length; i <= index; i++)\n            arr[i] = [];\n        return arr[index];\n    }\n\n    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n    const LEAST_UPPER_BOUND = -1;\n    const GREATEST_LOWER_BOUND = 1;\n    /**\n     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n     */\n    exports.encodedMappings = void 0;\n    /**\n     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n     */\n    exports.decodedMappings = void 0;\n    /**\n     * A low-level API to find the segment associated with a generated line/column (think, from a\n     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n     */\n    exports.traceSegment = void 0;\n    /**\n     * A higher-level API to find the source/line/column associated with a generated line/column\n     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n     * `source-map` library.\n     */\n    exports.originalPositionFor = void 0;\n    /**\n     * Finds the generated line/column position of the provided source/line/column source position.\n     */\n    exports.generatedPositionFor = void 0;\n    /**\n     * Finds all generated line/column positions of the provided source/line/column source position.\n     */\n    exports.allGeneratedPositionsFor = void 0;\n    /**\n     * Iterates each mapping in generated position order.\n     */\n    exports.eachMapping = void 0;\n    /**\n     * Retrieves the source content for a particular source, if its found. Returns null if not.\n     */\n    exports.sourceContentFor = void 0;\n    /**\n     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n     * maps.\n     */\n    exports.presortedDecodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.decodedMap = void 0;\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    exports.encodedMap = void 0;\n    class TraceMap {\n        constructor(map, mapUrl) {\n            const isString = typeof map === 'string';\n            if (!isString && map._decodedMemo)\n                return map;\n            const parsed = (isString ? JSON.parse(map) : map);\n            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n            this.version = version;\n            this.file = file;\n            this.names = names;\n            this.sourceRoot = sourceRoot;\n            this.sources = sources;\n            this.sourcesContent = sourcesContent;\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n            const { mappings } = parsed;\n            if (typeof mappings === 'string') {\n                this._encoded = mappings;\n                this._decoded = undefined;\n            }\n            else {\n                this._encoded = undefined;\n                this._decoded = maybeSort(mappings, isString);\n            }\n            this._decodedMemo = memoizedState();\n            this._bySources = undefined;\n            this._bySourceMemos = undefined;\n        }\n    }\n    (() => {\n        exports.encodedMappings = (map) => {\n            var _a;\n            return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = sourcemapCodec.encode(map._decoded)));\n        };\n        exports.decodedMappings = (map) => {\n            return (map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)));\n        };\n        exports.traceSegment = (map, line, column) => {\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return null;\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n            return index === -1 ? null : segments[index];\n        };\n        exports.originalPositionFor = (map, { line, column, bias }) => {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const decoded = exports.decodedMappings(map);\n            // It's common for parent source maps to have pointers to lines that have no\n            // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n            if (line >= decoded.length)\n                return OMapping(null, null, null, null);\n            const segments = decoded[line];\n            const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n            if (index === -1)\n                return OMapping(null, null, null, null);\n            const segment = segments[index];\n            if (segment.length === 1)\n                return OMapping(null, null, null, null);\n            const { names, resolvedSources } = map;\n            return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n        };\n        exports.allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n            // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n            return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n        };\n        exports.generatedPositionFor = (map, { source, line, column, bias }) => {\n            return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n        };\n        exports.eachMapping = (map, cb) => {\n            const decoded = exports.decodedMappings(map);\n            const { names, resolvedSources } = map;\n            for (let i = 0; i < decoded.length; i++) {\n                const line = decoded[i];\n                for (let j = 0; j < line.length; j++) {\n                    const seg = line[j];\n                    const generatedLine = i + 1;\n                    const generatedColumn = seg[0];\n                    let source = null;\n                    let originalLine = null;\n                    let originalColumn = null;\n                    let name = null;\n                    if (seg.length !== 1) {\n                        source = resolvedSources[seg[1]];\n                        originalLine = seg[2] + 1;\n                        originalColumn = seg[3];\n                    }\n                    if (seg.length === 5)\n                        name = names[seg[4]];\n                    cb({\n                        generatedLine,\n                        generatedColumn,\n                        source,\n                        originalLine,\n                        originalColumn,\n                        name,\n                    });\n                }\n            }\n        };\n        exports.sourceContentFor = (map, source) => {\n            const { sources, resolvedSources, sourcesContent } = map;\n            if (sourcesContent == null)\n                return null;\n            let index = sources.indexOf(source);\n            if (index === -1)\n                index = resolvedSources.indexOf(source);\n            return index === -1 ? null : sourcesContent[index];\n        };\n        exports.presortedDecodedMap = (map, mapUrl) => {\n            const tracer = new TraceMap(clone(map, []), mapUrl);\n            tracer._decoded = map.mappings;\n            return tracer;\n        };\n        exports.decodedMap = (map) => {\n            return clone(map, exports.decodedMappings(map));\n        };\n        exports.encodedMap = (map) => {\n            return clone(map, exports.encodedMappings(map));\n        };\n        function generatedPosition(map, source, line, column, bias, all) {\n            line--;\n            if (line < 0)\n                throw new Error(LINE_GTR_ZERO);\n            if (column < 0)\n                throw new Error(COL_GTR_EQ_ZERO);\n            const { sources, resolvedSources } = map;\n            let sourceIndex = sources.indexOf(source);\n            if (sourceIndex === -1)\n                sourceIndex = resolvedSources.indexOf(source);\n            if (sourceIndex === -1)\n                return all ? [] : GMapping(null, null);\n            const generated = (map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n            const segments = generated[sourceIndex][line];\n            if (segments == null)\n                return all ? [] : GMapping(null, null);\n            const memo = map._bySourceMemos[sourceIndex];\n            if (all)\n                return sliceGeneratedPositions(segments, memo, line, column, bias);\n            const index = traceSegmentInternal(segments, memo, line, column, bias);\n            if (index === -1)\n                return GMapping(null, null);\n            const segment = segments[index];\n            return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n        }\n    })();\n    function clone(map, mappings) {\n        return {\n            version: map.version,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings,\n        };\n    }\n    function OMapping(source, line, column, name) {\n        return { source, line, column, name };\n    }\n    function GMapping(line, column) {\n        return { line, column };\n    }\n    function traceSegmentInternal(segments, memo, line, column, bias) {\n        let index = memoizedBinarySearch(segments, column, memo, line);\n        if (found) {\n            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n        }\n        else if (bias === LEAST_UPPER_BOUND)\n            index++;\n        if (index === -1 || index === segments.length)\n            return -1;\n        return index;\n    }\n    function sliceGeneratedPositions(segments, memo, line, column, bias) {\n        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n        // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n        // match LEAST_UPPER_BOUND.\n        if (!found && bias === LEAST_UPPER_BOUND)\n            min++;\n        if (min === -1 || min === segments.length)\n            return [];\n        // We may have found the segment that started at an earlier column. If this is the case, then we\n        // need to slice all generated segments that match _that_ column, because all such segments span\n        // to our desired column.\n        const matchedColumn = found ? column : segments[min][COLUMN];\n        // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n        if (!found)\n            min = lowerBound(segments, matchedColumn, min);\n        const max = upperBound(segments, matchedColumn, min);\n        const result = [];\n        for (; min <= max; min++) {\n            const segment = segments[min];\n            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n        }\n        return result;\n    }\n\n    exports.AnyMap = AnyMap;\n    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n    exports.TraceMap = TraceMap;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n"}},"trace-mapping.umd.js.map":{"file":{"contents":"{\"version\":3,\"file\":\"trace-mapping.umd.js\",\"sources\":[\"../src/resolve.ts\",\"../src/strip-filename.ts\",\"../src/sourcemap-segment.ts\",\"../src/sort.ts\",\"../src/binary-search.ts\",\"../src/by-source.ts\",\"../src/any-map.ts\",\"../src/trace-mapping.ts\"],\"sourcesContent\":[\"import resolveUri from '@jridgewell/resolve-uri';\\n\\nexport default function resolve(input: string, base: string | undefined): string {\\n  // The base is always treated as a directory, if it's not empty.\\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\\n  if (base && !base.endsWith('/')) base += '/';\\n\\n  return resolveUri(input, base);\\n}\\n\",\"/**\\n * Removes everything after the last \\\"/\\\", but leaves the slash.\\n */\\nexport default function stripFilename(path: string | undefined | null): string {\\n  if (!path) return '';\\n  const index = path.lastIndexOf('/');\\n  return path.slice(0, index + 1);\\n}\\n\",\"type GeneratedColumn = number;\\ntype SourcesIndex = number;\\ntype SourceLine = number;\\ntype SourceColumn = number;\\ntype NamesIndex = number;\\n\\ntype GeneratedLine = number;\\n\\nexport type SourceMapSegment =\\n  | [GeneratedColumn]\\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\\n\\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\\n\\nexport const COLUMN = 0;\\nexport const SOURCES_INDEX = 1;\\nexport const SOURCE_LINE = 2;\\nexport const SOURCE_COLUMN = 3;\\nexport const NAMES_INDEX = 4;\\n\\nexport const REV_GENERATED_LINE = 1;\\nexport const REV_GENERATED_COLUMN = 2;\\n\",\"import { COLUMN } from './sourcemap-segment';\\n\\nimport type { SourceMapSegment } from './sourcemap-segment';\\n\\nexport default function maybeSort(\\n  mappings: SourceMapSegment[][],\\n  owned: boolean,\\n): SourceMapSegment[][] {\\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\\n  if (unsortedIndex === mappings.length) return mappings;\\n\\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\\n  // not, we do not want to modify the consumer's input array.\\n  if (!owned) mappings = mappings.slice();\\n\\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\\n    mappings[i] = sortSegments(mappings[i], owned);\\n  }\\n  return mappings;\\n}\\n\\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\\n  for (let i = start; i < mappings.length; i++) {\\n    if (!isSorted(mappings[i])) return i;\\n  }\\n  return mappings.length;\\n}\\n\\nfunction isSorted(line: SourceMapSegment[]): boolean {\\n  for (let j = 1; j < line.length; j++) {\\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\\n  if (!owned) line = line.slice();\\n  return line.sort(sortComparator);\\n}\\n\\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\\n  return a[COLUMN] - b[COLUMN];\\n}\\n\",\"import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\\nimport { COLUMN } from './sourcemap-segment';\\n\\nexport type MemoState = {\\n  lastKey: number;\\n  lastNeedle: number;\\n  lastIndex: number;\\n};\\n\\nexport let found = false;\\n\\n/**\\n * A binary search implementation that returns the index if a match is found.\\n * If no match is found, then the left-index (the index associated with the item that comes just\\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\\n * the next index:\\n *\\n * ```js\\n * const array = [1, 3];\\n * const needle = 2;\\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\\n *\\n * assert.equal(index, 0);\\n * array.splice(index + 1, 0, needle);\\n * assert.deepEqual(array, [1, 2, 3]);\\n * ```\\n */\\nexport function binarySearch(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  low: number,\\n  high: number,\\n): number {\\n  while (low <= high) {\\n    const mid = low + ((high - low) >> 1);\\n    const cmp = haystack[mid][COLUMN] - needle;\\n\\n    if (cmp === 0) {\\n      found = true;\\n      return mid;\\n    }\\n\\n    if (cmp < 0) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n\\n  found = false;\\n  return low - 1;\\n}\\n\\nexport function upperBound(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  index: number,\\n): number {\\n  for (let i = index + 1; i < haystack.length; index = i++) {\\n    if (haystack[i][COLUMN] !== needle) break;\\n  }\\n  return index;\\n}\\n\\nexport function lowerBound(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  index: number,\\n): number {\\n  for (let i = index - 1; i >= 0; index = i--) {\\n    if (haystack[i][COLUMN] !== needle) break;\\n  }\\n  return index;\\n}\\n\\nexport function memoizedState(): MemoState {\\n  return {\\n    lastKey: -1,\\n    lastNeedle: -1,\\n    lastIndex: -1,\\n  };\\n}\\n\\n/**\\n * This overly complicated beast is just to record the last tested line/column and the resulting\\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\\n */\\nexport function memoizedBinarySearch(\\n  haystack: SourceMapSegment[] | ReverseSegment[],\\n  needle: number,\\n  state: MemoState,\\n  key: number,\\n): number {\\n  const { lastKey, lastNeedle, lastIndex } = state;\\n\\n  let low = 0;\\n  let high = haystack.length - 1;\\n  if (key === lastKey) {\\n    if (needle === lastNeedle) {\\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\\n      return lastIndex;\\n    }\\n\\n    if (needle >= lastNeedle) {\\n      // lastIndex may be -1 if the previous needle was not found.\\n      low = lastIndex === -1 ? 0 : lastIndex;\\n    } else {\\n      high = lastIndex;\\n    }\\n  }\\n  state.lastKey = key;\\n  state.lastNeedle = needle;\\n\\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\\n}\\n\",\"import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\\nimport { memoizedBinarySearch, upperBound } from './binary-search';\\n\\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\\nimport type { MemoState } from './binary-search';\\n\\nexport type Source = {\\n  __proto__: null;\\n  [line: number]: Exclude<ReverseSegment, [number]>[];\\n};\\n\\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\\n// of generated line/column.\\nexport default function buildBySources(\\n  decoded: readonly SourceMapSegment[][],\\n  memos: MemoState[],\\n): Source[] {\\n  const sources: Source[] = memos.map(buildNullArray);\\n\\n  for (let i = 0; i < decoded.length; i++) {\\n    const line = decoded[i];\\n    for (let j = 0; j < line.length; j++) {\\n      const seg = line[j];\\n      if (seg.length === 1) continue;\\n\\n      const sourceIndex = seg[SOURCES_INDEX];\\n      const sourceLine = seg[SOURCE_LINE];\\n      const sourceColumn = seg[SOURCE_COLUMN];\\n      const originalSource = sources[sourceIndex];\\n      const originalLine = (originalSource[sourceLine] ||= []);\\n      const memo = memos[sourceIndex];\\n\\n      // The binary search either found a match, or it found the left-index just before where the\\n      // segment should go. Either way, we want to insert after that. And there may be multiple\\n      // generated segments associated with an original location, so there may need to move several\\n      // indexes before we find where we need to insert.\\n      const index = upperBound(\\n        originalLine,\\n        sourceColumn,\\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\\n      );\\n\\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\\n    }\\n  }\\n\\n  return sources;\\n}\\n\\nfunction insert<T>(array: T[], index: number, value: T) {\\n  for (let i = array.length; i > index; i--) {\\n    array[i] = array[i - 1];\\n  }\\n  array[index] = value;\\n}\\n\\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\\n// order when iterating with for-in.\\nfunction buildNullArray<T extends { __proto__: null }>(): T {\\n  return { __proto__: null } as T;\\n}\\n\",\"import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\\nimport {\\n  COLUMN,\\n  SOURCES_INDEX,\\n  SOURCE_LINE,\\n  SOURCE_COLUMN,\\n  NAMES_INDEX,\\n} from './sourcemap-segment';\\n\\nimport type {\\n  Section,\\n  SectionedSourceMap,\\n  DecodedSourceMap,\\n  SectionedSourceMapInput,\\n  Ro,\\n} from './types';\\nimport type { SourceMapSegment } from './sourcemap-segment';\\n\\ntype AnyMap = {\\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\\n};\\n\\nexport const AnyMap: AnyMap = function (map, mapUrl) {\\n  const parsed =\\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\\n\\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\\n\\n  const mappings: SourceMapSegment[][] = [];\\n  const sources: string[] = [];\\n  const sourcesContent: (string | null)[] = [];\\n  const names: string[] = [];\\n\\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\\n\\n  const joined: DecodedSourceMap = {\\n    version: 3,\\n    file: parsed.file,\\n    names,\\n    sources,\\n    sourcesContent,\\n    mappings,\\n  };\\n\\n  return presortedDecodedMap(joined);\\n} as AnyMap;\\n\\nfunction recurse(\\n  input: Ro<SectionedSourceMap>,\\n  mapUrl: string | null | undefined,\\n  mappings: SourceMapSegment[][],\\n  sources: string[],\\n  sourcesContent: (string | null)[],\\n  names: string[],\\n  lineOffset: number,\\n  columnOffset: number,\\n  stopLine: number,\\n  stopColumn: number,\\n) {\\n  const { sections } = input;\\n  for (let i = 0; i < sections.length; i++) {\\n    const { map, offset } = sections[i];\\n\\n    let sl = stopLine;\\n    let sc = stopColumn;\\n    if (i + 1 < sections.length) {\\n      const nextOffset = sections[i + 1].offset;\\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\\n\\n      if (sl === stopLine) {\\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\\n      } else if (sl < stopLine) {\\n        sc = columnOffset + nextOffset.column;\\n      }\\n    }\\n\\n    addSection(\\n      map,\\n      mapUrl,\\n      mappings,\\n      sources,\\n      sourcesContent,\\n      names,\\n      lineOffset + offset.line,\\n      columnOffset + offset.column,\\n      sl,\\n      sc,\\n    );\\n  }\\n}\\n\\nfunction addSection(\\n  input: Ro<Section['map']>,\\n  mapUrl: string | null | undefined,\\n  mappings: SourceMapSegment[][],\\n  sources: string[],\\n  sourcesContent: (string | null)[],\\n  names: string[],\\n  lineOffset: number,\\n  columnOffset: number,\\n  stopLine: number,\\n  stopColumn: number,\\n) {\\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\\n\\n  const map = new TraceMap(input, mapUrl);\\n  const sourcesOffset = sources.length;\\n  const namesOffset = names.length;\\n  const decoded = decodedMappings(map);\\n  const { resolvedSources, sourcesContent: contents } = map;\\n\\n  append(sources, resolvedSources);\\n  append(names, map.names);\\n  if (contents) append(sourcesContent, contents);\\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\\n\\n  for (let i = 0; i < decoded.length; i++) {\\n    const lineI = lineOffset + i;\\n\\n    // We can only add so many lines before we step into the range that the next section's map\\n    // controls. When we get to the last line, then we'll start checking the segments to see if\\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\\n    // still need to check that we don't overstep lines, too.\\n    if (lineI > stopLine) return;\\n\\n    // The out line may already exist in mappings (if we're continuing the line started by a\\n    // previous section). Or, we may have jumped ahead several lines to start this section.\\n    const out = getLine(mappings, lineI);\\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\\n    // map can be multiple lines), it doesn't.\\n    const cOffset = i === 0 ? columnOffset : 0;\\n\\n    const line = decoded[i];\\n    for (let j = 0; j < line.length; j++) {\\n      const seg = line[j];\\n      const column = cOffset + seg[COLUMN];\\n\\n      // If this segment steps into the column range that the next section's map controls, we need\\n      // to stop early.\\n      if (lineI === stopLine && column >= stopColumn) return;\\n\\n      if (seg.length === 1) {\\n        out.push([column]);\\n        continue;\\n      }\\n\\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\\n      const sourceLine = seg[SOURCE_LINE];\\n      const sourceColumn = seg[SOURCE_COLUMN];\\n      out.push(\\n        seg.length === 4\\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\\n      );\\n    }\\n  }\\n}\\n\\nfunction append<T>(arr: T[], other: T[]) {\\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\\n}\\n\\nfunction getLine<T>(arr: T[][], index: number): T[] {\\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\\n  return arr[index];\\n}\\n\",\"import { encode, decode } from '@jridgewell/sourcemap-codec';\\n\\nimport resolve from './resolve';\\nimport stripFilename from './strip-filename';\\nimport maybeSort from './sort';\\nimport buildBySources from './by-source';\\nimport {\\n  memoizedState,\\n  memoizedBinarySearch,\\n  upperBound,\\n  lowerBound,\\n  found as bsFound,\\n} from './binary-search';\\nimport {\\n  COLUMN,\\n  SOURCES_INDEX,\\n  SOURCE_LINE,\\n  SOURCE_COLUMN,\\n  NAMES_INDEX,\\n  REV_GENERATED_LINE,\\n  REV_GENERATED_COLUMN,\\n} from './sourcemap-segment';\\n\\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\\nimport type {\\n  SourceMapV3,\\n  DecodedSourceMap,\\n  EncodedSourceMap,\\n  InvalidOriginalMapping,\\n  OriginalMapping,\\n  InvalidGeneratedMapping,\\n  GeneratedMapping,\\n  SourceMapInput,\\n  Needle,\\n  SourceNeedle,\\n  SourceMap,\\n  EachMapping,\\n  Bias,\\n} from './types';\\nimport type { Source } from './by-source';\\nimport type { MemoState } from './binary-search';\\n\\nexport type { SourceMapSegment } from './sourcemap-segment';\\nexport type {\\n  SourceMapInput,\\n  SectionedSourceMapInput,\\n  DecodedSourceMap,\\n  EncodedSourceMap,\\n  SectionedSourceMap,\\n  InvalidOriginalMapping,\\n  OriginalMapping as Mapping,\\n  OriginalMapping,\\n  InvalidGeneratedMapping,\\n  GeneratedMapping,\\n  EachMapping,\\n} from './types';\\n\\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\\n\\nexport const LEAST_UPPER_BOUND = -1;\\nexport const GREATEST_LOWER_BOUND = 1;\\n\\n/**\\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\\n */\\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\\n\\n/**\\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\\n */\\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\\n\\n/**\\n * A low-level API to find the segment associated with a generated line/column (think, from a\\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\\n */\\nexport let traceSegment: (\\n  map: TraceMap,\\n  line: number,\\n  column: number,\\n) => Readonly<SourceMapSegment> | null;\\n\\n/**\\n * A higher-level API to find the source/line/column associated with a generated line/column\\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\\n * `source-map` library.\\n */\\nexport let originalPositionFor: (\\n  map: TraceMap,\\n  needle: Needle,\\n) => OriginalMapping | InvalidOriginalMapping;\\n\\n/**\\n * Finds the generated line/column position of the provided source/line/column source position.\\n */\\nexport let generatedPositionFor: (\\n  map: TraceMap,\\n  needle: SourceNeedle,\\n) => GeneratedMapping | InvalidGeneratedMapping;\\n\\n/**\\n * Finds all generated line/column positions of the provided source/line/column source position.\\n */\\nexport let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\\n\\n/**\\n * Iterates each mapping in generated position order.\\n */\\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\\n\\n/**\\n * Retrieves the source content for a particular source, if its found. Returns null if not.\\n */\\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\\n\\n/**\\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\\n * maps.\\n */\\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\\n\\n/**\\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\\n * a sourcemap, or to JSON.stringify.\\n */\\nexport let decodedMap: (\\n  map: TraceMap,\\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\\n\\n/**\\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\\n * a sourcemap, or to JSON.stringify.\\n */\\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\\n\\nexport { AnyMap } from './any-map';\\n\\nexport class TraceMap implements SourceMap {\\n  declare version: SourceMapV3['version'];\\n  declare file: SourceMapV3['file'];\\n  declare names: SourceMapV3['names'];\\n  declare sourceRoot: SourceMapV3['sourceRoot'];\\n  declare sources: SourceMapV3['sources'];\\n  declare sourcesContent: SourceMapV3['sourcesContent'];\\n\\n  declare resolvedSources: string[];\\n  private declare _encoded: string | undefined;\\n\\n  private declare _decoded: SourceMapSegment[][] | undefined;\\n  private declare _decodedMemo: MemoState;\\n\\n  private declare _bySources: Source[] | undefined;\\n  private declare _bySourceMemos: MemoState[] | undefined;\\n\\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\\n    const isString = typeof map === 'string';\\n\\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\\n\\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\\n\\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\\n    this.version = version;\\n    this.file = file;\\n    this.names = names;\\n    this.sourceRoot = sourceRoot;\\n    this.sources = sources;\\n    this.sourcesContent = sourcesContent;\\n\\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\\n\\n    const { mappings } = parsed;\\n    if (typeof mappings === 'string') {\\n      this._encoded = mappings;\\n      this._decoded = undefined;\\n    } else {\\n      this._encoded = undefined;\\n      this._decoded = maybeSort(mappings, isString);\\n    }\\n\\n    this._decodedMemo = memoizedState();\\n    this._bySources = undefined;\\n    this._bySourceMemos = undefined;\\n  }\\n\\n  static {\\n    encodedMappings = (map) => {\\n      return (map._encoded ??= encode(map._decoded!));\\n    };\\n\\n    decodedMappings = (map) => {\\n      return (map._decoded ||= decode(map._encoded!));\\n    };\\n\\n    traceSegment = (map, line, column) => {\\n      const decoded = decodedMappings(map);\\n\\n      // It's common for parent source maps to have pointers to lines that have no\\n      // mapping (like a \\\"//# sourceMappingURL=\\\") at the end of the child file.\\n      if (line >= decoded.length) return null;\\n\\n      const segments = decoded[line];\\n      const index = traceSegmentInternal(\\n        segments,\\n        map._decodedMemo,\\n        line,\\n        column,\\n        GREATEST_LOWER_BOUND,\\n      );\\n\\n      return index === -1 ? null : segments[index];\\n    };\\n\\n    originalPositionFor = (map, { line, column, bias }) => {\\n      line--;\\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\\n\\n      const decoded = decodedMappings(map);\\n\\n      // It's common for parent source maps to have pointers to lines that have no\\n      // mapping (like a \\\"//# sourceMappingURL=\\\") at the end of the child file.\\n      if (line >= decoded.length) return OMapping(null, null, null, null);\\n\\n      const segments = decoded[line];\\n      const index = traceSegmentInternal(\\n        segments,\\n        map._decodedMemo,\\n        line,\\n        column,\\n        bias || GREATEST_LOWER_BOUND,\\n      );\\n\\n      if (index === -1) return OMapping(null, null, null, null);\\n\\n      const segment = segments[index];\\n      if (segment.length === 1) return OMapping(null, null, null, null);\\n\\n      const { names, resolvedSources } = map;\\n      return OMapping(\\n        resolvedSources[segment[SOURCES_INDEX]],\\n        segment[SOURCE_LINE] + 1,\\n        segment[SOURCE_COLUMN],\\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\\n      );\\n    };\\n\\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\\n    };\\n\\n    generatedPositionFor = (map, { source, line, column, bias }) => {\\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\\n    };\\n\\n    eachMapping = (map, cb) => {\\n      const decoded = decodedMappings(map);\\n      const { names, resolvedSources } = map;\\n\\n      for (let i = 0; i < decoded.length; i++) {\\n        const line = decoded[i];\\n        for (let j = 0; j < line.length; j++) {\\n          const seg = line[j];\\n\\n          const generatedLine = i + 1;\\n          const generatedColumn = seg[0];\\n          let source = null;\\n          let originalLine = null;\\n          let originalColumn = null;\\n          let name = null;\\n          if (seg.length !== 1) {\\n            source = resolvedSources[seg[1]];\\n            originalLine = seg[2] + 1;\\n            originalColumn = seg[3];\\n          }\\n          if (seg.length === 5) name = names[seg[4]];\\n\\n          cb({\\n            generatedLine,\\n            generatedColumn,\\n            source,\\n            originalLine,\\n            originalColumn,\\n            name,\\n          } as EachMapping);\\n        }\\n      }\\n    };\\n\\n    sourceContentFor = (map, source) => {\\n      const { sources, resolvedSources, sourcesContent } = map;\\n      if (sourcesContent == null) return null;\\n\\n      let index = sources.indexOf(source);\\n      if (index === -1) index = resolvedSources.indexOf(source);\\n\\n      return index === -1 ? null : sourcesContent[index];\\n    };\\n\\n    presortedDecodedMap = (map, mapUrl) => {\\n      const tracer = new TraceMap(clone(map, []), mapUrl);\\n      tracer._decoded = map.mappings;\\n      return tracer;\\n    };\\n\\n    decodedMap = (map) => {\\n      return clone(map, decodedMappings(map));\\n    };\\n\\n    encodedMap = (map) => {\\n      return clone(map, encodedMappings(map));\\n    };\\n\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: false,\\n    ): GeneratedMapping | InvalidGeneratedMapping;\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: true,\\n    ): GeneratedMapping[];\\n    function generatedPosition(\\n      map: TraceMap,\\n      source: string,\\n      line: number,\\n      column: number,\\n      bias: Bias,\\n      all: boolean,\\n    ): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\\n      line--;\\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\\n\\n      const { sources, resolvedSources } = map;\\n      let sourceIndex = sources.indexOf(source);\\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\\n\\n      const generated = (map._bySources ||= buildBySources(\\n        decodedMappings(map),\\n        (map._bySourceMemos = sources.map(memoizedState)),\\n      ));\\n\\n      const segments = generated[sourceIndex][line];\\n      if (segments == null) return all ? [] : GMapping(null, null);\\n\\n      const memo = map._bySourceMemos![sourceIndex];\\n\\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\\n\\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\\n      if (index === -1) return GMapping(null, null);\\n\\n      const segment = segments[index];\\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\\n    }\\n  }\\n}\\n\\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\\n  mappings: T,\\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\\n  return {\\n    version: map.version,\\n    file: map.file,\\n    names: map.names,\\n    sourceRoot: map.sourceRoot,\\n    sources: map.sources,\\n    sourcesContent: map.sourcesContent,\\n    mappings,\\n  } as any;\\n}\\n\\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\\nfunction OMapping(\\n  source: string,\\n  line: number,\\n  column: number,\\n  name: string | null,\\n): OriginalMapping;\\nfunction OMapping(\\n  source: string | null,\\n  line: number | null,\\n  column: number | null,\\n  name: string | null,\\n): OriginalMapping | InvalidOriginalMapping {\\n  return { source, line, column, name } as any;\\n}\\n\\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\\nfunction GMapping(line: number, column: number): GeneratedMapping;\\nfunction GMapping(\\n  line: number | null,\\n  column: number | null,\\n): GeneratedMapping | InvalidGeneratedMapping {\\n  return { line, column } as any;\\n}\\n\\nfunction traceSegmentInternal(\\n  segments: SourceMapSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number;\\nfunction traceSegmentInternal(\\n  segments: ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number;\\nfunction traceSegmentInternal(\\n  segments: SourceMapSegment[] | ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): number {\\n  let index = memoizedBinarySearch(segments, column, memo, line);\\n  if (bsFound) {\\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\\n  } else if (bias === LEAST_UPPER_BOUND) index++;\\n\\n  if (index === -1 || index === segments.length) return -1;\\n  return index;\\n}\\n\\nfunction sliceGeneratedPositions(\\n  segments: ReverseSegment[],\\n  memo: MemoState,\\n  line: number,\\n  column: number,\\n  bias: Bias,\\n): GeneratedMapping[] {\\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\\n\\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\\n  // match LEAST_UPPER_BOUND.\\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\\n\\n  if (min === -1 || min === segments.length) return [];\\n\\n  // We may have found the segment that started at an earlier column. If this is the case, then we\\n  // need to slice all generated segments that match _that_ column, because all such segments span\\n  // to our desired column.\\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\\n\\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\\n  const max = upperBound(segments, matchedColumn, min);\\n\\n  const result = [];\\n  for (; min <= max; min++) {\\n    const segment = segments[min];\\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\\n  }\\n  return result;\\n}\\n\"],\"names\":[\"resolveUri\",\"presortedDecodedMap\",\"decodedMappings\",\"encodedMappings\",\"traceSegment\",\"originalPositionFor\",\"generatedPositionFor\",\"allGeneratedPositionsFor\",\"eachMapping\",\"sourceContentFor\",\"decodedMap\",\"encodedMap\",\"encode\",\"decode\",\"bsFound\"],\"mappings\":\"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\"}"}},"types":{"directory":{"any-map.d.ts":{"file":{"contents":"import { TraceMap } from './trace-mapping';\nimport type { SectionedSourceMapInput } from './types';\ndeclare type AnyMap = {\n    new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n    (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\nexport declare const AnyMap: AnyMap;\nexport {};\n"}},"binary-search.d.ts":{"file":{"contents":"import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nexport declare type MemoState = {\n    lastKey: number;\n    lastNeedle: number;\n    lastIndex: number;\n};\nexport declare let found: boolean;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport declare function binarySearch(haystack: SourceMapSegment[] | ReverseSegment[], needle: number, low: number, high: number): number;\nexport declare function upperBound(haystack: SourceMapSegment[] | ReverseSegment[], needle: number, index: number): number;\nexport declare function lowerBound(haystack: SourceMapSegment[] | ReverseSegment[], needle: number, index: number): number;\nexport declare function memoizedState(): MemoState;\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport declare function memoizedBinarySearch(haystack: SourceMapSegment[] | ReverseSegment[], needle: number, state: MemoState, key: number): number;\n"}},"by-source.d.ts":{"file":{"contents":"import type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\nexport declare type Source = {\n    __proto__: null;\n    [line: number]: Exclude<ReverseSegment, [number]>[];\n};\nexport default function buildBySources(decoded: readonly SourceMapSegment[][], memos: MemoState[]): Source[];\n"}},"resolve.d.ts":{"file":{"contents":"export default function resolve(input: string, base: string | undefined): string;\n"}},"sort.d.ts":{"file":{"contents":"import type { SourceMapSegment } from './sourcemap-segment';\nexport default function maybeSort(mappings: SourceMapSegment[][], owned: boolean): SourceMapSegment[][];\n"}},"sourcemap-segment.d.ts":{"file":{"contents":"declare type GeneratedColumn = number;\ndeclare type SourcesIndex = number;\ndeclare type SourceLine = number;\ndeclare type SourceColumn = number;\ndeclare type NamesIndex = number;\ndeclare type GeneratedLine = number;\nexport declare type SourceMapSegment = [GeneratedColumn] | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn] | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\nexport declare type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\nexport declare const COLUMN = 0;\nexport declare const SOURCES_INDEX = 1;\nexport declare const SOURCE_LINE = 2;\nexport declare const SOURCE_COLUMN = 3;\nexport declare const NAMES_INDEX = 4;\nexport declare const REV_GENERATED_LINE = 1;\nexport declare const REV_GENERATED_COLUMN = 2;\nexport {};\n"}},"strip-filename.d.ts":{"file":{"contents":"/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string;\n"}},"trace-mapping.d.ts":{"file":{"contents":"import type { SourceMapSegment } from './sourcemap-segment';\nimport type { SourceMapV3, DecodedSourceMap, EncodedSourceMap, InvalidOriginalMapping, OriginalMapping, InvalidGeneratedMapping, GeneratedMapping, SourceMapInput, Needle, SourceNeedle, SourceMap, EachMapping } from './types';\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type { SourceMapInput, SectionedSourceMapInput, DecodedSourceMap, EncodedSourceMap, SectionedSourceMap, InvalidOriginalMapping, OriginalMapping as Mapping, OriginalMapping, InvalidGeneratedMapping, GeneratedMapping, EachMapping, } from './types';\nexport declare const LEAST_UPPER_BOUND = -1;\nexport declare const GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport declare let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport declare let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport declare let traceSegment: (map: TraceMap, line: number, column: number) => Readonly<SourceMapSegment> | null;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport declare let originalPositionFor: (map: TraceMap, needle: Needle) => OriginalMapping | InvalidOriginalMapping;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport declare let generatedPositionFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping | InvalidGeneratedMapping;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport declare let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\n/**\n * Iterates each mapping in generated position order.\n */\nexport declare let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport declare let sourceContentFor: (map: TraceMap, source: string) => string | null;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport declare let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport declare let decodedMap: (map: TraceMap) => Omit<DecodedSourceMap, 'mappings'> & {\n    mappings: readonly SourceMapSegment[][];\n};\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport declare let encodedMap: (map: TraceMap) => EncodedSourceMap;\nexport { AnyMap } from './any-map';\nexport declare class TraceMap implements SourceMap {\n    version: SourceMapV3['version'];\n    file: SourceMapV3['file'];\n    names: SourceMapV3['names'];\n    sourceRoot: SourceMapV3['sourceRoot'];\n    sources: SourceMapV3['sources'];\n    sourcesContent: SourceMapV3['sourcesContent'];\n    resolvedSources: string[];\n    private _encoded;\n    private _decoded;\n    private _decodedMemo;\n    private _bySources;\n    private _bySourceMemos;\n    constructor(map: SourceMapInput, mapUrl?: string | null);\n}\n"}},"types.d.ts":{"file":{"contents":"import type { SourceMapSegment } from './sourcemap-segment';\nimport type { GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap } from './trace-mapping';\nexport interface SourceMapV3 {\n    file?: string | null;\n    names: string[];\n    sourceRoot?: string;\n    sources: (string | null)[];\n    sourcesContent?: (string | null)[];\n    version: 3;\n}\nexport interface EncodedSourceMap extends SourceMapV3 {\n    mappings: string;\n}\nexport interface DecodedSourceMap extends SourceMapV3 {\n    mappings: SourceMapSegment[][];\n}\nexport interface Section {\n    offset: {\n        line: number;\n        column: number;\n    };\n    map: EncodedSourceMap | DecodedSourceMap | SectionedSourceMap;\n}\nexport interface SectionedSourceMap {\n    file?: string | null;\n    sections: Section[];\n    version: 3;\n}\nexport declare type OriginalMapping = {\n    source: string | null;\n    line: number;\n    column: number;\n    name: string | null;\n};\nexport declare type InvalidOriginalMapping = {\n    source: null;\n    line: null;\n    column: null;\n    name: null;\n};\nexport declare type GeneratedMapping = {\n    line: number;\n    column: number;\n};\nexport declare type InvalidGeneratedMapping = {\n    line: null;\n    column: null;\n};\nexport declare type Bias = typeof GREATEST_LOWER_BOUND | typeof LEAST_UPPER_BOUND;\nexport declare type SourceMapInput = string | Ro<EncodedSourceMap> | Ro<DecodedSourceMap> | TraceMap;\nexport declare type SectionedSourceMapInput = SourceMapInput | Ro<SectionedSourceMap>;\nexport declare type Needle = {\n    line: number;\n    column: number;\n    bias?: Bias;\n};\nexport declare type SourceNeedle = {\n    source: string;\n    line: number;\n    column: number;\n    bias?: Bias;\n};\nexport declare type EachMapping = {\n    generatedLine: number;\n    generatedColumn: number;\n    source: null;\n    originalLine: null;\n    originalColumn: null;\n    name: null;\n} | {\n    generatedLine: number;\n    generatedColumn: number;\n    source: string | null;\n    originalLine: number;\n    originalColumn: number;\n    name: string | null;\n};\nexport declare abstract class SourceMap {\n    version: SourceMapV3['version'];\n    file: SourceMapV3['file'];\n    names: SourceMapV3['names'];\n    sourceRoot: SourceMapV3['sourceRoot'];\n    sources: SourceMapV3['sources'];\n    sourcesContent: SourceMapV3['sourcesContent'];\n    resolvedSources: SourceMapV3['sources'];\n}\nexport declare type Ro<T> = T extends Array<infer V> ? V[] | Readonly<V[]> | RoArray<V> | Readonly<RoArray<V>> : T extends object ? T | Readonly<T> | RoObject<T> | Readonly<RoObject<T>> : T;\ndeclare type RoArray<T> = Ro<T>[];\ndeclare type RoObject<T> = {\n    [K in keyof T]: T[K] | Ro<T[K]>;\n};\nexport {};\n"}}}}}},"LICENSE":{"file":{"contents":"Copyright 2022 Justin Ridgewell <justin@ridgewell.name>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"package.json":{"file":{"contents":"{\n  \"name\": \"@jridgewell/trace-mapping\",\n  \"version\": \"0.3.17\",\n  \"description\": \"Trace the original position through a source map\",\n  \"keywords\": [\n    \"source\",\n    \"map\"\n  ],\n  \"main\": \"dist/trace-mapping.umd.js\",\n  \"module\": \"dist/trace-mapping.mjs\",\n  \"typings\": \"dist/types/trace-mapping.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": [\n      {\n        \"types\": \"./dist/types/trace-mapping.d.ts\",\n        \"browser\": \"./dist/trace-mapping.umd.js\",\n        \"require\": \"./dist/trace-mapping.umd.js\",\n        \"import\": \"./dist/trace-mapping.mjs\"\n      },\n      \"./dist/trace-mapping.umd.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"author\": \"Justin Ridgewell <justin@ridgewell.name>\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jridgewell/trace-mapping.git\"\n  },\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"benchmark\": \"run-s build:rollup benchmark:*\",\n    \"benchmark:install\": \"cd benchmark && npm install\",\n    \"benchmark:only\": \"node --expose-gc benchmark/index.mjs\",\n    \"build\": \"run-s -n build:*\",\n    \"build:rollup\": \"rollup -c rollup.config.js\",\n    \"build:ts\": \"tsc --project tsconfig.build.json\",\n    \"lint\": \"run-s -n lint:*\",\n    \"lint:prettier\": \"npm run test:lint:prettier -- --write\",\n    \"lint:ts\": \"npm run test:lint:ts -- --fix\",\n    \"prebuild\": \"rm -rf dist\",\n    \"prepublishOnly\": \"npm run preversion\",\n    \"preversion\": \"run-s test build\",\n    \"test\": \"run-s -n test:lint test:only\",\n    \"test:debug\": \"ava debug\",\n    \"test:lint\": \"run-s -n test:lint:*\",\n    \"test:lint:prettier\": \"prettier --check '{src,test}/**/*.ts' '**/*.md'\",\n    \"test:lint:ts\": \"eslint '{src,test}/**/*.ts'\",\n    \"test:only\": \"c8 ava\",\n    \"test:watch\": \"ava --watch\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-typescript\": \"8.5.0\",\n    \"@typescript-eslint/eslint-plugin\": \"5.39.0\",\n    \"@typescript-eslint/parser\": \"5.39.0\",\n    \"ava\": \"4.3.3\",\n    \"benchmark\": \"2.1.4\",\n    \"c8\": \"7.12.0\",\n    \"esbuild\": \"0.15.10\",\n    \"eslint\": \"8.25.0\",\n    \"eslint-config-prettier\": \"8.5.0\",\n    \"eslint-plugin-no-only-tests\": \"3.0.0\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"2.7.1\",\n    \"rollup\": \"2.79.1\",\n    \"tsx\": \"3.10.1\",\n    \"typescript\": \"4.8.4\"\n  },\n  \"dependencies\": {\n    \"@jridgewell/resolve-uri\": \"3.1.0\",\n    \"@jridgewell/sourcemap-codec\": \"1.4.14\"\n  }\n}\n"}},"README.md":{"file":{"contents":"# @jridgewell/trace-mapping\n\n> Trace the original position through a source map\n\n`trace-mapping` allows you to take the line and column of an output file and trace it to the\noriginal location in the source file through a source map.\n\nYou may already be familiar with the [`source-map`][source-map] package's `SourceMapConsumer`. This\nprovides the same `originalPositionFor` and `generatedPositionFor` API, without requiring WASM.\n\n## Installation\n\n```sh\nnpm install @jridgewell/trace-mapping\n```\n\n## Usage\n\n```typescript\nimport {\n  TraceMap,\n  originalPositionFor,\n  generatedPositionFor,\n  sourceContentFor,\n} from '@jridgewell/trace-mapping';\n\nconst tracer = new TraceMap({\n  version: 3,\n  sources: ['input.js'],\n  sourcesContent: ['content of input.js'],\n  names: ['foo'],\n  mappings: 'KAyCIA',\n});\n\n// Lines start at line 1, columns at column 0.\nconst traced = originalPositionFor(tracer, { line: 1, column: 5 });\nassert.deepEqual(traced, {\n  source: 'input.js',\n  line: 42,\n  column: 4,\n  name: 'foo',\n});\n\nconst content = sourceContentFor(tracer, traced.source);\nassert.strictEqual(content, 'content for input.js');\n\nconst generated = generatedPositionFor(tracer, {\n  source: 'input.js',\n  line: 42,\n  column: 4,\n});\nassert.deepEqual(generated, {\n  line: 1,\n  column: 5,\n});\n```\n\nWe also provide a lower level API to get the actual segment that matches our line and column. Unlike\n`originalPositionFor`, `traceSegment` uses a 0-base for `line`:\n\n```typescript\nimport { traceSegment } from '@jridgewell/trace-mapping';\n\n// line is 0-base.\nconst traced = traceSegment(tracer, /* line */ 0, /* column */ 5);\n\n// Segments are [outputColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n// Again, line is 0-base and so is sourceLine\nassert.deepEqual(traced, [5, 0, 41, 4, 0]);\n```\n\n### SectionedSourceMaps\n\nThe sourcemap spec defines a special `sections` field that's designed to handle concatenation of\noutput code with associated sourcemaps. This type of sourcemap is rarely used (no major build tool\nproduces it), but if you are hand coding a concatenation you may need it. We provide an `AnyMap`\nhelper that can receive either a regular sourcemap or a `SectionedSourceMap` and returns a\n`TraceMap` instance:\n\n```typescript\nimport { AnyMap } from '@jridgewell/trace-mapping';\nconst fooOutput = 'foo';\nconst barOutput = 'bar';\nconst output = [fooOutput, barOutput].join('\\n');\n\nconst sectioned = new AnyMap({\n  version: 3,\n  sections: [\n    {\n      // 0-base line and column\n      offset: { line: 0, column: 0 },\n      // fooOutput's sourcemap\n      map: {\n        version: 3,\n        sources: ['foo.js'],\n        names: ['foo'],\n        mappings: 'AAAAA',\n      },\n    },\n    {\n      // barOutput's sourcemap will not affect the first line, only the second\n      offset: { line: 1, column: 0 },\n      map: {\n        version: 3,\n        sources: ['bar.js'],\n        names: ['bar'],\n        mappings: 'AAAAA',\n      },\n    },\n  ],\n});\n\nconst traced = originalPositionFor(sectioned, {\n  line: 2,\n  column: 0,\n});\n\nassert.deepEqual(traced, {\n  source: 'bar.js',\n  line: 1,\n  column: 0,\n  name: 'bar',\n});\n```\n\n## Benchmarks\n\n```\nnode v18.0.0\n\namp.js.map - 45120 segments\n\nMemory Usage:\ntrace-mapping decoded         562400 bytes\ntrace-mapping encoded        5706544 bytes\nsource-map-js               10717664 bytes\nsource-map-0.6.1            17446384 bytes\nsource-map-0.8.0             9701757 bytes\nSmallest memory usage is trace-mapping decoded\n\nInit speed:\ntrace-mapping:    decoded JSON input x 180 ops/sec ±0.34% (85 runs sampled)\ntrace-mapping:    encoded JSON input x 364 ops/sec ±1.77% (89 runs sampled)\ntrace-mapping:    decoded Object input x 3,116 ops/sec ±0.50% (96 runs sampled)\ntrace-mapping:    encoded Object input x 410 ops/sec ±2.62% (85 runs sampled)\nsource-map-js:    encoded Object input x 84.23 ops/sec ±0.91% (73 runs sampled)\nsource-map-0.6.1: encoded Object input x 37.21 ops/sec ±2.08% (51 runs sampled)\nFastest is trace-mapping:    decoded Object input\n\nTrace speed:\ntrace-mapping:    decoded originalPositionFor x 3,952,212 ops/sec ±0.17% (98 runs sampled)\ntrace-mapping:    encoded originalPositionFor x 3,487,468 ops/sec ±1.58% (90 runs sampled)\nsource-map-js:    encoded originalPositionFor x 827,730 ops/sec ±0.78% (97 runs sampled)\nsource-map-0.6.1: encoded originalPositionFor x 748,991 ops/sec ±0.53% (94 runs sampled)\nsource-map-0.8.0: encoded originalPositionFor x 2,532,894 ops/sec ±0.57% (95 runs sampled)\nFastest is trace-mapping:    decoded originalPositionFor\n\n\n***\n\n\nbabel.min.js.map - 347793 segments\n\nMemory Usage:\ntrace-mapping decoded          89832 bytes\ntrace-mapping encoded       35474640 bytes\nsource-map-js               51257176 bytes\nsource-map-0.6.1            63515664 bytes\nsource-map-0.8.0            42933752 bytes\nSmallest memory usage is trace-mapping decoded\n\nInit speed:\ntrace-mapping:    decoded JSON input x 15.41 ops/sec ±8.65% (34 runs sampled)\ntrace-mapping:    encoded JSON input x 28.20 ops/sec ±12.87% (42 runs sampled)\ntrace-mapping:    decoded Object input x 964 ops/sec ±0.36% (99 runs sampled)\ntrace-mapping:    encoded Object input x 31.77 ops/sec ±13.79% (45 runs sampled)\nsource-map-js:    encoded Object input x 6.45 ops/sec ±5.16% (21 runs sampled)\nsource-map-0.6.1: encoded Object input x 4.07 ops/sec ±5.24% (15 runs sampled)\nFastest is trace-mapping:    decoded Object input\n\nTrace speed:\ntrace-mapping:    decoded originalPositionFor x 7,183,038 ops/sec ±0.58% (95 runs sampled)\ntrace-mapping:    encoded originalPositionFor x 5,192,185 ops/sec ±0.41% (100 runs sampled)\nsource-map-js:    encoded originalPositionFor x 4,259,489 ops/sec ±0.79% (94 runs sampled)\nsource-map-0.6.1: encoded originalPositionFor x 3,742,629 ops/sec ±0.71% (95 runs sampled)\nsource-map-0.8.0: encoded originalPositionFor x 6,270,211 ops/sec ±0.64% (94 runs sampled)\nFastest is trace-mapping:    decoded originalPositionFor\n\n\n***\n\n\npreact.js.map - 1992 segments\n\nMemory Usage:\ntrace-mapping decoded          37128 bytes\ntrace-mapping encoded         247280 bytes\nsource-map-js                1143536 bytes\nsource-map-0.6.1             1290992 bytes\nsource-map-0.8.0               96544 bytes\nSmallest memory usage is trace-mapping decoded\n\nInit speed:\ntrace-mapping:    decoded JSON input x 3,483 ops/sec ±0.30% (98 runs sampled)\ntrace-mapping:    encoded JSON input x 6,092 ops/sec ±0.18% (97 runs sampled)\ntrace-mapping:    decoded Object input x 249,076 ops/sec ±0.24% (98 runs sampled)\ntrace-mapping:    encoded Object input x 14,555 ops/sec ±0.48% (100 runs sampled)\nsource-map-js:    encoded Object input x 2,447 ops/sec ±0.36% (99 runs sampled)\nsource-map-0.6.1: encoded Object input x 1,201 ops/sec ±0.57% (96 runs sampled)\nFastest is trace-mapping:    decoded Object input\n\nTrace speed:\ntrace-mapping:    decoded originalPositionFor x 7,620,192 ops/sec ±0.09% (99 runs sampled)\ntrace-mapping:    encoded originalPositionFor x 6,872,554 ops/sec ±0.30% (97 runs sampled)\nsource-map-js:    encoded originalPositionFor x 2,489,570 ops/sec ±0.35% (94 runs sampled)\nsource-map-0.6.1: encoded originalPositionFor x 1,698,633 ops/sec ±0.28% (98 runs sampled)\nsource-map-0.8.0: encoded originalPositionFor x 4,015,644 ops/sec ±0.22% (98 runs sampled)\nFastest is trace-mapping:    decoded originalPositionFor\n\n\n***\n\n\nreact.js.map - 5726 segments\n\nMemory Usage:\ntrace-mapping decoded          16176 bytes\ntrace-mapping encoded         681552 bytes\nsource-map-js                2418352 bytes\nsource-map-0.6.1             2443672 bytes\nsource-map-0.8.0              111768 bytes\nSmallest memory usage is trace-mapping decoded\n\nInit speed:\ntrace-mapping:    decoded JSON input x 1,720 ops/sec ±0.34% (98 runs sampled)\ntrace-mapping:    encoded JSON input x 4,406 ops/sec ±0.35% (100 runs sampled)\ntrace-mapping:    decoded Object input x 92,122 ops/sec ±0.10% (99 runs sampled)\ntrace-mapping:    encoded Object input x 5,385 ops/sec ±0.37% (99 runs sampled)\nsource-map-js:    encoded Object input x 794 ops/sec ±0.40% (98 runs sampled)\nsource-map-0.6.1: encoded Object input x 416 ops/sec ±0.54% (91 runs sampled)\nFastest is trace-mapping:    decoded Object input\n\nTrace speed:\ntrace-mapping:    decoded originalPositionFor x 32,759,519 ops/sec ±0.33% (100 runs sampled)\ntrace-mapping:    encoded originalPositionFor x 31,116,306 ops/sec ±0.33% (97 runs sampled)\nsource-map-js:    encoded originalPositionFor x 17,458,435 ops/sec ±0.44% (97 runs sampled)\nsource-map-0.6.1: encoded originalPositionFor x 12,687,097 ops/sec ±0.43% (95 runs sampled)\nsource-map-0.8.0: encoded originalPositionFor x 23,538,275 ops/sec ±0.38% (95 runs sampled)\nFastest is trace-mapping:    decoded originalPositionFor\n```\n\n[source-map]: https://www.npmjs.com/package/source-map\n"}}}}}}