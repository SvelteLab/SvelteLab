{"directory":{"fs.scandir":{"directory":{"LICENSE":{"file":{"contents":"The MIT License (MIT)\n\nCopyright (c) Denis Malinochkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"out":{"directory":{"adapters":{"directory":{"fs.d.ts":{"file":{"contents":"import type * as fsStat from '@nodelib/fs.stat';\nimport type { Dirent, ErrnoException } from '../types';\nexport interface ReaddirAsynchronousMethod {\n    (filepath: string, options: {\n        withFileTypes: true;\n    }, callback: (error: ErrnoException | null, files: Dirent[]) => void): void;\n    (filepath: string, callback: (error: ErrnoException | null, files: string[]) => void): void;\n}\nexport interface ReaddirSynchronousMethod {\n    (filepath: string, options: {\n        withFileTypes: true;\n    }): Dirent[];\n    (filepath: string): string[];\n}\nexport declare type FileSystemAdapter = fsStat.FileSystemAdapter & {\n    readdir: ReaddirAsynchronousMethod;\n    readdirSync: ReaddirSynchronousMethod;\n};\nexport declare const FILE_SYSTEM_ADAPTER: FileSystemAdapter;\nexport declare function createFileSystemAdapter(fsMethods?: Partial<FileSystemAdapter>): FileSystemAdapter;\n"}},"fs.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = require(\"fs\");\nexports.FILE_SYSTEM_ADAPTER = {\n    lstat: fs.lstat,\n    stat: fs.stat,\n    lstatSync: fs.lstatSync,\n    statSync: fs.statSync,\n    readdir: fs.readdir,\n    readdirSync: fs.readdirSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n    if (fsMethods === undefined) {\n        return exports.FILE_SYSTEM_ADAPTER;\n    }\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n"}}}},"constants.d.ts":{"file":{"contents":"/**\n * IS `true` for Node.js 10.10 and greater.\n */\nexport declare const IS_SUPPORT_READDIR_WITH_FILE_TYPES: boolean;\n"}},"constants.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;\nconst NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');\nif (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {\n    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);\n}\nconst MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\nconst MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\nconst SUPPORTED_MAJOR_VERSION = 10;\nconst SUPPORTED_MINOR_VERSION = 10;\nconst IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\nconst IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\n/**\n * IS `true` for Node.js 10.10 and greater.\n */\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\n"}},"index.d.ts":{"file":{"contents":"import type { FileSystemAdapter, ReaddirAsynchronousMethod, ReaddirSynchronousMethod } from './adapters/fs';\nimport * as async from './providers/async';\nimport Settings, { Options } from './settings';\nimport type { Dirent, Entry } from './types';\ndeclare type AsyncCallback = async.AsyncCallback;\ndeclare function scandir(path: string, callback: AsyncCallback): void;\ndeclare function scandir(path: string, optionsOrSettings: Options | Settings, callback: AsyncCallback): void;\ndeclare namespace scandir {\n    function __promisify__(path: string, optionsOrSettings?: Options | Settings): Promise<Entry[]>;\n}\ndeclare function scandirSync(path: string, optionsOrSettings?: Options | Settings): Entry[];\nexport { scandir, scandirSync, Settings, AsyncCallback, Dirent, Entry, FileSystemAdapter, ReaddirAsynchronousMethod, ReaddirSynchronousMethod, Options };\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Settings = exports.scandirSync = exports.scandir = void 0;\nconst async = require(\"./providers/async\");\nconst sync = require(\"./providers/sync\");\nconst settings_1 = require(\"./settings\");\nexports.Settings = settings_1.default;\nfunction scandir(path, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n    }\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.scandir = scandir;\nfunction scandirSync(path, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    return sync.read(path, settings);\n}\nexports.scandirSync = scandirSync;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n"}},"providers":{"directory":{"async.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport type Settings from '../settings';\nimport type { Entry } from '../types';\nexport declare type AsyncCallback = (error: NodeJS.ErrnoException, entries: Entry[]) => void;\nexport declare function read(directory: string, settings: Settings, callback: AsyncCallback): void;\nexport declare function readdirWithFileTypes(directory: string, settings: Settings, callback: AsyncCallback): void;\nexport declare function readdir(directory: string, settings: Settings, callback: AsyncCallback): void;\n"}},"async.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = require(\"@nodelib/fs.stat\");\nconst rpl = require(\"run-parallel\");\nconst constants_1 = require(\"../constants\");\nconst utils = require(\"../utils\");\nconst common = require(\"./common\");\nfunction read(directory, settings, callback) {\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        readdirWithFileTypes(directory, settings, callback);\n        return;\n    }\n    readdir(directory, settings, callback);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings, callback) {\n    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {\n        if (readdirError !== null) {\n            callFailureCallback(callback, readdirError);\n            return;\n        }\n        const entries = dirents.map((dirent) => ({\n            dirent,\n            name: dirent.name,\n            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        }));\n        if (!settings.followSymbolicLinks) {\n            callSuccessCallback(callback, entries);\n            return;\n        }\n        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));\n        rpl(tasks, (rplError, rplEntries) => {\n            if (rplError !== null) {\n                callFailureCallback(callback, rplError);\n                return;\n            }\n            callSuccessCallback(callback, rplEntries);\n        });\n    });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction makeRplTaskEntry(entry, settings) {\n    return (done) => {\n        if (!entry.dirent.isSymbolicLink()) {\n            done(null, entry);\n            return;\n        }\n        settings.fs.stat(entry.path, (statError, stats) => {\n            if (statError !== null) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    done(statError);\n                    return;\n                }\n                done(null, entry);\n                return;\n            }\n            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n            done(null, entry);\n        });\n    };\n}\nfunction readdir(directory, settings, callback) {\n    settings.fs.readdir(directory, (readdirError, names) => {\n        if (readdirError !== null) {\n            callFailureCallback(callback, readdirError);\n            return;\n        }\n        const tasks = names.map((name) => {\n            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n            return (done) => {\n                fsStat.stat(path, settings.fsStatSettings, (error, stats) => {\n                    if (error !== null) {\n                        done(error);\n                        return;\n                    }\n                    const entry = {\n                        name,\n                        path,\n                        dirent: utils.fs.createDirentFromStats(name, stats)\n                    };\n                    if (settings.stats) {\n                        entry.stats = stats;\n                    }\n                    done(null, entry);\n                });\n            };\n        });\n        rpl(tasks, (rplError, entries) => {\n            if (rplError !== null) {\n                callFailureCallback(callback, rplError);\n                return;\n            }\n            callSuccessCallback(callback, entries);\n        });\n    });\n}\nexports.readdir = readdir;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n    callback(null, result);\n}\n"}},"common.d.ts":{"file":{"contents":"export declare function joinPathSegments(a: string, b: string, separator: string): string;\n"}},"common.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinPathSegments = void 0;\nfunction joinPathSegments(a, b, separator) {\n    /**\n     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n     */\n    if (a.endsWith(separator)) {\n        return a + b;\n    }\n    return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n"}},"sync.d.ts":{"file":{"contents":"import type Settings from '../settings';\nimport type { Entry } from '../types';\nexport declare function read(directory: string, settings: Settings): Entry[];\nexport declare function readdirWithFileTypes(directory: string, settings: Settings): Entry[];\nexport declare function readdir(directory: string, settings: Settings): Entry[];\n"}},"sync.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = require(\"@nodelib/fs.stat\");\nconst constants_1 = require(\"../constants\");\nconst utils = require(\"../utils\");\nconst common = require(\"./common\");\nfunction read(directory, settings) {\n    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        return readdirWithFileTypes(directory, settings);\n    }\n    return readdir(directory, settings);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings) {\n    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });\n    return dirents.map((dirent) => {\n        const entry = {\n            dirent,\n            name: dirent.name,\n            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        };\n        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\n            try {\n                const stats = settings.fs.statSync(entry.path);\n                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n            }\n            catch (error) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    throw error;\n                }\n            }\n        }\n        return entry;\n    });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction readdir(directory, settings) {\n    const names = settings.fs.readdirSync(directory);\n    return names.map((name) => {\n        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\n        const entry = {\n            name,\n            path: entryPath,\n            dirent: utils.fs.createDirentFromStats(name, stats)\n        };\n        if (settings.stats) {\n            entry.stats = stats;\n        }\n        return entry;\n    });\n}\nexports.readdir = readdir;\n"}}}},"settings.d.ts":{"file":{"contents":"import * as fsStat from '@nodelib/fs.stat';\nimport * as fs from './adapters/fs';\nexport interface Options {\n    followSymbolicLinks?: boolean;\n    fs?: Partial<fs.FileSystemAdapter>;\n    pathSegmentSeparator?: string;\n    stats?: boolean;\n    throwErrorOnBrokenSymbolicLink?: boolean;\n}\nexport default class Settings {\n    private readonly _options;\n    readonly followSymbolicLinks: boolean;\n    readonly fs: fs.FileSystemAdapter;\n    readonly pathSegmentSeparator: string;\n    readonly stats: boolean;\n    readonly throwErrorOnBrokenSymbolicLink: boolean;\n    readonly fsStatSettings: fsStat.Settings;\n    constructor(_options?: Options);\n    private _getValue;\n}\n"}},"settings.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst fsStat = require(\"@nodelib/fs.stat\");\nconst fs = require(\"./adapters/fs\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.stats = this._getValue(this._options.stats, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n        this.fsStatSettings = new fsStat.Settings({\n            followSymbolicLink: this.followSymbolicLinks,\n            fs: this.fs,\n            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\n        });\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports.default = Settings;\n"}},"types":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport type * as fs from 'fs';\nexport interface Entry {\n    dirent: Dirent;\n    name: string;\n    path: string;\n    stats?: Stats;\n}\nexport declare type Stats = fs.Stats;\nexport declare type ErrnoException = NodeJS.ErrnoException;\nexport interface Dirent {\n    isBlockDevice: () => boolean;\n    isCharacterDevice: () => boolean;\n    isDirectory: () => boolean;\n    isFIFO: () => boolean;\n    isFile: () => boolean;\n    isSocket: () => boolean;\n    isSymbolicLink: () => boolean;\n    name: string;\n}\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"}}}},"utils":{"directory":{"fs.d.ts":{"file":{"contents":"import type { Dirent, Stats } from '../types';\nexport declare function createDirentFromStats(name: string, stats: Stats): Dirent;\n"}},"fs.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDirentFromStats = void 0;\nclass DirentFromStats {\n    constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n    }\n}\nfunction createDirentFromStats(name, stats) {\n    return new DirentFromStats(name, stats);\n}\nexports.createDirentFromStats = createDirentFromStats;\n"}},"index.d.ts":{"file":{"contents":"import * as fs from './fs';\nexport { fs };\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fs = void 0;\nconst fs = require(\"./fs\");\nexports.fs = fs;\n"}}}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"@nodelib/fs.scandir\",\n  \"version\": \"2.1.5\",\n  \"description\": \"List files and directories inside the specified directory\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/nodelib/nodelib/tree/master/packages/fs/fs.scandir\",\n  \"keywords\": [\n    \"NodeLib\",\n    \"fs\",\n    \"FileSystem\",\n    \"file system\",\n    \"scandir\",\n    \"readdir\",\n    \"dirent\"\n  ],\n  \"engines\": {\n    \"node\": \">= 8\"\n  },\n  \"files\": [\n    \"out/**\",\n    \"!out/**/*.map\",\n    \"!out/**/*.spec.*\"\n  ],\n  \"main\": \"out/index.js\",\n  \"typings\": \"out/index.d.ts\",\n  \"scripts\": {\n    \"clean\": \"rimraf {tsconfig.tsbuildinfo,out}\",\n    \"lint\": \"eslint \\\"src/**/*.ts\\\" --cache\",\n    \"compile\": \"tsc -b .\",\n    \"compile:watch\": \"tsc -p . --watch --sourceMap\",\n    \"test\": \"mocha \\\"out/**/*.spec.js\\\" -s 0\",\n    \"build\": \"npm run clean && npm run compile && npm run lint && npm test\",\n    \"watch\": \"npm run clean && npm run compile:watch\"\n  },\n  \"dependencies\": {\n    \"@nodelib/fs.stat\": \"2.0.5\",\n    \"run-parallel\": \"^1.1.9\"\n  },\n  \"devDependencies\": {\n    \"@nodelib/fs.macchiato\": \"1.0.4\",\n    \"@types/run-parallel\": \"^1.1.0\"\n  },\n  \"gitHead\": \"d6a7960d5281d3dd5f8e2efba49bb552d090f562\"\n}\n"}},"README.md":{"file":{"contents":"# @nodelib/fs.scandir\n\n> List files and directories inside the specified directory.\n\n## :bulb: Highlights\n\nThe package is aimed at obtaining information about entries in the directory.\n\n* :moneybag: Returns useful information: `name`, `path`, `dirent` and `stats` (optional).\n* :gear: On Node.js 10.10+ uses the mechanism without additional calls to determine the entry type. See [`old` and `modern` mode](#old-and-modern-mode).\n* :link: Can safely work with broken symbolic links.\n\n## Install\n\n```console\nnpm install @nodelib/fs.scandir\n```\n\n## Usage\n\n```ts\nimport * as fsScandir from '@nodelib/fs.scandir';\n\nfsScandir.scandir('path', (error, stats) => { /* … */ });\n```\n\n## API\n\n### .scandir(path, [optionsOrSettings], callback)\n\nReturns an array of plain objects ([`Entry`](#entry)) with information about entry for provided path with standard callback-style.\n\n```ts\nfsScandir.scandir('path', (error, entries) => { /* … */ });\nfsScandir.scandir('path', {}, (error, entries) => { /* … */ });\nfsScandir.scandir('path', new fsScandir.Settings(), (error, entries) => { /* … */ });\n```\n\n### .scandirSync(path, [optionsOrSettings])\n\nReturns an array of plain objects ([`Entry`](#entry)) with information about entry for provided path.\n\n```ts\nconst entries = fsScandir.scandirSync('path');\nconst entries = fsScandir.scandirSync('path', {});\nconst entries = fsScandir.scandirSync(('path', new fsScandir.Settings());\n```\n\n#### path\n\n* Required: `true`\n* Type: `string | Buffer | URL`\n\nA path to a file. If a URL is provided, it must use the `file:` protocol.\n\n#### optionsOrSettings\n\n* Required: `false`\n* Type: `Options | Settings`\n* Default: An instance of `Settings` class\n\nAn [`Options`](#options) object or an instance of [`Settings`](#settingsoptions) class.\n\n> :book: When you pass a plain object, an instance of the `Settings` class will be created automatically. If you plan to call the method frequently, use a pre-created instance of the `Settings` class.\n\n### Settings([options])\n\nA class of full settings of the package.\n\n```ts\nconst settings = new fsScandir.Settings({ followSymbolicLinks: false });\n\nconst entries = fsScandir.scandirSync('path', settings);\n```\n\n## Entry\n\n* `name` — The name of the entry (`unknown.txt`).\n* `path` — The path of the entry relative to call directory (`root/unknown.txt`).\n* `dirent` — An instance of [`fs.Dirent`](./src/types/index.ts) class. On Node.js below 10.10 will be emulated by [`DirentFromStats`](./src/utils/fs.ts) class.\n* `stats` (optional) — An instance of `fs.Stats` class.\n\nFor example, the `scandir` call for `tools` directory with one directory inside:\n\n```ts\n{\n\tdirent: Dirent { name: 'typedoc', /* … */ },\n\tname: 'typedoc',\n\tpath: 'tools/typedoc'\n}\n```\n\n## Options\n\n### stats\n\n* Type: `boolean`\n* Default: `false`\n\nAdds an instance of `fs.Stats` class to the [`Entry`](#entry).\n\n> :book: Always use `fs.readdir` without the `withFileTypes` option. ??TODO??\n\n### followSymbolicLinks\n\n* Type: `boolean`\n* Default: `false`\n\nFollow symbolic links or not. Call `fs.stat` on symbolic link if `true`.\n\n### `throwErrorOnBrokenSymbolicLink`\n\n* Type: `boolean`\n* Default: `true`\n\nThrow an error when symbolic link is broken if `true` or safely use `lstat` call if `false`.\n\n### `pathSegmentSeparator`\n\n* Type: `string`\n* Default: `path.sep`\n\nBy default, this package uses the correct path separator for your OS (`\\` on Windows, `/` on Unix-like systems). But you can set this option to any separator character(s) that you want to use instead.\n\n### `fs`\n\n* Type: [`FileSystemAdapter`](./src/adapters/fs.ts)\n* Default: A default FS methods\n\nBy default, the built-in Node.js module (`fs`) is used to work with the file system. You can replace any method with your own.\n\n```ts\ninterface FileSystemAdapter {\n\tlstat?: typeof fs.lstat;\n\tstat?: typeof fs.stat;\n\tlstatSync?: typeof fs.lstatSync;\n\tstatSync?: typeof fs.statSync;\n\treaddir?: typeof fs.readdir;\n\treaddirSync?: typeof fs.readdirSync;\n}\n\nconst settings = new fsScandir.Settings({\n\tfs: { lstat: fakeLstat }\n});\n```\n\n## `old` and `modern` mode\n\nThis package has two modes that are used depending on the environment and parameters of use.\n\n### old\n\n* Node.js below `10.10` or when the `stats` option is enabled\n\nWhen working in the old mode, the directory is read first (`fs.readdir`), then the type of entries is determined (`fs.lstat` and/or `fs.stat` for symbolic links).\n\n### modern\n\n* Node.js 10.10+ and the `stats` option is disabled\n\nIn the modern mode, reading the directory (`fs.readdir` with the `withFileTypes` option) is combined with obtaining information about its entries. An additional call for symbolic links (`fs.stat`) is still present.\n\nThis mode makes fewer calls to the file system. It's faster.\n\n## Changelog\n\nSee the [Releases section of our GitHub project](https://github.com/nodelib/nodelib/releases) for changelog for each release version.\n\n## License\n\nThis software is released under the terms of the MIT license.\n"}}}},"fs.stat":{"directory":{"LICENSE":{"file":{"contents":"The MIT License (MIT)\n\nCopyright (c) Denis Malinochkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"out":{"directory":{"adapters":{"directory":{"fs.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport * as fs from 'fs';\nimport type { ErrnoException } from '../types';\nexport declare type StatAsynchronousMethod = (path: string, callback: (error: ErrnoException | null, stats: fs.Stats) => void) => void;\nexport declare type StatSynchronousMethod = (path: string) => fs.Stats;\nexport interface FileSystemAdapter {\n    lstat: StatAsynchronousMethod;\n    stat: StatAsynchronousMethod;\n    lstatSync: StatSynchronousMethod;\n    statSync: StatSynchronousMethod;\n}\nexport declare const FILE_SYSTEM_ADAPTER: FileSystemAdapter;\nexport declare function createFileSystemAdapter(fsMethods?: Partial<FileSystemAdapter>): FileSystemAdapter;\n"}},"fs.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = require(\"fs\");\nexports.FILE_SYSTEM_ADAPTER = {\n    lstat: fs.lstat,\n    stat: fs.stat,\n    lstatSync: fs.lstatSync,\n    statSync: fs.statSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n    if (fsMethods === undefined) {\n        return exports.FILE_SYSTEM_ADAPTER;\n    }\n    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n"}}}},"index.d.ts":{"file":{"contents":"import type { FileSystemAdapter, StatAsynchronousMethod, StatSynchronousMethod } from './adapters/fs';\nimport * as async from './providers/async';\nimport Settings, { Options } from './settings';\nimport type { Stats } from './types';\ndeclare type AsyncCallback = async.AsyncCallback;\ndeclare function stat(path: string, callback: AsyncCallback): void;\ndeclare function stat(path: string, optionsOrSettings: Options | Settings, callback: AsyncCallback): void;\ndeclare namespace stat {\n    function __promisify__(path: string, optionsOrSettings?: Options | Settings): Promise<Stats>;\n}\ndeclare function statSync(path: string, optionsOrSettings?: Options | Settings): Stats;\nexport { Settings, stat, statSync, AsyncCallback, FileSystemAdapter, StatAsynchronousMethod, StatSynchronousMethod, Options, Stats };\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.statSync = exports.stat = exports.Settings = void 0;\nconst async = require(\"./providers/async\");\nconst sync = require(\"./providers/sync\");\nconst settings_1 = require(\"./settings\");\nexports.Settings = settings_1.default;\nfunction stat(path, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n    }\n    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.stat = stat;\nfunction statSync(path, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    return sync.read(path, settings);\n}\nexports.statSync = statSync;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n"}},"providers":{"directory":{"async.d.ts":{"file":{"contents":"import type Settings from '../settings';\nimport type { ErrnoException, Stats } from '../types';\nexport declare type AsyncCallback = (error: ErrnoException, stats: Stats) => void;\nexport declare function read(path: string, settings: Settings, callback: AsyncCallback): void;\n"}},"async.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read = void 0;\nfunction read(path, settings, callback) {\n    settings.fs.lstat(path, (lstatError, lstat) => {\n        if (lstatError !== null) {\n            callFailureCallback(callback, lstatError);\n            return;\n        }\n        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n            callSuccessCallback(callback, lstat);\n            return;\n        }\n        settings.fs.stat(path, (statError, stat) => {\n            if (statError !== null) {\n                if (settings.throwErrorOnBrokenSymbolicLink) {\n                    callFailureCallback(callback, statError);\n                    return;\n                }\n                callSuccessCallback(callback, lstat);\n                return;\n            }\n            if (settings.markSymbolicLink) {\n                stat.isSymbolicLink = () => true;\n            }\n            callSuccessCallback(callback, stat);\n        });\n    });\n}\nexports.read = read;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n    callback(null, result);\n}\n"}},"sync.d.ts":{"file":{"contents":"import type Settings from '../settings';\nimport type { Stats } from '../types';\nexport declare function read(path: string, settings: Settings): Stats;\n"}},"sync.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read = void 0;\nfunction read(path, settings) {\n    const lstat = settings.fs.lstatSync(path);\n    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n        return lstat;\n    }\n    try {\n        const stat = settings.fs.statSync(path);\n        if (settings.markSymbolicLink) {\n            stat.isSymbolicLink = () => true;\n        }\n        return stat;\n    }\n    catch (error) {\n        if (!settings.throwErrorOnBrokenSymbolicLink) {\n            return lstat;\n        }\n        throw error;\n    }\n}\nexports.read = read;\n"}}}},"settings.d.ts":{"file":{"contents":"import * as fs from './adapters/fs';\nexport interface Options {\n    followSymbolicLink?: boolean;\n    fs?: Partial<fs.FileSystemAdapter>;\n    markSymbolicLink?: boolean;\n    throwErrorOnBrokenSymbolicLink?: boolean;\n}\nexport default class Settings {\n    private readonly _options;\n    readonly followSymbolicLink: boolean;\n    readonly fs: fs.FileSystemAdapter;\n    readonly markSymbolicLink: boolean;\n    readonly throwErrorOnBrokenSymbolicLink: boolean;\n    constructor(_options?: Options);\n    private _getValue;\n}\n"}},"settings.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"./adapters/fs\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports.default = Settings;\n"}},"types":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport type * as fs from 'fs';\nexport declare type Stats = fs.Stats;\nexport declare type ErrnoException = NodeJS.ErrnoException;\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"}}}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"@nodelib/fs.stat\",\n  \"version\": \"2.0.5\",\n  \"description\": \"Get the status of a file with some features\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/nodelib/nodelib/tree/master/packages/fs/fs.stat\",\n  \"keywords\": [\n    \"NodeLib\",\n    \"fs\",\n    \"FileSystem\",\n    \"file system\",\n    \"stat\"\n  ],\n  \"engines\": {\n    \"node\": \">= 8\"\n  },\n  \"files\": [\n    \"out/**\",\n    \"!out/**/*.map\",\n    \"!out/**/*.spec.*\"\n  ],\n  \"main\": \"out/index.js\",\n  \"typings\": \"out/index.d.ts\",\n  \"scripts\": {\n    \"clean\": \"rimraf {tsconfig.tsbuildinfo,out}\",\n    \"lint\": \"eslint \\\"src/**/*.ts\\\" --cache\",\n    \"compile\": \"tsc -b .\",\n    \"compile:watch\": \"tsc -p . --watch --sourceMap\",\n    \"test\": \"mocha \\\"out/**/*.spec.js\\\" -s 0\",\n    \"build\": \"npm run clean && npm run compile && npm run lint && npm test\",\n    \"watch\": \"npm run clean && npm run compile:watch\"\n  },\n  \"devDependencies\": {\n    \"@nodelib/fs.macchiato\": \"1.0.4\"\n  },\n  \"gitHead\": \"d6a7960d5281d3dd5f8e2efba49bb552d090f562\"\n}\n"}},"README.md":{"file":{"contents":"# @nodelib/fs.stat\n\n> Get the status of a file with some features.\n\n## :bulb: Highlights\n\nWrapper around standard method `fs.lstat` and `fs.stat` with some features.\n\n* :beginner: Normally follows symbolic link.\n* :gear: Can safely work with broken symbolic link.\n\n## Install\n\n```console\nnpm install @nodelib/fs.stat\n```\n\n## Usage\n\n```ts\nimport * as fsStat from '@nodelib/fs.stat';\n\nfsStat.stat('path', (error, stats) => { /* … */ });\n```\n\n## API\n\n### .stat(path, [optionsOrSettings], callback)\n\nReturns an instance of `fs.Stats` class for provided path with standard callback-style.\n\n```ts\nfsStat.stat('path', (error, stats) => { /* … */ });\nfsStat.stat('path', {}, (error, stats) => { /* … */ });\nfsStat.stat('path', new fsStat.Settings(), (error, stats) => { /* … */ });\n```\n\n### .statSync(path, [optionsOrSettings])\n\nReturns an instance of `fs.Stats` class for provided path.\n\n```ts\nconst stats = fsStat.stat('path');\nconst stats = fsStat.stat('path', {});\nconst stats = fsStat.stat('path', new fsStat.Settings());\n```\n\n#### path\n\n* Required: `true`\n* Type: `string | Buffer | URL`\n\nA path to a file. If a URL is provided, it must use the `file:` protocol.\n\n#### optionsOrSettings\n\n* Required: `false`\n* Type: `Options | Settings`\n* Default: An instance of `Settings` class\n\nAn [`Options`](#options) object or an instance of [`Settings`](#settings) class.\n\n> :book: When you pass a plain object, an instance of the `Settings` class will be created automatically. If you plan to call the method frequently, use a pre-created instance of the `Settings` class.\n\n### Settings([options])\n\nA class of full settings of the package.\n\n```ts\nconst settings = new fsStat.Settings({ followSymbolicLink: false });\n\nconst stats = fsStat.stat('path', settings);\n```\n\n## Options\n\n### `followSymbolicLink`\n\n* Type: `boolean`\n* Default: `true`\n\nFollow symbolic link or not. Call `fs.stat` on symbolic link if `true`.\n\n### `markSymbolicLink`\n\n* Type: `boolean`\n* Default: `false`\n\nMark symbolic link by setting the return value of `isSymbolicLink` function to always `true` (even after `fs.stat`).\n\n> :book: Can be used if you want to know what is hidden behind a symbolic link, but still continue to know that it is a symbolic link.\n\n### `throwErrorOnBrokenSymbolicLink`\n\n* Type: `boolean`\n* Default: `true`\n\nThrow an error when symbolic link is broken if `true` or safely return `lstat` call if `false`.\n\n### `fs`\n\n* Type: [`FileSystemAdapter`](./src/adapters/fs.ts)\n* Default: A default FS methods\n\nBy default, the built-in Node.js module (`fs`) is used to work with the file system. You can replace any method with your own.\n\n```ts\ninterface FileSystemAdapter {\n\tlstat?: typeof fs.lstat;\n\tstat?: typeof fs.stat;\n\tlstatSync?: typeof fs.lstatSync;\n\tstatSync?: typeof fs.statSync;\n}\n\nconst settings = new fsStat.Settings({\n\tfs: { lstat: fakeLstat }\n});\n```\n\n## Changelog\n\nSee the [Releases section of our GitHub project](https://github.com/nodelib/nodelib/releases) for changelog for each release version.\n\n## License\n\nThis software is released under the terms of the MIT license.\n"}}}},"fs.walk":{"directory":{"LICENSE":{"file":{"contents":"The MIT License (MIT)\n\nCopyright (c) Denis Malinochkin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"}},"out":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport type { Readable } from 'stream';\nimport type { Dirent, FileSystemAdapter } from '@nodelib/fs.scandir';\nimport { AsyncCallback } from './providers/async';\nimport Settings, { DeepFilterFunction, EntryFilterFunction, ErrorFilterFunction, Options } from './settings';\nimport type { Entry } from './types';\ndeclare function walk(directory: string, callback: AsyncCallback): void;\ndeclare function walk(directory: string, optionsOrSettings: Options | Settings, callback: AsyncCallback): void;\ndeclare namespace walk {\n    function __promisify__(directory: string, optionsOrSettings?: Options | Settings): Promise<Entry[]>;\n}\ndeclare function walkSync(directory: string, optionsOrSettings?: Options | Settings): Entry[];\ndeclare function walkStream(directory: string, optionsOrSettings?: Options | Settings): Readable;\nexport { walk, walkSync, walkStream, Settings, AsyncCallback, Dirent, Entry, FileSystemAdapter, Options, DeepFilterFunction, EntryFilterFunction, ErrorFilterFunction };\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;\nconst async_1 = require(\"./providers/async\");\nconst stream_1 = require(\"./providers/stream\");\nconst sync_1 = require(\"./providers/sync\");\nconst settings_1 = require(\"./settings\");\nexports.Settings = settings_1.default;\nfunction walk(directory, optionsOrSettingsOrCallback, callback) {\n    if (typeof optionsOrSettingsOrCallback === 'function') {\n        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\n        return;\n    }\n    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\n}\nexports.walk = walk;\nfunction walkSync(directory, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    const provider = new sync_1.default(directory, settings);\n    return provider.read();\n}\nexports.walkSync = walkSync;\nfunction walkStream(directory, optionsOrSettings) {\n    const settings = getSettings(optionsOrSettings);\n    const provider = new stream_1.default(directory, settings);\n    return provider.read();\n}\nexports.walkStream = walkStream;\nfunction getSettings(settingsOrOptions = {}) {\n    if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n    }\n    return new settings_1.default(settingsOrOptions);\n}\n"}},"providers":{"directory":{"async.d.ts":{"file":{"contents":"import AsyncReader from '../readers/async';\nimport type Settings from '../settings';\nimport type { Entry, Errno } from '../types';\nexport declare type AsyncCallback = (error: Errno, entries: Entry[]) => void;\nexport default class AsyncProvider {\n    private readonly _root;\n    private readonly _settings;\n    protected readonly _reader: AsyncReader;\n    private readonly _storage;\n    constructor(_root: string, _settings: Settings);\n    read(callback: AsyncCallback): void;\n}\n"}},"async.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst async_1 = require(\"../readers/async\");\nclass AsyncProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._storage = [];\n    }\n    read(callback) {\n        this._reader.onError((error) => {\n            callFailureCallback(callback, error);\n        });\n        this._reader.onEntry((entry) => {\n            this._storage.push(entry);\n        });\n        this._reader.onEnd(() => {\n            callSuccessCallback(callback, this._storage);\n        });\n        this._reader.read();\n    }\n}\nexports.default = AsyncProvider;\nfunction callFailureCallback(callback, error) {\n    callback(error);\n}\nfunction callSuccessCallback(callback, entries) {\n    callback(null, entries);\n}\n"}},"index.d.ts":{"file":{"contents":"import AsyncProvider from './async';\nimport StreamProvider from './stream';\nimport SyncProvider from './sync';\nexport { AsyncProvider, StreamProvider, SyncProvider };\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncProvider = exports.StreamProvider = exports.AsyncProvider = void 0;\nconst async_1 = require(\"./async\");\nexports.AsyncProvider = async_1.default;\nconst stream_1 = require(\"./stream\");\nexports.StreamProvider = stream_1.default;\nconst sync_1 = require(\"./sync\");\nexports.SyncProvider = sync_1.default;\n"}},"stream.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport { Readable } from 'stream';\nimport AsyncReader from '../readers/async';\nimport type Settings from '../settings';\nexport default class StreamProvider {\n    private readonly _root;\n    private readonly _settings;\n    protected readonly _reader: AsyncReader;\n    protected readonly _stream: Readable;\n    constructor(_root: string, _settings: Settings);\n    read(): Readable;\n}\n"}},"stream.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\nconst async_1 = require(\"../readers/async\");\nclass StreamProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._stream = new stream_1.Readable({\n            objectMode: true,\n            read: () => { },\n            destroy: () => {\n                if (!this._reader.isDestroyed) {\n                    this._reader.destroy();\n                }\n            }\n        });\n    }\n    read() {\n        this._reader.onError((error) => {\n            this._stream.emit('error', error);\n        });\n        this._reader.onEntry((entry) => {\n            this._stream.push(entry);\n        });\n        this._reader.onEnd(() => {\n            this._stream.push(null);\n        });\n        this._reader.read();\n        return this._stream;\n    }\n}\nexports.default = StreamProvider;\n"}},"sync.d.ts":{"file":{"contents":"import SyncReader from '../readers/sync';\nimport type Settings from '../settings';\nimport type { Entry } from '../types';\nexport default class SyncProvider {\n    private readonly _root;\n    private readonly _settings;\n    protected readonly _reader: SyncReader;\n    constructor(_root: string, _settings: Settings);\n    read(): Entry[];\n}\n"}},"sync.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sync_1 = require(\"../readers/sync\");\nclass SyncProvider {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new sync_1.default(this._root, this._settings);\n    }\n    read() {\n        return this._reader.read();\n    }\n}\nexports.default = SyncProvider;\n"}}}},"readers":{"directory":{"async.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport { EventEmitter } from 'events';\nimport * as fsScandir from '@nodelib/fs.scandir';\nimport type Settings from '../settings';\nimport type { Entry, Errno } from '../types';\nimport Reader from './reader';\ndeclare type EntryEventCallback = (entry: Entry) => void;\ndeclare type ErrorEventCallback = (error: Errno) => void;\ndeclare type EndEventCallback = () => void;\nexport default class AsyncReader extends Reader {\n    protected readonly _settings: Settings;\n    protected readonly _scandir: typeof fsScandir.scandir;\n    protected readonly _emitter: EventEmitter;\n    private readonly _queue;\n    private _isFatalError;\n    private _isDestroyed;\n    constructor(_root: string, _settings: Settings);\n    read(): EventEmitter;\n    get isDestroyed(): boolean;\n    destroy(): void;\n    onEntry(callback: EntryEventCallback): void;\n    onError(callback: ErrorEventCallback): void;\n    onEnd(callback: EndEventCallback): void;\n    private _pushToQueue;\n    private _worker;\n    private _handleError;\n    private _handleEntry;\n    private _emitEntry;\n}\nexport {};\n"}},"async.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nconst fastq = require(\"fastq\");\nconst common = require(\"./common\");\nconst reader_1 = require(\"./reader\");\nclass AsyncReader extends reader_1.default {\n    constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n            if (!this._isFatalError) {\n                this._emitter.emit('end');\n            }\n        };\n    }\n    read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n            this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n    }\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this._isDestroyed) {\n            throw new Error('The reader is already destroyed');\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n    }\n    onEntry(callback) {\n        this._emitter.on('entry', callback);\n    }\n    onError(callback) {\n        this._emitter.once('error', callback);\n    }\n    onEnd(callback) {\n        this._emitter.once('end', callback);\n    }\n    _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n            if (error !== null) {\n                this._handleError(error);\n            }\n        });\n    }\n    _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n            if (error !== null) {\n                done(error, undefined);\n                return;\n            }\n            for (const entry of entries) {\n                this._handleEntry(entry, item.base);\n            }\n            done(null, undefined);\n        });\n    }\n    _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n            return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit('error', error);\n    }\n    _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n            return;\n        }\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _emitEntry(entry) {\n        this._emitter.emit('entry', entry);\n    }\n}\nexports.default = AsyncReader;\n"}},"common.d.ts":{"file":{"contents":"import type { FilterFunction } from '../settings';\nimport type Settings from '../settings';\nimport type { Errno } from '../types';\nexport declare function isFatalError(settings: Settings, error: Errno): boolean;\nexport declare function isAppliedFilter<T>(filter: FilterFunction<T> | null, value: T): boolean;\nexport declare function replacePathSegmentSeparator(filepath: string, separator: string): string;\nexport declare function joinPathSegments(a: string, b: string, separator: string): string;\n"}},"common.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;\nfunction isFatalError(settings, error) {\n    if (settings.errorFilter === null) {\n        return true;\n    }\n    return !settings.errorFilter(error);\n}\nexports.isFatalError = isFatalError;\nfunction isAppliedFilter(filter, value) {\n    return filter === null || filter(value);\n}\nexports.isAppliedFilter = isAppliedFilter;\nfunction replacePathSegmentSeparator(filepath, separator) {\n    return filepath.split(/[/\\\\]/).join(separator);\n}\nexports.replacePathSegmentSeparator = replacePathSegmentSeparator;\nfunction joinPathSegments(a, b, separator) {\n    if (a === '') {\n        return b;\n    }\n    /**\n     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n     */\n    if (a.endsWith(separator)) {\n        return a + b;\n    }\n    return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n"}},"reader.d.ts":{"file":{"contents":"import type Settings from '../settings';\nexport default class Reader {\n    protected readonly _root: string;\n    protected readonly _settings: Settings;\n    constructor(_root: string, _settings: Settings);\n}\n"}},"reader.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common = require(\"./common\");\nclass Reader {\n    constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\n    }\n}\nexports.default = Reader;\n"}},"sync.d.ts":{"file":{"contents":"import * as fsScandir from '@nodelib/fs.scandir';\nimport type { Entry } from '../types';\nimport Reader from './reader';\nexport default class SyncReader extends Reader {\n    protected readonly _scandir: typeof fsScandir.scandirSync;\n    private readonly _storage;\n    private readonly _queue;\n    read(): Entry[];\n    private _pushToQueue;\n    private _handleQueue;\n    private _handleDirectory;\n    private _handleError;\n    private _handleEntry;\n    private _pushToStorage;\n}\n"}},"sync.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nconst common = require(\"./common\");\nconst reader_1 = require(\"./reader\");\nclass SyncReader extends reader_1.default {\n    constructor() {\n        super(...arguments);\n        this._scandir = fsScandir.scandirSync;\n        this._storage = [];\n        this._queue = new Set();\n    }\n    read() {\n        this._pushToQueue(this._root, this._settings.basePath);\n        this._handleQueue();\n        return this._storage;\n    }\n    _pushToQueue(directory, base) {\n        this._queue.add({ directory, base });\n    }\n    _handleQueue() {\n        for (const item of this._queue.values()) {\n            this._handleDirectory(item.directory, item.base);\n        }\n    }\n    _handleDirectory(directory, base) {\n        try {\n            const entries = this._scandir(directory, this._settings.fsScandirSettings);\n            for (const entry of entries) {\n                this._handleEntry(entry, base);\n            }\n        }\n        catch (error) {\n            this._handleError(error);\n        }\n    }\n    _handleError(error) {\n        if (!common.isFatalError(this._settings, error)) {\n            return;\n        }\n        throw error;\n    }\n    _handleEntry(entry, base) {\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._pushToStorage(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n        }\n    }\n    _pushToStorage(entry) {\n        this._storage.push(entry);\n    }\n}\nexports.default = SyncReader;\n"}}}},"settings.d.ts":{"file":{"contents":"import * as fsScandir from '@nodelib/fs.scandir';\nimport type { Entry, Errno } from './types';\nexport declare type FilterFunction<T> = (value: T) => boolean;\nexport declare type DeepFilterFunction = FilterFunction<Entry>;\nexport declare type EntryFilterFunction = FilterFunction<Entry>;\nexport declare type ErrorFilterFunction = FilterFunction<Errno>;\nexport interface Options {\n    basePath?: string;\n    concurrency?: number;\n    deepFilter?: DeepFilterFunction;\n    entryFilter?: EntryFilterFunction;\n    errorFilter?: ErrorFilterFunction;\n    followSymbolicLinks?: boolean;\n    fs?: Partial<fsScandir.FileSystemAdapter>;\n    pathSegmentSeparator?: string;\n    stats?: boolean;\n    throwErrorOnBrokenSymbolicLink?: boolean;\n}\nexport default class Settings {\n    private readonly _options;\n    readonly basePath?: string;\n    readonly concurrency: number;\n    readonly deepFilter: DeepFilterFunction | null;\n    readonly entryFilter: EntryFilterFunction | null;\n    readonly errorFilter: ErrorFilterFunction | null;\n    readonly pathSegmentSeparator: string;\n    readonly fsScandirSettings: fsScandir.Settings;\n    constructor(_options?: Options);\n    private _getValue;\n}\n"}},"settings.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nclass Settings {\n    constructor(_options = {}) {\n        this._options = _options;\n        this.basePath = this._getValue(this._options.basePath, undefined);\n        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);\n        this.deepFilter = this._getValue(this._options.deepFilter, null);\n        this.entryFilter = this._getValue(this._options.entryFilter, null);\n        this.errorFilter = this._getValue(this._options.errorFilter, null);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.fsScandirSettings = new fsScandir.Settings({\n            followSymbolicLinks: this._options.followSymbolicLinks,\n            fs: this._options.fs,\n            pathSegmentSeparator: this._options.pathSegmentSeparator,\n            stats: this._options.stats,\n            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\n        });\n    }\n    _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n    }\n}\nexports.default = Settings;\n"}},"types":{"directory":{"index.d.ts":{"file":{"contents":"/// <reference types=\"node\" />\nimport type * as scandir from '@nodelib/fs.scandir';\nexport declare type Entry = scandir.Entry;\nexport declare type Errno = NodeJS.ErrnoException;\nexport interface QueueItem {\n    directory: string;\n    base?: string;\n}\n"}},"index.js":{"file":{"contents":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n"}}}}}},"package.json":{"file":{"contents":"{\n  \"name\": \"@nodelib/fs.walk\",\n  \"version\": \"1.2.8\",\n  \"description\": \"A library for efficiently walking a directory recursively\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/nodelib/nodelib/tree/master/packages/fs/fs.walk\",\n  \"keywords\": [\n    \"NodeLib\",\n    \"fs\",\n    \"FileSystem\",\n    \"file system\",\n    \"walk\",\n    \"scanner\",\n    \"crawler\"\n  ],\n  \"engines\": {\n    \"node\": \">= 8\"\n  },\n  \"files\": [\n    \"out/**\",\n    \"!out/**/*.map\",\n    \"!out/**/*.spec.*\",\n    \"!out/**/tests/**\"\n  ],\n  \"main\": \"out/index.js\",\n  \"typings\": \"out/index.d.ts\",\n  \"scripts\": {\n    \"clean\": \"rimraf {tsconfig.tsbuildinfo,out}\",\n    \"lint\": \"eslint \\\"src/**/*.ts\\\" --cache\",\n    \"compile\": \"tsc -b .\",\n    \"compile:watch\": \"tsc -p . --watch --sourceMap\",\n    \"test\": \"mocha \\\"out/**/*.spec.js\\\" -s 0\",\n    \"build\": \"npm run clean && npm run compile && npm run lint && npm test\",\n    \"watch\": \"npm run clean && npm run compile:watch\"\n  },\n  \"dependencies\": {\n    \"@nodelib/fs.scandir\": \"2.1.5\",\n    \"fastq\": \"^1.6.0\"\n  },\n  \"devDependencies\": {\n    \"@nodelib/fs.macchiato\": \"1.0.4\"\n  },\n  \"gitHead\": \"1e5bad48565da2b06b8600e744324ea240bf49d8\"\n}\n"}},"README.md":{"file":{"contents":"# @nodelib/fs.walk\n\n> A library for efficiently walking a directory recursively.\n\n## :bulb: Highlights\n\n* :moneybag: Returns useful information: `name`, `path`, `dirent` and `stats` (optional).\n* :rocket: On Node.js 10.10+ uses the mechanism without additional calls to determine the entry type for performance reasons. See [`old` and `modern` mode](https://github.com/nodelib/nodelib/blob/master/packages/fs/fs.scandir/README.md#old-and-modern-mode).\n* :gear: Built-in directories/files and error filtering system.\n* :link: Can safely work with broken symbolic links.\n\n## Install\n\n```console\nnpm install @nodelib/fs.walk\n```\n\n## Usage\n\n```ts\nimport * as fsWalk from '@nodelib/fs.walk';\n\nfsWalk.walk('path', (error, entries) => { /* … */ });\n```\n\n## API\n\n### .walk(path, [optionsOrSettings], callback)\n\nReads the directory recursively and asynchronously. Requires a callback function.\n\n> :book: If you want to use the Promise API, use `util.promisify`.\n\n```ts\nfsWalk.walk('path', (error, entries) => { /* … */ });\nfsWalk.walk('path', {}, (error, entries) => { /* … */ });\nfsWalk.walk('path', new fsWalk.Settings(), (error, entries) => { /* … */ });\n```\n\n### .walkStream(path, [optionsOrSettings])\n\nReads the directory recursively and asynchronously. [Readable Stream](https://nodejs.org/dist/latest-v12.x/docs/api/stream.html#stream_readable_streams) is used as a provider.\n\n```ts\nconst stream = fsWalk.walkStream('path');\nconst stream = fsWalk.walkStream('path', {});\nconst stream = fsWalk.walkStream('path', new fsWalk.Settings());\n```\n\n### .walkSync(path, [optionsOrSettings])\n\nReads the directory recursively and synchronously. Returns an array of entries.\n\n```ts\nconst entries = fsWalk.walkSync('path');\nconst entries = fsWalk.walkSync('path', {});\nconst entries = fsWalk.walkSync('path', new fsWalk.Settings());\n```\n\n#### path\n\n* Required: `true`\n* Type: `string | Buffer | URL`\n\nA path to a file. If a URL is provided, it must use the `file:` protocol.\n\n#### optionsOrSettings\n\n* Required: `false`\n* Type: `Options | Settings`\n* Default: An instance of `Settings` class\n\nAn [`Options`](#options) object or an instance of [`Settings`](#settings) class.\n\n> :book: When you pass a plain object, an instance of the `Settings` class will be created automatically. If you plan to call the method frequently, use a pre-created instance of the `Settings` class.\n\n### Settings([options])\n\nA class of full settings of the package.\n\n```ts\nconst settings = new fsWalk.Settings({ followSymbolicLinks: true });\n\nconst entries = fsWalk.walkSync('path', settings);\n```\n\n## Entry\n\n* `name` — The name of the entry (`unknown.txt`).\n* `path` — The path of the entry relative to call directory (`root/unknown.txt`).\n* `dirent` — An instance of [`fs.Dirent`](./src/types/index.ts) class.\n* [`stats`] — An instance of `fs.Stats` class.\n\n## Options\n\n### basePath\n\n* Type: `string`\n* Default: `undefined`\n\nBy default, all paths are built relative to the root path. You can use this option to set custom root path.\n\nIn the example below we read the files from the `root` directory, but in the results the root path will be `custom`.\n\n```ts\nfsWalk.walkSync('root'); // → ['root/file.txt']\nfsWalk.walkSync('root', { basePath: 'custom' }); // → ['custom/file.txt']\n```\n\n### concurrency\n\n* Type: `number`\n* Default: `Infinity`\n\nThe maximum number of concurrent calls to `fs.readdir`.\n\n> :book: The higher the number, the higher performance and the load on the File System. If you want to read in quiet mode, set the value to `4 * os.cpus().length` (4 is default size of [thread pool work scheduling](http://docs.libuv.org/en/v1.x/threadpool.html#thread-pool-work-scheduling)).\n\n### deepFilter\n\n* Type: [`DeepFilterFunction`](./src/settings.ts)\n* Default: `undefined`\n\nA function that indicates whether the directory will be read deep or not.\n\n```ts\n// Skip all directories that starts with `node_modules`\nconst filter: DeepFilterFunction = (entry) => !entry.path.startsWith('node_modules');\n```\n\n### entryFilter\n\n* Type: [`EntryFilterFunction`](./src/settings.ts)\n* Default: `undefined`\n\nA function that indicates whether the entry will be included to results or not.\n\n```ts\n// Exclude all `.js` files from results\nconst filter: EntryFilterFunction = (entry) => !entry.name.endsWith('.js');\n```\n\n### errorFilter\n\n* Type: [`ErrorFilterFunction`](./src/settings.ts)\n* Default: `undefined`\n\nA function that allows you to skip errors that occur when reading directories.\n\nFor example, you can skip `ENOENT` errors if required:\n\n```ts\n// Skip all ENOENT errors\nconst filter: ErrorFilterFunction = (error) => error.code == 'ENOENT';\n```\n\n### stats\n\n* Type: `boolean`\n* Default: `false`\n\nAdds an instance of `fs.Stats` class to the [`Entry`](#entry).\n\n> :book: Always use `fs.readdir` with additional `fs.lstat/fs.stat` calls to determine the entry type.\n\n### followSymbolicLinks\n\n* Type: `boolean`\n* Default: `false`\n\nFollow symbolic links or not. Call `fs.stat` on symbolic link if `true`.\n\n### `throwErrorOnBrokenSymbolicLink`\n\n* Type: `boolean`\n* Default: `true`\n\nThrow an error when symbolic link is broken if `true` or safely return `lstat` call if `false`.\n\n### `pathSegmentSeparator`\n\n* Type: `string`\n* Default: `path.sep`\n\nBy default, this package uses the correct path separator for your OS (`\\` on Windows, `/` on Unix-like systems). But you can set this option to any separator character(s) that you want to use instead.\n\n### `fs`\n\n* Type: `FileSystemAdapter`\n* Default: A default FS methods\n\nBy default, the built-in Node.js module (`fs`) is used to work with the file system. You can replace any method with your own.\n\n```ts\ninterface FileSystemAdapter {\n\tlstat: typeof fs.lstat;\n\tstat: typeof fs.stat;\n\tlstatSync: typeof fs.lstatSync;\n\tstatSync: typeof fs.statSync;\n\treaddir: typeof fs.readdir;\n\treaddirSync: typeof fs.readdirSync;\n}\n\nconst settings = new fsWalk.Settings({\n\tfs: { lstat: fakeLstat }\n});\n```\n\n## Changelog\n\nSee the [Releases section of our GitHub project](https://github.com/nodelib/nodelib/releases) for changelog for each release version.\n\n## License\n\nThis software is released under the terms of the MIT license.\n"}}}}}}