{"directory":{".eslintrc.js":{"file":{"contents":"'use strict';\n\nmodule.exports = {\n  extends: '@mscdex/eslint-config',\n};\n"}},".github":{"directory":{"workflows":{"directory":{"ci.yml":{"file":{"contents":"name: CI\n\non:\n  pull_request:\n  push:\n    branches: [ master ]\n\njobs:\n  tests-linux:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        node-version: [10.16.0, 10.x, 12.x, 14.x, 16.x]\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ matrix.node-version }}\n      - name: Install module\n        run: npm install\n      - name: Run tests\n        run: npm test\n"}},"lint.yml":{"file":{"contents":"name: lint\n\non:\n  pull_request:\n  push:\n    branches: [ master ]\n\nenv:\n  NODE_VERSION: 16.x\n\njobs:\n  lint-js:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js ${{ env.NODE_VERSION }}\n        uses: actions/setup-node@v1\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n      - name: Install ESLint + ESLint configs/plugins\n        run: npm install --only=dev\n      - name: Lint files\n        run: npm run lint\n"}}}}}},"bench":{"directory":{"bench-multipart-fields-100mb-big.js":{"file":{"contents":"'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"field${i + 1}\"`,\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, [\n  10,\n  10,\n  10,\n  20,\n  50,\n]);\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('field', (name, val, info) => {\n      ++calls.partBegin;\n      ++calls.partData;\n      ++calls.partEnd;\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}},"bench-multipart-fields-100mb-small.js":{"file":{"contents":"'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"field${i + 1}\"`,\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, (new Array(100)).fill(1));\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('field', (name, val, info) => {\n      ++calls.partBegin;\n      ++calls.partData;\n      ++calls.partEnd;\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}},"bench-multipart-files-100mb-big.js":{"file":{"contents":"'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"file${i + 1}\"; `\n        + `filename=\"random${i + 1}.bin\"`,\n      'content-type: application/octet-stream',\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, [\n  10,\n  10,\n  10,\n  20,\n  50,\n]);\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('file', (name, stream, info) => {\n      ++calls.partBegin;\n      stream.on('data', (chunk) => {\n        ++calls.partData;\n      }).on('end', () => {\n        ++calls.partEnd;\n      });\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}},"bench-multipart-files-100mb-small.js":{"file":{"contents":"'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"file${i + 1}\"; `\n        + `filename=\"random${i + 1}.bin\"`,\n      'content-type: application/octet-stream',\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, (new Array(100)).fill(1));\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('file', (name, stream, info) => {\n      ++calls.partBegin;\n      stream.on('data', (chunk) => {\n        ++calls.partData;\n      }).on('end', () => {\n        ++calls.partEnd;\n      });\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}},"bench-urlencoded-fields-100pairs-small.js":{"file":{"contents":"'use strict';\n\nconst buffers = [\n  Buffer.from(\n    (new Array(100)).fill('').map((_, i) => `key${i}=value${i}`).join('&')\n  ),\n];\nconst calls = {\n  field: 0,\n  end: 0,\n};\n\nlet n = 3e3;\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    console.time(moduleName);\n    (function next() {\n      const parser = busboy({\n        limits: {\n          fieldSizeLimit: Infinity,\n        },\n        headers: {\n          'content-type': 'application/x-www-form-urlencoded; charset=utf-8',\n        },\n      });\n      parser.on('field', (name, val, info) => {\n        ++calls.field;\n      }).on('close', () => {\n        ++calls.end;\n        if (--n === 0)\n          console.timeEnd(moduleName);\n        else\n          process.nextTick(next);\n      });\n\n      for (const buf of buffers)\n        parser.write(buf);\n      parser.end();\n    })();\n    break;\n  }\n\n  case 'formidable': {\n    const QuerystringParser =\n      require('formidable/src/parsers/Querystring.js');\n\n    console.time(moduleName);\n    (function next() {\n      const parser = new QuerystringParser();\n      parser.on('data', (obj) => {\n        ++calls.field;\n      }).on('end', () => {\n        ++calls.end;\n        if (--n === 0)\n          console.timeEnd(moduleName);\n        else\n          process.nextTick(next);\n      });\n\n      for (const buf of buffers)\n        parser.write(buf);\n      parser.end();\n    })();\n    break;\n  }\n\n  case 'formidable-streaming': {\n    const QuerystringParser =\n      require('formidable/src/parsers/StreamingQuerystring.js');\n\n    console.time(moduleName);\n    (function next() {\n      const parser = new QuerystringParser();\n      parser.on('data', (obj) => {\n        ++calls.field;\n      }).on('end', () => {\n        ++calls.end;\n        if (--n === 0)\n          console.timeEnd(moduleName);\n        else\n          process.nextTick(next);\n      });\n\n      for (const buf of buffers)\n        parser.write(buf);\n      parser.end();\n    })();\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}},"bench-urlencoded-fields-900pairs-small-alt.js":{"file":{"contents":"'use strict';\n\nconst buffers = [\n  Buffer.from(\n    (new Array(900)).fill('').map((_, i) => `key${i}=value${i}`).join('&')\n  ),\n];\nconst calls = {\n  field: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    console.time(moduleName);\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': 'application/x-www-form-urlencoded; charset=utf-8',\n      },\n    });\n    parser.on('field', (name, val, info) => {\n      ++calls.field;\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    for (const buf of buffers)\n      parser.write(buf);\n    parser.end();\n    break;\n  }\n\n  case 'formidable': {\n    const QuerystringParser =\n      require('formidable/src/parsers/Querystring.js');\n\n    console.time(moduleName);\n    const parser = new QuerystringParser();\n    parser.on('data', (obj) => {\n      ++calls.field;\n    }).on('end', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    for (const buf of buffers)\n      parser.write(buf);\n    parser.end();\n    break;\n  }\n\n  case 'formidable-streaming': {\n    const QuerystringParser =\n      require('formidable/src/parsers/StreamingQuerystring.js');\n\n    console.time(moduleName);\n    const parser = new QuerystringParser();\n    parser.on('data', (obj) => {\n      ++calls.field;\n    }).on('end', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    for (const buf of buffers)\n      parser.write(buf);\n    parser.end();\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"}}}},"lib":{"directory":{"index.js":{"file":{"contents":"'use strict';\n\nconst { parseContentType } = require('./utils.js');\n\nfunction getInstance(cfg) {\n  const headers = cfg.headers;\n  const conType = parseContentType(headers['content-type']);\n  if (!conType)\n    throw new Error('Malformed content type');\n\n  for (const type of TYPES) {\n    const matched = type.detect(conType);\n    if (!matched)\n      continue;\n\n    const instanceCfg = {\n      limits: cfg.limits,\n      headers,\n      conType,\n      highWaterMark: undefined,\n      fileHwm: undefined,\n      defCharset: undefined,\n      defParamCharset: undefined,\n      preservePath: false,\n    };\n    if (cfg.highWaterMark)\n      instanceCfg.highWaterMark = cfg.highWaterMark;\n    if (cfg.fileHwm)\n      instanceCfg.fileHwm = cfg.fileHwm;\n    instanceCfg.defCharset = cfg.defCharset;\n    instanceCfg.defParamCharset = cfg.defParamCharset;\n    instanceCfg.preservePath = cfg.preservePath;\n    return new type(instanceCfg);\n  }\n\n  throw new Error(`Unsupported content type: ${headers['content-type']}`);\n}\n\n// Note: types are explicitly listed here for easier bundling\n// See: https://github.com/mscdex/busboy/issues/121\nconst TYPES = [\n  require('./types/multipart'),\n  require('./types/urlencoded'),\n].filter(function(typemod) { return typeof typemod.detect === 'function'; });\n\nmodule.exports = (cfg) => {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  if (typeof cfg.headers !== 'object'\n      || cfg.headers === null\n      || typeof cfg.headers['content-type'] !== 'string') {\n    throw new Error('Missing Content-Type');\n  }\n\n  return getInstance(cfg);\n};\n"}},"types":{"directory":{"multipart.js":{"file":{"contents":"'use strict';\n\nconst { Readable, Writable } = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition,\n} = require('../utils.js');\n\nconst BUF_CRLF = Buffer.from('\\r\\n');\nconst BUF_CR = Buffer.from('\\r');\nconst BUF_DASH = Buffer.from('-');\n\nfunction noop() {}\n\nconst MAX_HEADER_PAIRS = 2000; // From node\nconst MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nconst HPARSER_NAME = 0;\nconst HPARSER_PRE_OWS = 1;\nconst HPARSER_VALUE = 2;\nclass HeaderParser {\n  constructor(cb) {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n\n  reset() {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n  }\n\n  push(chunk, pos, end) {\n    let start = pos;\n    while (pos < end) {\n      switch (this.state) {\n        case HPARSER_NAME: {\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (TOKEN[code] !== 1) {\n              if (code !== 58/* ':' */)\n                return -1;\n              this.name += chunk.latin1Slice(start, pos);\n              if (this.name.length === 0)\n                return -1;\n              ++pos;\n              done = true;\n              this.state = HPARSER_PRE_OWS;\n              break;\n            }\n          }\n          if (!done) {\n            this.name += chunk.latin1Slice(start, pos);\n            break;\n          }\n          // FALLTHROUGH\n        }\n        case HPARSER_PRE_OWS: {\n          // Skip optional whitespace\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (code !== 32/* ' ' */ && code !== 9/* '\\t' */) {\n              start = pos;\n              done = true;\n              this.state = HPARSER_VALUE;\n              break;\n            }\n          }\n          if (!done)\n            break;\n          // FALLTHROUGH\n        }\n        case HPARSER_VALUE:\n          switch (this.crlf) {\n            case 0: // Nothing yet\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE)\n                  return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n                if (FIELD_VCHAR[code] !== 1) {\n                  if (code !== 13/* '\\r' */)\n                    return -1;\n                  ++this.crlf;\n                  break;\n                }\n              }\n              this.value += chunk.latin1Slice(start, pos++);\n              break;\n            case 1: // Received CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              ++this.crlf;\n              break;\n            case 2: { // Received CR LF\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n              if (code === 32/* ' ' */ || code === 9/* '\\t' */) {\n                // Folded value\n                start = pos;\n                this.crlf = 0;\n              } else {\n                if (++this.pairCount < MAX_HEADER_PAIRS) {\n                  this.name = this.name.toLowerCase();\n                  if (this.header[this.name] === undefined)\n                    this.header[this.name] = [this.value];\n                  else\n                    this.header[this.name].push(this.value);\n                }\n                if (code === 13/* '\\r' */) {\n                  ++this.crlf;\n                  ++pos;\n                } else {\n                  // Assume start of next header field name\n                  start = pos;\n                  this.crlf = 0;\n                  this.state = HPARSER_NAME;\n                  this.name = '';\n                  this.value = '';\n                }\n              }\n              break;\n            }\n            case 3: { // Received CR LF CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              // End of header\n              const header = this.header;\n              this.reset();\n              this.cb(header);\n              return pos;\n            }\n          }\n          break;\n      }\n    }\n\n    return pos;\n  }\n}\n\nclass FileStream extends Readable {\n  constructor(opts, owner) {\n    super(opts);\n    this.truncated = false;\n    this._readcb = null;\n    this.once('end', () => {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      this._read();\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        const cb = owner._finalcb;\n        owner._finalcb = null;\n        // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n        process.nextTick(cb);\n      }\n    });\n  }\n  _read(n) {\n    const cb = this._readcb;\n    if (cb) {\n      this._readcb = null;\n      cb();\n    }\n  }\n}\n\nconst ignoreData = {\n  push: (chunk, pos) => {},\n  destroy: () => {},\n};\n\nfunction callAndUnsetCb(self, err) {\n  const cb = self._writecb;\n  self._writecb = null;\n  if (err)\n    self.destroy(err);\n  else if (cb)\n    cb();\n}\n\nfunction nullDecoder(val, hint) {\n  return val;\n}\n\nclass Multipart extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.highWaterMark === 'number'\n                      ? cfg.highWaterMark\n                      : undefined),\n    };\n    super(streamOpts);\n\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string')\n      throw new Error('Multipart: Boundary not found');\n\n    const boundary = cfg.conType.params.boundary;\n    const paramDecoder = (typeof cfg.defParamCharset === 'string'\n                            && cfg.defParamCharset\n                          ? getDecoder(cfg.defParamCharset)\n                          : nullDecoder);\n    const defCharset = (cfg.defCharset || 'utf8');\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.fileHwm === 'number'\n                      ? cfg.fileHwm\n                      : undefined),\n    };\n\n    const limits = cfg.limits;\n    const fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                            ? limits.fieldSize\n                            : 1 * 1024 * 1024);\n    const fileSizeLimit = (limits && typeof limits.fileSize === 'number'\n                           ? limits.fileSize\n                           : Infinity);\n    const filesLimit = (limits && typeof limits.files === 'number'\n                        ? limits.files\n                        : Infinity);\n    const fieldsLimit = (limits && typeof limits.fields === 'number'\n                         ? limits.fields\n                         : Infinity);\n    const partsLimit = (limits && typeof limits.parts === 'number'\n                        ? limits.parts\n                        : Infinity);\n\n    let parts = -1; // Account for initial boundary\n    let fields = 0;\n    let files = 0;\n    let skipPart = false;\n\n    this._fileEndsLeft = 0;\n    this._fileStream = undefined;\n    this._complete = false;\n    let fileSize = 0;\n\n    let field;\n    let fieldSize = 0;\n    let partCharset;\n    let partEncoding;\n    let partType;\n    let partName;\n    let partTruncated = false;\n\n    let hitFilesLimit = false;\n    let hitFieldsLimit = false;\n\n    this._hparser = null;\n    const hparser = new HeaderParser((header) => {\n      this._hparser = null;\n      skipPart = false;\n\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n\n      let filename;\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n\n      const disp = parseDisposition(header['content-disposition'][0],\n                                    paramDecoder);\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n\n      if (disp.params) {\n        if (disp.params.name)\n          partName = disp.params.name;\n\n        if (disp.params['filename*'])\n          filename = disp.params['filename*'];\n        else if (disp.params.filename)\n          filename = disp.params.filename;\n\n        if (filename !== undefined && !preservePath)\n          filename = basename(filename);\n      }\n\n      if (header['content-type']) {\n        const conType = parseContentType(header['content-type'][0]);\n        if (conType) {\n          partType = `${conType.type}/${conType.subtype}`;\n          if (conType.params && typeof conType.params.charset === 'string')\n            partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n\n      if (header['content-transfer-encoding'])\n        partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            this.emit('filesLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++files;\n\n        if (this.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        fileSize = 0;\n        this._fileStream = new FileStream(fileOpts, this);\n        ++this._fileEndsLeft;\n        this.emit(\n          'file',\n          partName,\n          this._fileStream,\n          { filename,\n            encoding: partEncoding,\n            mimeType: partType }\n        );\n      } else {\n        // Non-file\n\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            this.emit('fieldsLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++fields;\n\n        if (this.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        field = [];\n        fieldSize = 0;\n      }\n    });\n\n    let matchPostBoundary = 0;\n    const ssCb = (isMatch, data, start, end, isDataSafe) => {\nretrydata:\n      while (data) {\n        if (this._hparser !== null) {\n          const ret = this._hparser.push(data, start, end);\n          if (ret === -1) {\n            this._hparser = null;\n            hparser.reset();\n            this.emit('error', new Error('Malformed part header'));\n            break;\n          }\n          start = ret;\n        }\n\n        if (start === end)\n          break;\n\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45: // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n              case 13: // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n              default:\n                matchPostBoundary = 0;\n            }\n            if (start === end)\n              return;\n          }\n\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n            if (data[start] === 45/* '-' */) {\n              // End of multipart data\n              this._complete = true;\n              this._bparser = ignoreData;\n              return;\n            }\n            // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n            const writecb = this._writecb;\n            this._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            this._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n            if (data[start] === 10/* '\\n' */) {\n              ++start;\n              if (parts >= partsLimit)\n                break;\n              // Prepare the header parser\n              this._hparser = hparser;\n              if (start === end)\n                break;\n              // Process the remaining data as a header\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              const writecb = this._writecb;\n              this._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              this._writecb = writecb;\n            }\n          }\n        }\n\n        if (!skipPart) {\n          if (this._fileStream) {\n            let chunk;\n            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fileSize += chunk.length;\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0)\n                this._fileStream.push(chunk);\n              this._fileStream.emit('limit');\n              this._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!this._fileStream.push(chunk)) {\n              if (this._writecb)\n                this._fileStream._readcb = this._writecb;\n              this._writecb = null;\n            }\n          } else if (field !== undefined) {\n            let chunk;\n            const actualLen = Math.min(\n              end - start,\n              fieldSizeLimit - fieldSize\n            );\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fieldSize += actualLen;\n            field.push(chunk);\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (isMatch) {\n        matchPostBoundary = 1;\n\n        if (this._fileStream) {\n          // End the active file stream if the previous part was a file\n          this._fileStream.push(null);\n          this._fileStream = null;\n        } else if (field !== undefined) {\n          let data;\n          switch (field.length) {\n            case 0:\n              data = '';\n              break;\n            case 1:\n              data = convertToUTF8(field[0], partCharset, 0);\n              break;\n            default:\n              data = convertToUTF8(\n                Buffer.concat(field, fieldSize),\n                partCharset,\n                0\n              );\n          }\n          field = undefined;\n          fieldSize = 0;\n          this.emit(\n            'field',\n            partName,\n            data,\n            { nameTruncated: false,\n              valueTruncated: partTruncated,\n              encoding: partEncoding,\n              mimeType: partType }\n          );\n        }\n\n        if (++parts === partsLimit)\n          this.emit('partsLimit');\n      }\n    };\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, ssCb);\n\n    this._writecb = null;\n    this._finalcb = null;\n\n    // Just in case there is no preamble\n    this.write(BUF_CRLF);\n  }\n\n  static detect(conType) {\n    return (conType.type === 'multipart' && conType.subtype === 'form-data');\n  }\n\n  _write(chunk, enc, cb) {\n    this._writecb = cb;\n    this._bparser.push(chunk, 0);\n    if (this._writecb)\n      callAndUnsetCb(this);\n  }\n\n  _destroy(err, cb) {\n    this._hparser = null;\n    this._bparser = ignoreData;\n    if (!err)\n      err = checkEndState(this);\n    const fileStream = this._fileStream;\n    if (fileStream) {\n      this._fileStream = null;\n      fileStream.destroy(err);\n    }\n    cb(err);\n  }\n\n  _final(cb) {\n    this._bparser.destroy();\n    if (!this._complete)\n      return cb(new Error('Unexpected end of form'));\n    if (this._fileEndsLeft)\n      this._finalcb = finalcb.bind(null, this, cb);\n    else\n      finalcb(this, cb);\n  }\n}\n\nfunction finalcb(self, cb, err) {\n  if (err)\n    return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\n\nfunction checkEndState(self) {\n  if (self._hparser)\n    return new Error('Malformed part header');\n  const fileStream = self._fileStream;\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n  if (!self._complete)\n    return new Error('Unexpected end of form');\n}\n\nconst TOKEN = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst FIELD_VCHAR = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\nmodule.exports = Multipart;\n"}},"urlencoded.js":{"file":{"contents":"'use strict';\n\nconst { Writable } = require('stream');\n\nconst { getDecoder } = require('../utils.js');\n\nclass URLEncoded extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.highWaterMark === 'number'\n                      ? cfg.highWaterMark\n                      : undefined),\n    };\n    super(streamOpts);\n\n    let charset = (cfg.defCharset || 'utf8');\n    if (cfg.conType.params && typeof cfg.conType.params.charset === 'string')\n      charset = cfg.conType.params.charset;\n\n    this.charset = charset;\n\n    const limits = cfg.limits;\n    this.fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                           ? limits.fieldSize\n                           : 1 * 1024 * 1024);\n    this.fieldsLimit = (limits && typeof limits.fields === 'number'\n                        ? limits.fields\n                        : Infinity);\n    this.fieldNameSizeLimit = (\n      limits && typeof limits.fieldNameSize === 'number'\n      ? limits.fieldNameSize\n      : 100\n    );\n\n    this._inKey = true;\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._fields = 0;\n    this._key = '';\n    this._val = '';\n    this._byte = -2;\n    this._lastPos = 0;\n    this._encode = 0;\n    this._decoder = getDecoder(charset);\n  }\n\n  static detect(conType) {\n    return (conType.type === 'application'\n            && conType.subtype === 'x-www-form-urlencoded');\n  }\n\n  _write(chunk, enc, cb) {\n    if (this._fields >= this.fieldsLimit)\n      return cb();\n\n    let i = 0;\n    const len = chunk.length;\n    this._lastPos = 0;\n\n    // Check if we last ended mid-percent-encoded byte\n    if (this._byte !== -2) {\n      i = readPctEnc(this, chunk, i, len);\n      if (i === -1)\n        return cb(new Error('Malformed urlencoded form'));\n      if (i >= len)\n        return cb();\n      if (this._inKey)\n        ++this._bytesKey;\n      else\n        ++this._bytesVal;\n    }\n\nmain:\n    while (i < len) {\n      if (this._inKey) {\n        // Parsing key\n\n        i = skipKeyBytes(this, chunk, i, len);\n\n        while (i < len) {\n          switch (chunk[i]) {\n            case 61: // '='\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              this._inKey = false;\n              continue main;\n            case 38: // '&'\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0) {\n                this.emit(\n                  'field',\n                  this._key,\n                  '',\n                  { nameTruncated: this._keyTrunc,\n                    valueTruncated: false,\n                    encoding: this.charset,\n                    mimeType: 'text/plain' }\n                );\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue;\n            case 43: // '+'\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._key += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37: // '%'\n              if (this._encode === 0)\n                this._encode = 1;\n              if (this._lastPos < i)\n                this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1)\n                return cb(new Error('Malformed urlencoded form'));\n              if (i >= len)\n                return cb();\n              ++this._bytesKey;\n              i = skipKeyBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesKey;\n          i = skipKeyBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i)\n          this._key += chunk.latin1Slice(this._lastPos, i);\n      } else {\n        // Parsing value\n\n        i = skipValBytes(this, chunk, i, len);\n\n        while (i < len) {\n          switch (chunk[i]) {\n            case 38: // '&'\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._inKey = true;\n              this._val = this._decoder(this._val, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0 || this._bytesVal > 0) {\n                this.emit(\n                  'field',\n                  this._key,\n                  this._val,\n                  { nameTruncated: this._keyTrunc,\n                    valueTruncated: this._valTrunc,\n                    encoding: this.charset,\n                    mimeType: 'text/plain' }\n                );\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue main;\n            case 43: // '+'\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._val += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37: // '%'\n              if (this._encode === 0)\n                this._encode = 1;\n              if (this._lastPos < i)\n                this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1)\n                return cb(new Error('Malformed urlencoded form'));\n              if (i >= len)\n                return cb();\n              ++this._bytesVal;\n              i = skipValBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesVal;\n          i = skipValBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i)\n          this._val += chunk.latin1Slice(this._lastPos, i);\n      }\n    }\n\n    cb();\n  }\n\n  _final(cb) {\n    if (this._byte !== -2)\n      return cb(new Error('Malformed urlencoded form'));\n    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {\n      if (this._inKey)\n        this._key = this._decoder(this._key, this._encode);\n      else\n        this._val = this._decoder(this._val, this._encode);\n      this.emit(\n        'field',\n        this._key,\n        this._val,\n        { nameTruncated: this._keyTrunc,\n          valueTruncated: this._valTrunc,\n          encoding: this.charset,\n          mimeType: 'text/plain' }\n      );\n    }\n    cb();\n  }\n}\n\nfunction readPctEnc(self, chunk, pos, len) {\n  if (pos >= len)\n    return len;\n\n  if (self._byte === -1) {\n    // We saw a '%' but no hex characters yet\n    const hexUpper = HEX_VALUES[chunk[pos++]];\n    if (hexUpper === -1)\n      return -1;\n\n    if (hexUpper >= 8)\n      self._encode = 2; // Indicate high bits detected\n\n    if (pos < len) {\n      // Both hex characters are in this chunk\n      const hexLower = HEX_VALUES[chunk[pos++]];\n      if (hexLower === -1)\n        return -1;\n\n      if (self._inKey)\n        self._key += String.fromCharCode((hexUpper << 4) + hexLower);\n      else\n        self._val += String.fromCharCode((hexUpper << 4) + hexLower);\n\n      self._byte = -2;\n      self._lastPos = pos;\n    } else {\n      // Only one hex character was available in this chunk\n      self._byte = hexUpper;\n    }\n  } else {\n    // We saw only one hex character so far\n    const hexLower = HEX_VALUES[chunk[pos++]];\n    if (hexLower === -1)\n      return -1;\n\n    if (self._inKey)\n      self._key += String.fromCharCode((self._byte << 4) + hexLower);\n    else\n      self._val += String.fromCharCode((self._byte << 4) + hexLower);\n\n    self._byte = -2;\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\nfunction skipKeyBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesKey > self.fieldNameSizeLimit) {\n    if (!self._keyTrunc) {\n      if (self._lastPos < pos)\n        self._key += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._keyTrunc = true;\n    for (; pos < len; ++pos) {\n      const code = chunk[pos];\n      if (code === 61/* '=' */ || code === 38/* '&' */)\n        break;\n      ++self._bytesKey;\n    }\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\nfunction skipValBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesVal > self.fieldSizeLimit) {\n    if (!self._valTrunc) {\n      if (self._lastPos < pos)\n        self._val += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._valTrunc = true;\n    for (; pos < len; ++pos) {\n      if (chunk[pos] === 38/* '&' */)\n        break;\n      ++self._bytesVal;\n    }\n    self._lastPos = pos;\n  }\n\n  return pos;\n}\n\n/* eslint-disable no-multi-spaces */\nconst HEX_VALUES = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = URLEncoded;\n"}}}},"utils.js":{"file":{"contents":"'use strict';\n\nfunction parseContentType(str) {\n  if (str.length === 0)\n    return;\n\n  const params = Object.create(null);\n  let i = 0;\n\n  // Parse type\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      if (code !== 47/* '/' */ || i === 0)\n        return;\n      break;\n    }\n  }\n  // Check for type without subtype\n  if (i === str.length)\n    return;\n\n  const type = str.slice(0, i).toLowerCase();\n\n  // Parse subtype\n  const subtypeStart = ++i;\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      // Make sure we have a subtype\n      if (i === subtypeStart)\n        return;\n\n      if (parseContentTypeParams(str, i, params) === undefined)\n        return;\n      break;\n    }\n  }\n  // Make sure we have a subtype\n  if (i === subtypeStart)\n    return;\n\n  const subtype = str.slice(subtypeStart, i).toLowerCase();\n\n  return { type, subtype, params };\n}\n\nfunction parseContentTypeParams(str, i, params) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace\n    if (i === str.length)\n      break;\n\n    // Check for malformed parameter\n    if (str.charCodeAt(i++) !== 59/* ';' */)\n      return;\n\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace (malformed)\n    if (i === str.length)\n      return;\n\n    let name;\n    const nameStart = i;\n    // Parse parameter name\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (TOKEN[code] !== 1) {\n        if (code !== 61/* '=' */)\n          return;\n        break;\n      }\n    }\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    name = str.slice(nameStart, i);\n    ++i; // Skip over '='\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    let value = '';\n    let valueStart;\n    if (str.charCodeAt(i) === 34/* '\"' */) {\n      valueStart = ++i;\n      let escaping = false;\n      // Parse quoted value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code === 92/* '\\\\' */) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n          } else {\n            value += str.slice(valueStart, i);\n            escaping = true;\n          }\n          continue;\n        }\n        if (code === 34/* '\"' */) {\n          if (escaping) {\n            valueStart = i;\n            escaping = false;\n            continue;\n          }\n          value += str.slice(valueStart, i);\n          break;\n        }\n        if (escaping) {\n          valueStart = i - 1;\n          escaping = false;\n        }\n        // Invalid unescaped quoted character (malformed)\n        if (QDTEXT[code] !== 1)\n          return;\n      }\n\n      // No end quote (malformed)\n      if (i === str.length)\n        return;\n\n      ++i; // Skip over double quote\n    } else {\n      valueStart = i;\n      // Parse unquoted value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (TOKEN[code] !== 1) {\n          // No value (malformed)\n          if (i === valueStart)\n            return;\n          break;\n        }\n      }\n      value = str.slice(valueStart, i);\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined)\n      params[name] = value;\n  }\n\n  return params;\n}\n\nfunction parseDisposition(str, defDecoder) {\n  if (str.length === 0)\n    return;\n\n  const params = Object.create(null);\n  let i = 0;\n\n  for (; i < str.length; ++i) {\n    const code = str.charCodeAt(i);\n    if (TOKEN[code] !== 1) {\n      if (parseDispositionParams(str, i, params, defDecoder) === undefined)\n        return;\n      break;\n    }\n  }\n\n  const type = str.slice(0, i).toLowerCase();\n\n  return { type, params };\n}\n\nfunction parseDispositionParams(str, i, params, defDecoder) {\n  while (i < str.length) {\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace\n    if (i === str.length)\n      break;\n\n    // Check for malformed parameter\n    if (str.charCodeAt(i++) !== 59/* ';' */)\n      return;\n\n    // Consume whitespace\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (code !== 32/* ' ' */ && code !== 9/* '\\t' */)\n        break;\n    }\n\n    // Ended on whitespace (malformed)\n    if (i === str.length)\n      return;\n\n    let name;\n    const nameStart = i;\n    // Parse parameter name\n    for (; i < str.length; ++i) {\n      const code = str.charCodeAt(i);\n      if (TOKEN[code] !== 1) {\n        if (code === 61/* '=' */)\n          break;\n        return;\n      }\n    }\n\n    // No value (malformed)\n    if (i === str.length)\n      return;\n\n    let value = '';\n    let valueStart;\n    let charset;\n    //~ let lang;\n    name = str.slice(nameStart, i);\n    if (name.charCodeAt(name.length - 1) === 42/* '*' */) {\n      // Extended value\n\n      const charsetStart = ++i;\n      // Parse charset name\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (CHARSET[code] !== 1) {\n          if (code !== 39/* '\\'' */)\n            return;\n          break;\n        }\n      }\n\n      // Incomplete charset (malformed)\n      if (i === str.length)\n        return;\n\n      charset = str.slice(charsetStart, i);\n      ++i; // Skip over the '\\''\n\n      //~ const langStart = ++i;\n      // Parse language name\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (code === 39/* '\\'' */)\n          break;\n      }\n\n      // Incomplete language (malformed)\n      if (i === str.length)\n        return;\n\n      //~ lang = str.slice(langStart, i);\n      ++i; // Skip over the '\\''\n\n      // No value (malformed)\n      if (i === str.length)\n        return;\n\n      valueStart = i;\n\n      let encode = 0;\n      // Parse value\n      for (; i < str.length; ++i) {\n        const code = str.charCodeAt(i);\n        if (EXTENDED_VALUE[code] !== 1) {\n          if (code === 37/* '%' */) {\n            let hexUpper;\n            let hexLower;\n            if (i + 2 < str.length\n                && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1\n                && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {\n              const byteVal = (hexUpper << 4) + hexLower;\n              value += str.slice(valueStart, i);\n              value += String.fromCharCode(byteVal);\n              i += 2;\n              valueStart = i + 1;\n              if (byteVal >= 128)\n                encode = 2;\n              else if (encode === 0)\n                encode = 1;\n              continue;\n            }\n            // '%' disallowed in non-percent encoded contexts (malformed)\n            return;\n          }\n          break;\n        }\n      }\n\n      value += str.slice(valueStart, i);\n      value = convertToUTF8(value, charset, encode);\n      if (value === undefined)\n        return;\n    } else {\n      // Non-extended value\n\n      ++i; // Skip over '='\n\n      // No value (malformed)\n      if (i === str.length)\n        return;\n\n      if (str.charCodeAt(i) === 34/* '\"' */) {\n        valueStart = ++i;\n        let escaping = false;\n        // Parse quoted value\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n          if (code === 92/* '\\\\' */) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n            } else {\n              value += str.slice(valueStart, i);\n              escaping = true;\n            }\n            continue;\n          }\n          if (code === 34/* '\"' */) {\n            if (escaping) {\n              valueStart = i;\n              escaping = false;\n              continue;\n            }\n            value += str.slice(valueStart, i);\n            break;\n          }\n          if (escaping) {\n            valueStart = i - 1;\n            escaping = false;\n          }\n          // Invalid unescaped quoted character (malformed)\n          if (QDTEXT[code] !== 1)\n            return;\n        }\n\n        // No end quote (malformed)\n        if (i === str.length)\n          return;\n\n        ++i; // Skip over double quote\n      } else {\n        valueStart = i;\n        // Parse unquoted value\n        for (; i < str.length; ++i) {\n          const code = str.charCodeAt(i);\n          if (TOKEN[code] !== 1) {\n            // No value (malformed)\n            if (i === valueStart)\n              return;\n            break;\n          }\n        }\n        value = str.slice(valueStart, i);\n      }\n\n      value = defDecoder(value, 2);\n      if (value === undefined)\n        return;\n    }\n\n    name = name.toLowerCase();\n    if (params[name] === undefined)\n      params[name] = value;\n  }\n\n  return params;\n}\n\nfunction getDecoder(charset) {\n  let lc;\n  while (true) {\n    switch (charset) {\n      case 'utf-8':\n      case 'utf8':\n        return decoders.utf8;\n      case 'latin1':\n      case 'ascii': // TODO: Make these a separate, strict decoder?\n      case 'us-ascii':\n      case 'iso-8859-1':\n      case 'iso8859-1':\n      case 'iso88591':\n      case 'iso_8859-1':\n      case 'windows-1252':\n      case 'iso_8859-1:1987':\n      case 'cp1252':\n      case 'x-cp1252':\n        return decoders.latin1;\n      case 'utf16le':\n      case 'utf-16le':\n      case 'ucs2':\n      case 'ucs-2':\n        return decoders.utf16le;\n      case 'base64':\n        return decoders.base64;\n      default:\n        if (lc === undefined) {\n          lc = true;\n          charset = charset.toLowerCase();\n          continue;\n        }\n        return decoders.other.bind(charset);\n    }\n  }\n}\n\nconst decoders = {\n  utf8: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string') {\n      // If `data` never had any percent-encoded bytes or never had any that\n      // were outside of the ASCII range, then we can safely just return the\n      // input since UTF-8 is ASCII compatible\n      if (hint < 2)\n        return data;\n\n      data = Buffer.from(data, 'latin1');\n    }\n    return data.utf8Slice(0, data.length);\n  },\n\n  latin1: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      return data;\n    return data.latin1Slice(0, data.length);\n  },\n\n  utf16le: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    return data.ucs2Slice(0, data.length);\n  },\n\n  base64: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    return data.base64Slice(0, data.length);\n  },\n\n  other: (data, hint) => {\n    if (data.length === 0)\n      return '';\n    if (typeof data === 'string')\n      data = Buffer.from(data, 'latin1');\n    try {\n      const decoder = new TextDecoder(this);\n      return decoder.decode(data);\n    } catch {}\n  },\n};\n\nfunction convertToUTF8(data, charset, hint) {\n  const decode = getDecoder(charset);\n  if (decode)\n    return decode(data, hint);\n}\n\nfunction basename(path) {\n  if (typeof path !== 'string')\n    return '';\n  for (let i = path.length - 1; i >= 0; --i) {\n    switch (path.charCodeAt(i)) {\n      case 0x2F: // '/'\n      case 0x5C: // '\\'\n        path = path.slice(i + 1);\n        return (path === '..' || path === '.' ? '' : path);\n    }\n  }\n  return (path === '..' || path === '.' ? '' : path);\n}\n\nconst TOKEN = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst QDTEXT = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\nconst CHARSET = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst EXTENDED_VALUE = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\n/* eslint-disable no-multi-spaces */\nconst HEX_VALUES = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition,\n};\n"}}}},"LICENSE":{"file":{"contents":"Copyright Brian White. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE."}},"package.json":{"file":{"contents":"{ \"name\": \"busboy\",\n  \"version\": \"1.6.0\",\n  \"author\": \"Brian White <mscdex@mscdex.net>\",\n  \"description\": \"A streaming parser for HTML form data for node.js\",\n  \"main\": \"./lib/index.js\",\n  \"dependencies\": {\n    \"streamsearch\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"@mscdex/eslint-config\": \"^1.1.0\",\n    \"eslint\": \"^7.32.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node test/test.js\",\n    \"lint\": \"eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js lib test bench\",\n    \"lint:fix\": \"npm run lint -- --fix\"\n  },\n  \"engines\": { \"node\": \">=10.16.0\" },\n  \"keywords\": [ \"uploads\", \"forms\", \"multipart\", \"form-data\" ],\n  \"licenses\": [ { \"type\": \"MIT\", \"url\": \"http://github.com/mscdex/busboy/raw/master/LICENSE\" } ],\n  \"repository\": { \"type\": \"git\", \"url\": \"http://github.com/mscdex/busboy.git\" }\n}\n"}},"README.md":{"file":{"contents":"# Description\n\nA node.js module for parsing incoming HTML form data.\n\nChanges (breaking or otherwise) in v1.0.0 can be found [here](https://github.com/mscdex/busboy/issues/266).\n\n# Requirements\n\n* [node.js](http://nodejs.org/) -- v10.16.0 or newer\n\n\n# Install\n\n    npm install busboy\n\n\n# Examples\n\n* Parsing (multipart) with default options:\n\n```js\nconst http = require('http');\n\nconst busboy = require('busboy');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    console.log('POST request');\n    const bb = busboy({ headers: req.headers });\n    bb.on('file', (name, file, info) => {\n      const { filename, encoding, mimeType } = info;\n      console.log(\n        `File [${name}]: filename: %j, encoding: %j, mimeType: %j`,\n        filename,\n        encoding,\n        mimeType\n      );\n      file.on('data', (data) => {\n        console.log(`File [${name}] got ${data.length} bytes`);\n      }).on('close', () => {\n        console.log(`File [${name}] done`);\n      });\n    });\n    bb.on('field', (name, val, info) => {\n      console.log(`Field [${name}]: value: %j`, val);\n    });\n    bb.on('close', () => {\n      console.log('Done parsing form!');\n      res.writeHead(303, { Connection: 'close', Location: '/' });\n      res.end();\n    });\n    req.pipe(bb);\n  } else if (req.method === 'GET') {\n    res.writeHead(200, { Connection: 'close' });\n    res.end(`\n      <html>\n        <head></head>\n        <body>\n          <form method=\"POST\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"filefield\"><br />\n            <input type=\"text\" name=\"textfield\"><br />\n            <input type=\"submit\">\n          </form>\n        </body>\n      </html>\n    `);\n  }\n}).listen(8000, () => {\n  console.log('Listening for requests');\n});\n\n// Example output:\n//\n// Listening for requests\n//   < ... form submitted ... >\n// POST request\n// File [filefield]: filename: \"logo.jpg\", encoding: \"binary\", mime: \"image/jpeg\"\n// File [filefield] got 11912 bytes\n// Field [textfield]: value: \"testing! :-)\"\n// File [filefield] done\n// Done parsing form!\n```\n\n* Save all incoming files to disk:\n\n```js\nconst { randomFillSync } = require('crypto');\nconst fs = require('fs');\nconst http = require('http');\nconst os = require('os');\nconst path = require('path');\n\nconst busboy = require('busboy');\n\nconst random = (() => {\n  const buf = Buffer.alloc(16);\n  return () => randomFillSync(buf).toString('hex');\n})();\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    const bb = busboy({ headers: req.headers });\n    bb.on('file', (name, file, info) => {\n      const saveTo = path.join(os.tmpdir(), `busboy-upload-${random()}`);\n      file.pipe(fs.createWriteStream(saveTo));\n    });\n    bb.on('close', () => {\n      res.writeHead(200, { 'Connection': 'close' });\n      res.end(`That's all folks!`);\n    });\n    req.pipe(bb);\n    return;\n  }\n  res.writeHead(404);\n  res.end();\n}).listen(8000, () => {\n  console.log('Listening for requests');\n});\n```\n\n\n# API\n\n## Exports\n\n`busboy` exports a single function:\n\n**( _function_ )**(< _object_ >config) - Creates and returns a new _Writable_ form parser stream.\n\n* Valid `config` properties:\n\n    * **headers** - _object_ - These are the HTTP headers of the incoming request, which are used by individual parsers.\n\n    * **highWaterMark** - _integer_ - highWaterMark to use for the parser stream. **Default:** node's _stream.Writable_ default.\n\n    * **fileHwm** - _integer_ - highWaterMark to use for individual file streams. **Default:** node's _stream.Readable_ default.\n\n    * **defCharset** - _string_ - Default character set to use when one isn't defined. **Default:** `'utf8'`.\n\n    * **defParamCharset** - _string_ - For multipart forms, the default character set to use for values of part header parameters (e.g. filename) that are not extended parameters (that contain an explicit charset). **Default:** `'latin1'`.\n\n    * **preservePath** - _boolean_ - If paths in filenames from file parts in a `'multipart/form-data'` request shall be preserved. **Default:** `false`.\n\n    * **limits** - _object_ - Various limits on incoming data. Valid properties are:\n\n        * **fieldNameSize** - _integer_ - Max field name size (in bytes). **Default:** `100`.\n\n        * **fieldSize** - _integer_ - Max field value size (in bytes). **Default:** `1048576` (1MB).\n\n        * **fields** - _integer_ - Max number of non-file fields. **Default:** `Infinity`.\n\n        * **fileSize** - _integer_ - For multipart forms, the max file size (in bytes). **Default:** `Infinity`.\n\n        * **files** - _integer_ - For multipart forms, the max number of file fields. **Default:** `Infinity`.\n\n        * **parts** - _integer_ - For multipart forms, the max number of parts (fields + files). **Default:** `Infinity`.\n\n        * **headerPairs** - _integer_ - For multipart forms, the max number of header key-value pairs to parse. **Default:** `2000` (same as node's http module).\n\nThis function can throw exceptions if there is something wrong with the values in `config`. For example, if the Content-Type in `headers` is missing entirely, is not a supported type, or is missing the boundary for `'multipart/form-data'` requests.\n\n## (Special) Parser stream events\n\n* **file**(< _string_ >name, < _Readable_ >stream, < _object_ >info) - Emitted for each new file found. `name` contains the form field name. `stream` is a _Readable_ stream containing the file's data. No transformations/conversions (e.g. base64 to raw binary) are done on the file's data. `info` contains the following properties:\n\n    * `filename` - _string_ - If supplied, this contains the file's filename. **WARNING:** You should almost _never_ use this value as-is (especially if you are using `preservePath: true` in your `config`) as it could contain malicious input. You are better off generating your own (safe) filenames, or at the very least using a hash of the filename.\n\n    * `encoding` - _string_ - The file's `'Content-Transfer-Encoding'` value.\n\n    * `mimeType` - _string_ - The file's `'Content-Type'` value.\n\n    **Note:** If you listen for this event, you should always consume the `stream` whether you care about its contents or not (you can simply do `stream.resume();` if you want to discard/skip the contents), otherwise the `'finish'`/`'close'` event will never fire on the busboy parser stream.\n    However, if you aren't accepting files, you can either simply not listen for the `'file'` event at all or set `limits.files` to `0`, and any/all files will be automatically skipped (these skipped files will still count towards any configured `limits.files` and `limits.parts` limits though).\n\n    **Note:** If a configured `limits.fileSize` limit was reached for a file, `stream` will both have a boolean property `truncated` set to `true` (best checked at the end of the stream) and emit a `'limit'` event to notify you when this happens.\n\n* **field**(< _string_ >name, < _string_ >value, < _object_ >info) - Emitted for each new non-file field found. `name` contains the form field name. `value` contains the string value of the field. `info` contains the following properties:\n\n    * `nameTruncated` - _boolean_ - Whether `name` was truncated or not (due to a configured `limits.fieldNameSize` limit)\n\n    * `valueTruncated` - _boolean_ - Whether `value` was truncated or not (due to a configured `limits.fieldSize` limit)\n\n    * `encoding` - _string_ - The field's `'Content-Transfer-Encoding'` value.\n\n    * `mimeType` - _string_ - The field's `'Content-Type'` value.\n\n* **partsLimit**() - Emitted when the configured `limits.parts` limit has been reached. No more `'file'` or `'field'` events will be emitted.\n\n* **filesLimit**() - Emitted when the configured `limits.files` limit has been reached. No more `'file'` events will be emitted.\n\n* **fieldsLimit**() - Emitted when the configured `limits.fields` limit has been reached. No more `'field'` events will be emitted.\n"}},"test":{"directory":{"common.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\nconst { inspect } = require('util');\n\nconst mustCallChecks = [];\n\nfunction noop() {}\n\nfunction runCallChecks(exitCode) {\n  if (exitCode !== 0) return;\n\n  const failed = mustCallChecks.filter((context) => {\n    if ('minimum' in context) {\n      context.messageSegment = `at least ${context.minimum}`;\n      return context.actual < context.minimum;\n    }\n    context.messageSegment = `exactly ${context.exact}`;\n    return context.actual !== context.exact;\n  });\n\n  failed.forEach((context) => {\n    console.error('Mismatched %s function calls. Expected %s, actual %d.',\n                  context.name,\n                  context.messageSegment,\n                  context.actual);\n    console.error(context.stack.split('\\n').slice(2).join('\\n'));\n  });\n\n  if (failed.length)\n    process.exit(1);\n}\n\nfunction mustCall(fn, exact) {\n  return _mustCallInner(fn, exact, 'exact');\n}\n\nfunction mustCallAtLeast(fn, minimum) {\n  return _mustCallInner(fn, minimum, 'minimum');\n}\n\nfunction _mustCallInner(fn, criteria = 1, field) {\n  if (process._exiting)\n    throw new Error('Cannot use common.mustCall*() in process exit handler');\n\n  if (typeof fn === 'number') {\n    criteria = fn;\n    fn = noop;\n  } else if (fn === undefined) {\n    fn = noop;\n  }\n\n  if (typeof criteria !== 'number')\n    throw new TypeError(`Invalid ${field} value: ${criteria}`);\n\n  const context = {\n    [field]: criteria,\n    actual: 0,\n    stack: inspect(new Error()),\n    name: fn.name || '<anonymous>'\n  };\n\n  // Add the exit listener only once to avoid listener leak warnings\n  if (mustCallChecks.length === 0)\n    process.on('exit', runCallChecks);\n\n  mustCallChecks.push(context);\n\n  function wrapped(...args) {\n    ++context.actual;\n    return fn.call(this, ...args);\n  }\n  // TODO: remove origFn?\n  wrapped.origFn = fn;\n\n  return wrapped;\n}\n\nfunction getCallSite(top) {\n  const originalStackFormatter = Error.prepareStackTrace;\n  Error.prepareStackTrace = (err, stack) =>\n    `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;\n  const err = new Error();\n  Error.captureStackTrace(err, top);\n  // With the V8 Error API, the stack is not formatted until it is accessed\n  // eslint-disable-next-line no-unused-expressions\n  err.stack;\n  Error.prepareStackTrace = originalStackFormatter;\n  return err.stack;\n}\n\nfunction mustNotCall(msg) {\n  const callSite = getCallSite(mustNotCall);\n  return function mustNotCall(...args) {\n    args = args.map(inspect).join(', ');\n    const argsInfo = (args.length > 0\n                      ? `\\ncalled with arguments: ${args}`\n                      : '');\n    assert.fail(\n      `${msg || 'function should not have been called'} at ${callSite}`\n        + argsInfo);\n  };\n}\n\nmodule.exports = {\n  mustCall,\n  mustCallAtLeast,\n  mustNotCall,\n};\n"}},"test-types-multipart-charsets.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\nconst { inspect } = require('util');\n\nconst { mustCall } = require(`${__dirname}/common.js`);\n\nconst busboy = require('..');\n\nconst input = Buffer.from([\n  '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n 'Content-Disposition: form-data; '\n   + 'name=\"upload_file_0\"; filename=\"テスト.dat\"',\n 'Content-Type: application/octet-stream',\n '',\n 'A'.repeat(1023),\n '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n].join('\\r\\n'));\nconst boundary = '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k';\nconst expected = [\n  { type: 'file',\n    name: 'upload_file_0',\n    data: Buffer.from('A'.repeat(1023)),\n    info: {\n      filename: 'テスト.dat',\n      encoding: '7bit',\n      mimeType: 'application/octet-stream',\n    },\n    limited: false,\n  },\n];\nconst bb = busboy({\n  defParamCharset: 'utf8',\n  headers: {\n    'content-type': `multipart/form-data; boundary=${boundary}`,\n  }\n});\nconst results = [];\n\nbb.on('field', (name, val, info) => {\n  results.push({ type: 'field', name, val, info });\n});\n\nbb.on('file', (name, stream, info) => {\n  const data = [];\n  let nb = 0;\n  const file = {\n    type: 'file',\n    name,\n    data: null,\n    info,\n    limited: false,\n  };\n  results.push(file);\n  stream.on('data', (d) => {\n    data.push(d);\n    nb += d.length;\n  }).on('limit', () => {\n    file.limited = true;\n  }).on('close', () => {\n    file.data = Buffer.concat(data, nb);\n    assert.strictEqual(stream.truncated, file.limited);\n  }).once('error', (err) => {\n    file.err = err.message;\n  });\n});\n\nbb.on('error', (err) => {\n  results.push({ error: err.message });\n});\n\nbb.on('partsLimit', () => {\n  results.push('partsLimit');\n});\n\nbb.on('filesLimit', () => {\n  results.push('filesLimit');\n});\n\nbb.on('fieldsLimit', () => {\n  results.push('fieldsLimit');\n});\n\nbb.on('close', mustCall(() => {\n  assert.deepStrictEqual(\n    results,\n    expected,\n    'Results mismatch.\\n'\n      + `Parsed: ${inspect(results)}\\n`\n      + `Expected: ${inspect(expected)}`\n  );\n}));\n\nbb.end(input);\n"}},"test-types-multipart-stream-pause.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\nconst { randomFillSync } = require('crypto');\nconst { inspect } = require('util');\n\nconst busboy = require('..');\n\nconst { mustCall } = require('./common.js');\n\nconst BOUNDARY = 'u2KxIV5yF1y+xUspOQCCZopaVgeV6Jxihv35XQJmuTx8X3sh';\n\nfunction formDataSection(key, value) {\n  return Buffer.from(\n    `\\r\\n--${BOUNDARY}`\n      + `\\r\\nContent-Disposition: form-data; name=\"${key}\"`\n      + `\\r\\n\\r\\n${value}`\n  );\n}\n\nfunction formDataFile(key, filename, contentType) {\n  const buf = Buffer.allocUnsafe(100000);\n  return Buffer.concat([\n    Buffer.from(`\\r\\n--${BOUNDARY}\\r\\n`),\n    Buffer.from(`Content-Disposition: form-data; name=\"${key}\"`\n                  + `; filename=\"${filename}\"\\r\\n`),\n    Buffer.from(`Content-Type: ${contentType}\\r\\n\\r\\n`),\n    randomFillSync(buf)\n  ]);\n}\n\nconst reqChunks = [\n  Buffer.concat([\n    formDataFile('file', 'file.bin', 'application/octet-stream'),\n    formDataSection('foo', 'foo value'),\n  ]),\n  formDataSection('bar', 'bar value'),\n  Buffer.from(`\\r\\n--${BOUNDARY}--\\r\\n`)\n];\nconst bb = busboy({\n  headers: {\n    'content-type': `multipart/form-data; boundary=${BOUNDARY}`\n  }\n});\nconst expected = [\n  { type: 'file',\n    name: 'file',\n    info: {\n      filename: 'file.bin',\n      encoding: '7bit',\n      mimeType: 'application/octet-stream',\n    },\n  },\n  { type: 'field',\n    name: 'foo',\n    val: 'foo value',\n    info: {\n      nameTruncated: false,\n      valueTruncated: false,\n      encoding: '7bit',\n      mimeType: 'text/plain',\n    },\n  },\n  { type: 'field',\n    name: 'bar',\n    val: 'bar value',\n    info: {\n      nameTruncated: false,\n      valueTruncated: false,\n      encoding: '7bit',\n      mimeType: 'text/plain',\n    },\n  },\n];\nconst results = [];\n\nbb.on('field', (name, val, info) => {\n  results.push({ type: 'field', name, val, info });\n});\n\nbb.on('file', (name, stream, info) => {\n  results.push({ type: 'file', name, info });\n  // Simulate a pipe where the destination is pausing (perhaps due to waiting\n  // for file system write to finish)\n  setTimeout(() => {\n    stream.resume();\n  }, 10);\n});\n\nbb.on('close', mustCall(() => {\n  assert.deepStrictEqual(\n    results,\n    expected,\n    'Results mismatch.\\n'\n      + `Parsed: ${inspect(results)}\\n`\n      + `Expected: ${inspect(expected)}`\n  );\n}));\n\nfor (const chunk of reqChunks)\n  bb.write(chunk);\nbb.end();\n"}},"test-types-multipart.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\nconst { inspect } = require('util');\n\nconst busboy = require('..');\n\nconst active = new Map();\n\nconst tests = [\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'super alpha file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_1\"',\n       '',\n       'super beta file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'A'.repeat(1023),\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"1k_b.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'B'.repeat(1023),\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'super alpha file',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'field',\n        name: 'file_name_1',\n        val: 'super beta file',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('A'.repeat(1023)),\n        info: {\n          filename: '1k_a.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_1',\n        data: Buffer.from('B'.repeat(1023)),\n        info: {\n          filename: '1k_b.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Fields and files'\n  },\n  { source: [\n      ['------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: form-data; name=\"cont\"',\n       '',\n       'some random content',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: form-data; name=\"pass\"',\n       '',\n       'some random pass',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: form-data; name=bit',\n       '',\n       '2',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY--'\n      ].join('\\r\\n')\n    ],\n    boundary: '----WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n    expected: [\n      { type: 'field',\n        name: 'cont',\n        val: 'some random content',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'field',\n        name: 'pass',\n        val: 'some random pass',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'field',\n        name: 'bit',\n        val: '2',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n    ],\n    what: 'Fields only'\n  },\n  { source: [\n      ''\n    ],\n    boundary: '----WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n    expected: [\n      { error: 'Unexpected end of form' },\n    ],\n    what: 'No fields and no files'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'super alpha file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      fileSize: 13,\n      fieldSize: 5\n    },\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'super',\n        info: {\n          nameTruncated: false,\n          valueTruncated: true,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('ABCDEFGHIJKLM'),\n        info: {\n          filename: '1k_a.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: true,\n      },\n    ],\n    what: 'Fields and files (limits)'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'super alpha file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      files: 0\n    },\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'super alpha file',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      'filesLimit',\n    ],\n    what: 'Fields and files (limits: 0 files)'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'super alpha file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_1\"',\n       '',\n       'super beta file',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'A'.repeat(1023),\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"1k_b.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'B'.repeat(1023),\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'super alpha file',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      { type: 'field',\n        name: 'file_name_1',\n        val: 'super beta file',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n    ],\n    events: ['field'],\n    what: 'Fields and (ignored) files'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"/tmp/1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"C:\\\\files\\\\1k_b.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_2\"; filename=\"relative/1k_c.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: '1k_a.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_1',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: '1k_b.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_2',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: '1k_c.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Files with filenames containing paths'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"/absolute/1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"C:\\\\absolute\\\\1k_b.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_2\"; filename=\"relative/1k_c.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    preservePath: true,\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: '/absolute/1k_a.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_1',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: 'C:\\\\absolute\\\\1k_b.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_2',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: 'relative/1k_c.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Paths to be preserved through the preservePath option'\n  },\n  { source: [\n      ['------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: form-data; name=\"cont\"',\n       'Content-Type: ',\n       '',\n       'some random content',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: ',\n       '',\n       'some random pass',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY--'\n      ].join('\\r\\n')\n    ],\n    boundary: '----WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n    expected: [\n      { type: 'field',\n        name: 'cont',\n        val: 'some random content',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n    ],\n    what: 'Empty content-type and empty content-disposition'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"file\"; filename*=utf-8\\'\\'n%C3%A4me.txt',\n       'Content-Type: application/octet-stream',\n       '',\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--'\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'file',\n        data: Buffer.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        info: {\n          filename: 'näme.txt',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Unicode filenames'\n  },\n  { source: [\n      ['--asdasdasdasd\\r\\n',\n       'Content-Type: text/plain\\r\\n',\n       'Content-Disposition: form-data; name=\"foo\"\\r\\n',\n       '\\r\\n',\n       'asd\\r\\n',\n       '--asdasdasdasd--'\n      ].join(':)')\n    ],\n    boundary: 'asdasdasdasd',\n    expected: [\n      { error: 'Malformed part header' },\n      { error: 'Unexpected end of form' },\n    ],\n    what: 'Stopped mid-header'\n  },\n  { source: [\n      ['------WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n       'Content-Disposition: form-data; name=\"cont\"',\n       'Content-Type: application/json',\n       '',\n       '{}',\n       '------WebKitFormBoundaryTB2MiQ36fnSJlrhY--',\n      ].join('\\r\\n')\n    ],\n    boundary: '----WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n    expected: [\n      { type: 'field',\n        name: 'cont',\n        val: '{}',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'application/json',\n        },\n      },\n    ],\n    what: 'content-type for fields'\n  },\n  { source: [\n      '------WebKitFormBoundaryTB2MiQ36fnSJlrhY--',\n    ],\n    boundary: '----WebKitFormBoundaryTB2MiQ36fnSJlrhY',\n    expected: [],\n    what: 'empty form'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=upload_file_0; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       'Content-Transfer-Encoding: binary',\n       '',\n       '',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.alloc(0),\n        info: {\n          filename: '1k_a.dat',\n          encoding: 'binary',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n        err: 'Unexpected end of form',\n      },\n      { error: 'Unexpected end of form' },\n    ],\n    what: 'Stopped mid-file #1'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=upload_file_0; filename=\"1k_a.dat\"',\n       'Content-Type: application/octet-stream',\n       '',\n       'a',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('a'),\n        info: {\n          filename: '1k_a.dat',\n          encoding: '7bit',\n          mimeType: 'application/octet-stream',\n        },\n        limited: false,\n        err: 'Unexpected end of form',\n      },\n      { error: 'Unexpected end of form' },\n    ],\n    what: 'Stopped mid-file #2'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'a',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('a'),\n        info: {\n          filename: 'notes.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Text file with charset'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: ',\n       ' text/plain; charset=utf8',\n       '',\n       'a',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('a'),\n        info: {\n          filename: 'notes.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Folded header value'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'a',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [],\n    what: 'No Content-Disposition'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'a'.repeat(64 * 1024),\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: ',\n       ' text/plain; charset=utf8',\n       '',\n       'bc',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      fieldSize: Infinity,\n    },\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('bc'),\n        info: {\n          filename: 'notes.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    events: [ 'file' ],\n    what: 'Skip field parts if no listener'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'a',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: ',\n       ' text/plain; charset=utf8',\n       '',\n       'bc',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      parts: 1,\n    },\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'a',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      'partsLimit',\n    ],\n    what: 'Parts limit'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_0\"',\n       '',\n       'a',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; name=\"file_name_1\"',\n       '',\n       'b',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      fields: 1,\n    },\n    expected: [\n      { type: 'field',\n        name: 'file_name_0',\n        val: 'a',\n        info: {\n          nameTruncated: false,\n          valueTruncated: false,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n      },\n      'fieldsLimit',\n    ],\n    what: 'Fields limit'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'ab',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"notes2.txt\"',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'cd',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    limits: {\n      files: 1,\n    },\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('ab'),\n        info: {\n          filename: 'notes.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n      'filesLimit',\n    ],\n    what: 'Files limit'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + `name=\"upload_file_0\"; filename=\"${'a'.repeat(64 * 1024)}.txt\"`,\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'ab',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_1\"; filename=\"notes2.txt\"',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'cd',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { error: 'Malformed part header' },\n      { type: 'file',\n        name: 'upload_file_1',\n        data: Buffer.from('cd'),\n        info: {\n          filename: 'notes2.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Oversized part header'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + 'name=\"upload_file_0\"; filename=\"notes.txt\"',\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'a'.repeat(31) + '\\r',\n      ].join('\\r\\n'),\n      'b'.repeat(40),\n      '\\r\\n-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    fileHwm: 32,\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('a'.repeat(31) + '\\r' + 'b'.repeat(40)),\n        info: {\n          filename: 'notes.txt',\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Lookbehind data should not stall file streams'\n  },\n  { source: [\n      ['-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + `name=\"upload_file_0\"; filename=\"${'a'.repeat(8 * 1024)}.txt\"`,\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'ab',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + `name=\"upload_file_1\"; filename=\"${'b'.repeat(8 * 1024)}.txt\"`,\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'cd',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n       'Content-Disposition: form-data; '\n         + `name=\"upload_file_2\"; filename=\"${'c'.repeat(8 * 1024)}.txt\"`,\n       'Content-Type: text/plain; charset=utf8',\n       '',\n       'ef',\n       '-----------------------------paZqsnEHRufoShdX6fh0lUhXBP4k--',\n      ].join('\\r\\n')\n    ],\n    boundary: '---------------------------paZqsnEHRufoShdX6fh0lUhXBP4k',\n    expected: [\n      { type: 'file',\n        name: 'upload_file_0',\n        data: Buffer.from('ab'),\n        info: {\n          filename: `${'a'.repeat(8 * 1024)}.txt`,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_1',\n        data: Buffer.from('cd'),\n        info: {\n          filename: `${'b'.repeat(8 * 1024)}.txt`,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n      { type: 'file',\n        name: 'upload_file_2',\n        data: Buffer.from('ef'),\n        info: {\n          filename: `${'c'.repeat(8 * 1024)}.txt`,\n          encoding: '7bit',\n          mimeType: 'text/plain',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Header size limit should be per part'\n  },\n  { source: [\n      '\\r\\n--d1bf46b3-aa33-4061-b28d-6c5ced8b08ee\\r\\n',\n      'Content-Type: application/gzip\\r\\n'\n        + 'Content-Encoding: gzip\\r\\n'\n        + 'Content-Disposition: form-data; name=batch-1; filename=batch-1'\n        + '\\r\\n\\r\\n',\n      '\\r\\n--d1bf46b3-aa33-4061-b28d-6c5ced8b08ee--',\n    ],\n    boundary: 'd1bf46b3-aa33-4061-b28d-6c5ced8b08ee',\n    expected: [\n      { type: 'file',\n        name: 'batch-1',\n        data: Buffer.alloc(0),\n        info: {\n          filename: 'batch-1',\n          encoding: '7bit',\n          mimeType: 'application/gzip',\n        },\n        limited: false,\n      },\n    ],\n    what: 'Empty part'\n  },\n];\n\nfor (const test of tests) {\n  active.set(test, 1);\n\n  const { what, boundary, events, limits, preservePath, fileHwm } = test;\n  const bb = busboy({\n    fileHwm,\n    limits,\n    preservePath,\n    headers: {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    }\n  });\n  const results = [];\n\n  if (events === undefined || events.includes('field')) {\n    bb.on('field', (name, val, info) => {\n      results.push({ type: 'field', name, val, info });\n    });\n  }\n\n  if (events === undefined || events.includes('file')) {\n    bb.on('file', (name, stream, info) => {\n      const data = [];\n      let nb = 0;\n      const file = {\n        type: 'file',\n        name,\n        data: null,\n        info,\n        limited: false,\n      };\n      results.push(file);\n      stream.on('data', (d) => {\n        data.push(d);\n        nb += d.length;\n      }).on('limit', () => {\n        file.limited = true;\n      }).on('close', () => {\n        file.data = Buffer.concat(data, nb);\n        assert.strictEqual(stream.truncated, file.limited);\n      }).once('error', (err) => {\n        file.err = err.message;\n      });\n    });\n  }\n\n  bb.on('error', (err) => {\n    results.push({ error: err.message });\n  });\n\n  bb.on('partsLimit', () => {\n    results.push('partsLimit');\n  });\n\n  bb.on('filesLimit', () => {\n    results.push('filesLimit');\n  });\n\n  bb.on('fieldsLimit', () => {\n    results.push('fieldsLimit');\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    bb.write(buf);\n  }\n  bb.end();\n}\n\n// Byte-by-byte versions\nfor (let test of tests) {\n  test = { ...test };\n  test.what += ' (byte-by-byte)';\n  active.set(test, 1);\n\n  const { what, boundary, events, limits, preservePath, fileHwm } = test;\n  const bb = busboy({\n    fileHwm,\n    limits,\n    preservePath,\n    headers: {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    }\n  });\n  const results = [];\n\n  if (events === undefined || events.includes('field')) {\n    bb.on('field', (name, val, info) => {\n      results.push({ type: 'field', name, val, info });\n    });\n  }\n\n  if (events === undefined || events.includes('file')) {\n    bb.on('file', (name, stream, info) => {\n      const data = [];\n      let nb = 0;\n      const file = {\n        type: 'file',\n        name,\n        data: null,\n        info,\n        limited: false,\n      };\n      results.push(file);\n      stream.on('data', (d) => {\n        data.push(d);\n        nb += d.length;\n      }).on('limit', () => {\n        file.limited = true;\n      }).on('close', () => {\n        file.data = Buffer.concat(data, nb);\n        assert.strictEqual(stream.truncated, file.limited);\n      }).once('error', (err) => {\n        file.err = err.message;\n      });\n    });\n  }\n\n  bb.on('error', (err) => {\n    results.push({ error: err.message });\n  });\n\n  bb.on('partsLimit', () => {\n    results.push('partsLimit');\n  });\n\n  bb.on('filesLimit', () => {\n    results.push('filesLimit');\n  });\n\n  bb.on('fieldsLimit', () => {\n    results.push('fieldsLimit');\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    for (let i = 0; i < buf.length; ++i)\n      bb.write(buf.slice(i, i + 1));\n  }\n  bb.end();\n}\n\n{\n  let exception = false;\n  process.once('uncaughtException', (ex) => {\n    exception = true;\n    throw ex;\n  });\n  process.on('exit', () => {\n    if (exception || active.size === 0)\n      return;\n    process.exitCode = 1;\n    console.error('==========================');\n    console.error(`${active.size} test(s) did not finish:`);\n    console.error('==========================');\n    console.error(Array.from(active.keys()).map((v) => v.what).join('\\n'));\n  });\n}\n"}},"test-types-urlencoded.js":{"file":{"contents":"'use strict';\n\nconst assert = require('assert');\nconst { transcode } = require('buffer');\nconst { inspect } = require('util');\n\nconst busboy = require('..');\n\nconst active = new Map();\n\nconst tests = [\n  { source: ['foo'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Unassigned value'\n  },\n  { source: ['foo=bar'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value'\n  },\n  { source: ['foo&bar=baz'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       'baz',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Unassigned and assigned value'\n  },\n  { source: ['foo=bar&baz'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned and unassigned value'\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bla',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two assigned values'\n  },\n  { source: ['foo&bar'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two unassigned values'\n  },\n  { source: ['foo&bar&'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two unassigned values and ampersand'\n  },\n  { source: ['foo+1=bar+baz%2Bquux'],\n    expected: [\n      ['foo 1',\n       'bar baz+quux',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned key and value with (plus) space'\n  },\n  { source: ['foo=bar%20baz%21'],\n    expected: [\n      ['foo',\n       'bar baz!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value with encoded bytes'\n  },\n  { source: ['foo%20bar=baz%20bla%21'],\n    expected: [\n      ['foo bar',\n       'baz bla!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value with encoded bytes #2'\n  },\n  { source: ['foo=bar%20baz%21&num=1000'],\n    expected: [\n      ['foo',\n       'bar baz!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['num',\n       '1000',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two assigned values, one with encoded bytes'\n  },\n  { source: [\n      Array.from(transcode(Buffer.from('foo'), 'utf8', 'utf16le')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n      '=',\n      Array.from(transcode(Buffer.from('😀!'), 'utf8', 'utf16le')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n    ],\n    expected: [\n      ['foo',\n       '😀!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'UTF-16LE',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    charset: 'UTF-16LE',\n    what: 'Encoded value with multi-byte charset'\n  },\n  { source: [\n      'foo=<',\n      Array.from(transcode(Buffer.from('©:^þ'), 'utf8', 'latin1')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n    ],\n    expected: [\n      ['foo',\n       '<©:^þ',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'ISO-8859-1',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    charset: 'ISO-8859-1',\n    what: 'Encoded value with single-byte, ASCII-compatible, non-UTF8 charset'\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [],\n    what: 'Limits: zero fields',\n    limits: { fields: 0 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: one field',\n    limits: { fields: 1 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bla',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: field part lengths match limits',\n    limits: { fieldNameSize: 3, fieldSize: 3 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       'bar',\n       { nameTruncated: true,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       'bla',\n       { nameTruncated: true,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name',\n    limits: { fieldNameSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'ba',\n       { nameTruncated: false,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bl',\n       { nameTruncated: false,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field value',\n    limits: { fieldSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       'ba',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       'bl',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name and value',\n    limits: { fieldNameSize: 2, fieldSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name and zero value limit',\n    limits: { fieldNameSize: 2, fieldSize: 0 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated zero field name and zero value limit',\n    limits: { fieldNameSize: 0, fieldSize: 0 }\n  },\n  { source: ['&'],\n    expected: [],\n    what: 'Ampersand'\n  },\n  { source: ['&&&&&'],\n    expected: [],\n    what: 'Many ampersands'\n  },\n  { source: ['='],\n    expected: [\n      ['',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value, empty name and value'\n  },\n  { source: [''],\n    expected: [],\n    what: 'Nothing'\n  },\n];\n\nfor (const test of tests) {\n  active.set(test, 1);\n\n  const { what } = test;\n  const charset = test.charset || 'utf-8';\n  const bb = busboy({\n    limits: test.limits,\n    headers: {\n      'content-type': `application/x-www-form-urlencoded; charset=${charset}`,\n    },\n  });\n  const results = [];\n\n  bb.on('field', (key, val, info) => {\n    results.push([key, val, info]);\n  });\n\n  bb.on('file', () => {\n    throw new Error(`[${what}] Unexpected file`);\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    bb.write(buf);\n  }\n  bb.end();\n}\n\n// Byte-by-byte versions\nfor (let test of tests) {\n  test = { ...test };\n  test.what += ' (byte-by-byte)';\n  active.set(test, 1);\n\n  const { what } = test;\n  const charset = test.charset || 'utf-8';\n  const bb = busboy({\n    limits: test.limits,\n    headers: {\n      'content-type': `application/x-www-form-urlencoded; charset=\"${charset}\"`,\n    },\n  });\n  const results = [];\n\n  bb.on('field', (key, val, info) => {\n    results.push([key, val, info]);\n  });\n\n  bb.on('file', () => {\n    throw new Error(`[${what}] Unexpected file`);\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    for (let i = 0; i < buf.length; ++i)\n      bb.write(buf.slice(i, i + 1));\n  }\n  bb.end();\n}\n\n{\n  let exception = false;\n  process.once('uncaughtException', (ex) => {\n    exception = true;\n    throw ex;\n  });\n  process.on('exit', () => {\n    if (exception || active.size === 0)\n      return;\n    process.exitCode = 1;\n    console.error('==========================');\n    console.error(`${active.size} test(s) did not finish:`);\n    console.error('==========================');\n    console.error(Array.from(active.keys()).map((v) => v.what).join('\\n'));\n  });\n}\n"}},"test.js":{"file":{"contents":"'use strict';\n\nconst { spawnSync } = require('child_process');\nconst { readdirSync } = require('fs');\nconst { join } = require('path');\n\nconst files = readdirSync(__dirname).sort();\nfor (const filename of files) {\n  if (filename.startsWith('test-')) {\n    const path = join(__dirname, filename);\n    console.log(`> Running ${filename} ...`);\n    const result = spawnSync(`${process.argv0} ${path}`, {\n      shell: true,\n      stdio: 'inherit',\n      windowsHide: true\n    });\n    if (result.status !== 0)\n      process.exitCode = 1;\n  }\n}\n"}}}}}}